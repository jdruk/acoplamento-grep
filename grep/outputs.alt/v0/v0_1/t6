#define MAX(A,B) ((A) > (B) ? (A) : (B))
#define strerror(E) ((E) < sys_nerr ? sys_errlist[(E)] : "bogus error number")
      bp = lastout ? lastout : bufbeg;
	fp = strcmp(optarg, "-") != 0 ? fopen(optarg, "r") : stdin;
	desc = strcmp(argv[optind], "-") ? open(argv[optind], O_RDONLY) : 0;
	    filename = desc == 0 ? "(standard input)" : argv[optind];
  exit(errseen ? 2 : status);
int optopt = '?';
   return '?' after printing an error message.  If you set `opterr' to
   zero, the error message is suppressed but we still return '?'.
	  return '?';
		  return '?';
		  return optstring[0] == ':' ? ':' : '?';
	  return '?';
	return '?';
		  c = '?';
      int this_option_optind = optind ? optind : 1;
	case '?':
	  printf ("?? getopt returned character code 0%o ??\n", c);
/* Should we use malloc or alloca?  If REGEX_MALLOC is not defined, we
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define MIN(a, b) ((a) < (b) ? (a) : (b))
	            (re_opcode_t) *(p - 1) == charset_not ? "^" : "");
		  /* Are we starting a range?  */
		  /* Have we broken a range?  */
          printf ("?%d", *(p-1));
  /* Perhaps we should print the translate table?  */
#define TRANSLATE(d) (translate ? translate[(unsigned char) (d)] : (d))
        case '?':
            /* Are we optimizing this jump?  */
                many_times_ok |= c != '?';
                    || (!(syntax & RE_BK_PLUS_QM) && (c == '+' || c == '?')))
                    if (!(c1 == '+' || c1 == '?'))
                   for null bytes, because of RE_DOT_NOT_NULL?  */
            INSERT_JUMP (keep_string_p ? on_failure_keep_string_jump
            BUF_PUSH (*p == '^' ? charset_not : charset); 
                = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
                    ? bufp->buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1 
            case '?':
		  ? *p == '\\' && (p[1] == '+' || p[1] == '?')
		  : (*p == '+' || *p == '?'))
		      ? *p == '{'
       /* After a subexpression?  */
       /* After an alternative?  */
  const char *next_next = p + 1 < pend ? p + 1 : NULL;
       /* Before a subexpression?  */
       (syntax & RE_NO_BK_PARENS ? *next == ')'
       /* Before an alternative?  */
    || (syntax & RE_NO_BK_VBAR ? *next == '|'
    return syntax & RE_NO_EMPTY_RANGES ? REG_ERANGE : REG_NOERROR;
   ? 0									\
      ? 0								\
    ? 0									\
          /* For some patterns, e.g., `(a?)?', `p+j' here points to the
	      d = (startpos >= size1 ? string2 - size1 : string1) + startpos;
                                 ? string2[startpos - size1] 
  (FIRST_STRING_P (ptr) ? (ptr) - string1 : (ptr) - string2 + size1)
#define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)
  (SYNTAX ((d) == end1 ? *string2					\
           : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\
		           ? end_match_1 : end_match_2);
              /* Have the register data arrays been allocated?  */
                  regs->end[0] = (MATCHING_IN_FIRST_STRING ? d - string1
			    ? string1 
            DEBUG_PRINT2 ("EXECUTING charset%s.\n", not ? "_not" : "");
                             ? REG_UNSET (regstart[*p]) ? d : regstart[*p]
                           ? REG_UNSET (regend[*p]) ? d : regend[*p]
                          /* xx why this test?  */
		     ? regend[regno] : end_match_1);
                    ? bcmp_translate (d, d2, mcnt, translate) 
          else if ((d == end1 ? *string2 : *d) == '\n'
                  = *p2 == (unsigned char) endline ? '\n' : p2[2];
    = (cflags & REG_EXTENDED) ?
        preg->translate[i] = ISUPPER (i) ? tolower (i) : i;
                   want_reg_info ? &regs : (struct re_registers *) 0);
  return ret >= 0 ? (int) REG_NOERROR : (int) REG_NOMATCH;
		  ? lexleft > 0 && *lexptr == ')'
		  ? lexleft > 0 && *lexptr == '|'
	case '?':
  newline = newline ? 1 : 0;
  letter = letter ? 1 : 0;
      fprintf(stderr, nullable[-1] ? " nullable: yes\n" : " nullable: no\n");
	    (intersect[k] = matches[k] & labels[j][k]) ? intersectf = 1 : 0;
	      (leftovers[k] = ~match & label) ? leftoversf = 1 : 0;
	      (matches[k] = match & ~label) ? matchesf = 1 : 0;
	CAT	(p->is==ZERO)?	(q->is==ZERO)?	(p->is!=ZERO &&	p->in plus
		p->left :	q->right :	q->is!=ZERO) ?	q->in plus
		of p->left	of p->right	content) ?	
   'aaa')?
   Is optimization easy (enough)?
   the same as the one you get from "psi" (for example)?
   'psi|epsilon' is likelier)? */
  newsize = (new == NULL) ? 0 : strlen(new);
  /* Is there already something in the list that's new (or longer)? */
      label = kwset->trans ? kwset->trans[(unsigned char) *--text] : *--text;
		      l->balance = t->balance != 1 ? 0 : -1;
		      r->balance = t->balance != (char) -1 ? 0 : 1;
		      l->balance = t->balance != 1 ? 0 : -1;
		      r->balance = t->balance != (char) -1 ? 0 : 1;
	  c = trans ? trans[(unsigned char) *--beg] : *--beg;
	  c = trans ? trans[(unsigned char) *--beg] : *--beg;
   For free, do not use ?:, since some compilers, like the MIPS compilers,
   do not allow (expr) ? void : void.  */
   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
#define TOLOWER(C) (ISUPPER(C) ? tolower(C) : (C))
  if (!(kwset = kwsalloc(match_icase ? trans : (char *) 0)))
  *endp = end < buflim ? end + 1 : end;
