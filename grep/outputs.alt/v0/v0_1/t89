../inputs/grep0.dat:        : next_backslash && next_next && *next_next == ')')
../inputs/grep1.dat:#define MAX(A,B) ((A) > (B) ? (A) : (B))
../inputs/grep1.dat:#define strerror(E) ((E) < sys_nerr ? sys_errlist[(E)] : "bogus error number")
../inputs/grep1.dat:      bp = lastout ? lastout : bufbeg;
../inputs/grep1.dat:	fp = strcmp(optarg, "-") != 0 ? fopen(optarg, "r") : stdin;
../inputs/grep1.dat:	desc = strcmp(argv[optind], "-") ? open(argv[optind], O_RDONLY) : 0;
../inputs/grep1.dat:	    filename = desc == 0 ? "(standard input)" : argv[optind];
../inputs/grep1.dat:  exit(errseen ? 2 : status);
../inputs/grep1.dat:		  return optstring[0] == ':' ? ':' : '?';
../inputs/grep1.dat:      int this_option_optind = optind ? optind : 1;
../inputs/grep1.dat:#define MAX(a, b) ((a) > (b) ? (a) : (b))
../inputs/grep1.dat:#define MIN(a, b) ((a) < (b) ? (a) : (b))
../inputs/grep1.dat:	            (re_opcode_t) *(p - 1) == charset_not ? "^" : "");
../inputs/grep1.dat:#define TRANSLATE(d) (translate ? translate[(unsigned char) (d)] : (d))
../inputs/grep1.dat:                                       : on_failure_jump,
../inputs/grep1.dat:            BUF_PUSH (*p == '^' ? charset_not : charset); 
../inputs/grep1.dat:                = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
../inputs/grep1.dat:                    : 0;
../inputs/grep1.dat:		  : (*p == '+' || *p == '?'))
../inputs/grep1.dat:                      : (p[0] == '\\' && p[1] == '{'))))
../inputs/grep1.dat:  const char *next_next = p + 1 < pend ? p + 1 : NULL;
../inputs/grep1.dat:        : next_backslash && next_next && *next_next == ')')
../inputs/grep1.dat:        : next_backslash && next_next && *next_next == '|');
../inputs/grep1.dat:    return syntax & RE_NO_EMPTY_RANGES ? REG_ERANGE : REG_NOERROR;
../inputs/grep1.dat:   : ((fail_stack).stack = (fail_stack_elt_t *)				\
../inputs/grep1.dat:      : ((fail_stack).size <<= 1, 					\
../inputs/grep1.dat:    : ((fail_stack).stack[(fail_stack).avail++] = pattern_op,		\
../inputs/grep1.dat:	      d = (startpos >= size1 ? string2 - size1 : string1) + startpos;
../inputs/grep1.dat:                                 : string1[startpos]);
../inputs/grep1.dat:    unsigned match_null_string_p : 2;
../inputs/grep1.dat:    unsigned is_active : 1;
../inputs/grep1.dat:    unsigned matched_something : 1;
../inputs/grep1.dat:    unsigned ever_matched_something : 1;
../inputs/grep1.dat:  (FIRST_STRING_P (ptr) ? (ptr) - string1 : (ptr) - string2 + size1)
../inputs/grep1.dat:#define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)
../inputs/grep1.dat:           : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\
../inputs/grep1.dat:		           ? end_match_1 : end_match_2);
../inputs/grep1.dat:			          : d - string2 + size1);
../inputs/grep1.dat:			    : string2 - size1);
../inputs/grep1.dat:            DEBUG_PRINT2 ("EXECUTING charset%s.\n", not ? "_not" : "");
../inputs/grep1.dat:                             ? REG_UNSET (regstart[*p]) ? d : regstart[*p]
../inputs/grep1.dat:                             : regstart[*p];
../inputs/grep1.dat:                           ? REG_UNSET (regend[*p]) ? d : regend[*p]
../inputs/grep1.dat:			   : regend[*p];
../inputs/grep1.dat:		     ? regend[regno] : end_match_1);
../inputs/grep1.dat:                    : bcmp (d, d2, mcnt))
../inputs/grep1.dat:          else if ((d == end1 ? *string2 : *d) == '\n'
../inputs/grep1.dat:                  = *p2 == (unsigned char) endline ? '\n' : p2[2];
../inputs/grep1.dat:      RE_SYNTAX_POSIX_EXTENDED : RE_SYNTAX_POSIX_BASIC;
../inputs/grep1.dat:        preg->translate[i] = ISUPPER (i) ? tolower (i) : i;
../inputs/grep1.dat:                   want_reg_info ? &regs : (struct re_registers *) 0);
../inputs/grep1.dat:  return ret >= 0 ? (int) REG_NOERROR : (int) REG_NOMATCH;
../inputs/grep1.dat:		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == ')')
../inputs/grep1.dat:		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == '|')
../inputs/grep1.dat:	      /* Nobody ever said this had to be fast. :-)
../inputs/grep1.dat:  newline = newline ? 1 : 0;
../inputs/grep1.dat:  letter = letter ? 1 : 0;
../inputs/grep1.dat:      fprintf(stderr, nullable[-1] ? " nullable: yes\n" : " nullable: no\n");
../inputs/grep1.dat:	    (intersect[k] = matches[k] & labels[j][k]) ? intersectf = 1 : 0;
../inputs/grep1.dat:	      (leftovers[k] = ~match & label) ? leftoversf = 1 : 0;
../inputs/grep1.dat:	      (matches[k] = match & ~label) ? matchesf = 1 : 0;
../inputs/grep1.dat:		p->left :	q->right :	q->is!=ZERO) ?	q->in plus
../inputs/grep1.dat:		p->is##q->left	p->right##q->is	p->is##q->is :	p->right##q->left
../inputs/grep1.dat:		and q->left	and q->right	p->is : NULL	
../inputs/grep1.dat:  newsize = (new == NULL) ? 0 : strlen(new);
../inputs/grep1.dat:      label = kwset->trans ? kwset->trans[(unsigned char) *--text] : *--text;
../inputs/grep1.dat:		      l->balance = t->balance != 1 ? 0 : -1;
../inputs/grep1.dat:		      r->balance = t->balance != (char) -1 ? 0 : 1;
../inputs/grep1.dat:		      l->balance = t->balance != 1 ? 0 : -1;
../inputs/grep1.dat:		      r->balance = t->balance != (char) -1 ? 0 : 1;
../inputs/grep1.dat:	  c = trans ? trans[(unsigned char) *--beg] : *--beg;
../inputs/grep1.dat:	  c = trans ? trans[(unsigned char) *--beg] : *--beg;
../inputs/grep1.dat:   do not allow (expr) ? void : void.  */
../inputs/grep1.dat:   : (*(h)->chunkfun) ((size)))
../inputs/grep1.dat:#define TOLOWER(C) (ISUPPER(C) ? tolower(C) : (C))
../inputs/grep1.dat:  if (!(kwset = kwsalloc(match_icase ? trans : (char *) 0)))
../inputs/grep1.dat:  *endp = end < buflim ? end + 1 : end;
