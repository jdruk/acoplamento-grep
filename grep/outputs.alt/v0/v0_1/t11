/* grep.c - main driver file for grep.
   Copyright (C) 1992 Free Software Foundation, Inc.
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   Written July 1992 by Mike Haertel.  */
#define GREP 1
#define STDC_HEADERS 1
#define HAVE_STRING_H 1
#define HAVE_SYS_PARAM_H 1
#define HAVE_UNISTD_H 1
#define HAVE_ALLOCA_H 1
#define HAVE_GETPAGESIZE 1
#define HAVE_MEMCHR 1
#define HAVE_STRERROR 1
#define HAVE_VALLOC 1
#define HAVE_WORKING_MMAP 1
#define flag_stdlib 1
#define flag_systypes 1
#define flag_string 1
#define flag_memory 1
#define flag_strings 1
#define flag_systypes 1
  for (p = (unsigned char *) vp; n--; ++p)
  errseen = 1;
static char *bufbeg;		/* Beginning of user-visible stuff. */
static char *buflim;		/* Limit of user-visible stuff. */
#define flag_systypes 1
      initialized = 1;
      bufsalloc = MAX(8192, getpagesize());
      /* The 1 byte of overflow is a kludge for dfaexec(), which
      buffer = valloc(bufalloc + 1);
      bufmapped = 1;
      bufoffset = lseek(fd, 0, 1);
      nbuffer = valloc(bufalloc + 1);
  sp = buflim - save;
  dp = nbuffer + bufsalloc - save;
  while (save--)
      && bufstat.st_size - bufoffset >= bufalloc - bufsalloc)
      maddr = mmap(maddr, bufalloc - bufsalloc, PROT_READ | PROT_WRITE,
      if (maddr == (caddr_t) -1)
	 but it doesn't, at least not on a Sun running 4.1.
      madvise(maddr, bufalloc - bufsalloc, MADV_SEQUENTIAL);
      cc = bufalloc - bufsalloc;
      cc = read(bufdesc, buffer + bufsalloc, bufalloc - bufsalloc);
  cc = read(bufdesc, buffer + bufsalloc, bufalloc - bufsalloc);
    printf("%lu%c", totalcc + (beg - bufbeg), sep);
  fwrite(beg, 1, lim - beg, stdout);
      --pending;
      if ((nl = memchr(lastout, '\n', lim - lastout)) != 0)
      prline(lastout, nl, '-');
   If NLINESP is non-null, store a count of lines between BEG and LIM. */
  static int used;		/* avoid printing "--" before any output */
	    --p;
	  while (p > bp && p[-1] != '\n');
      /* We only print the "--" separator if our output is
	puts("--");
	  nl = memchr(p, '\n', beg - p);
	  prline(p, nl + 1, '-');
	  p = nl + 1;
	  if ((nl = memchr(p, '\n', lim - p)) != 0)
  used = 1;
  while ((b = (*execute)(p, lim - p, &endp)) != 0)
      if (b == lim && ((b > beg && b[-1] == '\n') || b == beg))
	  nlines += 1;
      if (buflim - bufbeg == save)
      beg = bufbeg + save - residue;
      for (lim = buflim; lim > beg && lim[-1] != '\n'; --lim)
      residue = buflim - lim;
	    --beg;
	  while (beg > bufbeg && beg[-1] != '\n');
      save = residue + lim - beg;
      totalcc += buflim - bufbeg - save;
      nlines += grepbuf(bufbeg + save - residue, buflim);
  "usage: %s [-[[AB] ]<num>] [-[CEFGVchilnqsvwx]] [-[ef]] <expr> [<files...>]\n"
   If we find it, install it in compile and execute, and return 1.  */
	return 1;
    prog = strrchr(prog, '/') + 1;
  while ((opt = getopt(argc, argv, "0123456789A:B:CEFGVX:bce:f:hiLlnqsvwxy"))
      case '1':
	out_before = 10 * out_before + opt - '0';
	out_after = 10 * out_after + opt - '0';
	  fatal("you may specify only one of -E, -F, or -G", 0);
	matcher = "posix-egrep";
	  fatal("you may specify only one of -E, -F, or -G", 0);;
	  fatal("you may specify only one of -E, -F, or -G", 0);
	out_byte = 1;
	out_quiet = 1;
	count_matches = 1;
	keys = xrealloc(keys, keycc + cc + 1);
	keyfound = 1;
	fp = strcmp(optarg, "-") != 0 ? fopen(optarg, "r") : stdin;
	for (keyalloc = 1; keyalloc <= keycc; keyalloc *= 2)
	       && (cc = fread(keys + keycc, 1, keyalloc - keycc, fp)) > 0)
	if (keycc - oldcc > 0 && keys[keycc - 1] == '\n')
	  --keycc;
	keyfound = 1;
	no_filenames = 1;
      case 'y':			/* For old-timers . . . */
	match_icase = 1;
	/* Like -l, except list files that don't contain matches.
	out_quiet = 1;
	list_files = -1;
	out_quiet = 1;
	list_files = 1;
	out_line = 1;
	out_quiet = 1;
	suppress_errors = 1;
	out_invert = 1;
	match_words = 1;
	match_lines = 1;
  if (argc - optind > 1 && !no_filenames)
    out_file = 1;
  status = 1;
	desc = strcmp(argv[optind], "-") ? open(argv[optind], O_RDONLY) : 0;
		if (list_files == 1)
	    else if (list_files == -1)
	  if (list_files == 1)
      else if (list_files == -1)
   "Keep this file name-space clean" means, talk to roland@gnu.ai.mit.edu
   Copyright (C) 1987, 88, 89, 90, 91, 92, 1993
   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
#define flag_config 1
#define flag_alloca 1
/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.  */
   program understand `configure --with-gnu-libc' and omit the object files,
/* Don't include stdlib.h for non-GNU C libraries because some of them
#define flag_stdlib 1
/* If GETOPT_COMPAT is defined, `+' as well as `--' can introduce a
   long-named option.  Because this is not POSIX.2 compliant, it is
   each non-option ARGV-element is returned here.  */
   non-option elements that the caller should itself scan.
/* XXX 1003.2 says this must be 1 before any call.  */
/* The next char to be scanned in the option-element
   by advancing to the next ARGV-element.  */
int opterr = 1;
/* Describe how to deal with options that follow non-option ARGV-elements.
   stop option processing when the first non-option is seen.
   so that eventually all the non-options are at the end.  This allows options
   to expect options and other ARGV-elements in any order and that care about
   the ordering of the two.  We describe each non-option ARGV-element
   as if it were the argument of an option with character code 1.
   Using `-' as the first character of the list of option characters
   The special argument `--' forces an end of option-scanning regardless
   `--' can cause `getopt' to return EOF with `optind' != ARGC.  */
/* We want to avoid inclusion of string.h with non-GNU libraries
#define flag_string 1
/* Describe the part of ARGV that contains non-options that have
   which contains all the non-options that have been skipped so far.
   the options processed since those non-options were skipped.
   the new indices of the non-options in ARGV after they are moved.  */
  int nonopts_size = (last_nonopt - first_nonopt) * sizeof (char *);
	    (optind - last_nonopt) * sizeof (char *));
	    (char *) &argv[first_nonopt + optind - last_nonopt],
  /* Update records for the slots the non-options now occupy.  */
  first_nonopt += (optind - last_nonopt);
   If an element of ARGV starts with '-', and is not exactly "-" or "--",
   (aside from the initial '-') are option characters.  If `getopt'
   resume the scan with the following option character or ARGV-element.
   Then `optind' is the index in ARGV of the first ARGV-element
   that is not an option.  (The ARGV-elements have been permuted
   so the following text in the same ARGV-element, or the text of the following
   ARGV-element, is returned in `optarg'.  Two colons mean an option that
   wants an optional arg; if there is text in the current ARGV-element,
   If OPTSTRING starts with `-' or `+', it requests different methods of
   handling the non-option ARGV-elements.
   Long-named options begin with `--' instead of `-'.
   argument, it follows the option name in the same ARGV-element, separated
   from the option name by a `=', or else the in next ARGV-element.
   When `getopt' finds a long-named option, it returns 0 if that option's
   LONGIND returns the index in LONGOPT of the long-named option found.
   It is only valid when a long-named option has been found by the most
   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
   long-named options.  */
     Start processing options with ARGV-element 1 (since ARGV-element 0
     non-option ARGV-elements is empty.  */
      first_nonopt = last_nonopt = optind = 1;
      if (optstring[0] == '-')
	  /* If we have just processed some options following some non-options,
	  /* Now skip any additional non-options
	     and extend the range of non-options previously skipped.  */
		 && (argv[optind][0] != '-' || argv[optind][1] == '\0')
		     || argv[optind][0] != '+' || argv[optind][1] == '\0')
      /* Special ARGV-element `--' means premature end of options.
	 then exchange with previous non-options as if it were an option,
	 then skip everything else like a non-option.  */
      if (optind != argc && !strcmp (argv[optind], "--"))
      /* If we have done all the ARGV-elements, stop the scan
	 and back over any non-options that we skipped and permuted.  */
	  /* Set the next-arg-index to point at the non-options
      /* If we have come to a non-option and did not permute it,
      if ((argv[optind][0] != '-' || argv[optind][1] == '\0')
	      || argv[optind][0] != '+' || argv[optind][1] == '\0')
	  return 1;
      /* We have found another option-ARGV-element.
      nextchar = (argv[optind] + 1
		  + (longopts != NULL && argv[optind][1] == '-'));
      && ((argv[optind][0] == '-'
	   && (argv[optind][1] == '-' || long_only))
      for (p = longopts, option_index = 0; p->name;
	if (!strncmp (p->name, nextchar, s - nextchar))
	    if (s - nextchar == strlen (p->name))
		exact = 1;
	      ambig = 1;
	      if (pfound->has_arg)
		optarg = s + 1;
		      if (argv[optind - 1][1] == '-')
			/* --option */
				 "%s: option `--%s' doesn't allow an argument\n",
				 argv[0], pfound->name);
			/* +option or -option */
			     argv[0], argv[optind - 1][0], pfound->name);
	  else if (pfound->has_arg == 1)
			     argv[0], argv[optind - 1]);
	  if (pfound->flag)
	      *(pfound->flag) = pfound->val;
	  return pfound->val;
	 or the option starts with '--' or is not a valid short
      if (!long_only || argv[optind][1] == '-'
	      if (argv[optind][1] == '-')
		/* --option */
		fprintf (stderr, "%s: unrecognized option `--%s'\n",
		/* +option or -option */
  /* Look at and handle the next option-character.  */
	    if (c < 040 || c >= 0177)
	      fprintf (stderr, "%s: unrecognized option `-%c'\n", argv[0], c);
	    /* 1003.2 specifies the format of this message.  */
	    fprintf (stderr, "%s: illegal option -- %c\n", argv[0], c);
    if (temp[1] == ':')
		/* If we end this ARGV-element by taking the rest as an arg,
		    fprintf (stderr, "%s: option `-%c' requires an argument\n",
		    /* 1003.2 specifies the format of this message.  */
		    fprintf (stderr, "%s: option requires an argument -- %c\n",
		 increment it again when taking next ARGV-elt as argument.  */
/* Compile with -DTEST to make an executable for use in testing
  while (1)
      int this_option_optind = optind ? optind : 1;
      c = getopt (argc, argv, "abc:d:0123456789");
	case '1':
	    printf ("digits occur in two different argv-elements.\n");
      printf ("non-option ARGV-elements: ");
   version 0.12.
   (Implements POSIX draft P10003.2/D11.2, except for
   Copyright (C) 1993 Free Software Foundation, Inc.
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
#define flag_systypes 1
#define flag_config 1
#define flag_string 1
#define bcmp(s1, s2, n)	memcmp ((s1), (s2), (n))
#define flag_strings 1
#define flag_stdlib 1
#define Sword 1
   done = 1;
   isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
   Defining isascii to 1 should let any compiler worth its salt
#define isascii(c) 1
#define SIGN_EXTEND_CHAR(c) ((((unsigned char) (c)) ^ 128) - 128)
   re_search* or re_match* could cause memory leaks when C-g is used in
   not functions -- `alloca'-allocated space disappears at the end of the
#define flag_alloca 1
/* True if `size1' is non-NULL and PTR is pointing anywhere inside
   `string1' or just past its end.  This works if PTR is NULL, which is
  (size1 && string1 <= (ptr) && (ptr) <= string1 + size1)
#define STREQ(s1, s2) ((strcmp (s1, s2) == 0))
#define true 1
   So regex.h defines a symbol `RE_EXACTN_VALUE' to be 1; the value of
   `exactn' we use here must also be 1.  */
  exactn = 1,
           are ordered low-bit-first.  A character is in the set if its
           bit is 1.  A character too large to have a bit in the map is
        /* Followed by two-byte relative address of place to resume at
           two-byte relative address.  */
           Followed by two-byte address.  */
        /* Jump to following two-byte address, and push a dummy failure
        /* Followed by two-byte relative address and two-byte number n.
        /* Followed by two-byte relative address, and two-byte number n.
        /* Set the following two-byte relative address to the
           subsequent two-byte number.  The address *includes* the two
  wordchar,	/* Matches any word-constituent character.  */
  notwordchar,	/* Matches any char that is not a word-constituent.  */
    (destination)[1] = (number) >> 8;					\
    (destination) += SIGN_EXTEND_CHAR (*((source) + 1)) << 8;		\
  int temp = SIGN_EXTEND_CHAR (*(source + 1)); 
   the other test files, you can run the already-written tests.  */
#define DEBUG_PRINT1(x) if (debug) printf (x)
#define DEBUG_PRINT2(x1, x2) if (debug) printf (x1, x2)
#define DEBUG_PRINT3(x1, x2, x3) if (debug) printf (x1, x2, x3)
#define DEBUG_PRINT4(x1, x2, x3, x4) if (debug) printf (x1, x2, x3, x4)
#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)			\
  if (debug) print_double_string (w, s1, sz1, s2, sz2)
/* Print the fastmap in human-readable form.  */
  while (i < (1 << BYTEWIDTH))
          printchar (i - 1);
          while (i < (1 << BYTEWIDTH)  &&  fastmap[i])
              was_a_range = 1;
              printf ("-");
              printchar (i - 1);
/* Print a compiled pattern string in human-readable form, starting at
      printf ("%d:\t", p - start);
          while (--mcnt);
            register int c, last = -100;
	            (re_opcode_t) *(p - 1) == charset_not ? "^" : "");
		  && (p[1 + (c/8)] & (1 << (c % 8))))
		  if (last + 1 == c && ! in_range)
		      putchar ('-');
		      in_range = 1;
		  else if (last + 1 != c && in_range)
	    p += 1 + *p;
  	  printf ("/on_failure_jump to %d", p + mcnt - start);
  	  printf ("/on_failure_keep_string_jump to %d", p + mcnt - start);
  	  printf ("/dummy_failure_jump to %d", p + mcnt - start);
  	  printf ("/maybe_pop_jump to %d", p + mcnt - start);
  	  printf ("/pop_failure_jump to %d", p + mcnt - start);
  	  printf ("/jump_past_alt to %d", p + mcnt - start);
  	  printf ("/jump to %d", p + mcnt - start);
	  printf ("/succeed_n to %d, %d times", p + mcnt - start, mcnt2);
	  printf ("/jump_n to %d, %d times", p + mcnt - start, mcnt2);
	  printf ("/set_number_at location %d to %d", p + mcnt - start, mcnt2);
          printf ("?%d", *(p-1));
  printf ("%d:\tend of pattern.\n", p - start);
  unsigned char *buffer = bufp->buffer;
  print_partial_compiled_pattern (buffer, buffer + bufp->used);
  printf ("%d bytes used/%d bytes allocated.\n", bufp->used, bufp->allocated);
  if (bufp->fastmap_accurate && bufp->fastmap)
      print_fastmap (bufp->fastmap);
  printf ("re_nsub: %d\t", bufp->re_nsub);
  printf ("regs_alloc: %d\t", bufp->regs_allocated);
  printf ("can_be_null: %d\t", bufp->can_be_null);
  printf ("newline_anchor: %d\n", bufp->newline_anchor);
  printf ("no_sub: %d\t", bufp->no_sub);
  printf ("not_bol: %d\t", bufp->not_bol);
  printf ("not_eol: %d\t", bufp->not_eol);
  printf ("syntax: %d\n", bufp->syntax);
print_double_string (where, string1, size1, string2, size2)
    const char *string1;
    int size1;
          for (this_char = where - string1; this_char < size1; this_char++)
            printchar (string1[this_char]);
      for (this_char = where - string2; this_char < size2; this_char++)
#define DEBUG_PRINT1(x)
#define DEBUG_PRINT2(x1, x2)
#define DEBUG_PRINT3(x1, x2, x3)
#define DEBUG_PRINT4(x1, x2, x3, x4)
#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)
static void store_op1 (), store_op2 ();
static void insert_op1 (), insert_op2 ();
/* Fetch the next character in the uncompiled pattern---translating it 
#define PATUNFETCH p--
/* If `translate' is non-null, return translate[D], else just D.  We
    while (b - bufp->buffer + (n) > bufp->allocated)			\
    GET_BUFFER_SPACE (1);						\
/* Ensure we have two more bytes of buffer space and then append C1 and C2.  */
#define BUF_PUSH_2(c1, c2)						\
    *b++ = (unsigned char) (c1);					\
#define BUF_PUSH_3(c1, c2, c3)						\
    *b++ = (unsigned char) (c1);					\
  store_op1 (op, loc, (to) - (loc) - 3)
/* Likewise, for a two-argument jump.  */
  store_op2 (op, loc, (to) - (loc) - 3, arg)
  insert_op1 (op, loc, (to) - (loc) - 3, b)
  insert_op2 (op, loc, (to) - (loc) - 3, arg, b)
   into the pattern are two bytes long.  So if 2^16 bytes turns out to
#define MAX_BUF_SIZE (1L << 16)
    unsigned char *old_buffer = bufp->buffer;				\
    if (bufp->allocated == MAX_BUF_SIZE) 				\
    bufp->allocated <<= 1;						\
    if (bufp->allocated > MAX_BUF_SIZE)					\
      bufp->allocated = MAX_BUF_SIZE; 					\
    bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated);\
    if (bufp->buffer == NULL)						\
    if (old_buffer != bufp->buffer)					\
        b = (b - old_buffer) + bufp->buffer;				\
        begalt = (begalt - old_buffer) + bufp->buffer;			\
          fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;\
          laststart = (laststart - old_buffer) + bufp->buffer;		\
          pending_exact = (pending_exact - old_buffer) + bufp->buffer;	\
   be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
   |= 1 << (((unsigned char) c) % BYTEWIDTH))
           num = num * 10 + c - '0'; 					\
  register unsigned char c, c1;
  const char *p1;
  char *translate = bufp->translate;
  /* Address of the count-byte of the most recently inserted `exactn'
     command.  This makes it possible to tell if a new exact-match
     the containing expression.  Each alternative of an `or' -- except the
     last -- ends with a forward jump of this sort.  */
  /* Counts open-groups as they are encountered.  Remembered for the
     matching close-group on the compile stack, so the same register
  DEBUG_PRINT1 ("\nCompiling pattern: ");
  bufp->syntax = syntax;
  bufp->fastmap_accurate = 0;
  bufp->not_bol = bufp->not_eol = 0;
  bufp->used = 0;
  /* Always count groups, whether or not bufp->no_sub is set.  */
  bufp->re_nsub = 0;				
  if (bufp->allocated == 0)
      if (bufp->buffer)
	{ /* If zero allocated, but buffer is non-null, try to realloc
          RETALLOC (bufp->buffer, INIT_BUF_SIZE, unsigned char);
          bufp->buffer = TALLOC (INIT_BUF_SIZE, unsigned char);
      if (!bufp->buffer) return REG_ESPACE;
      bufp->allocated = INIT_BUF_SIZE;
  begalt = b = bufp->buffer;
                   p == pattern + 1
            /* 1 means zero (many) matches is allowed.  */
                    PATFETCH (c1);
                    if (!(c1 == '+' || c1 == '?'))
                    c = c1;
                assert (p - 1 > pattern);
                if (TRANSLATE (*(p - 2)) == TRANSLATE ('.')
                  STORE_JUMP (maybe_pop_jump, b, laststart - 3);
            p1 = p;
            BUF_PUSH ((1 << BYTEWIDTH) / BYTEWIDTH);
            bzero (b, (1 << BYTEWIDTH) / BYTEWIDTH);
            if ((re_opcode_t) b[-2] == charset_not
                    PATFETCH (c1);
                    SET_LIST_BIT (c1);
                if (c == ']' && p != p1 + 1)
                if (had_char_class && c == '-' && *p != ']')
                if (c == '-' 
                    && !(p - 2 >= pattern && p[-2] == '[') 
                    && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^')
                else if (p[0] == '-' && p[1] != ']')
		    /* Move past the `-'.  */
                    PATFETCH (c1);
                    char str[CHAR_CLASS_MAX_LENGTH + 1];
                    c1 = 0;
                            || c1 == CHAR_CLASS_MAX_LENGTH)
                        str[c1++] = c;
                    str[c1] = '\0';
                        for (ch = 0; ch < 1 << BYTEWIDTH; ch++)
                        c1++;
                        while (c1--)    
               end of the map.  Decrease the map-length byte too.  */
            while ((int) b[-1] > 0 && b[b[-1] - 1] == 0) 
              b[-1]--; 
            b += b[-1];
              bufp->re_nsub++;
                  RETALLOC (compile_stack.stack, compile_stack.size << 1,
                  compile_stack.size <<= 1;
              COMPILE_STACK_TOP.begalt_offset = begalt - bufp->buffer;
                = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
              COMPILE_STACK_TOP.laststart_offset = b - bufp->buffer;
                  COMPILE_STACK_TOP.inner_group_offset = b - bufp->buffer + 2;
                  STORE_JUMP (jump_past_alt, fixup_alt_jump, b - 1);
                   as in `(ab)c(de)' -- the second group is #2.  */
                compile_stack.avail--;		
                begalt = bufp->buffer + COMPILE_STACK_TOP.begalt_offset;
                    ? bufp->buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1 
                laststart = bufp->buffer + COMPILE_STACK_TOP.laststart_offset;
                      = bufp->buffer + COMPILE_STACK_TOP.inner_group_offset;
                    *inner_group_loc = regnum - this_group_regnum;
                                regnum - this_group_regnum);
                 three-byte space after `a'.  We'll put in the jump, set
                     /* If we're at `\{' and it's not the open-interval 
                  || (p - 2 == pattern  &&  p == pend))
                int lower_bound = -1, upper_bound = -1;
                beg_interval = p - 1;
                  /* Interval such as `{1}' => match exactly once. */
                    `upper_bound' is 1, though.)  */
                   { /* If the upper bound is > 1, we need to insert
                     unsigned nbytes = 10 + (upper_bound > 1) * 10;
                                   b + 5 + (upper_bound > 1) * 5,
                     if (upper_bound > 1)
                            jump back only `upper_bound - 1' times.  */
                                      upper_bound - 1);
                            parameter of the `jump_n'; that is `b-2' as
                            inserting into the middle of the pattern --
                            Conclusion: (b - 2) - (laststart + 3) + 5,
                            i.e., b - laststart.
                         insert_op2 (set_number_at, laststart, b - laststart,
                                     upper_bound - 1, b);
                   if (p > pattern  &&  p[-1] == '\\')
               operators.  rms says this is ok.  --karl  */
            case '1': case '2': case '3': case '4': case '5':
              c1 = c - '0';
              if (c1 > regnum)
              if (group_in_compile_stack (compile_stack, c1))
              BUF_PUSH_2 (duplicate, c1);
              || pending_exact + *pending_exact + 1 != b
	      || *pending_exact == (1 << BYTEWIDTH) - 1
		  ? *p == '\\' && (p[1] == '+' || p[1] == '?')
                      : (p[0] == '\\' && p[1] == '{'))))
	      pending_exact = b - 1;
  bufp->used = b - bufp->buffer;
      DEBUG_PRINT1 ("\nCompiled pattern: \n");
/* Store OP at LOC followed by two-byte integer parameter ARG.  */
store_op1 (op, loc, arg)
  STORE_NUMBER (loc + 1, arg);
/* Like `store_op1', but" for 'two two-byte parameters ARG1 and ARG2.  */
store_op2 (op, loc, arg1, arg2)
    int arg1, arg2;
  STORE_NUMBER (loc + 1, arg1);
   for OP followed by two-byte integer parameter ARG.  */
insert_op1 (op, loc, arg, end)
    *--pto = *--pfrom;
  store_op1 (op, loc, arg);
/* Like `insert_op1', but for two two-byte parameters ARG1 and ARG2.  */
insert_op2 (op, loc, arg1, arg2, end)
    int arg1, arg2;
    *--pto = *--pfrom;
  store_op2 (op, loc, arg1, arg2);
   after an alternative or a begin-subexpression.  We assume there is at
  const char *prev = p - 2;
  boolean prev_prev_backslash = prev > pattern && prev[-1] == '\\';
  const char *next_next = p + 1 < pend ? p + 1 : NULL;
  for (this_element = compile_stack.avail - 1;  
       this_element--)
   starting character is in `P[-2]'.  (`P[-1]' is the character `-'.)
     appropriate translation is done in the bit-setting loop below.  */
  range_start = ((unsigned char *) p)[-2];
     char' -- the range is inclusive, so if `range_end' == 0xff
     (assuming 8-bit characters), we would otherwise go into an infinite
#define FAIL_STACK_PTR_EMPTY() (fail_stack_ptr->avail == 0)
/* Initialize `fail_stack'.  Do `return -2' if the alloc fails.  */
      return -2;							\
   Return 1 if succeeds, and 0 if either ran out of memory
          ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),	\
      : ((fail_stack).size <<= 1, 					\
         1)))
   Return 1 if was able to do so and 0 if ran out of memory allocating
       1))
/* This pushes an item onto the failure stack.  Must be a four-byte
#define POP_FAILURE_ITEM() fail_stack.stack[--fail_stack.avail]
       of 0 + -1 isn't done as unsigned.  */				\
    DEBUG_PRINT1 ("\n");						\
	DEBUG_PRINT1 ("\n");						\
    DEBUG_PRINT_DOUBLE_STRING (string_place, string1, size1, string2,   \
    DEBUG_PRINT1 ("'\n");						\
#define MAX_FAILURE_ITEMS ((num_regs - 1) * NUM_REG_ITEMS + NUM_NONREG_ITEMS)
  ((highest_active_reg - lowest_active_reg + 1) * NUM_REG_ITEMS 	\
#define REMAINING_AVAIL_SLOTS ((fail_stack).size - (fail_stack).avail)
     STR -- the saved data position.
     PAT -- the saved pattern position.
     LOW_REG, HIGH_REG -- the highest and lowest active registers.
     REGSTART, REGEND -- arrays of string positions.
     REG_INFO -- array of information about each subexpression.
   `pend', `string1', `size1', `string2', and `size2'.  */
  DEBUG_PRINT1 ("POP_FAILURE_POINT:\n");				\
  DEBUG_PRINT_DOUBLE_STRING (str, string1, size1, string2, size2);	\
  DEBUG_PRINT1 ("'\n");							\
  for (this_reg = high_reg; this_reg >= low_reg; this_reg--)		\
   BUFP.  A fastmap records which of the (1 << BYTEWIDTH) possible
   The caller must supply the address of a (1 << BYTEWIDTH)-byte data
   area as BUFP->fastmap.
   Returns 0 if we succeed, -2 if an internal error.   */
  register char *fastmap = bufp->fastmap;
  unsigned char *pattern = bufp->buffer;
  unsigned long size = bufp->used;
  bzero (fastmap, 1 << BYTEWIDTH);  /* Assume nothing's valid.  */
  bufp->fastmap_accurate = 1;	    /* It will be when we're done.  */
  bufp->can_be_null = 0;
          bufp->can_be_null |= path_can_be_null;
          p = fail_stack.stack[--fail_stack.avail];
	  bufp->can_be_null = 1;
          fastmap[p[1]] = 1;
          for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
	    if (p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH)))
              fastmap[j] = 1;
	  for (j = *p * BYTEWIDTH; j < (1 << BYTEWIDTH); j++)
            fastmap[j] = 1;
	  for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
	    if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))))
              fastmap[j] = 1;
	  for (j = 0; j < (1 << BYTEWIDTH); j++)
	      fastmap[j] = 1;
	  for (j = 0; j < (1 << BYTEWIDTH); j++)
	      fastmap[j] = 1;
	  for (j = 0; j < (1 << BYTEWIDTH); j++)
            fastmap[j] = 1;
          if (!(bufp->syntax & RE_DOT_NEWLINE))
	  else if (bufp->can_be_null)
	  for (j = 0; j < (1 << BYTEWIDTH); j++)
	      fastmap[j] = 1;
	  for (j = 0; j < (1 << BYTEWIDTH); j++)
	      fastmap[j] = 1;
	      && fail_stack.stack[fail_stack.avail - 1] == p)
            fail_stack.avail--;
                return -2;
            bufp->can_be_null = 1;
              p -= 4;
         characters for one path of the pattern -- and that the empty
  bufp->can_be_null |= path_can_be_null;
      bufp->regs_allocated = REGS_REALLOCATE;
      regs->num_regs = num_regs;
      regs->start = starts;
      regs->end = ends;
      bufp->regs_allocated = REGS_UNALLOCATED;
      regs->num_regs = 0;
      regs->start = regs->end = (regoff_t) 0;
/* Using the compiled pattern in BUFP->buffer, first tries to match the
   virtual concatenation of STRING1 and STRING2, starting first at index
   STARTPOS, then at STARTPOS + 1, and so on.
   STRING1 and STRING2 have length SIZE1 and SIZE2, respectively.
   In REGS, return the indices of the virtual concatenation of STRING1
   and STRING2 that matched the entire BUFP->buffer and its contained
   concatenation of STRING1 and STRING2.
   found, -1 if no match, or -2 if error (such as failure
re_search_2 (bufp, string1, size1, string2, size2, startpos, range, regs, stop)
     const char *string1, *string2;
     int size1, size2;
  register char *fastmap = bufp->fastmap;
  register char *translate = bufp->translate;
  int total_size = size1 + size2;
  /* Check for out-of-range STARTPOS.  */
    return -1;
     the virtual concatenation of STRING1 and STRING2.  */
  if (endpos < -1)
    range = -1 - startpos;
    range = total_size - startpos;
  if (bufp->used > 0 && (re_opcode_t) bufp->buffer[0] == begbuf && range > 0)
	return -1;
	range = 1;
  if (fastmap && !bufp->fastmap_accurate)
    if (re_compile_fastmap (bufp) == -2)
      return -2;
      if (fastmap && startpos < total_size && !bufp->can_be_null)
              if (startpos < size1 && startpos + range >= size1)
                lim = range - (size1 - startpos);
	      d = (startpos >= size1 ? string2 - size1 : string1) + startpos;
              /* Written out as an if-else to avoid testing `translate'
                  range--;
                  range--;
	      startpos += irange - range;
	      register char c = (size1 == 0 || startpos >= size1
                                 ? string2[startpos - size1] 
                                 : string1[startpos]);
          && !bufp->can_be_null)
	return -1;
      val = re_match_2 (bufp, string1, size1, string2, size2,
      if (val == -2)
	return -2;
          range--; 
          startpos--;
  return -1;
/* Structure for per-register (a.k.a. per-group) information.
    unsigned is_active : 1;
    unsigned matched_something : 1;
    unsigned ever_matched_something : 1;
            = 1;							\
/* This converts PTR, a pointer into one of the search strings `string1'
  (FIRST_STRING_P (ptr) ? (ptr) - string1 : (ptr) - string2 + size1)
#define REG_UNSET_VALUE ((char *) -1)
#define MATCHING_IN_FIRST_STRING  (dend == end_match_1)
      /* End of string1 => advance to string2.  */ 			\
   of `string1' and `string2'.  If only one string, it's `string2'.  */
#define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)
/* Test if D points to a character which is word-constituent.  We have
   two special cases to check for: if past the end of string1, look at
   string2, look at the last character in string1.  */
  (SYNTAX ((d) == end1 ? *string2					\
           : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\
   to being word-constituent.  */
   || WORDCHAR_P (d - 1) != WORDCHAR_P (d))
   use numbers larger than 255.  They must differ by 1, because of
#define NO_HIGHEST_ACTIVE_REG (1 << BYTEWIDTH)
#define NO_LOWEST_ACTIVE_REG (NO_HIGHEST_ACTIVE_REG + 1)
   the (virtual) concatenation of STRING1 and STRING2 (of length SIZE1
   If REGS is non-null and the `no_sub' field of BUFP is nonzero, we
   We return -1 if no match, -2 if an internal error (such as the
re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
     const char *string1, *string2;
     int size1, size2;
  unsigned char *p1;
  const char *end1, *end2;
  /* Pointers into string1 and string2, just past the last characters in
  const char *end_match_1, *end_match_2;
  unsigned char *p = bufp->buffer;
  register unsigned char *pend = p + bufp->used;
  char *translate = bufp->translate;
  unsigned num_regs = bufp->re_nsub + 1;
     regnum-th regstart pointer points to where in the pattern we began
     matching and the regnum-th regend points to right after where we
     stopped matching the regnum-th subexpression.  (The zeroth register
     are when we last see its open-group operator.  Similarly for a
     matched any of the pattern so far this time through the reg_num-th
  DEBUG_PRINT1 ("\n\nEntering re_match_2.\n");
  if (bufp->re_nsub)
          return -2;
  if (pos < 0 || pos > size1 + size2)
      return -1;
  /* Initialize subexpression text positions to -1 to mark ones that no
  for (mcnt = 1; mcnt < num_regs; mcnt++)
  /* We move `string1' into `string2' if the latter's empty -- but not if
     `string1' is null.  */
  if (size2 == 0 && string1 != NULL)
      string2 = string1;
      size2 = size1;
      string1 = 0;
      size1 = 0;
  end1 = string1 + size1;
  if (stop <= size1)
      end_match_1 = string1 + stop;
      end_match_1 = end1;
      end_match_2 = string2 + stop - size1;
  if (size1 > 0 && pos <= size1)
      d = string1 + pos;
      dend = end_match_1;
      d = string2 + pos - size1;
  DEBUG_PRINT1 ("The compiled pattern is: ");
  DEBUG_PRINT1 ("The string to match is: `");
  DEBUG_PRINT_DOUBLE_STRING (d, string1, size1, string2, size2);
  DEBUG_PRINT1 ("'\n");
          DEBUG_PRINT1 ("end of pattern ... ");
              DEBUG_PRINT1 ("backtracking.\n");
                      DEBUG_PRINT1 ("\nSAVING match as best so far.\n");
                      for (mcnt = 1; mcnt < num_regs; mcnt++)
                     end_match_1' while the restored d is in string2.
                     strings `x-' and `y-z-', if the two strings are
                  DEBUG_PRINT1 ("Restoring best registers.\n");
                  dend = ((d >= string1 && d <= end1)
		           ? end_match_1 : end_match_2);
		  for (mcnt = 1; mcnt < num_regs; mcnt++)
          DEBUG_PRINT1 ("Accepting match.\n");
          if (regs && !bufp->no_sub)
              if (bufp->regs_allocated == REGS_UNALLOCATED)
                     extra element beyond `num_regs' for the `-1' marker
                  regs->num_regs = MAX (RE_NREGS, num_regs + 1);
                  regs->start = TALLOC (regs->num_regs, regoff_t);
                  regs->end = TALLOC (regs->num_regs, regoff_t);
                  if (regs->start == NULL || regs->end == NULL)
                    return -2;
                  bufp->regs_allocated = REGS_REALLOCATE;
              else if (bufp->regs_allocated == REGS_REALLOCATE)
                  if (regs->num_regs < num_regs + 1)
                      regs->num_regs = num_regs + 1;
                      RETALLOC (regs->start, regs->num_regs, regoff_t);
                      RETALLOC (regs->end, regs->num_regs, regoff_t);
                      if (regs->start == NULL || regs->end == NULL)
                        return -2;
		  /* These braces fend off a "empty body in an else-statement"
		  assert (bufp->regs_allocated == REGS_FIXED);
              if (regs->num_regs > 0)
                  regs->start[0] = pos;
                  regs->end[0] = (MATCHING_IN_FIRST_STRING ? d - string1
			          : d - string2 + size1);
              /* Go through the first `min (num_regs, regs->num_regs)'
	      for (mcnt = 1; mcnt < MIN (num_regs, regs->num_regs); mcnt++)
                    regs->start[mcnt] = regs->end[mcnt] = -1;
		      regs->start[mcnt] = POINTER_TO_OFFSET (regstart[mcnt]);
                      regs->end[mcnt] = POINTER_TO_OFFSET (regend[mcnt]);
                 were in the pattern, set the extra elements to -1.  If
                 -1 at the end.  */
              for (mcnt = num_regs; mcnt < regs->num_regs; mcnt++)
                regs->start[mcnt] = regs->end[mcnt] = -1;
	    } /* regs && !bufp->no_sub */
                        nfailure_points_pushed - nfailure_points_popped);
          mcnt = d - pos - (MATCHING_IN_FIRST_STRING 
			    ? string1 
			    : string2 - size1);
          DEBUG_PRINT1 ("EXECUTING no_op.\n");
          /* This is written out as an if-else so we don't waste time
	      while (--mcnt);
	      while (--mcnt);
          DEBUG_PRINT1 ("EXECUTING anychar.\n");
          if ((!(bufp->syntax & RE_DOT_NEWLINE) && TRANSLATE (*d) == '\n')
              || (bufp->syntax & RE_DOT_NOT_NULL && TRANSLATE (*d) == '\000'))
	    boolean not = (re_opcode_t) *(p - 1) == charset_not;
		&& p[1 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
	    p += 1 + *p;
	  DEBUG_PRINT3 ("EXECUTING start_memory %d (%d):\n", *p, p[1]);
	  p1 = p;		/* To send to group_match_null_string_p.  */
              = group_match_null_string_p (&p1, pend, reg_info);
             we were at this open-group operator in case the group is
          IS_ACTIVE (reg_info[*p]) = 1;
	  DEBUG_PRINT3 ("EXECUTING stop_memory %d (%d):\n", *p, p[1]);
             this close-group operator in case the group is operated
                 new highest active register is 1.  */
              unsigned char r = *p - 1;
                r--;
                 registers 1 and 2 as a result of the *, but when we pop
                 back to the second ), we are at the stop_memory 1.
               || (re_opcode_t) p[-3] == start_memory)
              p1 = p + 2;
              switch ((re_opcode_t) *p1++)
                    EXTRACT_NUMBER_AND_INCR (mcnt, p1);
		      p1 += 2;
	      p1 += mcnt;
              if (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump
                  && (re_opcode_t) p1[3] == start_memory && p1[4] == *p)
                     regstart[1], and, e.g., with `((a*)*(b*)*)*'
                      for (r = *p; r < *p + *(p + 1); r++)
		  p1++;
                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
                  PUSH_FAILURE_POINT (p1 + mcnt, d, -2);
		     ? regend[regno] : end_match_1);
                    /* End of string1 => advance to string2. */
		mcnt = dend - d;
                if (mcnt > dend2 - d2)
		  mcnt = dend2 - d2;
          DEBUG_PRINT1 ("EXECUTING begline.\n");
              if (!bufp->not_bol) break;
          else if (d[-1] == '\n' && bufp->newline_anchor)
          DEBUG_PRINT1 ("EXECUTING endline.\n");
              if (!bufp->not_eol) break;
          else if ((d == end1 ? *string2 : *d) == '\n'
                   && bufp->newline_anchor)
          DEBUG_PRINT1 ("EXECUTING begbuf.\n");
          DEBUG_PRINT1 ("EXECUTING endbuf.\n");
          DEBUG_PRINT1 ("EXECUTING on_failure_keep_string_jump");
          PUSH_FAILURE_POINT (p + mcnt, NULL, -2);
          DEBUG_PRINT1 ("EXECUTING on_failure_jump");
             For example, in \(a*\)*\1, we need the preceding group,
          p1 = p;
             the result of a completed succeed_n, as in \(a\)\{1,3\}b\1
          while (p1 < pend && (re_opcode_t) *p1 == no_op)
            p1++;
          if (p1 < pend && (re_opcode_t) *p1 == start_memory)
              highest_active_reg = *(p1 + 1) + *(p1 + 2);
                lowest_active_reg = *(p1 + 1);
          DEBUG_PRINT1 (":\n");
          PUSH_FAILURE_POINT (p + mcnt, d, -2);
	    /* Skip over open/close-group commands.  */
  	        p[-3] = (unsigned char) pop_failure_jump;
                DEBUG_PRINT1
		     || (bufp->newline_anchor && (re_opcode_t) *p2 == endline))
		p1 = p + mcnt;
                /* p1[0] ... p1[2] are the `on_failure_jump' corresponding
                if ((re_opcode_t) p1[3] == exactn && p1[5] != c)
  		    p[-3] = (unsigned char) pop_failure_jump;
                                  c, p1[5]);
		else if ((re_opcode_t) p1[3] == charset
			 || (re_opcode_t) p1[3] == charset_not)
		    int not = (re_opcode_t) p1[3] == charset_not;
		    if (c < (unsigned char) (p1[4] * BYTEWIDTH)
			&& p1[5 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
                    /* `not' is equal to 1 if c would match, which means
  		        p[-3] = (unsigned char) pop_failure_jump;
                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
	  p -= 2;		/* Point at relative address again.  */
	  if ((re_opcode_t) p[-1] != pop_failure_jump)
	      p[-1] = (unsigned char) jump;
              DEBUG_PRINT1 ("  Match => jump.\n");
            DEBUG_PRINT1 ("EXECUTING pop_failure_jump.\n");
          DEBUG_PRINT1 ("EXECUTING jump_past_alt.\n");
          DEBUG_PRINT1 ("EXECUTING dummy_failure_jump.\n");
          PUSH_FAILURE_POINT (0, 0, -2);
          DEBUG_PRINT1 ("EXECUTING push_dummy_failure.\n");
          PUSH_FAILURE_POINT (0, 0, -2);
               mcnt--;
               mcnt--;
            DEBUG_PRINT1 ("EXECUTING set_number_at.\n");
            p1 = p + mcnt;
            DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p1, mcnt);
	    STORE_NUMBER (p1, mcnt);
          DEBUG_PRINT1 ("EXECUTING wordbound.\n");
          DEBUG_PRINT1 ("EXECUTING notwordbound.\n");
          DEBUG_PRINT1 ("EXECUTING wordbeg.\n");
	  if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))
          DEBUG_PRINT1 ("EXECUTING wordend.\n");
	  if (!AT_STRINGS_BEG (d) && WORDCHAR_P (d - 1)
#ifdef emacs19
          DEBUG_PRINT1 ("EXECUTING before_dot.\n");
          DEBUG_PRINT1 ("EXECUTING at_dot.\n");
          DEBUG_PRINT1 ("EXECUTING after_dot.\n");
#else /* not emacs19 */
          DEBUG_PRINT1 ("EXECUTING at_dot.\n");
	  if (PTR_CHAR_POS ((unsigned char *) d) + 1 != point)
#endif /* not emacs19 */
          DEBUG_PRINT1 ("EXECUTING Emacs wordchar.\n");
          DEBUG_PRINT1 ("EXECUTING Emacs notwordchar.\n");
          DEBUG_PRINT1 ("EXECUTING non-Emacs wordchar.\n");
          DEBUG_PRINT1 ("EXECUTING non-Emacs notwordchar.\n");
          DEBUG_PRINT1 ("\nFAIL:\n");
                  p1 = p + 1;
                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
                  p1 += mcnt;	
                  if ((is_a_jump_n && (re_opcode_t) *p1 == succeed_n)
                          && (re_opcode_t) *p1 == on_failure_jump))
          if (d >= string1 && d <= end1)
	    dend = end_match_1;
  return -1;         			/* Failure to match.  */
  unsigned char *p1 = *p + 2;
  while (p1 < end)
      switch ((re_opcode_t) *p1)
          p1++;
          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
                 /on_failure_jump/0/6/exactn/1/a/jump_past_alt/0/6
                 /on_failure_jump/0/6/exactn/1/b/jump_past_alt/0/3
                 /exactn/1/c						
                 So, we have to first go through the first (n-1)
              /* Deal with the first (n-1) alternatives, which start
              while ((re_opcode_t) p1[mcnt-3] == jump_past_alt)
                  if (!alt_match_null_string_p (p1, p1 + mcnt - 3, 
                  p1 += mcnt;	
                  /* Break if it's the beginning of an n-th alternative
                  if ((re_opcode_t) *p1 != on_failure_jump)
		  /* Still have to check that it's not an n-th
		  p1++;
                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
                  if ((re_opcode_t) p1[mcnt-3] != jump_past_alt)
		      /* Get to the beginning of the n-th alternative.  */
                      p1 -= 3;
              EXTRACT_NUMBER (mcnt, p1 - 2);
              if (!alt_match_null_string_p (p1, p1 + mcnt, reg_info))
              p1 += mcnt;	/* Get past the n-th alternative.  */
	  assert (p1[1] == **p);
          *p = p1 + 2;
          if (!common_op_match_null_string_p (&p1, end, reg_info))
    } /* while p1 < end */
  unsigned char *p1 = p;
  while (p1 < end)
      switch ((re_opcode_t) *p1)
          p1++;
          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
          p1 += mcnt;
          if (!common_op_match_null_string_p (&p1, end, reg_info))
    }  /* while p1 < end */
  unsigned char *p1 = *p;
  switch ((re_opcode_t) *p1++)
      reg_no = *p1;
      ret = group_match_null_string_p (&p1, end, reg_info);
      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
        p1 += mcnt;
      p1 += 2;		
      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
          p1 -= 4;
          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
          p1 += mcnt;
      if (!REG_MATCH_NULL_STRING_P (reg_info[*p1]))
      p1 += 4;
  *p = p1;
/* Return zero if TRANSLATE[S1] and TRANSLATE[S2] are identical for LEN
bcmp_translate (s1, s2, len, translate)
     unsigned char *s1, *s2;
  register unsigned char *p1 = s1, *p2 = s2;
      if (translate[*p1++] != translate[*p2++]) return 1;
      len--;
     (and at least one extra will be -1).  */
  bufp->regs_allocated = REGS_UNALLOCATED;
  bufp->no_sub = 0;
  bufp->newline_anchor = 1;
      re_comp_buf.fastmap = (char *) malloc (1 << BYTEWIDTH);
  re_comp_buf.newline_anchor = 1;
     If REG_ICASE is set, then we considers upper- and lowercase
  preg->buffer = 0;
  preg->allocated = 0;
  preg->used = 0;
  preg->fastmap = 0;
      preg->translate = (char *) malloc (CHAR_SET_SIZE);
      if (preg->translate == NULL)
        preg->translate[i] = ISUPPER (i) ? tolower (i) : i;
    preg->translate = NULL;
      preg->newline_anchor = 1;
    preg->newline_anchor = 0;
  preg->no_sub = !!(cflags & REG_NOSUB);
  /* POSIX doesn't distinguish between an unmatched open-group and an
     unmatched close-group: both are REG_EPAREN.  */
  boolean want_reg_info = !preg->no_sub && nmatch > 0;
  msg_size = strlen (msg) + 1; /* Includes the null.  */
          strncpy (errbuf, msg, errbuf_size - 1);
          errbuf[errbuf_size - 1] = 0;
  if (preg->buffer != NULL)
    free (preg->buffer);
  preg->buffer = NULL;
  preg->allocated = 0;
  preg->used = 0;
  if (preg->fastmap != NULL)
    free (preg->fastmap);
  preg->fastmap = NULL;
  preg->fastmap_accurate = 0;
  if (preg->translate != NULL)
    free (preg->translate);
  preg->translate = NULL;
make-backup-files: t
version-control: t
trim-versions-without-asking: nil
/* dfa.c - deterministic extended regexp routines for GNU
   Copyright (C) 1988 Free Software Foundation, Inc.
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
/* Written June, 1988 by Mike Haertel
   Modified July, 1988 by Arthur David Olson to assist BMG speedups  */
#define flag_stdlib 1
#define flag_systypes 1
#define flag_string 1
#define flag_strings 1
xmalloc_1(n)
xrealloc_1(p, n)
#define MALLOC(p, t, n) ((p) = (t *) xmalloc_1((n) * sizeof (t)))
#define REALLOC(p, t, n) ((p) = (t *) xrealloc_1((ptr_t) (p), (n) * sizeof (t)))
  return c[b / INTBITS] & 1 << b % INTBITS;
  c[b / INTBITS] |= 1 << b % INTBITS;
  c[b / INTBITS] &= ~(1 << b % INTBITS);
equal(s1, s2)
     charclass s1;
    if (s1[i] != s2[i])
  return 1;
/* Find the index of charclass s in dfa->charclasses, or allocate a new charclass. */
  for (i = 0; i < dfa->cindex; ++i)
    if (equal(s, dfa->charclasses[i]))
  REALLOC_IF_NECESSARY(dfa->charclasses, charclass, dfa->calloc, dfa->cindex);
  ++dfa->cindex;
  copyset(s, dfa->charclasses[i]);
/* Flag for case-folding letters into sets. */
  syntax_bits_set = 1;
				   only by zero-width characters. */
    --lexleft;		   	      \
  token c, c1, c2;
	  backslash = 1;
		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == ')')
		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == '|')
	case '1':
	     {M} - exact count
	     {M,} - minimum count, maximum is infinity
	     {,M} - 0 through M
	     {M,N} - M through N */
	      minrep = c - '0';
		  minrep = 10 * minrep + c - '0';
		maxrep = 10 * maxrep + c - '0';
	  laststart = 1;
	  laststart = 1;
	  laststart = 1;
	  --parens;
	      invert = 1;
	      /* Nobody ever said this had to be fast. :-)
		for (c1 = 0; prednames[c1].name; ++c1)
		  if (looking_at(prednames[c1].name))
			if ((*prednames[c1].pred)(c2))
		      lexptr += strlen(prednames[c1].name);
		      lexleft -= strlen(prednames[c1].name);
		      FETCH(c1, "Unbalanced [");
	      FETCH(c1, "Unbalanced [");
	      if (c1 == '-')
		      /* In the case [x-], the - is an ordinary hyphen,
			 which is left in c1, the lookahead character. */
		      --lexptr;
		      FETCH(c1, "Unbalanced [");
	  while ((c = c1) != ']');
  REALLOC_IF_NECESSARY(dfa->tokens, token, dfa->talloc, dfa->tindex);
  dfa->tokens[dfa->tindex++] = t;
      --depth;
      ++dfa->nleaves;
  if (depth > dfa->depth)
    dfa->depth = depth;
  int ntoks1;
  switch (dfa->tokens[tindex - 1])
      return 1;
      return 1 + nsubtoks(tindex - 1);
      ntoks1 = nsubtoks(tindex - 1);
      return 1 + ntoks1 + nsubtoks(tindex - 1 - ntoks1);
    addtok(dfa->tokens[tindex + i]);
	ntokens = nsubtoks(dfa->tindex);
	tindex = dfa->tindex - ntokens;
	for (i = 1; i < minrep; ++i)
  laststart = 1;
  depth = d->depth;
  regexp(1);
  addtok(END - d->nregexps);
  if (d->nregexps)
  ++d->nregexps;
  for (i = 0; i < src->nelem; ++i)
    dst->elems[i] = src->elems[i];
  dst->nelem = src->nelem;
   S->elems must point to an array large enough to hold the resulting set. */
  position t1, t2;
  for (i = 0; i < s->nelem && p.index < s->elems[i].index; ++i)
  if (i < s->nelem && p.index == s->elems[i].index)
    s->elems[i].constraint |= p.constraint;
      t1 = p;
      ++s->nelem;
      while (i < s->nelem)
	  t2 = s->elems[i];
	  s->elems[i++] = t1;
	  t1 = t2;
merge(s1, s2, m)
     position_set *s1;
  m->nelem = 0;
  while (i < s1->nelem && j < s2->nelem)
    if (s1->elems[i].index > s2->elems[j].index)
      m->elems[m->nelem++] = s1->elems[i++];
    else if (s1->elems[i].index < s2->elems[j].index)
      m->elems[m->nelem++] = s2->elems[j++];
	m->elems[m->nelem] = s1->elems[i++];
	m->elems[m->nelem++].constraint |= s2->elems[j++].constraint;
  while (i < s1->nelem)
    m->elems[m->nelem++] = s1->elems[i++];
  while (j < s2->nelem)
    m->elems[m->nelem++] = s2->elems[j++];
  for (i = 0; i < s->nelem; ++i)
    if (p.index == s->elems[i].index)
  if (i < s->nelem)
    for (--s->nelem; i < s->nelem; ++i)
      s->elems[i] = s->elems[i + 1];
  newline = newline ? 1 : 0;
  letter = letter ? 1 : 0;
  for (i = 0; i < s->nelem; ++i)
    hash ^= s->elems[i].index + s->elems[i].constraint;
  for (i = 0; i < d->sindex; ++i)
      if (hash != d->states[i].hash || s->nelem != d->states[i].elems.nelem
	  || newline != d->states[i].newline || letter != d->states[i].letter)
      for (j = 0; j < s->nelem; ++j)
	if (s->elems[j].constraint
	    != d->states[i].elems.elems[j].constraint
	    || s->elems[j].index != d->states[i].elems.elems[j].index)
      if (j == s->nelem)
  REALLOC_IF_NECESSARY(d->states, dfa_state, d->salloc, d->sindex);
  d->states[i].hash = hash;
  MALLOC(d->states[i].elems.elems, position, s->nelem);
  copy(s, &d->states[i].elems);
  d->states[i].newline = newline;
  d->states[i].letter = letter;
  d->states[i].backref = 0;
  d->states[i].constraint = 0;
  d->states[i].first_end = 0;
  for (j = 0; j < s->nelem; ++j)
    if (d->tokens[s->elems[j].index] < 0)
	constraint = s->elems[j].constraint;
	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 0, letter, 1)
	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 1, letter, 0)
	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 1, letter, 1))
	  d->states[i].constraint |= constraint;
	if (! d->states[i].first_end)
	  d->states[i].first_end = d->tokens[s->elems[j].index];
    else if (d->tokens[s->elems[j].index] == BACKREF)
	d->states[i].constraint = NO_CONSTRAINT;
	d->states[i].backref = 1;
  ++d->sindex;
   S->elems must be large enough to hold the result. */
  MALLOC(visited, int, d->tindex);
  for (i = 0; i < d->tindex; ++i)
  for (i = 0; i < s->nelem; ++i)
    if (d->tokens[s->elems[i].index] >= NOTCHAR
	&& d->tokens[s->elems[i].index] != BACKREF
	&& d->tokens[s->elems[i].index] < CSET)
	old = s->elems[i];
	delete(s->elems[i], s);
	    --i;
	visited[old.index] = 1;
	switch (d->tokens[old.index])
	for (j = 0; j < d->follows[old.index].nelem; ++j)
	    p.index = d->follows[old.index].elems[j].index;
	i = -1;
/* Perform bottom-up analysis on the parse tree, computing various functions.
   Because of the postfix representation of the parse tree, the depth-first
   Sets are stored as arrays of the elements, obeying a stack-like allocation
  for (i = 0; i < d->tindex; ++i)
      prtok(d->tokens[i]);
  d->searchflag = searchflag;
  MALLOC(nullable, int, d->depth);
  MALLOC(nfirstpos, int, d->depth);
  MALLOC(firstpos, position, d->nleaves);
  o_firstpos = firstpos, firstpos += d->nleaves;
  MALLOC(nlastpos, int, d->depth);
  MALLOC(lastpos, position, d->nleaves);
  o_lastpos = lastpos, lastpos += d->nleaves;
  MALLOC(nalloc, int, d->tindex);
  for (i = 0; i < d->tindex; ++i)
  MALLOC(merged.elems, position, d->nleaves);
  CALLOC(d->follows, position_set, d->tindex);
  for (i = 0; i < d->tindex; ++i)
    switch (d->tokens[i])
	*nullable++ = 1;
	tmp.nelem = nfirstpos[-1];
	for (j = 0; j < nlastpos[-1]; ++j)
	    merge(&tmp, &d->follows[pos[j].index], &merged);
	    REALLOC_IF_NECESSARY(d->follows[pos[j].index].elems, position,
				 nalloc[pos[j].index], merged.nelem - 1);
	    copy(&merged, &d->follows[pos[j].index]);
	if (d->tokens[i] != PLUS)
	  nullable[-1] = 1;
	tmp.nelem = nfirstpos[-1];
	pos = lastpos + nlastpos[-1];
	for (j = 0; j < nlastpos[-2]; ++j)
	    merge(&tmp, &d->follows[pos[j].index], &merged);
	    REALLOC_IF_NECESSARY(d->follows[pos[j].index].elems, position,
				 nalloc[pos[j].index], merged.nelem - 1);
	    copy(&merged, &d->follows[pos[j].index]);
	if (nullable[-2])
	  nfirstpos[-2] += nfirstpos[-1];
	  firstpos += nfirstpos[-1];
	--nfirstpos;
	if (nullable[-1])
	  nlastpos[-2] += nlastpos[-1];
	    pos = lastpos + nlastpos[-2];
	    for (j = nlastpos[-1] - 1; j >= 0; --j)
	    lastpos += nlastpos[-2];
	    nlastpos[-2] = nlastpos[-1];
	--nlastpos;
	nullable[-2] = nullable[-1] && nullable[-2];
	--nullable;
	nfirstpos[-2] += nfirstpos[-1];
	--nfirstpos;
	nlastpos[-2] += nlastpos[-1];
	--nlastpos;
	nullable[-2] = nullable[-1] || nullable[-2];
	--nullable;
	*nullable++ = d->tokens[i] == BACKREF;
	*nfirstpos++ = *nlastpos++ = 1;
	--firstpos, --lastpos;
	firstpos->index = lastpos->index = i;
	firstpos->constraint = lastpos->constraint = NO_CONSTRAINT;
	nalloc[i] = 1;
	MALLOC(d->follows[i].elems, position, nalloc[i]);
      prtok(d->tokens[i]);
      fprintf(stderr, nullable[-1] ? " nullable: yes\n" : " nullable: no\n");
      for (j = nfirstpos[-1] - 1; j >= 0; --j)
	  prtok(d->tokens[firstpos[j].index]);
      for (j = nlastpos[-1] - 1; j >= 0; --j)
	  prtok(d->tokens[lastpos[j].index]);
  for (i = 0; i < d->tindex; ++i)
    if (d->tokens[i] < NOTCHAR || d->tokens[i] == BACKREF
	|| d->tokens[i] >= CSET)
	prtok(d->tokens[i]);
	for (j = d->follows[i].nelem - 1; j >= 0; --j)
	    fprintf(stderr, " %d:", d->follows[i].elems[j].index);
	    prtok(d->tokens[d->follows[i].elems[j].index]);
	copy(&d->follows[i], &merged);
	if (d->follows[i].nelem < merged.nelem)
	  REALLOC(d->follows[i].elems, position, merged.nelem);
	copy(&merged, &d->follows[i]);
  for (i = 0; i < nfirstpos[-1]; ++i)
      wants_newline = 1;
  d->salloc = 1;
  d->sindex = 0;
  MALLOC(d->states, dfa_state, d->salloc);
   The collection of groups is constructed by building an equivalence-class
   intersection with C.  If L - C is nonempty, create a new group labeled
   L - C and having the same positions as the current group, and set L to
   C = C - L, and resume scanning.
      initialized = 1;
  for (i = 0; i < d->states[s].elems.nelem; ++i)
      pos = d->states[s].elems.elems[i];
      if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR)
	setbit(d->tokens[pos.index], matches);
      else if (d->tokens[pos.index] >= CSET)
	copyset(d->charclasses[d->tokens[pos.index] - CSET], matches);
					 d->states[s].newline, 1))
					 d->states[s].newline, 0))
					d->states[s].letter, 1))
					d->states[s].letter, 0))
	  if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR
	      && !tstbit(d->tokens[pos.index], labels[j]))
	    (intersect[k] = matches[k] & labels[j][k]) ? intersectf = 1 : 0;
	      (leftovers[k] = ~match & label) ? leftoversf = 1 : 0;
	      (matches[k] = match & ~label) ? matchesf = 1 : 0;
	      MALLOC(grps[ngrps].elems, position, d->nleaves);
	  MALLOC(grps[ngrps].elems, position, d->nleaves);
	  grps[ngrps].nelem = 1;
  MALLOC(follows.elems, position, d->nleaves);
  MALLOC(tmp.elems, position, d->nleaves);
  if (d->searchflag)
      for (i = 0; i < d->states[0].elems.nelem; ++i)
	  if (PREV_NEWLINE_DEPENDENT(d->states[0].elems.elems[i].constraint))
	    wants_newline = 1;
	  if (PREV_LETTER_DEPENDENT(d->states[0].elems.elems[i].constraint))
	    wants_letter = 1;
      copy(&d->states[0].elems, &follows);
	state_newline = state_index(d, &follows, 1, 0);
	state_letter = state_index(d, &follows, 0, 1);
      trans[i] = -1;
	for (k = 0; k < d->follows[grps[i].elems[j].index].nelem; ++k)
	  insert(d->follows[grps[i].elems[j].index].elems[k], &follows);
      if (d->searchflag)
	for (j = 0; j < d->states[0].elems.nelem; ++j)
	  insert(d->states[0].elems.elems[j], &follows);
	    wants_newline = 1;
	    wants_letter = 1;
	state_newline = state_index(d, &follows, 1, 0);
	state_letter = state_index(d, &follows, 0, 1);
	  if (labels[i][j] & 1 << k)
   is a non-accepting state, then d->trans[state] points to its table.
   If it is an accepting state then d->fails[state] points to its table.
   If it has no table at all, then d->trans[state] is NULL.
     exist at once.  1024 is arbitrary.  The idea is that the frequently
  if (d->trcount >= 1024)
      for (i = 0; i < d->tralloc; ++i)
	if (d->trans[i])
	    free((ptr_t) d->trans[i]);
	    d->trans[i] = NULL;
	else if (d->fails[i])
	    free((ptr_t) d->fails[i]);
	    d->fails[i] = NULL;
      d->trcount = 0;
  ++d->trcount;
  d->success[s] = 0;
  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 1, d->states[s].letter, 0,
    d->success[s] |= 4;
  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 0, d->states[s].letter, 1,
    d->success[s] |= 2;
  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 0, d->states[s].letter, 0,
    d->success[s] |= 1;
    if (trans[i] >= d->tralloc)
	int oldalloc = d->tralloc;
	while (trans[i] >= d->tralloc)
	  d->tralloc *= 2;
	REALLOC(d->realtrans, int *, d->tralloc + 1);
	d->trans = d->realtrans + 1;
	REALLOC(d->fails, int *, d->tralloc);
	REALLOC(d->success, int, d->tralloc);
	REALLOC(d->newlines, int, d->tralloc);
	while (oldalloc < d->tralloc)
	    d->trans[oldalloc] = NULL;
	    d->fails[oldalloc++] = NULL;
  d->newlines[s] = trans['\n'];
  trans['\n'] = -1;
    d->fails[s] = trans;
    d->trans[s] = trans;
  d->tralloc = 1;
  d->trcount = 0;
  CALLOC(d->realtrans, int *, d->tralloc + 1);
  d->trans = d->realtrans + 1;
  CALLOC(d->fails, int *, d->tralloc);
  MALLOC(d->success, int, d->tralloc);
  MALLOC(d->newlines, int, d->tralloc);
   allow newlines to be in the matching string.  If count is non-
   see a newline.  Finally, if backref is non-NULL it points to a place
   where we're supposed to store a 1 if backreferencing happened and the
  register s, s1, tmp;		/* Current state. */
  register **trans, *t;		/* Copy of d->trans so it can be optimized
  static sbit[NOTCHAR];	/* Table for anding with d->success. */
      sbit_init = 1;
	  sbit[i] = 1;
  if (! d->tralloc)
  s = s1 = 0;
  trans = d->trans;
	    s1 = t[*p++];
	    if (! (t = trans[s1]))
      goto last_was_s1;
      tmp = s, s = s1, s1 = tmp;
    last_was_s1:
      if (s >= 0 && p <= (unsigned char *) end && d->fails[s])
	  if (d->success[s] & sbit[*p])
		if (d->states[s].backref)
		  *backref = 1;
	  s1 = s;
	  s = d->fails[s][*p++];
      if (count && (char *) p <= end && p[-1] == '\n')
	  trans = d->trans;
      if (p[-1] == '\n' && newline)
	  s = d->newlines[s1];
  d->calloc = 1;
  MALLOC(d->charclasses, charclass, d->calloc);
  d->cindex = 0;
  d->talloc = 1;
  MALLOC(d->tokens, token, d->talloc);
  d->tindex = d->depth = d->nleaves = d->nregexps = 0;
  d->searchflag = 0;
  d->tralloc = 0;
  d->musts = 0;
      d->cindex = d->tindex = d->depth = d->nleaves = d->nregexps = 0;
      case_fold = 1;
  free((ptr_t) d->charclasses);
  free((ptr_t) d->tokens);
  for (i = 0; i < d->sindex; ++i)
    free((ptr_t) d->states[i].elems.elems);
  free((ptr_t) d->states);
  for (i = 0; i < d->tindex; ++i)
    if (d->follows[i].elems)
      free((ptr_t) d->follows[i].elems);
  free((ptr_t) d->follows);
  for (i = 0; i < d->tralloc; ++i)
    if (d->trans[i])
      free((ptr_t) d->trans[i]);
    else if (d->fails[i])
      free((ptr_t) d->fails[i]);
  free((ptr_t) d->realtrans);
  free((ptr_t) d->fails);
  free((ptr_t) d->newlines);
  for (dm = d->musts; dm; dm = ndm)
      ndm = dm->next;
      free(dm->must);
   (Take "(ab|a)b"--please.)
   We do a bottom-up calculation of sequences of characters that must appear
   d->must (where "d" is the single argument passed to "dfamust");
   the length of the sequence is returned in d->mustn.
   are shown below.  "p" is the operand of unary operators (and the left-hand
   operand of binary operators); "q" is the right-hand operand of binary
   "ZERO" means "a zero-length sequence" below.
	----	----		-----		--		--
	PLUS	p->left		p->right	ZERO		p->in
	CAT	(p->is==ZERO)?	(q->is==ZERO)?	(p->is!=ZERO &&	p->in plus
		p->left :	q->right :	q->is!=ZERO) ?	q->in plus
		p->is##q->left	p->right##q->is	p->is##q->is :	p->right##q->left
	OR	longest common	longest common	(do p->is and	substrings common to
		leading		trailing	q->is have same	p->in and q->in
		of p->left	of p->right	content) ?	
		and q->left	and q->right	p->is : NULL	
   to zero-length sequences.  If there's something we don't recognize in the tree,
   we just return a zero-length sequence.
	egrep 'psi|epsilon'	->	egrep 'psi'
	egrep 'pepsi|epsilon'	->	egrep 'epsi'
	grep '[c]'		->	grep 'c'
	grep '(ab|a)b'		->	grep 'ab'
	grep 'ab*'		->	grep 'a'
	grep 'a*b'		->	grep 'b'
   Are optimizable r.e.'s likely to be used in real-life situations
    result = (char *) malloc(newsize + 1);
    result = (char *) realloc((void *) old, oldsize + newsize + 1);
	if (--i == j)
  cpp[i + 1] = NULL;
	  for (i = 1; lcp[i] != '\0' && lcp[i] == rcp[i]; ++i)
	  rcp = index(rcp + 1, *lcp);
  mp->left[0] = mp->right[0] = mp->is[0] = '\0';
  freelist(mp->in);
  musts = (must *) malloc((dfa->tindex + 1) * sizeof *musts);
  for (i = 0; i <= dfa->tindex; ++i)
  for (i = 0; i <= dfa->tindex; ++i)
  for (i = 0; i < dfa->tindex; ++i)
      prtok(dfa->tokens[i]);
  for (ri = 0; ri < dfa->tindex; ++ri)
      switch (t = dfa->tokens[ri])
	  --mp;
	    rmp = --mp;
	    lmp = --mp;
	    if (strcmp(lmp->is, rmp->is) != 0)
	      lmp->is[0] = '\0';
	    /* Left side--easy */
	    while (lmp->left[i] != '\0' && lmp->left[i] == rmp->left[i])
	    lmp->left[i] = '\0';
	    ln = strlen(lmp->right);
	    rn = strlen(rmp->right);
	      if (lmp->right[ln - i - 1] != rmp->right[rn - i - 1])
	      lmp->right[j] = lmp->right[(ln - i) + j];
	    lmp->right[j] = '\0';
	    new = inboth(lmp->in, rmp->in);
	    freelist(lmp->in);
	    free((char *) lmp->in);
	    lmp->in = new;
	  --mp;
	  mp->is[0] = '\0';
	  if (mp != &musts[1])
	    exact = 1;
	    rmp = --mp;
	    lmp = --mp;
	    lmp->in = addlists(lmp->in, rmp->in);
	    if (lmp->in == NULL)
	    if (lmp->right[0] != '\0' &&
		rmp->left[0] != '\0')
		tp = icpyalloc(lmp->right);
		tp = icatalloc(tp, rmp->left);
		lmp->in = enlist(lmp->in, tp,
		if (lmp->in == NULL)
	    /* Left-hand */
	    if (lmp->is[0] != '\0')
		lmp->left = icatalloc(lmp->left,
				      rmp->left);
		if (lmp->left == NULL)
	    /* Right-hand */
	    if (rmp->is[0] == '\0')
	      lmp->right[0] = '\0';
	    lmp->right = icatalloc(lmp->right, rmp->right);
	    if (lmp->right == NULL)
	    if (lmp->is[0] != '\0' && rmp->is[0] != '\0')
		lmp->is = icatalloc(lmp->is, rmp->is);
		if (lmp->is == NULL)
	      lmp->is[0] = '\0';
	      mp->is[0] = mp->left[0] = mp->right[0] = t;
	      mp->is[1] = mp->left[1] = mp->right[1] = '\0';
	      mp->in = enlist(mp->in, mp->is, 1);
	      if (mp->in == NULL)
      prtok(dfa->tokens[ri]);
      for (i = 0; mp->in[i]; ++i)
	fprintf(stderr, " \"%s\"", mp->in[i]);
      fprintf(stderr, "\n  is: \"%s\"\n", mp->is);
      fprintf(stderr, "  left: \"%s\"\n", mp->left);
      fprintf(stderr, "  right: \"%s\"\n", mp->right);
      dm->exact = exact;
      dm->must = malloc(strlen(result) + 1);
      strcpy(dm->must, result);
      dm->next = dfa->musts;
      dfa->musts = dm;
  for (i = 0; i <= dfa->tindex; ++i)
/* kwset.c - search for any of a set of keywords.
   Copyright 1989 Free Software Foundation
		  Written August 1989 by Mike Haertel.
   the Free Software Foundation; either version 1, or (at your option)
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   to one discovered by Beate Commentz-Walter, although it is not identical.
   IBM-Germany, Scientific Center Heidelberg, Tiergartenstrasse 15, D-6900
   String Matching:  An Aid to Bibliographic Search," CACM June 1975,
   Vol. 18, No. 6, which describes the failure function used below. */
#define flag_limits 1
#define flag_stdlib 1
#define INT_MAX 2147483647
#define flag_systypes 1
#define flag_string 1
#define flag_memory 1
#define NCHAR (UCHAR_MAX + 1)
  struct trie *fail;		/* Aho-Corasick failure function. */
  int mind2;			/* Used in Boyer-Moore search for one string. */
  obstack_init(&kwset->obstack);
  kwset->words = 0;
  kwset->trie
    = (struct trie *) obstack_alloc(&kwset->obstack, sizeof (struct trie));
  if (!kwset->trie)
  kwset->trie->accepting = 0;
  kwset->trie->links = 0;
  kwset->trie->parent = 0;
  kwset->trie->next = 0;
  kwset->trie->fail = 0;
  kwset->trie->depth = 0;
  kwset->trie->shift = 0;
  kwset->mind = INT_MAX;
  kwset->maxd = -1;
  kwset->target = 0;
  kwset->trans = trans;
  struct tree *links[12];
  enum { L, R } dirs[12];
  trie = kwset->trie;
  /* Descend the trie (built of reversed keywords) character-by-character,
  while (len--)
      label = kwset->trans ? kwset->trans[(unsigned char) *--text] : *--text;
      link = trie->links;
      links[0] = (struct tree *) &trie->links;
      depth = 1;
      while (link && label != link->label)
	  if (label < link->label)
	    dirs[depth++] = L, link = link->llink;
	    dirs[depth++] = R, link = link->rlink;
	  link = (struct tree *) obstack_alloc(&kwset->obstack,
	  link->llink = 0;
	  link->rlink = 0;
	  link->trie = (struct trie *) obstack_alloc(&kwset->obstack,
	  if (!link->trie)
	  link->trie->accepting = 0;
	  link->trie->links = 0;
	  link->trie->parent = trie;
	  link->trie->next = 0;
	  link->trie->fail = 0;
	  link->trie->depth = trie->depth + 1;
	  link->trie->shift = 0;
	  link->label = label;
	  link->balance = 0;
	  if (dirs[--depth] == L)
	    links[depth]->llink = link;
	    links[depth]->rlink = link;
	  while (depth && !links[depth]->balance)
		--links[depth]->balance;
		++links[depth]->balance;
	      --depth;
	  if (depth && ((dirs[depth] == L && --links[depth]->balance)
			|| (dirs[depth] == R && ++links[depth]->balance)))
	      switch (links[depth]->balance)
		case (char) -2:
		  switch (dirs[depth + 1])
		      r = links[depth], t = r->llink, rl = t->rlink;
		      t->rlink = r, r->llink = rl;
		      t->balance = r->balance = 0;
		      r = links[depth], l = r->llink, t = l->rlink;
		      rl = t->rlink, lr = t->llink;
		      t->llink = l, l->rlink = lr, t->rlink = r, r->llink = rl;
		      l->balance = t->balance != 1 ? 0 : -1;
		      r->balance = t->balance != (char) -1 ? 0 : 1;
		      t->balance = 0;
		  switch (dirs[depth + 1])
		      l = links[depth], t = l->rlink, lr = t->llink;
		      t->llink = l, l->rlink = lr;
		      t->balance = l->balance = 0;
		      l = links[depth], r = l->rlink, t = r->llink;
		      lr = t->llink, rl = t->rlink;
		      t->llink = l, l->rlink = lr, t->rlink = r, r->llink = rl;
		      l->balance = t->balance != 1 ? 0 : -1;
		      r->balance = t->balance != (char) -1 ? 0 : 1;
		      t->balance = 0;
	      if (dirs[depth - 1] == L)
		links[depth - 1]->llink = t;
		links[depth - 1]->rlink = t;
      trie = link->trie;
  if (!trie->accepting)
    trie->accepting = 1 + 2 * kwset->words;
  ++kwset->words;
  if (trie->depth < kwset->mind)
    kwset->mind = trie->depth;
  if (trie->depth > kwset->maxd)
    kwset->maxd = trie->depth;
  enqueue(tree->llink, last);
  enqueue(tree->rlink, last);
  (*last) = (*last)->next = tree->trie;
/* Compute the Aho-Corasick failure function for the trie nodes referenced
  treefails(tree->llink, fail, recourse);
  treefails(tree->rlink, fail, recourse);
      link = fail->links;
      while (link && tree->label != link->label)
	if (tree->label < link->label)
	  link = link->llink;
	  link = link->rlink;
	  tree->trie->fail = link->trie;
      fail = fail->fail;
  tree->trie->fail = recourse;
  treedelta(tree->llink, depth, delta);
  treedelta(tree->rlink, depth, delta);
  if (depth < delta[tree->label])
    delta[tree->label] = depth;
    return 1;
  if (!hasevery(a, b->llink))
  if (!hasevery(a, b->rlink))
  while (a && b->label != a->label)
    if (b->label < a->label)
      a = a->llink;
      a = a->rlink;
  treenext(tree->llink, next);
  treenext(tree->rlink, next);
  next[tree->label] = tree->trie;
  if (kwset->mind < 256)
      delta[i] = kwset->mind;
  /* Check if we can use the simple boyer-moore algorithm, instead
     of the hairy commentz-walter algorithm. */
  if (kwset->words == 1 && kwset->trans == 0)
      kwset->target = obstack_alloc(&kwset->obstack, kwset->mind);
      for (i = kwset->mind - 1, curr = kwset->trie; i >= 0; --i)
	  kwset->target[i] = curr->links->label;
	  curr = curr->links->trie;
      for (i = 0; i < kwset->mind; ++i)
	delta[(unsigned char) kwset->target[i]] = kwset->mind - (i + 1);
      kwset->mind2 = kwset->mind;
      for (i = 0; i < kwset->mind - 1; ++i)
	if (kwset->target[i] == kwset->target[kwset->mind - 1])
	  kwset->mind2 = kwset->mind - (i + 1);
      for (curr = last = kwset->trie; curr; curr = curr->next)
	  enqueue(curr->links, &last);
	  curr->shift = kwset->mind;
	  curr->maxshift = kwset->mind;
	  treedelta(curr->links, curr->depth, delta);
	  treefails(curr->links, curr->fail, kwset->trie);
	  for (fail = curr->fail; fail; fail = fail->fail)
	      if (!hasevery(fail->links, curr->links))
		if (curr->depth - fail->depth < fail->shift)
		  fail->shift = curr->depth - fail->depth;
	      if (curr->accepting && fail->maxshift > curr->depth - fail->depth)
		fail->maxshift = curr->depth - fail->depth;
      for (curr = kwset->trie->next; curr; curr = curr->next)
	  if (curr->maxshift > curr->parent->maxshift)
	    curr->maxshift = curr->parent->maxshift;
	  if (curr->shift > curr->maxshift)
	    curr->shift = curr->maxshift;
      treenext(kwset->trie->links, next);
      if ((trans = kwset->trans) != 0)
	  kwset->next[i] = next[(unsigned char) trans[i]];
	  kwset->next[i] = next[i];
  if ((trans = kwset->trans) != 0)
      kwset->delta[i] = delta[(unsigned char) trans[i]];
      kwset->delta[i] = delta[i];
/* Fast boyer-moore search. */
  register unsigned char *d1;
  len = kwset->mind;
  if (len == 1)
    return memchr(text, kwset->target[0], size);
  d1 = kwset->delta;
  sp = kwset->target + len;
  gc = U(sp[-2]);
  md2 = kwset->mind2;
  /* Significance of 12: 1 (initial offset) + 10 (skip loop) + 1 (md2). */
  if (size > 12 * len)
    /* 11 is not a bug, the initial offset happens only once. */
    for (ep = text + size - 11 * len;;)
	    d = d1[U(tp[-1])], tp += d;
	    d = d1[U(tp[-1])], tp += d;
	    d = d1[U(tp[-1])], tp += d;
	    d = d1[U(tp[-1])], tp += d;
	    d = d1[U(tp[-1])], tp += d;
	    d = d1[U(tp[-1])], tp += d;
	    d = d1[U(tp[-1])], tp += d;
	    d = d1[U(tp[-1])], tp += d;
	    d = d1[U(tp[-1])], tp += d;
	    d = d1[U(tp[-1])], tp += d;
	if (U(tp[-2]) == gc)
	    for (i = 3; i <= len && U(tp[-i]) == U(sp[-i]); ++i)
	      return tp - len;
     carefully avoid ever producing an out-of-bounds pointer. */
  d = d1[U(tp[-1])];
  while (d <= ep - tp)
      d = d1[U((tp += d)[-1])];
      if (tp[-2] == gc)
	  for (i = 3; i <= len && U(tp[-i]) == U(sp[-i]); ++i)
	    return tp - len;
  if (len < kwset->mind)
  next = kwset->next;
  delta = kwset->delta;
  trans = kwset->trans;
  if ((d = kwset->mind) != 0)
      mch = text, accept = kwset->trie;
  if (len >= 4 * kwset->mind)
    qlim = lim - 4 * kwset->mind;
  while (lim - end >= d)
	  end += d - 1;
	d = delta[c = (end += d)[-1]];
      beg = end - 1;
      if (trie->accepting)
      d = trie->shift;
	  c = trans ? trans[(unsigned char) *--beg] : *--beg;
	  tree = trie->links;
	  while (tree && c != tree->label)
	    if (c < tree->label)
	      tree = tree->llink;
	      tree = tree->rlink;
	      trie = tree->trie;
	      if (trie->accepting)
	  d = trie->shift;
  if (lim - mch > kwset->maxd)
    lim = mch + kwset->maxd;
  d = 1;
  while (lim - end >= d)
      if ((d = delta[c = (end += d)[-1]]) != 0)
      beg = end - 1;
	  d = 1;
      if (trie->accepting && beg <= mch)
      d = trie->shift;
	  c = trans ? trans[(unsigned char) *--beg] : *--beg;
	  tree = trie->links;
	  while (tree && c != tree->label)
	    if (c < tree->label)
	      tree = tree->llink;
	      tree = tree->rlink;
	      trie = tree->trie;
	      if (trie->accepting && beg <= mch)
	  d = trie->shift;
	d = 1;
      kwsmatch->index = accept->accepting / 2;
      kwsmatch->beg[0] = mch;
      kwsmatch->size[0] = accept->depth;
   is non-NULL store in the referenced location the length of the
   matching substring.  Similarly, if FOUNDIDX is non-NULL, store
  if (kwset->words == 1 && kwset->trans == 0)
	  kwsmatch->index = 0;
	  kwsmatch->beg[0] = ret;
	  kwsmatch->size[0] = kwset->mind;
  obstack_free(&kwset->obstack, 0);
/* obstack.c - subroutines used implicitly by object stack macros
   Copyright (C) 1988, 1993 Free Software Foundation, Inc.
Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
   program understand `configure --with-gnu-libc' and omit the object files,
  ((PTR_INT_TYPE) ((char *)&((struct fooalign *) 0)->d - (char *)0))
/* The non-GNU-C macros copy the obstack into this global variable
  (((h) -> use_extra_arg) \
   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
   : (*(h)->chunkfun) ((size)))
    if ((h) -> use_extra_arg) \
      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
      (*(h)->freefun) ((old_chunk)); \
    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
		    + 4 + DEFAULT_ROUNDING - 1)
		   & ~(DEFAULT_ROUNDING - 1));
      size = 4096 - extra;
  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
  h->freefun = freefun;
  h->chunk_size = size;
  h->alignment_mask = alignment - 1;
  h->use_extra_arg = 0;
  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
  h->next_free = h->object_base = chunk->contents;
  h->chunk_limit = chunk->limit
    = (char *) chunk + h->chunk_size;
  chunk->prev = 0;
  h->maybe_empty_object = 0;
_obstack_begin_1 (h, size, alignment, chunkfun, freefun, arg)
    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
		    + 4 + DEFAULT_ROUNDING - 1)
		   & ~(DEFAULT_ROUNDING - 1));
      size = 4096 - extra;
  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
  h->freefun = freefun;
  h->chunk_size = size;
  h->alignment_mask = alignment - 1;
  h->extra_arg = arg;
  h->use_extra_arg = 1;
  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
  h->next_free = h->object_base = chunk->contents;
  h->chunk_limit = chunk->limit
    = (char *) chunk + h->chunk_size;
  chunk->prev = 0;
  h->maybe_empty_object = 0;
  register struct _obstack_chunk*	old_chunk = h->chunk;
  register int obj_size = h->next_free - h->object_base;
  new_size = (obj_size + length) + (obj_size >> 3) + 100;
  if (new_size < h->chunk_size)
    new_size = h->chunk_size;
  new_chunk = h->chunk = CALL_CHUNKFUN (h, new_size);
  new_chunk->prev = old_chunk;
  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;
  if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)
      for (i = obj_size / sizeof (COPYING_UNIT) - 1;
	   i >= 0; i--)
	((COPYING_UNIT *)new_chunk->contents)[i]
	  = ((COPYING_UNIT *)h->object_base)[i];
    new_chunk->contents[i] = h->object_base[i];
  if (h->object_base == old_chunk->contents && ! h->maybe_empty_object)
      new_chunk->prev = old_chunk->prev;
  h->object_base = new_chunk->contents;
  h->next_free = h->object_base + obj_size;
  h->maybe_empty_object = 0;
  lp = (h)->chunk;
  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
      plp = lp->prev;
   This is the first one, called from non-ANSI code.  */
  lp = h->chunk;
  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
      plp = lp->prev;
      h->maybe_empty_object = 1;
      h->object_base = h->next_free = (char *)(obj);
      h->chunk_limit = lp->limit;
      h->chunk = lp;
  lp = h->chunk;
  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
      plp = lp->prev;
      h->maybe_empty_object = 1;
      h->object_base = h->next_free = (char *)(obj);
      h->chunk_limit = lp->limit;
      h->chunk = lp;
/* These function definitions do not work with non-ANSI preprocessors;
   the macro-definitions of the names from being expanded there.  */
void (obstack_1grow) (obstack, character)
  obstack_1grow (obstack, character);
void (obstack_1grow_fast) (obstack, character)
  obstack_1grow_fast (obstack, character);
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Copyright (C) 1992 Free Software Foundation, Inc.
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   Written August 1992 by Mike Haertel. */
#define flag_limits 1
#define flag_stdlib 1
#define flag_systypes 1
#define flag_string 1
#define flag_memory 1
#define NCHAR (UCHAR_MAX + 1)
  { "posix-egrep", Ecompile, EGexecute },
/* For -w, we also consider _ to be word constituent.  */
static struct dfa dfa_1;
  if (dfa_1.musts)
      for (dm = dfa_1.musts; dm; dm = dm->next)
	  if (!dm->exact)
	  if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0)
      for (dm = dfa_1.musts; dm; dm = dm->next)
	  if (dm->exact)
	  if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0)
  dfainit(&dfa_1);
      /* In the whole-word case, we use the pattern:
	 (^|[^A-Za-z_])(userpattern)([^A-Za-z_]|$).
	 In the whole-line case, we use the pattern:
	 BUG: Using [A-Za-z_] is locale-dependent!  */
	strcpy(n, "\\(^\\|[^0-9A-Za-z_]\\)\\(");
	strcpy(n + i, "\\)\\([^0-9A-Za-z_]\\|$\\)");
      dfacomp(n, i, &dfa_1, 1);
    dfacomp(pattern, size, &dfa_1, 1);
  if (strcmp(matcher, "posix-egrep") == 0)
  dfainit(&dfa_1);
      /* In the whole-word case, we use the pattern:
	 (^|[^A-Za-z_])(userpattern)([^A-Za-z_]|$).
	 In the whole-line case, we use the pattern:
	 BUG: Using [A-Za-z_] is locale-dependent!  */
	strcpy(n, "(^|[^0-9A-Za-z_])(");
	strcpy(n + i, ")([^0-9A-Za-z_]|$)");
      dfacomp(n, i, &dfa_1, 1);
    dfacomp(pattern, size, &dfa_1, 1);
  static struct re_registers regs; /* This is static on account of a BRAIN-DEAD
  for (beg = end = buf; end < buflim; beg = end + 1)
	  beg = kwsexec(kwset, beg, buflim - beg, &kwsm);
	  end = memchr(beg, '\n', buflim - beg);
	  while (beg > buf && beg[-1] != '\n')
	    --beg;
	  if (!dfaexec(&dfa_1, beg, end, 0, (int *) 0, &backref))
	  beg = dfaexec(&dfa_1, beg, buflim, 0, (int *) 0, &backref);
	  end = memchr(beg, '\n', buflim - beg);
	  while (beg > buf && beg[-1] != '\n')
	    --beg;
      if ((start = re_search(&regex, beg, end - beg, 0, end - beg, &regs)) >= 0)
	  len = regs.end[0] - start;
	  if (!match_lines && !match_words || match_lines && len == end - beg)
	  /* If -w, check if the match aligns with word boundaries.
		if ((start == 0 || !WCHAR(beg[start - 1]))
		    && (len == end - beg || !WCHAR(beg[start + len])))
		    --len;
		    regex.not_eol = 1;
		    if (start == end - beg)
		    start = re_search(&regex, beg, end - beg,
				      start, end - beg - start, &regs);
		    len = regs.end[0] - start;
  *endp = end < buflim ? end + 1 : end;
      if ((err = kwsincr(kwset, beg, lim - beg)) != 0)
      if (!(beg = kwsexec(kwset, beg, buf + size - beg, &kwsmatch)))
	  if (beg > buf && beg[-1] != '\n')
	    if (try > buf && WCHAR((unsigned char) try[-1]))
		try = kwsexec(kwset, beg, --len, &kwsmatch);
  if ((end = memchr(beg + len, '\n', (buf + size) - (beg + len))) != 0)
  while (beg > buf && beg[-1] != '\n')
    --beg;
