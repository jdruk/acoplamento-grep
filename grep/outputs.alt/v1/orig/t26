   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   Written July 1992 by Mike Haertel.  */
#define strerror(E) ((E) < sys_nerr ? sys_errlist[(E)] : "bogus error number")
/* Print a message and possibly an error string.  Remember
/* Like error(), but die horribly after printing. */
/* Interface to handle errors and fix library lossage. */
/* Interface to handle errors and fix some library lossage. */
/* Hairy buffering mechanism for grep.  The intent is to keep
   all reads aligned on a page boundary and multiples of the
static char *buffer;		/* Base of buffer. */
static size_t bufsalloc;	/* Allocated size of buffer save region. */
static size_t bufalloc;		/* Total buffer size. */
static int bufdesc;		/* File descriptor. */
static char *bufbeg;		/* Beginning of user-visible stuff. */
static char *buflim;		/* Limit of user-visible stuff. */
static int bufmapped;		/* True for ordinary files. */
static struct stat bufstat;	/* From fstat(). */
static off_t bufoffset;		/* What read() normally remembers. */
/* Reset the buffer for a new file.  Initialize
      bufsalloc = MAX(8192, getpagesize());
      bufsalloc = BUFSALLOC;
      bufalloc = 5 * bufsalloc;
      /* The 1 byte of overflow is a kludge for dfaexec(), which
	 inserts a sentinel newline at the end of the buffer
	 being searched.  There's gotta be a better way... */
      buffer = valloc(bufalloc + 1);
      if (!buffer)
      bufbeg = buffer;
      buflim = buffer;
  bufdesc = fd;
  if (fstat(fd, &bufstat) < 0 || !S_ISREG(bufstat.st_mode))
    bufmapped = 0;
      bufmapped = 1;
      bufoffset = lseek(fd, 0, 1);
/* Read new stuff into the buffer, saving the specified
   amount of old stuff.  When we're done, 'bufbeg' points
   to the beginning of the buffer contents, and 'buflim'
fillbuf(save)
  char *nbuffer, *dp, *sp;
    abort();
  if (save > bufsalloc)
      while (save > bufsalloc)
	bufsalloc *= 2;
      bufalloc = 5 * bufsalloc;
      nbuffer = valloc(bufalloc + 1);
      if (!nbuffer)
    nbuffer = buffer;
  sp = buflim - save;
  dp = nbuffer + bufsalloc - save;
  bufbeg = dp;
  /* We may have allocated a new, larger buffer.  Since
     there is no portable vfree(), we just have to forget
     about the old one.  Sorry. */
  buffer = nbuffer;
  if (bufmapped && bufoffset % pagesize == 0
      && bufstat.st_size - bufoffset >= bufalloc - bufsalloc)
      maddr = buffer + bufsalloc;
      maddr = mmap(maddr, bufalloc - bufsalloc, PROT_READ | PROT_WRITE,
		   MAP_PRIVATE | MAP_FIXED, bufdesc, bufoffset);
	 but it doesn't, at least not on a Sun running 4.1.
	 In fact, it actually slows us down about 30%! */
      madvise(maddr, bufalloc - bufsalloc, MADV_SEQUENTIAL);
      cc = bufalloc - bufsalloc;
      bufoffset += cc;
      if (bufmapped)
	  bufmapped = 0;
	  lseek(bufdesc, bufoffset, 0);
      cc = read(bufdesc, buffer + bufsalloc, bufalloc - bufsalloc);
  cc = read(bufdesc, buffer + bufsalloc, bufalloc - bufsalloc);
    buflim = buffer + bufsalloc + cc;
    buflim = buffer + bufsalloc;
static int out_line;		/* Print line numbers. */
static int out_byte;		/* Print byte offsets. */
static int out_before;		/* Lines of leading context. */
/* Internal variables to keep track of byte count, context, etc. */
static size_t totalcc;		/* Total character count before bufbeg. */
				   NULL if no character has been output
				   or if it's conceptually before bufbeg. */
static size_t totalnl;		/* Total newline count before lastnl. */
  char *beg;
  for (beg = lastnl; beg < lim; ++beg)
    if (*beg == '\n')
  lastnl = beg;
prline(beg, lim, sep)
     char *beg;
      nlscan(beg);
  if (out_byte)
    printf("%lu%c", totalcc + (beg - bufbeg), sep);
  fwrite(beg, 1, lim - beg, stdout);
    lastout = bufbeg;
/* Print the lines between BEG and LIM.  Deal with context crap.
   If NLINESP is non-null, store a count of lines between BEG and LIM. */
prtext(beg, lim, nlinesp)
     char *beg;
  static int used;		/* avoid printing "--" before any output */
  char *bp, *p, *nl;
    prpending(beg);
  p = beg;
      bp = lastout ? lastout : bufbeg;
      for (i = 0; i < out_before; ++i)
	if (p > bp)
	  while (p > bp && p[-1] != '\n');
      if ((out_before || out_after) && used && p != lastout)
      while (p < beg)
	  nl = memchr(p, '\n', beg - p);
      prline(beg, lim, ':');
/* Scan the specified portion of the buffer, matching lines (or
   between matching lines if OUT_INVERT is true).  Return a count of
grepbuf(beg, lim)
     char *beg;
  p = beg;
      /* Avoid matching the empty line at the end of the buffer. */
      if (b == lim && ((b > beg && b[-1] == '\n') || b == beg))
	break;
  char *beg, *lim;
      if (fillbuf(save) < 0)
      lastnl = bufbeg;
	lastout = bufbeg;
      if (buflim - bufbeg == save)
	break;
      beg = bufbeg + save - residue;
      for (lim = buflim; lim > beg && lim[-1] != '\n'; --lim)
      residue = buflim - lim;
      if (beg < lim)
	  nlines += grepbuf(beg, lim);
      beg = lim;
      while (i < out_before && beg > bufbeg && beg != lastout)
	    --beg;
	  while (beg > bufbeg && beg[-1] != '\n');
      if (beg != lastout)
      save = residue + lim - beg;
      totalcc += buflim - bufbeg - save;
	nlscan(beg);
      nlines += grepbuf(bufbeg + save - residue, buflim);
	prpending(buflim);
  while ((opt = getopt(argc, argv, "0123456789A:B:CEFGVX:bce:f:hiLlnqsvwxy"))
	out_before = 10 * out_before + opt - '0';
	break;
	break;
	out_before = atoi(optarg);
	if (out_before < 0)
	break;
	out_before = out_after = 2;
	break;
	break;
	break;
	break;
	break;
	break;
	out_byte = 1;
	break;
	break;
	break;
	break;
	break;
	break;
	   Inspired by the same option in Hume's gre. */
	break;
	break;
	break;
	break;
	break;
	break;
	break;
	break;
	break;
    abort();
   NOTE: getopt is now part of the C library, so if you don't know what
   before changing it!
   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by the
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
/* NOTE!!!  AIX requires this to be the first thing in the file.
   Do not put ANYTHING before it!  */
#define alloca __builtin_alloca
/* Comment out all this code if we are using the GNU C Library, and are not
   actually compiling the library itself.  This code is part of the GNU C
   Library, but also included in many other GNU distributions.  Compiling
   and linking in this code is a waste when using the GNU C library
   (especially if it is a shared library).  Rather than having every GNU
   program understand `configure --with-gnu-libc' and omit the object files,
/* This needs to come after some library #include
/* Don't include stdlib.h for non-GNU C libraries because some of them
#else	/* Not GNU C library.  */
#endif	/* GNU C library.  */
   being phased out.  */
   but it behaves differently for the user, since it allows the user
   all application programs are extended to handle flexible argument order.
   Setting the environment variable POSIXLY_CORRECT disables permutation.
   Then the behavior is completely standard.
/* Index in ARGV of the next element to be scanned.
   and for communication between successive calls to `getopt'.
   how much of ARGV has been scanned so far.  */
/* XXX 1003.2 says this must be 1 before any call.  */
/* The next char to be scanned in the option-element
   by advancing to the next ARGV-element.  */
/* Callers store zero here to inhibit the error message
   This must be initialized on some systems to avoid linking in the
/* Describe how to deal with options that follow non-option ARGV-elements.
   the default is REQUIRE_ORDER if the environment variable
   This mode of operation is selected by either setting the environment
   variable POSIXLY_CORRECT, or using `+' as the first character
   to be given in any order, even with programs that were not written to
   RETURN_IN_ORDER is an option available to programs that were written
   to expect options and other ARGV-elements in any order and that care about
   the ordering of the two.  We describe each non-option ARGV-element
/* We want to avoid inclusion of string.h with non-GNU libraries
   because there are many ways it can cause trouble.
#define	my_bcopy(src, dst, n)	memcpy ((dst), (src), (n))
/* Avoid depending on library functions or files
my_bcopy (from, to, size)
#endif				/* GNU C library.  */
/* Describe the part of ARGV that contains non-options that have
   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
/* Exchange two adjacent subsequences of ARGV.
   One subsequence is elements [first_nonopt,last_nonopt)
   which contains all the non-options that have been skipped so far.
   `first_nonopt' and `last_nonopt' are relocated so that they describe
  /* Interchange the two blocks of data in ARGV.  */
  my_bcopy ((char *) &argv[first_nonopt], (char *) temp, nonopts_size);
  my_bcopy ((char *) &argv[last_nonopt], (char *) &argv[first_nonopt],
  my_bcopy ((char *) temp,
   that is not an option.  (The ARGV-elements have been permuted
   zero, the error message is suppressed but we still return '?'.
   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
   Long-named options begin with `--' instead of `-'.
   Their names may be abbreviated as long as the abbreviation is unique
   from the option name by a `=', or else the in next ARGV-element.
   The elements of ARGV aren't really const, because we permute them.
   But we pretend they're const in the prototype to be compatible
   LONGOPTS is a vector of `struct option' terminated by an
   It is only valid when a long-named option has been found by the most
	 and back over any non-options that we skipped and permuted.  */
	 either stop the scan or describe it to the caller and pass it by.  */
      int ambig = 0;
      /* Test all options for either exact match or abbreviated matches.  */
		break;
	      ambig = 1;
      if (ambig && !exact)
	    fprintf (stderr, "%s: option `%s' is ambiguous\n",
	      /* Don't test has_arg with >, because some C compilers don't
		 allow it to be used on enums.  */
		/* If we end this ARGV-element by taking the rest as an arg,
/* Compile with -DTEST to make an executable for use in testing
   the above definition of `getopt'.  */
      c = getopt (argc, argv, "abc:d:0123456789");
	break;
	  break;
	  break;
	  break;
	  break;
	  break;
/* Extended regular expression matching and search library,
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
/* AIX requires this to be the first thing in the file. */
#include "buffer.h"
/* We used to test for `BSTRING' here, but only GCC and Emacs define
#ifndef bcmp
#define bcmp(s1, s2, n)	memcmp ((s1), (s2), (n))
#ifndef bcopy
#define bcopy(s, d, n)	memcpy ((d), (s), (n))
#ifndef bzero
#define bzero(s, n)	memset ((s), 0, (n))
/* This must be nonzero for the wordchar and notwordchar pattern
extern char *re_syntax_table;
static char re_syntax_table[CHAR_SET_SIZE];
   bzero (re_syntax_table, sizeof re_syntax_table);
     re_syntax_table[c] = Sword;
     re_syntax_table[c] = Sword;
     re_syntax_table[c] = Sword;
   re_syntax_table['_'] = Sword;
#define SYNTAX(c) re_syntax_table[c]
/* Get the interface, including the syntax bits.  */
   using /bin/cc or gcc but without giving an ansi option).  So, all
   ctype uses should be through macros like ISPRINT...  If
   macros don't need to be guarded with references to isascii. ...
#ifdef isblank
#define ISBLANK(c) (isascii (c) && isblank (c))
   since ours (we hope) works properly with all combinations of
   (Per Bothner suggested the basic approach.)  */
/* As in Harbison and Steele.  */
   use `alloca' instead of `malloc'.  This is because using malloc in
   the other hand, malloc is more portable, and easier to debug.  
   Because we sometimes use alloca, some routines have to be macros,
/* Make alloca work the best possible way.  */
#define alloca __builtin_alloca
/* Assumes a `char *destination' variable.  */
   bcopy (source, destination, osize),					\
#define BYTEWIDTH 8 /* In bits.  */
typedef char boolean;
   expressions.  Some opcodes are followed by argument bytes.  A
   arguments.  Zero bytes may appear in the compiled regular expression.
   The value of `exactn' is needed in search.c (search_buffer) in Emacs.
   So regex.h defines a symbol `RE_EXACTN_VALUE' to be 1; the value of
   `exactn' we use here must also be 1.  */
        /* Followed by one byte giving n, then by n literal bytes.  */
        /* Matches any one char belonging to specified set.  First
           following byte is number of bitmap bytes.  Then come bytes
           for a bitmap saying which chars are in.  Bits in each byte
           are ordered low-bit-first.  A character is in the set if its
           bit is 1.  A character too large to have a bit in the map is
        /* Same parameters as charset, but match any character that is
        /* Start remembering the text that is matched, for storing in a
           register.  Followed by one byte with the register number, in
           the range 0 to one less than the pattern buffer's re_nsub
           field.  Then followed by one byte with the number of groups
           inner to this one.  (This last has to be part of the
           start_memory only because we need it in the on_failure_jump
        /* Stop remembering the text that is matched and store it in a
           memory register.  Followed by one byte with the register
           number, in the range 0 to one less than `re_nsub' in the
           pattern buffer, and one byte with the number of inner groups,
           just like `start_memory'.  (We need the number of inner
           groups here because we don't have any easy way of finding the
        /* Match a duplicate of something remembered. Followed by one
           byte containing the register number.  */
        /* Fail unless at beginning of line.  */
  begline,
        /* Succeeds if at beginning of buffer (if emacs) or at beginning
           of string to be matched (if not).  */
  begbuf,
        /* Analogously, for end of buffer/string.  */
  endbuf,
        /* Followed by two byte relative address to which to jump.  */
	/* Same as jump, but marks the end of an alternative.  */
        /* Followed by two-byte relative address of place to resume at
        /* Like on_failure_jump, but pushes a placeholder instead of the
           two-byte relative address.  */
        /* Change to pop_failure_jump if know won't have to backtrack to
           back to the beginning of a repeat.  If what follows this jump
           clearly won't match what the repeat does, such that we can be
           sure that there is no use backtracking out of repetitions
           Followed by two-byte address.  */
  maybe_pop_jump,
        /* Jump to following two-byte address, and push a dummy failure
           point. This failure point will be thrown away if an attempt
           before the first repeat.  Also used as an intermediary kind
        /* Followed by two-byte relative address and two-byte number n.
        /* Followed by two-byte relative address, and two-byte number n.
        /* Set the following two-byte relative address to the
           subsequent two-byte number.  The address *includes* the two
           bytes of number.  */
  set_number_at,
  wordbeg,	/* Succeeds if at word beginning.  */
  wordbound,	/* Succeeds if at a word boundary.  */
  notwordbound	/* Succeeds if not at a word boundary.  */
  ,before_dot,	/* Succeeds if before point.  */
	/* Matches any character whose syntax is specified.  Followed by
           a byte which contains a syntax code, e.g., Sword.  */
/* Store NUMBER in two contiguous bytes starting at DESTINATION.  */
#define STORE_NUMBER(destination, number)				\
    (destination)[0] = (number) & 0377;					\
    (destination)[1] = (number) >> 8;					\
   the byte after where the number is stored.  Therefore, DESTINATION
   must be an lvalue.  */
#define STORE_NUMBER_AND_INCR(destination, number)			\
    STORE_NUMBER (destination, number);					\
/* Put into DESTINATION a number stored in two contiguous bytes starting
extract_number (dest, source)
#ifndef EXTRACT_MACROS /* To debug the macros.  */
#define EXTRACT_NUMBER(dest, src) extract_number (&dest, src)
/* Same as EXTRACT_NUMBER, except increment SOURCE to after the number.
   SOURCE must be an lvalue.  */
extract_number_and_incr (destination, source)
  extract_number (destination, *source);
  extract_number_and_incr (&dest, &src)
/* If DEBUG is defined, Regex prints many voluminous messages about what
   it is doing (if the variable `debug' is nonzero).  If linked with the
/* We use standard I/O for debugging.  */
/* It is useful to test things that ``must'' be true when debugging.  */
static int debug = 0;
#define DEBUG_PRINT1(x) if (debug) printf (x)
#define DEBUG_PRINT2(x1, x2) if (debug) printf (x1, x2)
#define DEBUG_PRINT3(x1, x2, x3) if (debug) printf (x1, x2, x3)
#define DEBUG_PRINT4(x1, x2, x3, x4) if (debug) printf (x1, x2, x3, x4)
  if (debug) print_partial_compiled_pattern (s, e)
  if (debug) print_double_string (w, s1, sz1, s2, sz2)
/* Print the fastmap in human-readable form.  */
/* Print a compiled pattern string in human-readable form, starting at
   the START pointer into it and ending just before the pointer END.  */
          break;
          break;
          break;
          break;
	  break;
	  break;
		  /* Have we broken a range?  */
	  break;
	case begline:
	  printf ("/begline");
          break;
          break;
          extract_number_and_incr (&mcnt, &p);
          break;
          extract_number_and_incr (&mcnt, &p);
          break;
          extract_number_and_incr (&mcnt, &p);
          break;
          break;
        case maybe_pop_jump:
          extract_number_and_incr (&mcnt, &p);
  	  printf ("/maybe_pop_jump to %d", p + mcnt - start);
	  break;
	  extract_number_and_incr (&mcnt, &p);
	  break;          
	  extract_number_and_incr (&mcnt, &p);
	  break;          
	  extract_number_and_incr (&mcnt, &p);
	  break;
          extract_number_and_incr (&mcnt, &p);
          extract_number_and_incr (&mcnt2, &p);
          break;
          extract_number_and_incr (&mcnt, &p);
          extract_number_and_incr (&mcnt2, &p);
          break;
        case set_number_at: 
          extract_number_and_incr (&mcnt, &p);
          extract_number_and_incr (&mcnt2, &p);
	  printf ("/set_number_at location %d to %d", p + mcnt - start, mcnt2);
          break;
        case wordbound:
	  printf ("/wordbound");
	  break;
	case notwordbound:
	  printf ("/notwordbound");
          break;
	case wordbeg:
	  printf ("/wordbeg");
	  break;
	case before_dot:
	  printf ("/before_dot");
          break;
          break;
          break;
          break;
	  break;
          break;
          break;
	case begbuf:
	  printf ("/begbuf");
          break;
	case endbuf:
	  printf ("/endbuf");
          break;
print_compiled_pattern (bufp)
    struct re_pattern_buffer *bufp;
  unsigned char *buffer = bufp->buffer;
  print_partial_compiled_pattern (buffer, buffer + bufp->used);
  printf ("%d bytes used/%d bytes allocated.\n", bufp->used, bufp->allocated);
  if (bufp->fastmap_accurate && bufp->fastmap)
      print_fastmap (bufp->fastmap);
  printf ("re_nsub: %d\t", bufp->re_nsub);
  printf ("regs_alloc: %d\t", bufp->regs_allocated);
  printf ("can_be_null: %d\t", bufp->can_be_null);
  printf ("newline_anchor: %d\n", bufp->newline_anchor);
  printf ("no_sub: %d\t", bufp->no_sub);
  printf ("not_bol: %d\t", bufp->not_bol);
  printf ("not_eol: %d\t", bufp->not_eol);
  printf ("syntax: %d\n", bufp->syntax);
  /* Perhaps we should print the translate table?  */
print_double_string (where, string1, size1, string2, size2)
/* Set by `re_set_syntax' to the current regexp syntax to recognize.  Can
   also be assigned to arbitrarily: each pattern buffer stores its own
   syntax, so it can be changed between regex compilations.  */
   for compatibility for various utilities which historically have
   different, incompatible syntaxes.
   The argument SYNTAX is a bit mask comprised of the various bits
/* This table gives an error message for each of the error codes listed
   in regex.h.  Obviously the order here has to be same as there.  */
    "Trailing backslash",			/* REG_EESCAPE */
    "Invalid back reference",			/* REG_ESUBREG */
    "Regular expression too big",		/* REG_ESIZE */
/* Subroutine declarations and macros for regex_compile.  */
static boolean at_begline_loc_p (), at_endline_loc_p ();
static boolean group_in_compile_stack ();
   string passed to us by the user to an unsigned char that we can use
/* Go backwards one character in the pattern.  */
   cast the subscript to translate because some data is declared as
   when we use a character as a subscript we must make it unsigned.  */
/* Macros for outputting the compiled pattern into `buffer'.  */
/* If the buffer isn't allocated when it comes in, use this.  */
/* Make sure we have at least N more bytes of space in buffer.  */
    while (b - bufp->buffer + (n) > bufp->allocated)			\
/* Make sure we have one more byte of buffer space and then add C to it.  */
/* Ensure we have two more bytes of buffer space and then append C1 and C2.  */
/* As with BUF_PUSH_2, except for three bytes.  */
   relative address offset by the three bytes the jump itself occupies.  */
/* Like `STORE_JUMP', but for inserting.  Assume `b' is the buffer end.  */
/* Like `STORE_JUMP2', but for inserting.  Assume `b' is the buffer end.  */
/* This is not an arbitrary limit: the arguments which represent offsets
   into the pattern are two bytes long.  So if 2^16 bytes turns out to
   be too small, many things would have to change.  */
/* Extend the buffer by twice its current size via realloc and
   reset the pointers that pointed into the old block to point to the
   correct places in the new one.  If extending the buffer results in it
   being larger than MAX_BUF_SIZE, then flag memory exhausted.  */
    unsigned char *old_buffer = bufp->buffer;				\
    if (bufp->allocated == MAX_BUF_SIZE) 				\
    bufp->allocated <<= 1;						\
    if (bufp->allocated > MAX_BUF_SIZE)					\
      bufp->allocated = MAX_BUF_SIZE; 					\
    bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated);\
    if (bufp->buffer == NULL)						\
    /* If the buffer moved, move all the pointers into it.  */		\
    if (old_buffer != bufp->buffer)					\
        b = (b - old_buffer) + bufp->buffer;				\
        begalt = (begalt - old_buffer) + bufp->buffer;			\
          fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;\
          laststart = (laststart - old_buffer) + bufp->buffer;		\
          pending_exact = (pending_exact - old_buffer) + bufp->buffer;	\
/* Since we have one byte reserved for the register number argument to
   {start,stop}_memory, the maximum number of groups we can report
   things about is what fits in that byte.  */
/* Since offsets can go either forwards or backwards, this type needs to
   be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
  pattern_offset_t begalt_offset;
/* The next available element.  */
/* Set the bit for character C in a list.  */
/* Get the next unsigned number in the uncompiled pattern.  */
              break; 							\
    || STREQ (string, "cntrl") || STREQ (string, "blank"))
   Assumes the `allocated' (and perhaps `buffer') and `translate'
     `buffer' is the compiled pattern;
     `re_nsub' is the number of subexpressions in PATTERN;
     `not_bol' and `not_eol' are zero;
regex_compile (pattern, size, syntax, bufp)
     struct re_pattern_buffer *bufp;
     `char *' (i.e., signed), we declare these variables as unsigned, so
     they can be reliably used as array indices.  */
  /* Points to the end of the buffer, where we should append.  */
  char *translate = bufp->translate;
  /* Address of the count-byte of the most recently inserted `exactn'
     command.  This makes it possible to tell if a new exact-match
     character can be added to that command or if the character requires
     operand.  Reset at the beginning of groups and alternatives.  */
  /* Address of beginning of regexp, or inside of last group.  */
  unsigned char *begalt;
     which to go back if the interval is invalid.  */
  const char *beg_interval;
  /* Counts open-groups as they are encountered.  Remembered for the
     number is put in the stop_memory as the start_memory.  */
  if (debug)
      unsigned debug_count;
      for (debug_count = 0; debug_count < size; debug_count++)
        printchar (pattern[debug_count]);
  /* Initialize the pattern buffer.  */
  bufp->syntax = syntax;
  bufp->fastmap_accurate = 0;
  bufp->not_bol = bufp->not_eol = 0;
     printer (for debugging) will think there's no pattern.  We reset it
  bufp->used = 0;
  /* Always count groups, whether or not bufp->no_sub is set.  */
  bufp->re_nsub = 0;				
  /* Initialize the syntax table.  */
  if (bufp->allocated == 0)
      if (bufp->buffer)
	{ /* If zero allocated, but buffer is non-null, try to realloc
             enough space.  This loses if buffer's address is bogus, but
             that is the user's responsibility.  */
          RETALLOC (bufp->buffer, INIT_BUF_SIZE, unsigned char);
        { /* Caller did not allocate a buffer.  Do it for them.  */
          bufp->buffer = TALLOC (INIT_BUF_SIZE, unsigned char);
      if (!bufp->buffer) return REG_ESPACE;
      bufp->allocated = INIT_BUF_SIZE;
  begalt = b = bufp->buffer;
                   /* Otherwise, depends on what's come before.  */
                || at_begline_loc_p (pattern, p, syntax))
              BUF_PUSH (begline);
          break;
           break;
            boolean keep_string_p = false;
               down to just one (the right one).  We can't combine
               interval operators with these because of, e.g., `a{2}*',
               which should only match an even number of `a's.  */
                  break;
                        break;
                    break;
              break;
                   end a backward relative jump from `b' to before the next
                   jump we're going to put in below (which jumps from
                   insert an unconditional jump backwards to the .,
                   instead of the beginning of the loop.  This way we only
                   because laststart was nonzero.  And we've already
                   incremented `p', by the way, to be the character after
                   for null bytes, because of RE_DOT_NOT_NULL?  */
                  STORE_JUMP (maybe_pop_jump, b, laststart - 3);
                /* We've added more stuff to the buffer.  */
            /* On failure, jump from laststart to b + 3, which will be the
               end of the buffer after this jump is inserted.  */
                   `dummy_failure_jump' before the initial
	  break;
          break;
            boolean had_char_class = false;
               opcode, the length count, and the bitset; 34 bytes in all.  */
            /* Remember the first position in the bracket expression.  */
            /* Push the number of bytes in the bitmap.  */
            bzero (b, (1 << BYTEWIDTH) / BYTEWIDTH);
            /* charset_not matches newline according to a syntax bit.  */
            /* Read in characters and ranges, setting map bits.  */
                /* Could be the end of the bracket expression.  If it's
                   not (i.e., when the bracket expression is `[]' so
                   far), the ']' character bit gets set way below.  */
                  break;
                   beginning or the end of a list, then it's the range
                /* See if we're at the beginning of a possible character
                          break;
                    /* If isn't a word bracketed by `[:' and:`]':
                       the leading `:' and `[' (but set bits for them).  */
                        boolean is_alnum = STREQ (str, "alnum");
                        boolean is_alpha = STREQ (str, "alpha");
                        boolean is_blank = STREQ (str, "blank");
                        boolean is_cntrl = STREQ (str, "cntrl");
                        boolean is_digit = STREQ (str, "digit");
                        boolean is_graph = STREQ (str, "graph");
                        boolean is_lower = STREQ (str, "lower");
                        boolean is_print = STREQ (str, "print");
                        boolean is_punct = STREQ (str, "punct");
                        boolean is_space = STREQ (str, "space");
                        boolean is_upper = STREQ (str, "upper");
                        boolean is_xdigit = STREQ (str, "xdigit");
                                || (is_blank  && ISBLANK (ch))
            /* Discard any (non)matching list bytes that are all 0 at the
               end of the map.  Decrease the map-length byte too.  */
          break;
                goto normal_backslash;
              bufp->re_nsub++;
                 whole pattern moves because of realloc, they will still
                 be valid.  */
              COMPILE_STACK_TOP.begalt_offset = begalt - bufp->buffer;
                = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
              COMPILE_STACK_TOP.laststart_offset = b - bufp->buffer;
              /* We will eventually replace the 0 with the number of
                 start_memory for groups beyond the last one we can
                  COMPILE_STACK_TOP.inner_group_offset = b - bufp->buffer + 2;
              begalt = b;
              break;
              if (syntax & RE_NO_BK_PARENS) goto normal_backslash;
                  goto normal_backslash;
                     alternative for a possible future
                     to `fixup_alt_jump', in the `handle_alt' case below.  */
              /* See similar code for backslashed left paren above.  */
              /* Since we just checked for an empty stack above, this
                /* We don't just want to restore into `regnum', because
                   later groups should continue to be numbered higher,
                begalt = bufp->buffer + COMPILE_STACK_TOP.begalt_offset;
                    ? bufp->buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1 
                laststart = bufp->buffer + COMPILE_STACK_TOP.laststart_offset;
                      = bufp->buffer + COMPILE_STACK_TOP.inner_group_offset;
              break;
                goto normal_backslash;
              /* Insert before the previous alternative a jump which
              INSERT_JUMP (on_failure_jump, begalt, b + 6);
              /* The alternative before this one has a jump after it
                 jump (put in below, which in turn will jump to the next
                 three-byte space after `a'.  We'll put in the jump, set
                 fixup_alt_jump to right after `b', and leave behind three
                 bytes which we'll fill in when we get to after `c'.  */
                 to be filled in later either by next alternative or
              begalt = b;
              break;
                goto normal_backslash;
                /* At least (most) this many matches must be made.  */
                int lower_bound = -1, upper_bound = -1;
                beg_interval = p - 1;
                GET_UNSIGNED_NUMBER (lower_bound);
                    GET_UNSIGNED_NUMBER (upper_bound);
                    if (upper_bound < 0) upper_bound = RE_DUP_MAX;
                  upper_bound = lower_bound;
                if (lower_bound < 0 || upper_bound > RE_DUP_MAX
                    || lower_bound > upper_bound)
                /* If the upper bound is zero, don't want to succeed at
                   all; jump from `laststart' to `b + 3', which will be
                   the end of the buffer after we insert the jump.  */
                 if (upper_bound == 0)
                      set_number_at <jump count> <upper bound>
                      set_number_at <succeed_n count> <lower bound>
                      <body of loop>
                    (The upper bound and `jump_n' are omitted if
                    `upper_bound' is 1, though.)  */
                   { /* If the upper bound is > 1, we need to insert
                     unsigned nbytes = 10 + (upper_bound > 1) * 10;
                     GET_BUFFER_SPACE (nbytes);
                     /* Initialize lower bound of the `succeed_n', even
                        though it will be set during matching by its
                        attendant `set_number_at' (inserted next),
                        because `re_compile_fastmap' needs to know.
                        Jump to the `jump_n' we might insert below.  */
                                   b + 5 + (upper_bound > 1) * 5,
                                   lower_bound);
                     /* Code to initialize the lower bound.  Insert 
                        before the `succeed_n'.  The `5' is the last two
                        bytes of this `set_number_at', plus 3 bytes of
                     insert_op2 (set_number_at, laststart, 5, lower_bound, b);
                     if (upper_bound > 1)
                            append a backward jump to the `succeed_n'
                            jump back only `upper_bound - 1' times.  */
                                      upper_bound - 1);
                            an absolute address.  `laststart' will be
                            the `set_number_at' we're about to insert;
                            `laststart+3' the number to set, the source
                            so everything is getting moved up by 5.
                            We insert this at the beginning of the loop
                            reinitialize the bounds.  */
                         insert_op2 (set_number_at, laststart, b - laststart,
                                     upper_bound - 1, b);
                beg_interval = NULL;
              break;
               assert (beg_interval);
               p = beg_interval;
               beg_interval = NULL;
               /* normal_char and normal_backslash need `c'.  */
                     goto normal_backslash;
            /* There is no way to specify the before_dot and after_dot
              break;
              break;
              break;
              break;
              break;
              BUF_PUSH (wordbeg);
              break;
              break;
              BUF_PUSH (wordbound);
              break;
              BUF_PUSH (notwordbound);
              break;
              BUF_PUSH (begbuf);
              break;
              BUF_PUSH (endbuf);
              break;
              /* Can't back reference to a subexpression if inside of it.  */
              break;
                goto normal_backslash;
            normal_backslash:
              /* You might think it would be useful for \ to mean
                 not to translate; but if we don't translate it
          break;
	      /* If no exactn currently being built.  */
              /* We have only one byte following the exactn for the count.  */
              /* If followed by a repetition operator.  */
	      /* Start building a new exactn.  */
	  break;
  /* We have succeeded; set the length of the buffer.  */
  bufp->used = b - bufp->buffer;
  if (debug)
      print_compiled_pattern (bufp);
/* Subroutines for `regex_compile'.  */
/* Store OP at LOC followed by two-byte integer parameter ARG.  */
/* Like `store_op1', but" for 'two two-byte parameters ARG1 and ARG2.  */
/* Copy the bytes from LOC to END to open up three bytes of space at LOC
   for OP followed by two-byte integer parameter ARG.  */
/* Like `insert_op1', but for two two-byte parameters ARG1 and ARG2.  */
   after an alternative or a begin-subexpression.  We assume there is at
   least one character before the ^.  */
static boolean
at_begline_loc_p (pattern, p, syntax)
  boolean prev_prev_backslash = prev > pattern && prev[-1] == '\\';
       /* After a subexpression?  */
       (*prev == '(' && (syntax & RE_NO_BK_PARENS || prev_prev_backslash))
    || (*prev == '|' && (syntax & RE_NO_BK_VBAR || prev_prev_backslash));
/* The dual of at_begline_loc_p.  This one is for $.  We assume there is
static boolean
  boolean next_backslash = *next == '\\';
       /* Before a subexpression?  */
        : next_backslash && next_next && *next_next == ')')
        : next_backslash && next_next && *next_next == '|');
static boolean
/* Read the ending character of a range (in a bracket expression) from the
   Then we set the translation of all bits between the starting and
   We use these short variable names so we can use the same macros as
     with unsigned char *'s; if the high bit of the pattern character
     is set, the range endpoints will be negative if we fetch using a
     appropriate translation is done in the bit-setting loop below.  */
  /* Here we see why `this_char' has to be larger than an `unsigned
     (assuming 8-bit characters), we would otherwise go into an infinite
/* Failure stack declarations and macros; both re_compile_fastmap and
   re_match_2 use a failure stack.  These have to be macros because of
/* Number of failure points for which to initially allocate space
   when matching.  If this number is exceeded, we allocate more
/* Roughly the maximum number of failure points on the stack.  Would be
   This is a variable only so users of regex can assign to it; we never
/* Double the size of FAIL_STACK, up to approximately `re_max_failures' items.
   REGEX_REALLOCATE requires `destination' be declared.   */
   Return 1 if was able to do so and 0 if ran out of memory allocating
/* This pushes an item onto the failure stack.  Must be a four-byte
   value.  Assumes the variable `fail_stack'.  Probably should only
   be called from within `PUSH_FAILURE_POINT'.  */
/* Used to omit pushing failure point id's when we're not debugging.  */
/* Push the information about the state we will need
   if we ever fail back to it.  
   Requires variables fail_stack, regstart, regend, reg_info, and
   num_regs be declared.  DOUBLE_FAIL_STACK requires `destination' be
    /* Must be int, so when we don't save any registers, the arithmetic	\
    DEBUG_PRINT2 ("     available: %d\n", REMAINING_AVAIL_SLOTS);	\
        DEBUG_PRINT2 ("\n  Doubled stack; size now: %d\n",		\
        DEBUG_PRINT2 ("  slots available: %d\n", REMAINING_AVAIL_SLOTS);\
    DEBUG_PRINT_COMPILED_PATTERN (bufp, pattern_place, pend);		\
/* This is the number of items that are pushed and popped on the stack
/* How many items can still be added to the stack without overflowing it.  */
   We restore into the parameters, all of which should be lvalues:
     REG_INFO -- array of information about each subexpression.
   Also assumes the variables `fail_stack' and (if debugging), `bufp',
  DEBUG_PRINT_COMPILED_PATTERN (bufp, pat, pend);			\
   BUFP.  A fastmap records which of the (1 << BYTEWIDTH) possible
   is used by re_search to skip quickly over impossible starting points.
   The caller must supply the address of a (1 << BYTEWIDTH)-byte data
   We set the `fastmap', `fastmap_accurate', and `can_be_null' fields in
   the pattern buffer.
re_compile_fastmap (bufp)
     struct re_pattern_buffer *bufp;
  register char *fastmap = bufp->fastmap;
  unsigned char *pattern = bufp->buffer;
  unsigned long size = bufp->used;
  /* Assume that each path through the pattern can be null until
     proven otherwise.  We set this false at the bottom of switch
  boolean path_can_be_null = true;
  /* We aren't doing a `succeed_n' to begin with.  */
  boolean succeed_n_p = false;
  bzero (fastmap, 1 << BYTEWIDTH);  /* Assume nothing's valid.  */
  bufp->fastmap_accurate = 1;	    /* It will be when we're done.  */
  bufp->can_be_null = 0;
          bufp->can_be_null |= path_can_be_null;
          path_can_be_null = true;
      /* We should never be about to go beyond the end of the pattern.  */
        /* I guess the idea here is to simply not bother with a fastmap
           if a backreference is used, since it's too hard to figure out
           `can_be_null' stops `re_search_2' from using the fastmap, so
	  bufp->can_be_null = 1;
         with `break'.  */
	  break;
	  break;
	  /* Chars beyond end of map must be allowed.  */
          break;
	  break;
	  break;
          if (!(bufp->syntax & RE_DOT_NEWLINE))
          /* Return if we have already set `can_be_null'; if we have,
	  else if (bufp->can_be_null)
	  break;
	  break;
	  break;
	case before_dot:
        case begline:
	case begbuf:
	case endbuf:
	case wordbound:
	case notwordbound:
	case wordbeg:
	case maybe_pop_jump:
          /* Jump backward implies we just went through the body of a
             loop and matched nothing.  Opcode jumped to should be
             since when we restore it above, entering the switch will
             to push such a point since we obviously won't find any more
             fastmap entries beyond `pend'.  Such a pattern can match
            bufp->can_be_null = 1;
          /* Get to the number of times to succeed.  */
	case set_number_at:
          abort (); /* We have listed all the cases.  */
      /* Getting here means we have found the possible starting
         Instead, look at the next alternative (remembered on the
      path_can_be_null = false;
  /* Set `can_be_null' for the last path (also the first path, if the
  bufp->can_be_null |= path_can_be_null;
   ENDS.  Subsequent matches using PATTERN_BUFFER and REGS will use
   must be allocated using the malloc library routine, and must each
   be at least NUM_REGS * sizeof (regoff_t) bytes long.
   If NUM_REGS == 0, then subsequent matches should allocate their own
re_set_registers (bufp, regs, num_regs, starts, ends)
    struct re_pattern_buffer *bufp;
      bufp->regs_allocated = REGS_REALLOCATE;
      bufp->regs_allocated = REGS_UNALLOCATED;
/* Like re_search_2, below, but only one string is specified, and
re_search (bufp, string, size, startpos, range, regs)
     struct re_pattern_buffer *bufp;
  return re_search_2 (bufp, NULL, 0, string, size, startpos, range, 
/* Using the compiled pattern in BUFP->buffer, first tries to match the
   and STRING2 that matched the entire BUFP->buffer and its contained
   subexpressions.
re_search_2 (bufp, string1, size1, string2, size2, startpos, range, regs, stop)
     struct re_pattern_buffer *bufp;
  register char *fastmap = bufp->fastmap;
  register char *translate = bufp->translate;
  /* If the search isn't to be a backwards one, don't waste time in a
     search for a pattern that must be anchored.  */
  if (bufp->used > 0 && (re_opcode_t) bufp->buffer[0] == begbuf && range > 0)
  if (fastmap && !bufp->fastmap_accurate)
    if (re_compile_fastmap (bufp) == -2)
         cannot be the start of a match.  If the pattern can match the
      if (fastmap && startpos < total_size && !bufp->can_be_null)
	  else				/* Searching backwards.  */
          && !bufp->can_be_null)
      val = re_match_2 (bufp, string1, size1, string2, size2,
        break;
static int bcmp_translate ();
static boolean alt_match_null_string_p (),
   This must not be longer than one word, because we push this value
   inner groups (which is a bits list) are maintained in separate
   variables.  
   We are making a (strictly speaking) nonportable assumption here: that
   the compiler will pack our bit fields into something that fits into
  } bits;
#define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)
#define IS_ACTIVE(R)  ((R).bits.is_active)
#define MATCHED_SOMETHING(R)  ((R).bits.matched_something)
#define EVER_MATCHED_SOMETHING(R)  ((R).bits.ever_matched_something)
   for the subexpressions which we are currently inside.  Also records
   that those subexprs have matched.  */
   and `string2' into an offset from the beginning of that string.  */
/* Call before fetching a character with *d.  This switches over to
/* Test if at very beginning or at very end of the virtual concatenation
   the first character in string2; and if before the beginning of
/* Test if the character before D and the one at D differ with respect
   to being word-constituent.  */
    FREE_VAR (best_regstart);						\
    FREE_VAR (best_regend);						\
/* These values must meet several constraints.  They must not be valid
   register values; since we have a limit of 255 registers (because
   we use only one byte in the pattern for the register number), we can
   use numbers larger than 255.  They must differ by 1, because of
   NUM_FAILURE_ITEMS above.  And the value for the lowest register must
   be larger than the value for the highest register, so we do not try
re_match (bufp, string, size, pos, regs)
     struct re_pattern_buffer *bufp;
  return re_match_2 (bufp, NULL, 0, string, size, pos, regs, size); 
   store offsets for the substring each group matched in REGS.  See the
   matched substring.  */
re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
     struct re_pattern_buffer *bufp;
  unsigned char *p = bufp->buffer;
  register unsigned char *pend = p + bufp->used;
  char *translate = bufp->translate;
     the subexpressions we're currently inside, plus the number of such
     return, for use in backreferences.  The number here includes
  unsigned num_regs = bufp->re_nsub + 1;
     attempt) by a subexpression part of the pattern, that is, the
     regnum-th regstart pointer points to where in the pattern we began
     stopped matching the regnum-th subexpression.  (The zeroth register
  /* If a group that's operated upon by a repetition operator fails to
     match anything, then the register for its start will need to be
     restored because it will have been set to wherever in the string we
  /* The is_active field of reg_info helps us keep track of which (possibly
     nested) subexpressions we are currently in. The matched_something
     subexpression.  These two fields get reset each time through any
  /* The following record the register info as found in the above
     variables when we find a match better than any we've seen before. 
     This happens as we backtrack through the failure points, which in
  unsigned best_regs_set = false;
  const char **best_regstart, **best_regend;
  /* Logically, this is `best_regend[0]'.  But we don't want to have to
     else (see below).  Also, we never need info about register 0 for
     treat `best_regend' differently than the rest.  So we keep track of
     the end of the best match so far in a separate variable.  We
     initialize this to NULL so that when we backtrack the first time
     and need to test it, it's not garbage.  */
  /* Used when we pop values we don't care about.  */
  /* Counts the total number of registers pushed.  */
  /* Do not bother to initialize all the register variables if there are
  if (bufp->re_nsub)
      best_regstart = REGEX_TALLOC (num_regs, const char *);
      best_regend = REGEX_TALLOC (num_regs, const char *);
            && best_regstart && best_regend && reg_dummy && reg_info_dummy)) 
      /* We must initialize all our variables to NULL, so that
      regstart = regend = old_regstart = old_regend = best_regstart
        = best_regend = reg_dummy = NULL;
  /* The starting position is bogus.  */
  /* Initialize subexpression text positions to -1 to mark ones that no
     start_memory/stop_memory has been seen for. Also initialize the
  /* We move `string1' into `string2' if the latter's empty -- but not if
     is advanced into the following input string whenever necessary, but
     this happens before fetching; therefore, at the beginning of the
     loop, `d' can be pointing at the end of a string, but it cannot
  DEBUG_PRINT_COMPILED_PATTERN (bufp, p, pend);
  /* This loops over pattern commands.  It exits by returning from the
             longest match, try backtracking.  */
              DEBUG_PRINT1 ("backtracking.\n");
                  boolean same_str_p = (FIRST_STRING_P (match_end) 
                  /* If exceeds best match so far, save it.  */
                  if (!best_regs_set
                      best_regs_set = true;
                      DEBUG_PRINT1 ("\nSAVING match as best so far.\n");
                          best_regstart[mcnt] = regstart[mcnt];
                          best_regend[mcnt] = regend[mcnt];
              /* If no failure points, don't restore garbage.  */
              else if (best_regs_set)   
  	        restore_best_regs:
                  /* Restore best match.  It may happen that `dend ==
                  DEBUG_PRINT1 ("Restoring best registers.\n");
		      regstart[mcnt] = best_regstart[mcnt];
		      regend[mcnt] = best_regend[mcnt];
          /* If caller wants register contents data back, do it.  */
          if (regs && !bufp->no_sub)
              /* Have the register data arrays been allocated?  */
              if (bufp->regs_allocated == REGS_UNALLOCATED)
                     extra element beyond `num_regs' for the `-1' marker
                  bufp->regs_allocated = REGS_REALLOCATE;
              else if (bufp->regs_allocated == REGS_REALLOCATE)
		  /* These braces fend off a "empty body in an else-statement"
		  assert (bufp->regs_allocated == REGS_FIXED);
                 indices.  Register zero has to be set differently,
                 because we always allocate enough to have at least one
	    } /* regs && !bufp->no_sub */
          break;
           byte in the pattern defines n, and the n bytes after that
          break;
        /* Match any character except possibly a newline or a null.  */
          if ((!(bufp->syntax & RE_DOT_NEWLINE) && TRANSLATE (*d) == '\n')
              || (bufp->syntax & RE_DOT_NOT_NULL && TRANSLATE (*d) == '\000'))
	  break;
	    boolean not = (re_opcode_t) *(p - 1) == charset_not;
               bit list is a full 32 bytes long.  */
	    break;
        /* The beginning of a group is represented by start_memory.
           The arguments are the register number in the next byte, and the
           number of groups inner to this one in the next.  The text
           registers data structure) under the register number.  */
             operated upon by a repetition operator, e.g., with `(a*)*b'
          /* If nothing was active before, this is the new lowest active
          /* Move past the register number and inner group count.  */
          break;
           number, and the number of inner groups.  */
             upon by a repetition operator, e.g., with `((a*)*(b*)*)*'
             against `aba'; then we want to ignore where we are now in
                 registers 1 and 2 as a result of the *, but when we pop
                 back to the second ), we are at the stop_memory 1.
             group that's operated on by a repetition operator, try to
             information for this group that we had before trying this
              boolean is_a_jump_n = false;
		  case maybe_pop_jump:
                    break;
              /* If the next operation is a jump backwards in the pattern
	         to an on_failure_jump right before the start_memory
                 by forcing a failure after pushing on the stack the
                     what its registers were before trying this last
                     against `aba' for regend[3].
                     e.g., `((a*)(b*))*' against `aba' (register 3 would
          /* Move past the register number and the inner group count.  */
          break;
	/* \<digit> has been turned into a `duplicate' command which is
           followed by the numeric value of <digit> as the register number.  */
	    /* Can't back reference a group which we've never matched.  */
            /* Where to stop matching; if both the place to start and
		    if (dend2 == end_match_2) break;
		    if (dend2 == regend[regno]) break;
		if (d2 == dend2) break;
                    ? bcmp_translate (d, d2, mcnt, translate) 
                    : bcmp (d, d2, mcnt))
	  break;
        /* begline matches the empty string at the beginning of the string
           (unless `not_bol' is set in `bufp'), and, if
	case begline:
          DEBUG_PRINT1 ("EXECUTING begline.\n");
              if (!bufp->not_bol) break;
          else if (d[-1] == '\n' && bufp->newline_anchor)
              break;
        /* endline is the dual of begline.  */
              if (!bufp->not_eol) break;
                   && bufp->newline_anchor)
              break;
	/* Match at the very beginning of the data.  */
        case begbuf:
          DEBUG_PRINT1 ("EXECUTING begbuf.\n");
            break;
        case endbuf:
          DEBUG_PRINT1 ("EXECUTING endbuf.\n");
	    break;
           matching `foo\nbar' against `.*\n'.  The .* matches the foo;
           string value, we would be back at the foo.
           `anychar's code to do something besides goto fail in this
          break;
           to the beginning of the next alternative.  Each alternative
           ending jump of the following alternative, because tensioning
           Repeats start with an on_failure_jump that points past both
           pop_failure_jump back to this on_failure_jump.  */
          /* If this on_failure_jump comes right before a group (i.e.,
             for that group and all inner ones, so that if we fail back
             to this point, the group's information will be correct.
          /* We can't use `p' to check ahead because we push
          /* We need to skip no_op's before we look for the
             against aba.  */
                 get reset at the start_memory we are about to get to,
                 but we will have saved all the registers relevant to
                 this repetition op, as described above.  */
          break;
        /* A smart repeat ends with `maybe_pop_jump'.
        case maybe_pop_jump:
          DEBUG_PRINT2 ("EXECUTING maybe_pop_jump %d.\n", mcnt);
            /* Compare the beginning of the repeat with what in the
               pattern follows its end. If we can establish that there
               is nothing that they would both match, i.e., that we
               would have to backtrack because of (as in, e.g., `a*a')
               then we can change to pop_failure_jump, because we'll
               never have to backtrack.
               `(a|ab)*' we do need to backtrack to the `ab' alternative
		     || (bufp->newline_anchor && (re_opcode_t) *p2 == endline))
                   to the `maybe_finalize_jump' of this case.  Examine what 
	/* The end of a simple repeat has a pop_failure_jump back to
           points put on by this pop_failure_jump's matching
               highest registers, even though we don't care about the
	  break;
           point in case we are followed by a `pop_failure_jump', because
           we don't want the failure point for the alternative to be
          /* See comments just above at `dummy_failure_jump' about the
          break;
              DEBUG_PRINT2 ("  Setting two bytes from 0x%x to no_op.\n", p+2);
          break;
          break;
	case set_number_at:
            DEBUG_PRINT1 ("EXECUTING set_number_at.\n");
            break;
        case wordbound:
          DEBUG_PRINT1 ("EXECUTING wordbound.\n");
	    break;
	case notwordbound:
          DEBUG_PRINT1 ("EXECUTING notwordbound.\n");
          break;
	case wordbeg:
          DEBUG_PRINT1 ("EXECUTING wordbeg.\n");
	    break;
	    break;
  	case before_dot:
          DEBUG_PRINT1 ("EXECUTING before_dot.\n");
  	  break;
  	  break;
  	  break;
	  break;
	  break;
          break;
	  break;
	  break;
          abort ();
              boolean is_a_jump_n = false;
              /* If failed to a backwards jump that's part of a repetition
                case maybe_pop_jump:
                  break;
        break;   /* Matching at this starting point really fails.  */
  if (best_regs_set)
    goto restore_best_regs;
/* Subroutine definitions for re_match_2.  */
/* We are passed P pointing to a register number after a start_memory.
   If we find the matching stop_memory, sets P to point to one past its number.
   Otherwise, sets P to an undefined byte less than or equal to END.
static boolean
        /* Could be either a loop or a series of alternatives.  */
          /* If the next operation is not a jump backwards in the
                 with an on_failure_jump (see above) that jumps to right
                  /* `mcnt' holds how many bytes long the alternative
                     its number.  */
                  /* Break if it's the beginning of an n-th alternative
                     that doesn't begin with an on_failure_jump.  */
                    break;
		      /* Get to the beginning of the n-th alternative.  */
                      break;
              /* Deal with the last alternative: go back and get number
                 of the `jump_past_alt' just before it.  `mcnt' contains
          break;
/* Similar to group_match_null_string_p, but doesn't deal with alternatives:
   It expects P to be the first byte of a single alternative and END one
   byte past the last. The alternative can contain groups.  */
static boolean
      /* Skip over opcodes that can match nothing, and break when we get 
          break;
static boolean
  boolean ret;
    case begline:
    case begbuf:
    case endbuf:
    case wordbeg:
    case wordbound:
    case notwordbound:
    case before_dot:
      break;
         contains a group and a back reference to it.  */
      break;
      break;
      /* Get to the number of times to succeed.  */
      break;
      break;
    case set_number_at:
   bytes; nonzero otherwise.  */
bcmp_translate (s1, s2, len, translate)
   Assumes the `allocated' (and perhaps `buffer') and `translate' fields
re_compile_pattern (pattern, length, bufp)
     struct re_pattern_buffer *bufp;
  /* GNU code is written to assume at least RE_NREGS registers will be set
     (and at least one extra will be -1).  */
  bufp->regs_allocated = REGS_UNALLOCATED;
     by passing null for the REGS argument to re_match, etc., not by
  bufp->no_sub = 0;
  bufp->newline_anchor = 1;
  ret = regex_compile (pattern, length, re_syntax_options, bufp);
/* Entry points compatible with 4.2 BSD regex library.  We don't define
/* BSD has one and only one pattern buffer.  */
static struct re_pattern_buffer re_comp_buf;
      if (!re_comp_buf.buffer)
  if (!re_comp_buf.buffer)
      re_comp_buf.buffer = (unsigned char *) malloc (200);
      if (re_comp_buf.buffer == NULL)
      re_comp_buf.allocated = 200;
      re_comp_buf.fastmap = (char *) malloc (1 << BYTEWIDTH);
      if (re_comp_buf.fastmap == NULL)
     don't need to initialize the pattern buffer fields which affect it.  */
  re_comp_buf.newline_anchor = 1;
  ret = regex_compile (s, strlen (s), re_syntax_options, &re_comp_buf);
    0 <= re_search (&re_comp_buf, s, len, 0, len, (struct re_registers *) 0);
   PREG is a regex_t *.  We do not expect any fields to be initialized,
     `buffer' to the compiled pattern;
       REG_EXTENDED bit in CFLAGS is set; otherwise, to
     `newline_anchor' to REG_NEWLINE being set in CFLAGS;
     `re_nsub' to the number of subexpressions in PATTERN.
   CFLAGS is a series of bits which affect compilation.
     use POSIX basic syntax.
     Also, regexec will try a match beginning after every newline.
     versions of letters to be equivalent when matching.
     routine will report only success or failure, and nothing about the
  preg->buffer = 0;
  /* Don't bother to use a fastmap when searching.  This simplifies the
      /* It also changes the matching behavior.  */
  /* POSIX doesn't distinguish between an unmatched open-group and an
     unmatched close-group: both are REG_EPAREN.  */
/* regexec searches for a given pattern, specified by PREG, in the
   corresponding matched substrings.
   REG_NOTBOL is set, then ^ does not match at the beginning of the
  boolean want_reg_info = !preg->no_sub && nmatch > 0;
  private_preg.not_bol = !!(eflags & REG_NOTBOL);
     information about, via `nmatch'.  We have to pass that on to the
regerror (errcode, preg, errbuf, errbuf_size)
    char *errbuf;
    size_t errbuf_size;
    /* Only error codes returned by the rest of the code should be passed 
       code generates an invalid error code, then the program has a bug.
    abort ();
  /* POSIX doesn't require that we do anything in this case, but why
     not be nice.  */
  if (errbuf_size != 0)
      if (msg_size > errbuf_size)
          strncpy (errbuf, msg, errbuf_size - 1);
          errbuf[errbuf_size - 1] = 0;
        strcpy (errbuf, msg);
/* Free dynamically allocated space used by PREG.  */
  if (preg->buffer != NULL)
    free (preg->buffer);
  preg->buffer = NULL;
Local variables:
make-backup-files: t
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
/* Written June, 1988 by Mike Haertel
   Modified July, 1988 by Arthur David Olson to assist BMG speedups  */
	case EMPTY: s = "EMPTY"; break;
	case BACKREF: s = "BACKREF"; break;
	case BEGLINE: s = "BEGLINE"; break;
	case ENDLINE: s = "ENDLINE"; break;
	case BEGWORD: s = "BEGWORD"; break;
	case ENDWORD: s = "ENDWORD"; break;
	case LIMWORD: s = "LIMWORD"; break;
	case NOTLIMWORD: s = "NOTLIMWORD"; break;
	case QMARK: s = "QMARK"; break;
	case STAR: s = "STAR"; break;
	case PLUS: s = "PLUS"; break;
	case CAT: s = "CAT"; break;
	case OR: s = "OR"; break;
	case ORTOP: s = "ORTOP"; break;
	case LPAREN: s = "LPAREN"; break;
	case RPAREN: s = "RPAREN"; break;
	default: s = "CSET"; break;
tstbit(b, c)
setbit(b, c)
clrbit(b, c)
/* Syntax bits controlling the behavior of the lexical analyzer. */
static int syntax_bits, syntax_bits_set;
dfasyntax(bits, fold)
     int bits;
  syntax_bits_set = 1;
  syntax_bits = bits;
/* Lexical analyzer.  All the dross that deals with the obnoxious
   GNU Regex syntax bits is located here.  The poor, suffering
   meaning of the @#%!@#%^!@ syntax bits. */
static char *lexstart;		/* Pointer to beginning of input string. */
static lexleft;			/* Number of characters remaining. */
static int laststart;		/* True if we're separated from beginning or (, |
				   only by zero-width characters. */
/* Note that characters become unsigned here. */
   the class.  The leading [ has already been eaten by the lexical analyzer. */
  int backslash = 0, invert;
  /* Basic plan: We fetch a character.  If it's a backslash,
     we set the backslash flag and go through the loop again.
     main switch inside the backslash case.  On the minus side,
     it means that just about every case begins with
     "if (backslash) ...".  */
	  if (backslash)
	  backslash = 1;
	  break;
	  if (backslash)
	  if (syntax_bits & RE_CONTEXT_INDEP_ANCHORS
	  if (backslash)
	  if (syntax_bits & RE_CONTEXT_INDEP_ANCHORS
	      || (syntax_bits & RE_NO_BK_PARENS
	      || (syntax_bits & RE_NO_BK_VBAR
	      || ((syntax_bits & RE_NEWLINE_ALT)
	  if (backslash && !(syntax_bits & RE_NO_BK_REFS))
	  if (backslash)
	  if (backslash)
	  if (backslash)
	  if (backslash)
	  if (syntax_bits & RE_LIMITED_OPS)
	  if (backslash != ((syntax_bits & RE_BK_PLUS_QM) != 0))
	  if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)
	  if (backslash)
	  if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)
	  if (syntax_bits & RE_LIMITED_OPS)
	  if (backslash != ((syntax_bits & RE_BK_PLUS_QM) != 0))
	  if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)
	  if (!(syntax_bits & RE_INTERVALS))
	  if (backslash != ((syntax_bits & RE_NO_BK_BRACES) == 0))
		    break;
		  break;
	  if (!(syntax_bits & RE_NO_BK_BRACES))
	  if (syntax_bits & RE_LIMITED_OPS)
	  if (backslash != ((syntax_bits & RE_NO_BK_VBAR) == 0))
	  if (syntax_bits & RE_LIMITED_OPS
	      || backslash
	      || !(syntax_bits & RE_NEWLINE_ALT))
	  if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))
	  if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))
	  if (parens == 0 && syntax_bits & RE_UNMATCHED_RIGHT_PAREN_ORD)
	  if (backslash)
	  if (!(syntax_bits & RE_DOT_NEWLINE))
	    clrbit('\n', ccl);
	  if (syntax_bits & RE_DOT_NOT_NULL)
	    clrbit('\0', ccl);
	  if (!backslash)
	      setbit(c2, ccl);
	  if (backslash)
	  FETCH(c, "Unbalanced [");
	      FETCH(c, "Unbalanced [");
	      /* Nobody ever said this had to be fast. :-)
		 construct, we just treat it as a bunch of ordinary
		 characters.  We can do this because we assume
		 regex has checked for syntax errors before
	      if (c == '[' && (syntax_bits & RE_CHAR_CLASSES))
			  setbit(c2, ccl);
		      FETCH(c1, "Unbalanced [");
	      if (c == '\\' && (syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))
		FETCH(c, "Unbalanced [");
	      FETCH(c1, "Unbalanced [");
		  FETCH(c2, "Unbalanced [");
			  && (syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))
			FETCH(c2, "Unbalanced [");
		      FETCH(c1, "Unbalanced [");
		  setbit(c, ccl);
		      setbit(tolower(c), ccl);
		      setbit(toupper(c), ccl);
	      if (syntax_bits & RE_HAT_LISTS_NOT_NEWLINE)
		clrbit('\n', ccl);
	      setbit(c, ccl);
		setbit(tolower(c), ccl);
		setbit(toupper(c), ccl);
  /* The above loop should consume at most a backslash
  abort();
				   used to determine the depth that will be
      break;
      break;
      break;
/* The grammar understood by the parser is as follows.
     regexp OR branch
     branch
   branch:
     branch closure
   The parser builds a parse tree in postfix form in an array of tokens. */
	dfaerror("Unbalanced (");
/* Return the number of tokens in the given subexpression. */
nsubtoks(tindex)
      return 1 + nsubtoks(tindex - 1);
      ntoks1 = nsubtoks(tindex - 1);
      return 1 + ntoks1 + nsubtoks(tindex - 1 - ntoks1);
/* Copy the given subexpression to the top of the tree. */
	ntokens = nsubtoks(dfa->tindex);
branch()
  branch();
      branch();
/* Main entry point for the parser.  S is a string to be parsed, len is the
  if (! syntax_bits_set)
    dfaerror("Unbalanced )");
/* Copy one set to another; the destination must be large enough. */
   the positions of both sets were inserted into an initially empty set. */
      break;
	  break;
  d->states[i].backref = 0;
	d->states[i].backref = 1;
   contains a symbol that matches the empty string in some context, replace
   that position with the elements of its follow labeled with an appropriate
   S->elems must be large enough to hold the result. */
	    break;
	    break;
	    break;
	    break;
	    break;
	    break;
	    break;
	/* Force rescan to start at the beginning. */
/* Perform bottom-up analysis on the parse tree, computing various functions.
   Nullable:  A node is nullable if it is at the root of a regexp that can
   *  EMPTY leaves are nullable.
   * No other leaf is nullable.
   * A QMARK or STAR node is nullable.
   * A PLUS node is nullable if its argument is nullable.
   * A CAT node is nullable if both its arguments are nullable.
   * An OR node is nullable if either argument is nullable.
     the firstpos of the right if the left argument is nullable.
     the lastpos of the left if the right argument is nullable.
   a string matching the regexp.  At this point we consider special symbols
   that match the empty string in some context to be just normal characters.
   Later, if we find that a special symbol is in a follow set, we will
   replace it with the elements of its follow, labeled with an appropriate
   analysis is conveniently done by a linear scan with the aid of a stack.
   Sets are stored as arrays of the elements, obeying a stack-like allocation
   scheme; the number of elements in each set deeper in the stack can be
  int *nullable;		/* Nullable stack. */
  int *o_nullable;
  MALLOC(nullable, int, d->depth);
  o_nullable = nullable;
	/* The empty set is nullable. */
	*nullable++ = 1;
	/* The firstpos and lastpos of the empty leaf are both empty. */
	break;
	/* A QMARK or STAR node is automatically nullable. */
	  nullable[-1] = 1;
	break;
	   union that of the second argument if the first is nullable. */
	if (nullable[-2])
	   union that of the first argument if the second is nullable. */
	if (nullable[-1])
	/* A CAT node is nullable if both arguments are nullable. */
	nullable[-2] = nullable[-1] && nullable[-2];
	--nullable;
	break;
	/* An OR node is nullable if either argument is nullable. */
	nullable[-2] = nullable[-1] || nullable[-2];
	--nullable;
	break;
	   an "epsilon closure" effectively makes them nullable later.
	   transitions on them later.  But they are nullable. */
	*nullable++ = d->tokens[i] == BACKREF;
	break;
    /* ... balance the above nonsyntactic #ifdef goo... */
      fprintf(stderr, nullable[-1] ? " nullable: yes\n" : " nullable: no\n");
     be the set of positions of state 0. */
  free(o_nullable);
   than one group).  Each group is labeled with a set of characters that
   new state.  For each character in the group's label, set the transition
   on this character to be to a state corresponding to the set's positions,
   and its associated backward context information, if necessary.
   If we are building a searching matcher, we include the positions of state
   The collection of groups is constructed by building an equivalence-class
   any characters from C that fail on grounds of backward context.
   Search through the groups, looking for a group whose label L has nonempty
   intersection with C.  If L - C is nonempty, create a new group labeled
   create a new group labeled with the characters of C and insert this
  position_set grps[NOTCHAR];	/* As many as will ever be needed. */
  charclass labels[NOTCHAR];	/* Labels corresponding to the groups. */
  int ngrps = 0;		/* Number of groups actually used. */
  position pos;			/* Current position being considered. */
  charclass intersect;		/* Intersection with some label set. */
  charclass leftovers;		/* Stuff in the label that didn't match. */
	  setbit(i, letters);
      setbit('\n', newline);
	setbit(d->tokens[pos.index], matches);
      /* Some characters may need to be eliminated from matches because
	    clrbit('\n', matches);
	     group's label doesn't contain that character, go on to the
	      && !tstbit(d->tokens[pos.index], labels[j]))
	  /* Check if this group's label has a nonempty intersection with
	    (intersect[k] = matches[k] & labels[j][k]) ? intersectf = 1 : 0;
	  /* It does; now find the set differences both ways. */
	      int match = matches[k], label = labels[j][k];
	      (leftovers[k] = ~match & label) ? leftoversf = 1 : 0;
	      (matches[k] = match & ~label) ? matchesf = 1 : 0;
	  /* If there were leftovers, create a new group labeled with them. */
	      copyset(leftovers, labels[ngrps]);
	      copyset(intersect, labels[j]);
	  /* If every character matching the current position has been
	    break;
	  copyset(matches, labels[ngrps]);
     is to fail miserably. */
      /* If we are building a searching matcher, throw in the positions
      if (tstbit('\n', labels[i]))
	if (labels[i][j] & letters[j])
	  break;
      /* Set the transitions for each character in the current label. */
	  if (labels[i][j] & 1 << k)
/* Some routines for manipulating a compiled dfa's transition tables.
   Each state may or may not have a transition table; if it does, and it
   is a non-accepting state, then d->trans[state] points to its table.
   If it is an accepting state then d->fails[state] points to its table.
   If it has no table at all, then d->trans[state] is NULL.
build_state(s, d)
  int *trans;			/* The new transition table. */
  /* Set an upper limit on the number of transition tables that will ever
     exist at once.  1024 is arbitrary.  The idea is that the frequently
     used transition tables will be quickly rebuilt, whereas the ones that
     were only needed once or twice will be cleared away. */
  /* Set up the success bits for this state. */
  /* Now go through the new transition table, and make sure that the trans
     largest state mentioned in the table. */
build_state_zero(d)
  build_state(0, d);
/* Search through a buffer looking for a match to the given struct dfa.
   Find the first occurrence of a string matching the regexp in the buffer,
   and the shortest possible version thereof.  Return a pointer to the first
   the beginning of the buffer, and end points to the first character after
   better point somewhere valid.  Newline is a flag indicating whether to
   allow newlines to be in the matching string.  If count is non-
   see a newline.  Finally, if backref is non-NULL it points to a place
   where we're supposed to store a 1 if backreferencing happened and the
   match needs to be verified by a backtracking matcher.  Otherwise
   we store a 0 in *backref. */
dfaexec(d, begin, end, newline, count, backref)
     char *begin;
     int *backref;
  register **trans, *t;		/* Copy of d->trans so it can be optimized
  static sbit[NOTCHAR];	/* Table for anding with d->success. */
  static sbit_init;
  if (! sbit_init)
      sbit_init = 1;
	  sbit[i] = 4;
	  sbit[i] = 2;
	  sbit[i] = 1;
    build_state_zero(d);
  p = (unsigned char *) begin;
	  if (d->success[s] & sbit[*p])
	      if (backref)
		if (d->states[s].backref)
		  *backref = 1;
		  *backref = 0;
      /* Check if we've run off the end of the buffer. */
	  build_state(s, d);
/* Free the storage held by the components of a dfa. */
   Finding a "longest" sequence is beyond the scope here;
   we take an easy way out and hope for the best.
   We do a bottom-up calculation of sequences of characters that must appear
   in matches of r.e.'s represented by trees rooted at the nodes of the postfix
   are shown below.  "p" is the operand of unary operators (and the left-hand
   operand of binary operators); "q" is the right-hand operand of binary
   "ZERO" means "a zero-length sequence" below.
	OR	longest common	longest common	(do p->is and	substrings common to
					that must occur", but we might also
					simplify the *entire* r.e. being sought)
   Are optimizable r.e.'s likely to be used in real-life situations
   (something like 'ab*' is probably unlikely; something like is
  /* Eliminate any obsoleted strings. */
	  break;
   list of their distinct common substrings. Return NULL if something
comsubs(left, right)
	break;
	break;
/* Given two lists of substrings, return a new list giving substrings
   common to both. */
inboth(left, right)
  char **both;
  both = (char **) malloc(sizeof *both);
  if (both == NULL)
  both[0] = NULL;
	  temp = comsubs(left[lnum], right[rnum]);
	      freelist(both);
	  both = addlists(both, temp);
	  if (both == NULL)
  return both;
	  break;
	  break;
	    /* Guaranteed to be.  Unlikely, but. . . */
		break;
	    new = inboth(lmp->in, rmp->in);
	  break;
	  break;
	    /* Guaranteed to be */
	  break;
	  break;
		  Written August 1989 by Mike Haertel.
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   The author may be reached (Email) at the address mike@ai.mit.edu,
/* The algorithm implemented by these routines bears a startling resemblence
   to one discovered by Beate Commentz-Walter, although it is not identical.
   IBM-Germany, Scientific Center Heidelberg, Tiergartenstrasse 15, D-6900
   Heidelberg, Germany.  See also Aho, A.V., and M. Corasick, "Efficient
   String Matching:  An Aid to Bibliographic Search," CACM June 1975,
   Vol. 18, No. 6, which describes the failure function used below. */
#include "obstack.h"
#define obstack_chunk_alloc malloc
#define obstack_chunk_free free
/* Balanced tree of edges and labels leaving a given trie node. */
  struct tree *llink;		/* Left link; MUST be first field. */
  struct tree *rlink;		/* Right link (to larger labels). */
  struct trie *trie;		/* Trie node pointed to by this edge. */
  unsigned char label;		/* Label on this edge. */
  char balance;			/* Difference in depths of subtrees. */
  struct obstack obstack;	/* Obstack for node allocation. */
  int words;			/* Number of words in the trie. */
  unsigned char delta[NCHAR];	/* Delta table for rapid search. */
  struct trie *next[NCHAR];	/* Table of children of the root. */
  char *trans;			/* Character translation table. */
/* Allocate and initialize a keyword set object, returning an opaque
   pointer to it.  Return NULL if memory is not available. */
  obstack_init(&kwset->obstack);
    = (struct trie *) obstack_alloc(&kwset->obstack, sizeof (struct trie));
  register unsigned char label;
  /* Descend the trie (built of reversed keywords) character-by-character,
      label = kwset->trans ? kwset->trans[(unsigned char) *--text] : *--text;
      while (link && label != link->label)
	  if (label < link->label)
	 this trie node, so build a new trie node and install
	  link = (struct tree *) obstack_alloc(&kwset->obstack,
	  link->trie = (struct trie *) obstack_alloc(&kwset->obstack,
	  link->label = label;
	  link->balance = 0;
	  /* Back up the tree fixing the balance flags. */
	  while (depth && !links[depth]->balance)
		--links[depth]->balance;
		++links[depth]->balance;
	  /* Rebalance the tree by pointer rotations if necessary. */
	  if (depth && ((dirs[depth] == L && --links[depth]->balance)
			|| (dirs[depth] == R && ++links[depth]->balance)))
	      switch (links[depth]->balance)
		      t->balance = r->balance = 0;
		      break;
		      l->balance = t->balance != 1 ? 0 : -1;
		      r->balance = t->balance != (char) -1 ? 0 : 1;
		      t->balance = 0;
		      break;
		  break;
		      t->balance = l->balance = 0;
		      break;
		      l->balance = t->balance != 1 ? 0 : -1;
		      r->balance = t->balance != (char) -1 ? 0 : 1;
		      t->balance = 0;
		      break;
		  break;
     index number of this word in the keyword set so far. */
  /* Find, in the chain of fails going back to the root, the first
     node that has a descendent on the current label. */
      while (link && tree->label != link->label)
	if (tree->label < link->label)
  if (depth < delta[tree->label])
    delta[tree->label] = depth;
/* Return true if A has every label in B. */
  while (a && b->label != a->label)
    if (b->label < a->label)
/* Compute a vector, indexed by character code, of the trie nodes
  next[tree->label] = tree->trie;
   table and next cache for the given keyword set. */
  /* Initial values for the delta table; will be changed later.  The
     node at which an outgoing edge is labeled by that character. */
  /* Check if we can use the simple boyer-moore algorithm, instead
      kwset->target = obstack_alloc(&kwset->obstack, kwset->mind);
	  kwset->target[i] = curr->links->label;
	 a backwards match has failed. */
	 computing the delta table, failure function, and shift function. */
	  /* Update the delta table for the descendents of this node. */
	     of fails back to the root. */
		 doesn't, then the shift at the fail should be no larger
		 fail and its descendents should be no larger than the
      /* Create a vector, indexed by character code, of the outgoing links
  /* Fix things up for any translation table. */
/* Fast boyer-moore search. */
bmexec(kws, text, size)
    /* 11 is not a bug, the initial offset happens only once. */
	break;
     carefully avoid ever producing an out-of-bounds pointer. */
  char *beg, *lim, *mch, *lmch;
      beg = end - 1;
	  mch = beg;
      while (beg > text)
	  c = trans ? trans[(unsigned char) *--beg] : *--beg;
	  while (tree && c != tree->label)
	    if (c < tree->label)
		  mch = beg;
	    break;
  /* Given a known match, find the longest possible match anchored
     at or before its starting point.  This is nearly a verbatim
      beg = end - 1;
      if (trie->accepting && beg <= mch)
	  lmch = beg;
      while (beg > text)
	  c = trans ? trans[(unsigned char) *--beg] : *--beg;
	  while (tree && c != tree->label)
	    if (c < tree->label)
	      if (trie->accepting && beg <= mch)
		  lmch = beg;
	    break;
      kwsmatch->beg[0] = mch;
/* Search through the given text for a match of any member of the
   the matching substring, or NULL if no match is found.  If FOUNDLEN
   matching substring.  Similarly, if FOUNDIDX is non-NULL, store
   in the referenced location the index number of the particular
      ret = bmexec(kws, text, size);
	  kwsmatch->beg[0] = ret;
  obstack_free(&kwset->obstack, 0);
/* obstack.c - subroutines used implicitly by object stack macros
This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
/*#include "obstack.h"*/
/* Comment out all this code if we are using the GNU C Library, and are not
   actually compiling the library itself.  This code is part of the GNU C
   Library, but also included in many other GNU distributions.  Compiling
   and linking in this code is a waste when using the GNU C library
   (especially if it is a shared library).  Rather than having every GNU
   program understand `configure --with-gnu-libc' and omit the object files,
struct fooalign {char x; double d;};
   But in fact it might be less smart and round addresses to as much as
union fooround {long x; double d;};
/* When we copy a long block of data, this is the unit to do it with.
/* The non-GNU-C macros copy the obstack into this global variable
struct obstack *_obstack;
   (that adds an extra first argument), based on the state of use_extra_arg.
/* Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).
   Objects start on multiples of ALIGNMENT (0 means use default).
_obstack_begin (h, size, alignment, chunkfun, freefun)
     struct obstack *h;
  register struct _obstack_chunk* chunk; /* points to new chunk */
    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
	 Use the values for range checking, because if range checking is off,
	 the extra bytes won't be missed terribly, but if range checking is on
	 and we used a larger request, a whole extra 4096 bytes would be
	 These number are irrelevant to the new GNU malloc.  I suspect it is
  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
  h->next_free = h->object_base = chunk->contents;
  /* The initial chunk now contains no empty object.  */
  h->maybe_empty_object = 0;
_obstack_begin_1 (h, size, alignment, chunkfun, freefun, arg)
     struct obstack *h;
  register struct _obstack_chunk* chunk; /* points to new chunk */
    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
	 Use the values for range checking, because if range checking is off,
	 the extra bytes won't be missed terribly, but if range checking is on
	 and we used a larger request, a whole extra 4096 bytes would be
	 These number are irrelevant to the new GNU malloc.  I suspect it is
  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
  h->next_free = h->object_base = chunk->contents;
  /* The initial chunk now contains no empty object.  */
  h->maybe_empty_object = 0;
/* Allocate a new current chunk for the obstack *H
   on the assumption that LENGTH bytes need to be added
   to the current object, or a new object of length LENGTH allocated.
   Copies any partial object from the end of the old chunk
   to the beginning of the new one.  */
_obstack_newchunk (h, length)
     struct obstack *h;
  register struct _obstack_chunk*	old_chunk = h->chunk;
  register struct _obstack_chunk*	new_chunk;
  register int obj_size = h->next_free - h->object_base;
  new_size = (obj_size + length) + (obj_size >> 3) + 100;
  /* Move the existing object to the new chunk.
     Word at a time is fast and is safe if the object
      for (i = obj_size / sizeof (COPYING_UNIT) - 1;
	  = ((COPYING_UNIT *)h->object_base)[i];
      /* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,
	 but that can cross a page boundary on a machine
      already = obj_size / sizeof (COPYING_UNIT) * sizeof (COPYING_UNIT);
  /* Copy remaining bytes one by one.  */
  for (i = already; i < obj_size; i++)
    new_chunk->contents[i] = h->object_base[i];
  /* If the object just copied was the only data in OLD_CHUNK,
     But not if that chunk might contain an empty object.  */
  if (h->object_base == old_chunk->contents && ! h->maybe_empty_object)
  h->object_base = new_chunk->contents;
  h->next_free = h->object_base + obj_size;
  /* The new chunk certainly contains no empty object yet.  */
  h->maybe_empty_object = 0;
/* Return nonzero if object OBJ has been allocated from obstack H.
   This is here for debugging.
   If you use it in a program, you are probably losing.  */
_obstack_allocated_p (h, obj)
     struct obstack *h;
     POINTER obj;
  register struct _obstack_chunk*  lp;	/* below addr of any objects in this chunk */
  register struct _obstack_chunk*  plp;	/* point to previous chunk if any */
  /* We use >= rather than > since the object cannot be exactly at
     the beginning of the chunk but might be an empty object exactly
  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
/* Free objects in obstack H, including OBJ and everything allocate
#undef obstack_free
_obstack_free (h, obj)
     struct obstack *h;
     POINTER obj;
  register struct _obstack_chunk*  lp;	/* below addr of any objects in this chunk */
  register struct _obstack_chunk*  plp;	/* point to previous chunk if any */
  /* We use >= because there cannot be an object at the beginning of a chunk.
     But there can be an empty object at that address
  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
	 chunk contains an empty object, so assume that it may.  */
      h->maybe_empty_object = 1;
      h->object_base = h->next_free = (char *)(obj);
  else if (obj != 0)
    /* obj is not in any of the chunks! */
    abort ();
obstack_free (h, obj)
     struct obstack *h;
     POINTER obj;
  register struct _obstack_chunk*  lp;	/* below addr of any objects in this chunk */
  register struct _obstack_chunk*  plp;	/* point to previous chunk if any */
  /* We use >= because there cannot be an object at the beginning of a chunk.
     But there can be an empty object at that address
  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
	 chunk contains an empty object, so assume that it may.  */
      h->maybe_empty_object = 1;
      h->object_base = h->next_free = (char *)(obj);
  else if (obj != 0)
    /* obj is not in any of the chunks! */
    abort ();
/* These are now turned off because the applications do not use it
   and it uses bcopy via obstack_grow, which causes trouble on sysV.  */
/* Now define the functional versions of the obstack macros.
   the macro-definitions of the names from being expanded there.  */
POINTER (obstack_base) (obstack)
     struct obstack *obstack;
  return obstack_base (obstack);
POINTER (obstack_next_free) (obstack)
     struct obstack *obstack;
  return obstack_next_free (obstack);
int (obstack_object_size) (obstack)
     struct obstack *obstack;
  return obstack_object_size (obstack);
int (obstack_room) (obstack)
     struct obstack *obstack;
  return obstack_room (obstack);
void (obstack_grow) (obstack, pointer, length)
     struct obstack *obstack;
  obstack_grow (obstack, pointer, length);
void (obstack_grow0) (obstack, pointer, length)
     struct obstack *obstack;
  obstack_grow0 (obstack, pointer, length);
void (obstack_1grow) (obstack, character)
     struct obstack *obstack;
  obstack_1grow (obstack, character);
void (obstack_blank) (obstack, length)
     struct obstack *obstack;
  obstack_blank (obstack, length);
void (obstack_1grow_fast) (obstack, character)
     struct obstack *obstack;
  obstack_1grow_fast (obstack, character);
void (obstack_blank_fast) (obstack, length)
     struct obstack *obstack;
  obstack_blank_fast (obstack, length);
POINTER (obstack_finish) (obstack)
     struct obstack *obstack;
  return obstack_finish (obstack);
POINTER (obstack_alloc) (obstack, length)
     struct obstack *obstack;
  return obstack_alloc (obstack, length);
POINTER (obstack_copy) (obstack, pointer, length)
     struct obstack *obstack;
  return obstack_copy (obstack, pointer, length);
POINTER (obstack_copy0) (obstack, pointer, length)
     struct obstack *obstack;
  return obstack_copy0 (obstack, pointer, length);
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   Written August 1992 by Mike Haertel. */
#undef bcopy
#define bcopy(s, d, n) memcpy((d), (s), (n))
/* For -w, we also consider _ to be word constituent.  */
static struct re_pattern_buffer regex;
   which must occur in the match, then we build a kwset matcher
   to find those strings, and thus quickly filter out impossible
      /* First, we compile in the substrings known to be exact
      /* Now, we compile the substrings that will require
      bcopy(pattern, n + i, size);
      bcopy(pattern, n + i, size);
EGexecute(buf, size, endp)
     char *buf;
  register char *buflim, *beg, *end, save;
  int backref, start, len;
				    Q@#%!# library interface in regex.c.  */
  buflim = buf + size;
  for (beg = end = buf; end < buflim; beg = end + 1)
	  /* Find a possible match using the KWset matcher. */
	  beg = kwsexec(kwset, beg, buflim - beg, &kwsm);
	  if (!beg)
	  end = memchr(beg, '\n', buflim - beg);
	    end = buflim;
	  while (beg > buf && beg[-1] != '\n')
	    --beg;
	  if (!dfaexec(&dfa_1, beg, end, 0, (int *) 0, &backref))
	  /* Successful, no backreferences encountered. */
	  if (!backref)
	  save = *buflim;
	  beg = dfaexec(&dfa_1, beg, buflim, 0, (int *) 0, &backref);
	  *buflim = save;
	  if (!beg)
	  end = memchr(beg, '\n', buflim - beg);
	    end = buflim;
	  while (beg > buf && beg[-1] != '\n')
	    --beg;
	  /* Successful, no backreferences encountered! */
	  if (!backref)
	 a probable match, and we need to run it through Regex. */
      if ((start = re_search(&regex, beg, end - beg, 0, end - beg, &regs)) >= 0)
	  if (!match_lines && !match_words || match_lines && len == end - beg)
	  /* If -w, check if the match aligns with word boundaries.
	     We do this iteratively because:
	     (b) Several alternatives in the pattern might be valid at a given
	     boundary. */
		if ((start == 0 || !WCHAR(beg[start - 1]))
		    && (len == end - beg || !WCHAR(beg[start + len])))
		    len = re_match(&regex, beg, start + len, start, &regs);
		    if (start == end - beg)
		      break;
		    start = re_search(&regex, beg, end - beg,
				      start, end - beg - start, &regs);
  *endp = end < buflim ? end + 1 : end;
  return beg;
  char *beg, *lim, *err;
  beg = pattern;
      for (lim = beg; lim < pattern + size && *lim != '\n'; ++lim)
      if ((err = kwsincr(kwset, beg, lim - beg)) != 0)
      beg = lim;
  while (beg < pattern + size);
Fexecute(buf, size, endp)
     char *buf;
  register char *beg, *try, *end;
  for (beg = buf; beg <= buf + size; ++beg)
      if (!(beg = kwsexec(kwset, beg, buf + size - beg, &kwsmatch)))
	  if (beg > buf && beg[-1] != '\n')
	  if (beg + len < buf + size && beg[len] != '\n')
	for (try = beg; len && try;)
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	      break;
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
		try = kwsexec(kwset, beg, --len, &kwsmatch);
  if ((end = memchr(beg + len, '\n', (buf + size) - (beg + len))) != 0)
    end = buf + size;
  while (beg > buf && beg[-1] != '\n')
    --beg;
  return beg;
if agout end = buf + size;
3eif agout end = buf + size;
3eif agoutvf end = buf + size;
argue if agout end = buf + size;
