   Copyright (C) 1992 Free Software Foundation, Inc.
   the Free Software Foundation; either version 2, or (at your option)
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   Written July 1992 by Mike Haertel.  */
#define GREP 1
#define STDC_HEADERS 1
#define HAVE_STRING_H 1
#define HAVE_SYS_PARAM_H 1
#define HAVE_UNISTD_H 1
#define HAVE_ALLOCA_H 1
#define HAVE_GETPAGESIZE 1
#define HAVE_MEMCHR 1
#define HAVE_STRERROR 1
#define HAVE_VALLOC 1
#define HAVE_WORKING_MMAP 1
#define flag_stdlib 1
#define flag_systypes 1
#define flag_string 1
#define flag_memory 1
#define flag_strings 1
#if flag_systypes==0
#define flag_systypes 1
#define O_RDONLY 0
  return 0;
  errseen = 1;
  exit(2);
    fatal("memory exhausted", 0);
    fatal("memory exhausted", 0);
#if flag_systypes==0
#define flag_systypes 1
      initialized = 1;
      bufsalloc = MAX(8192, getpagesize());
      bufalloc = 5 * bufsalloc;
      /* The 1 byte of overflow is a kludge for dfaexec(), which
      buffer = valloc(bufalloc + 1);
	fatal("memory exhausted", 0);
  if (fstat(fd, &bufstat) < 0 || !S_ISREG(bufstat.st_mode))
    bufmapped = 0;
      bufmapped = 1;
      bufoffset = lseek(fd, 0, 1);
  if (pagesize == 0 && (pagesize = getpagesize()) == 0)
	bufsalloc *= 2;
      bufalloc = 5 * bufsalloc;
      nbuffer = valloc(bufalloc + 1);
	fatal("memory exhausted", 0);
  if (bufmapped && bufoffset % pagesize == 0
      if (maddr == (caddr_t) -1)
#if 0
	 but it doesn't, at least not on a Sun running 4.1.
	 In fact, it actually slows us down about 30%! */
	  bufmapped = 0;
	  lseek(bufdesc, bufoffset, 0);
  if (cc > 0)
  fwrite(beg, 1, lim - beg, stdout);
  while (pending > 0 && lastout < lim)
      if ((nl = memchr(lastout, '\n', lim - lastout)) != 0)
  if (!out_quiet && pending > 0)
      for (i = 0; i < out_before; ++i)
	  while (p > bp && p[-1] != '\n');
	  prline(p, nl + 1, '-');
	  p = nl + 1;
      for (n = 0; p < lim; ++n)
	  if ((nl = memchr(p, '\n', lim - p)) != 0)
  used = 1;
  nlines = 0;
  while ((b = (*execute)(p, lim - p, &endp)) != 0)
      if (b == lim && ((b > beg && b[-1] == '\n') || b == beg))
	  prtext(b, endp, (int *) 0);
	  nlines += 1;
  totalcc = 0;
  lastout = 0;
  totalnl = 0;
  pending = 0;
  nlines = 0;
  residue = 0;
  save = 0;
      if (fillbuf(save) < 0)
      for (lim = buflim; lim > beg && lim[-1] != '\n'; --lim)
      i = 0;
	  while (beg > bufbeg && beg[-1] != '\n');
	lastout = 0;
static char version[] = "GNU grep version 2.0";
  exit(2);
   If we find it, install it in compile and execute, and return 1.  */
  for (i = 0; matchers[i].name; ++i)
    if (strcmp(name, matchers[i].name) == 0)
	return 1;
  return 0;
  prog = argv[0];
    prog = strrchr(prog, '/') + 1;
  keycc = 0;
  keyfound = 0;
  count_matches = 0;
  no_filenames = 0;
  list_files = 0;
  suppress_errors = 0;
  while ((opt = getopt(argc, argv, "0123456789A:B:CEFGVX:bce:f:hiLlnqsvwxy"))
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
	out_before = 10 * out_before + opt - '0';
	out_after = 10 * out_after + opt - '0';
	if (out_after < 0)
	if (out_before < 0)
	out_before = out_after = 2;
	if (matcher && strcmp(matcher, "egrep") != 0)
	  fatal("you may specify only one of -E, -F, or -G", 0);
	if (matcher && strcmp(matcher, "fgrep") != 0)
	  fatal("you may specify only one of -E, -F, or -G", 0);;
	if (matcher && strcmp(matcher, "grep") != 0)
	  fatal("you may specify only one of -E, -F, or -G", 0);
	  fatal("matcher already specified", 0);
	out_byte = 1;
	out_quiet = 1;
	count_matches = 1;
	keys = xrealloc(keys, keycc + cc + 1);
	keyfound = 1;
	fp = strcmp(optarg, "-") != 0 ? fopen(optarg, "r") : stdin;
	for (keyalloc = 1; keyalloc <= keycc; keyalloc *= 2)
	       && (cc = fread(keys + keycc, 1, keyalloc - keycc, fp)) > 0)
	      keys = xrealloc(keys, keyalloc *= 2);
	if (keycc - oldcc > 0 && keys[keycc - 1] == '\n')
	keyfound = 1;
	no_filenames = 1;
	match_icase = 1;
	out_quiet = 1;
	list_files = -1;
	out_quiet = 1;
	list_files = 1;
	out_line = 1;
	out_quiet = 1;
	suppress_errors = 1;
	out_invert = 1;
	match_words = 1;
	match_lines = 1;
  if (argc - optind > 1 && !no_filenames)
    out_file = 1;
  status = 1;
	desc = strcmp(argv[optind], "-") ? open(argv[optind], O_RDONLY) : 0;
	if (desc < 0)
	    filename = desc == 0 ? "(standard input)" : argv[optind];
		status = 0;
		if (list_files == 1)
	    else if (list_files == -1)
	if (desc != 0)
      count = grep(0);
	  status = 0;
	  if (list_files == 1)
      else if (list_files == -1)
  exit(errseen ? 2 : status);
   Copyright (C) 1987, 88, 89, 90, 91, 92, 1993
   Free Software Foundation; either version 2, or (at your option) any
   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
#define flag_config 1
#if defined (HAVE_ALLOCA_H) || (defined(sparc) && (defined(sun) || (!defined(USG) && !defined(SVR4) && !defined(__svr4__))))
#define flag_alloca 1
/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.  */
#if flag_stdlib==0   
#define flag_stdlib 1
   long-named option.  Because this is not POSIX.2 compliant, it is
char *optarg = 0;
/* XXX 1003.2 says this must be 1 before any call.  */
int optind = 0;
int opterr = 1;
   as if it were the argument of an option with character code 1.
#if flag_string==0   
#define flag_string 1
  return 0;
  for (i = 0; i < size; i++)
   When `getopt' finds a long-named option, it returns 0 if that option's
  optarg = 0;
     Start processing options with ARGV-element 1 (since ARGV-element 0
  if (optind == 0)
      first_nonopt = last_nonopt = optind = 1;
      if (optstring[0] == '-')
      else if (optstring[0] == '+')
  if (nextchar == NULL || *nextchar == '\0')
		 && (argv[optind][0] != '-' || argv[optind][1] == '\0')
		     || argv[optind][0] != '+' || argv[optind][1] == '\0')
      if ((argv[optind][0] != '-' || argv[optind][1] == '\0')
	      || argv[optind][0] != '+' || argv[optind][1] == '\0')
	  return 1;
      nextchar = (argv[optind] + 1
		  + (longopts != NULL && argv[optind][1] == '-'));
      && ((argv[optind][0] == '-'
	   && (argv[optind][1] == '-' || long_only))
	  || argv[optind][0] == '+'
      int exact = 0;
      int ambig = 0;
      for (p = longopts, option_index = 0; p->name;
		exact = 1;
	      ambig = 1;
		     argv[0], argv[optind]);
		optarg = s + 1;
		      if (argv[optind - 1][1] == '-')
				 argv[0], pfound->name);
			     argv[0], argv[optind - 1][0], pfound->name);
	  else if (pfound->has_arg == 1)
			     argv[0], argv[optind - 1]);
		  return optstring[0] == ':' ? ':' : '?';
	      return 0;
      if (!long_only || argv[optind][1] == '-'
	  || argv[optind][0] == '+'
	      if (argv[optind][1] == '-')
			 argv[0], nextchar);
			 argv[0], argv[optind][0], nextchar);
    if (*nextchar == '\0')
#if 0
	    if (c < 040 || c >= 0177)
	      fprintf (stderr, "%s: unrecognized option, character code 0%o\n",
		       argv[0], c);
	      fprintf (stderr, "%s: unrecognized option `-%c'\n", argv[0], c);
	    /* 1003.2 specifies the format of this message.  */
	    fprintf (stderr, "%s: illegal option -- %c\n", argv[0], c);
    if (temp[1] == ':')
	if (temp[2] == ':')
	    if (*nextchar != '\0')
	      optarg = 0;
	    if (*nextchar != '\0')
#if 0
			     argv[0], c);
		    /* 1003.2 specifies the format of this message.  */
			     argv[0], c);
		if (optstring[0] == ':')
			   (const struct option *) 0,
			   (int *) 0,
			   0);
  int digit_optind = 0;
  while (1)
      int this_option_optind = optind ? optind : 1;
      c = getopt (argc, argv, "abc:d:0123456789");
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	  if (digit_optind != 0 && digit_optind != this_option_optind)
	  printf ("?? getopt returned character code 0%o ??\n", c);
  exit (0);
   version 0.12.
   (Implements POSIX draft P10003.2/D11.2, except for
   Copyright (C) 1993 Free Software Foundation, Inc.
   the Free Software Foundation; either version 2, or (at your option)
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
#if flag_systypes==0
#define flag_systypes 1
#if flag_config==0
#define flag_config 1
#if flag_string==0
#define flag_string 1
#define bcmp(s1, s2, n)	memcmp ((s1), (s2), (n))
#define bzero(s, n)	memset ((s), 0, (n))
#if flag_strings==0
#define flag_strings 1
#if flag_stdlib==0 
#define flag_stdlib 1
   commands in re_match_2.  */
#define Sword 1
#define CHAR_SET_SIZE 256
   static int done = 0;
   for (c = '0'; c <= '9'; c++)
   done = 1;
   isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
   Defining isascii to 1 should let any compiler worth its salt
#define isascii(c) 1
#define NULL 0
#define SIGN_EXTEND_CHAR(c) ((((unsigned char) (c)) ^ 128) - 128)
#if flag_alloca==0
#define flag_alloca 1
/* True if `size1' is non-NULL and PTR is pointing anywhere inside
   `string1' or just past its end.  This works if PTR is NULL, which is
  (size1 && string1 <= (ptr) && (ptr) <= string1 + size1)
#define BYTEWIDTH 8 /* In bits.  */
#define STREQ(s1, s2) ((strcmp (s1, s2) == 0))
#define false 0
#define true 1
   So regex.h defines a symbol `RE_EXACTN_VALUE' to be 1; the value of
   `exactn' we use here must also be 1.  */
  no_op = 0,
  exactn = 1,
           bit is 1.  A character too large to have a bit in the map is
           the range 0 to one less than the pattern buffer's re_nsub
           of re_match_2.)  */
           number, in the range 0 to one less than `re_nsub' in the
    (destination)[0] = (number) & 0377;					\
    (destination)[1] = (number) >> 8;					\
  } while (0)
    (destination) += 2;							\
  } while (0)
    (destination) = *(source) & 0377;					\
    (destination) += SIGN_EXTEND_CHAR (*((source) + 1)) << 8;		\
  } while (0)
  int temp = SIGN_EXTEND_CHAR (*(source + 1)); 
  *dest = *source & 0377;
  *dest += temp << 8;
    (source) += 2; 							\
  } while (0)
  *source += 2;
static int debug = 0;
#define DEBUG_PRINT1(x) if (debug) printf (x)
#define DEBUG_PRINT2(x1, x2) if (debug) printf (x1, x2)
#define DEBUG_PRINT3(x1, x2, x3) if (debug) printf (x1, x2, x3)
#define DEBUG_PRINT4(x1, x2, x3, x4) if (debug) printf (x1, x2, x3, x4)
#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)			\
  if (debug) print_double_string (w, s1, sz1, s2, sz2)
  unsigned was_a_range = 0;
  unsigned i = 0;  
  while (i < (1 << BYTEWIDTH))
	  was_a_range = 0;
          printchar (i - 1);
          while (i < (1 << BYTEWIDTH)  &&  fastmap[i])
              was_a_range = 1;
              printchar (i - 1);
  int mcnt, mcnt2;
            register int c, last = -100;
	    register int in_range = 0;
	            (re_opcode_t) *(p - 1) == charset_not ? "^" : "");
            for (c = 0; c < 256; c++)
	      if (c / 8 < *p
		  && (p[1 + (c/8)] & (1 << (c % 8))))
		  if (last + 1 == c && ! in_range)
		      in_range = 1;
		  else if (last + 1 != c && in_range)
		      in_range = 0;
	    p += 1 + *p;
          extract_number_and_incr (&mcnt2, &p);
	  printf ("/succeed_n to %d, %d times", p + mcnt - start, mcnt2);
          extract_number_and_incr (&mcnt2, &p);
	  printf ("/jump_n to %d, %d times", p + mcnt - start, mcnt2);
          extract_number_and_incr (&mcnt2, &p);
	  printf ("/set_number_at location %d to %d", p + mcnt - start, mcnt2);
          printf ("?%d", *(p-1));
print_double_string (where, string1, size1, string2, size2)
    const char *string1;
    const char *string2;
    int size1;
    int size2;
          for (this_char = where - string1; this_char < size1; this_char++)
            printchar (string1[this_char]);
          where = string2;    
      for (this_char = where - string2; this_char < size2; this_char++)
        printchar (string2[this_char]);
#define DEBUG_PRINT1(x)
#define DEBUG_PRINT2(x1, x2)
#define DEBUG_PRINT3(x1, x2, x3)
#define DEBUG_PRINT4(x1, x2, x3, x4)
#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)
static void store_op1 (), store_op2 ();
static void insert_op1 (), insert_op2 ();
  } while (0)
  } while (0)
#define INIT_BUF_SIZE  32
    GET_BUFFER_SPACE (1);						\
  } while (0)
/* Ensure we have two more bytes of buffer space and then append C1 and C2.  */
#define BUF_PUSH_2(c1, c2)						\
    GET_BUFFER_SPACE (2);						\
    *b++ = (unsigned char) (c1);					\
    *b++ = (unsigned char) (c2);					\
  } while (0)
/* As with BUF_PUSH_2, except for three bytes.  */
#define BUF_PUSH_3(c1, c2, c3)						\
    GET_BUFFER_SPACE (3);						\
    *b++ = (unsigned char) (c1);					\
    *b++ = (unsigned char) (c2);					\
    *b++ = (unsigned char) (c3);					\
  } while (0)
  store_op1 (op, loc, (to) - (loc) - 3)
#define STORE_JUMP2(op, loc, to, arg) \
  store_op2 (op, loc, (to) - (loc) - 3, arg)
  insert_op1 (op, loc, (to) - (loc) - 3, b)
/* Like `STORE_JUMP2', but for inserting.  Assume `b' is the buffer end.  */
#define INSERT_JUMP2(op, loc, to, arg) \
  insert_op2 (op, loc, (to) - (loc) - 3, arg, b)
   into the pattern are two bytes long.  So if 2^16 bytes turns out to
#define MAX_BUF_SIZE (1L << 16)
    bufp->allocated <<= 1;						\
  } while (0)
#define MAX_REGNUM 255
   be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
#define INIT_COMPILE_STACK_SIZE 32
#define COMPILE_STACK_EMPTY  (compile_stack.avail == 0)
   |= 1 << (((unsigned char) c) % BYTEWIDTH))
           if (num < 0)							\
              num = 0;							\
           num = num * 10 + c - '0'; 					\
#define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */
  register unsigned char c, c1;
  const char *p1;
  unsigned char *pending_exact = 0;
  unsigned char *laststart = 0;
  unsigned char *fixup_alt_jump = 0;
  regnum_t regnum = 0;
  DEBUG_PRINT1 ("\nCompiling pattern: ");
      for (debug_count = 0; debug_count < size; debug_count++)
  compile_stack.avail = 0;
  bufp->fastmap_accurate = 0;
  bufp->not_bol = bufp->not_eol = 0;
  bufp->used = 0;
  bufp->re_nsub = 0;				
  if (bufp->allocated == 0)
                   p == pattern + 1
            /* 1 means zero (many) matches is allowed.  */
            char zero_times_ok = 0, many_times_ok = 0;
               interval operators with these because of, e.g., `a{2}*',
                    PATFETCH (c1);
                    if (!(c1 == '+' || c1 == '?'))
                    c = c1;
                assert (p - 1 > pattern);
                GET_BUFFER_SPACE (3);
                if (TRANSLATE (*(p - 2)) == TRANSLATE ('.')
                  STORE_JUMP (maybe_pop_jump, b, laststart - 3);
                b += 3;
            /* On failure, jump from laststart to b + 3, which will be the
            GET_BUFFER_SPACE (3);
                         laststart, b + 3);
            pending_exact = 0;
            b += 3;
                GET_BUFFER_SPACE (3);
                INSERT_JUMP (dummy_failure_jump, laststart, laststart + 6);
                b += 3;
               opcode, the length count, and the bitset; 34 bytes in all.  */
	    GET_BUFFER_SPACE (34);
            p1 = p;
            BUF_PUSH ((1 << BYTEWIDTH) / BYTEWIDTH);
            bzero (b, (1 << BYTEWIDTH) / BYTEWIDTH);
            if ((re_opcode_t) b[-2] == charset_not
                    PATFETCH (c1);
                    SET_LIST_BIT (c1);
                if (c == ']' && p != p1 + 1)
                    && !(p - 2 >= pattern && p[-2] == '[') 
                    && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^')
                else if (p[0] == '-' && p[1] != ']')
                    PATFETCH (c1);
                    char str[CHAR_CLASS_MAX_LENGTH + 1];
                    c1 = 0;
                            || c1 == CHAR_CLASS_MAX_LENGTH)
                        str[c1++] = c;
                    str[c1] = '\0';
                        for (ch = 0; ch < 1 << BYTEWIDTH; ch++)
                        c1++;
                        while (c1--)    
            /* Discard any (non)matching list bytes that are all 0 at the
            while ((int) b[-1] > 0 && b[b[-1] - 1] == 0) 
              b[-1]--; 
            b += b[-1];
                  RETALLOC (compile_stack.stack, compile_stack.size << 1,
                  compile_stack.size <<= 1;
                = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
              /* We will eventually replace the 0 with the number of
                  COMPILE_STACK_TOP.inner_group_offset = b - bufp->buffer + 2;
                  BUF_PUSH_3 (start_memory, regnum, 0);
              fixup_alt_jump = 0;
              laststart = 0;
	      pending_exact = 0;
                     `push_dummy_failure' in `re_match_2'.  */
                  STORE_JUMP (jump_past_alt, fixup_alt_jump, b - 1);
              assert (compile_stack.avail != 0);
                   as in `(ab)c(de)' -- the second group is #2.  */
                    ? bufp->buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1 
                    : 0;
		pending_exact = 0;
                    BUF_PUSH_3 (stop_memory, this_group_regnum,
              GET_BUFFER_SPACE (3);
              INSERT_JUMP (on_failure_jump, begalt, b + 6);
              pending_exact = 0;
              b += 3;
              GET_BUFFER_SPACE (3);
              b += 3;
              laststart = 0;
                  || (p - 2 == pattern  &&  p == pend))
                int lower_bound = -1, upper_bound = -1;
                beg_interval = p - 1;
                    if (upper_bound < 0) upper_bound = RE_DUP_MAX;
                  /* Interval such as `{1}' => match exactly once. */
                if (lower_bound < 0 || upper_bound > RE_DUP_MAX
                   all; jump from `laststart' to `b + 3', which will be
                 if (upper_bound == 0)
                     GET_BUFFER_SPACE (3);
                     INSERT_JUMP (jump, laststart, b + 3);
                     b += 3;
                    `upper_bound' is 1, though.)  */
                   { /* If the upper bound is > 1, we need to insert
                     unsigned nbytes = 10 + (upper_bound > 1) * 10;
                     INSERT_JUMP2 (succeed_n, laststart,
                                   b + 5 + (upper_bound > 1) * 5,
                     b += 5;
                        before the `succeed_n'.  The `5' is the last two
                        bytes of this `set_number_at', plus 3 bytes of
                     insert_op2 (set_number_at, laststart, 5, lower_bound, b);
                     b += 5;
                     if (upper_bound > 1)
                            jump back only `upper_bound - 1' times.  */
                         STORE_JUMP2 (jump_n, b, laststart + 5,
                                      upper_bound - 1);
                         b += 5;
                            parameter of the `jump_n'; that is `b-2' as
                            `laststart+3' the number to set, the source
                            so everything is getting moved up by 5.
                            Conclusion: (b - 2) - (laststart + 3) + 5,
                         insert_op2 (set_number_at, laststart, b - laststart,
                                     upper_bound - 1, b);
                         b += 5;
                pending_exact = 0;
                   if (p > pattern  &&  p[-1] == '\\')
              BUF_PUSH_2 (syntaxspec, syntax_spec_code[c]);
              BUF_PUSH_2 (notsyntaxspec, syntax_spec_code[c]);
            case '1': case '2': case '3': case '4': case '5':
            case '6': case '7': case '8': case '9':
              c1 = c - '0';
              if (c1 > regnum)
              if (group_in_compile_stack (compile_stack, c1))
              BUF_PUSH_2 (duplicate, c1);
              || pending_exact + *pending_exact + 1 != b
	      || *pending_exact == (1 << BYTEWIDTH) - 1
		  ? *p == '\\' && (p[1] == '+' || p[1] == '?')
                      : (p[0] == '\\' && p[1] == '{'))))
	      BUF_PUSH_2 (exactn, 0);
	      pending_exact = b - 1;
      DEBUG_PRINT1 ("\nCompiled pattern: \n");
store_op1 (op, loc, arg)
  STORE_NUMBER (loc + 1, arg);
/* Like `store_op1', but" for 'two two-byte parameters ARG1 and ARG2.  */
store_op2 (op, loc, arg1, arg2)
    int arg1, arg2;
  STORE_NUMBER (loc + 1, arg1);
  STORE_NUMBER (loc + 3, arg2);
insert_op1 (op, loc, arg, end)
  register unsigned char *pto = end + 3;
  store_op1 (op, loc, arg);
/* Like `insert_op1', but for two two-byte parameters ARG1 and ARG2.  */
insert_op2 (op, loc, arg1, arg2, end)
    int arg1, arg2;
  register unsigned char *pto = end + 5;
  store_op2 (op, loc, arg1, arg2);
  const char *prev = p - 2;
  boolean prev_prev_backslash = prev > pattern && prev[-1] == '\\';
  const char *next_next = p + 1 < pend ? p + 1 : NULL;
  for (this_element = compile_stack.avail - 1;  
       this_element >= 0; 
   starting character is in `P[-2]'.  (`P[-1]' is the character `-'.)
  range_start = ((unsigned char *) p)[-2];
  range_end   = ((unsigned char *) p)[0];
     char' -- the range is inclusive, so if `range_end' == 0xff
     (assuming 8-bit characters), we would otherwise go into an infinite
     loop, since all characters <= 0xff.  */
   re_match_2 use a failure stack.  These have to be macros because of
#define INIT_FAILURE_ALLOC 5
int re_max_failures = 2000;
#define FAIL_STACK_EMPTY()     (fail_stack.avail == 0)
#define FAIL_STACK_PTR_EMPTY() (fail_stack_ptr->avail == 0)
/* Initialize `fail_stack'.  Do `return -2' if the alloc fails.  */
      return -2;							\
    fail_stack.avail = 0;						\
  } while (0)
   Return 1 if succeeds, and 0 if either ran out of memory
   ? 0									\
          ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),	\
      ? 0								\
      : ((fail_stack).size <<= 1, 					\
         1)))
   Return 1 if was able to do so and 0 if ran out of memory allocating
    ? 0									\
       1))
       of 0 + -1 isn't done as unsigned.  */				\
    DEBUG_PRINT2 ("\nPUSH_FAILURE_POINT #%u:\n", failure_id);		\
    DEBUG_PRINT2 ("  Before push, next avail: %d\n", (fail_stack).avail);\
    DEBUG_PRINT2 ("                     size: %d\n", (fail_stack).size);\
    DEBUG_PRINT2 ("  slots needed: %d\n", NUM_FAILURE_ITEMS);		\
    DEBUG_PRINT2 ("     available: %d\n", REMAINING_AVAIL_SLOTS);	\
        DEBUG_PRINT2 ("\n  Doubled stack; size now: %d\n",		\
        DEBUG_PRINT2 ("  slots available: %d\n", REMAINING_AVAIL_SLOTS);\
    DEBUG_PRINT1 ("\n");						\
	DEBUG_PRINT2 ("  Pushing reg: %d\n", this_reg);			\
	DEBUG_PRINT2 ("    start: 0x%x\n", regstart[this_reg]);		\
	DEBUG_PRINT2 ("    end: 0x%x\n", regend[this_reg]);		\
	DEBUG_PRINT2 ("    info: 0x%x\n      ", reg_info[this_reg]);	\
        DEBUG_PRINT2 (" match_null=%d",					\
        DEBUG_PRINT2 (" active=%d", IS_ACTIVE (reg_info[this_reg]));	\
        DEBUG_PRINT2 (" matched_something=%d",				\
        DEBUG_PRINT2 (" ever_matched=%d",				\
	DEBUG_PRINT1 ("\n");						\
    DEBUG_PRINT2 ("  Pushing  low active reg: %d\n", lowest_active_reg);\
    DEBUG_PRINT2 ("  Pushing high active reg: %d\n", highest_active_reg);\
    DEBUG_PRINT2 ("  Pushing pattern 0x%x: ", pattern_place);		\
    DEBUG_PRINT2 ("  Pushing string 0x%x: `", string_place);		\
    DEBUG_PRINT_DOUBLE_STRING (string_place, string1, size1, string2,   \
				 size2);				\
    DEBUG_PRINT1 ("'\n");						\
    DEBUG_PRINT2 ("  Pushing failure id: %u\n", failure_id);		\
  } while (0)
#define NUM_REG_ITEMS  3
#define NUM_NONREG_ITEMS 5 /* Includes failure point id.  */
#define NUM_NONREG_ITEMS 4
#define MAX_FAILURE_ITEMS ((num_regs - 1) * NUM_REG_ITEMS + NUM_NONREG_ITEMS)
  ((highest_active_reg - lowest_active_reg + 1) * NUM_REG_ITEMS 	\
   `pend', `string1', `size1', `string2', and `size2'.  */
  DEBUG_PRINT1 ("POP_FAILURE_POINT:\n");				\
  DEBUG_PRINT2 ("  Before pop, next avail: %d\n", fail_stack.avail);	\
  DEBUG_PRINT2 ("                    size: %d\n", fail_stack.size);	\
  DEBUG_PRINT2 ("  Popping failure id: %u\n", failure_id);		\
  DEBUG_PRINT2 ("  Popping string 0x%x: `", str);			\
  DEBUG_PRINT_DOUBLE_STRING (str, string1, size1, string2, size2);	\
  DEBUG_PRINT1 ("'\n");							\
  DEBUG_PRINT2 ("  Popping pattern 0x%x: ", pat);			\
  DEBUG_PRINT2 ("  Popping high active reg: %d\n", high_reg);		\
  DEBUG_PRINT2 ("  Popping  low active reg: %d\n", low_reg);		\
      DEBUG_PRINT2 ("    Popping reg: %d\n", this_reg);			\
      DEBUG_PRINT2 ("      info: 0x%x\n", reg_info[this_reg]);		\
      DEBUG_PRINT2 ("      end: 0x%x\n", regend[this_reg]);		\
      DEBUG_PRINT2 ("      start: 0x%x\n", regstart[this_reg]);		\
   BUFP.  A fastmap records which of the (1 << BYTEWIDTH) possible
   The caller must supply the address of a (1 << BYTEWIDTH)-byte data
   Returns 0 if we succeed, -2 if an internal error.   */
  unsigned num_regs = 0;
  bzero (fastmap, 1 << BYTEWIDTH);  /* Assume nothing's valid.  */
  bufp->fastmap_accurate = 1;	    /* It will be when we're done.  */
  bufp->can_be_null = 0;
           `can_be_null' stops `re_search_2' from using the fastmap, so
	  bufp->can_be_null = 1;
          return 0;
          fastmap[p[1]] = 1;
          for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
	    if (p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH)))
              fastmap[j] = 1;
	  for (j = *p * BYTEWIDTH; j < (1 << BYTEWIDTH); j++)
            fastmap[j] = 1;
	  for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
	    if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))))
              fastmap[j] = 1;
	  for (j = 0; j < (1 << BYTEWIDTH); j++)
	      fastmap[j] = 1;
	  for (j = 0; j < (1 << BYTEWIDTH); j++)
	      fastmap[j] = 1;
	  for (j = 0; j < (1 << BYTEWIDTH); j++)
            fastmap[j] = 1;
            fastmap['\n'] = 0;
	    return 0;
	  for (j = 0; j < (1 << BYTEWIDTH); j++)
	      fastmap[j] = 1;
	  for (j = 0; j < (1 << BYTEWIDTH); j++)
	      fastmap[j] = 1;
	  if (j > 0)
	      && fail_stack.stack[fail_stack.avail - 1] == p)
                return -2;
            bufp->can_be_null = 1;
          p += 2;		
          /* Increment p past the n for when k != 0.  */
          if (k == 0)
              p -= 4;
          p += 4;
	  p += 2;
  return 0;
   If NUM_REGS == 0, then subsequent matches should allocate their own
      regs->num_regs = 0;
      regs->start = regs->end = (regoff_t) 0;
/* Like re_search_2, below, but only one string is specified, and
  return re_search_2 (bufp, NULL, 0, string, size, startpos, range, 
   virtual concatenation of STRING1 and STRING2, starting first at index
   STARTPOS, then at STARTPOS + 1, and so on.
   STRING1 and STRING2 have length SIZE1 and SIZE2, respectively.
   RANGE is how far to scan while trying to match.  RANGE = 0 means try
   In REGS, return the indices of the virtual concatenation of STRING1
   and STRING2 that matched the entire BUFP->buffer and its contained
   concatenation of STRING1 and STRING2.
   found, -1 if no match, or -2 if error (such as failure
re_search_2 (bufp, string1, size1, string2, size2, startpos, range, regs, stop)
     const char *string1, *string2;
     int size1, size2;
  int total_size = size1 + size2;
  if (startpos < 0 || startpos > total_size)
    return -1;
     the virtual concatenation of STRING1 and STRING2.  */
  if (endpos < -1)
    range = -1 - startpos;
  if (bufp->used > 0 && (re_opcode_t) bufp->buffer[0] == begbuf && range > 0)
      if (startpos > 0)
	return -1;
	range = 1;
    if (re_compile_fastmap (bufp) == -2)
      return -2;
	  if (range > 0)	/* Searching forwards.  */
	      register int lim = 0;
              if (startpos < size1 && startpos + range >= size1)
                lim = range - (size1 - startpos);
	      d = (startpos >= size1 ? string2 - size1 : string1) + startpos;
	      register char c = (size1 == 0 || startpos >= size1
                                 ? string2[startpos - size1] 
                                 : string1[startpos]);
      if (range >= 0 && startpos == total_size && fastmap
	return -1;
      val = re_match_2 (bufp, string1, size1, string2, size2,
      if (val >= 0)
      if (val == -2)
	return -2;
      else if (range > 0) 
  return -1;
} /* re_search_2 */
/* Declarations and macros for re_match_2.  */
#define MATCH_NULL_UNSET_VALUE 3
    unsigned match_null_string_p : 2;
    unsigned is_active : 1;
    unsigned matched_something : 1;
    unsigned ever_matched_something : 1;
            = 1;							\
  while (0)
/* This converts PTR, a pointer into one of the search strings `string1'
   and `string2' into an offset from the beginning of that string.  */
  (FIRST_STRING_P (ptr) ? (ptr) - string1 : (ptr) - string2 + size1)
#define REG_UNSET_VALUE ((char *) -1)
/* Macros for dealing with the split strings in re_match_2.  */
#define MATCHING_IN_FIRST_STRING  (dend == end_match_1)
   string2 if necessary.  */
      /* End of string2 => fail.  */					\
      if (dend == end_match_2) 						\
      /* End of string1 => advance to string2.  */ 			\
      d = string2;						        \
      dend = end_match_2;						\
   of `string1' and `string2'.  If only one string, it's `string2'.  */
#define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)
#define AT_STRINGS_END(d) ((d) == end2)	
   two special cases to check for: if past the end of string1, look at
   the first character in string2; and if before the beginning of
   string2, look at the last character in string1.  */
  (SYNTAX ((d) == end1 ? *string2					\
           : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\
   || WORDCHAR_P (d - 1) != WORDCHAR_P (d))
  } while (0)
#define FREE_VARIABLES() alloca (0)
   register values; since we have a limit of 255 registers (because
   use numbers larger than 255.  They must differ by 1, because of
#define NO_HIGHEST_ACTIVE_REG (1 << BYTEWIDTH)
#define NO_LOWEST_ACTIVE_REG (NO_HIGHEST_ACTIVE_REG + 1)
/* re_match is like re_match_2 except it takes only a single string.  */
  return re_match_2 (bufp, NULL, 0, string, size, pos, regs, size); 
/* re_match_2 matches the compiled pattern in BUFP against the
   the (virtual) concatenation of STRING1 and STRING2 (of length SIZE1
   and SIZE2, respectively).  We start matching at POS, and stop
   We return -1 if no match, -2 if an internal error (such as the
re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
     const char *string1, *string2;
     int size1, size2;
  unsigned char *p1;
  const char *end1, *end2;
  /* Pointers into string1 and string2, just past the last characters in
  const char *end_match_1, *end_match_2;
  static unsigned failure_id = 0;
  unsigned nfailure_points_pushed = 0, nfailure_points_popped = 0;
  unsigned num_regs = bufp->re_nsub + 1;
  /* Logically, this is `best_regend[0]'.  But we don't want to have to
     else (see below).  Also, we never need info about register 0 for
  unsigned num_regs_pushed = 0; 	
  DEBUG_PRINT1 ("\n\nEntering re_match_2.\n");
     there are groups, we include space for register 0 (the whole
          return -2;
  if (pos < 0 || pos > size1 + size2)
      return -1;
  /* Initialize subexpression text positions to -1 to mark ones that no
  for (mcnt = 1; mcnt < num_regs; mcnt++)
      IS_ACTIVE (reg_info[mcnt]) = 0;
      MATCHED_SOMETHING (reg_info[mcnt]) = 0;
      EVER_MATCHED_SOMETHING (reg_info[mcnt]) = 0;
  /* We move `string1' into `string2' if the latter's empty -- but not if
     `string1' is null.  */
  if (size2 == 0 && string1 != NULL)
      string2 = string1;
      size2 = size1;
      string1 = 0;
      size1 = 0;
  end1 = string1 + size1;
  end2 = string2 + size2;
  if (stop <= size1)
      end_match_1 = string1 + stop;
      end_match_2 = string2;
      end_match_1 = end1;
      end_match_2 = string2 + stop - size1;
     equal `string2'.  */
  if (size1 > 0 && pos <= size1)
      d = string1 + pos;
      dend = end_match_1;
      d = string2 + pos - size1;
      dend = end_match_2;
  DEBUG_PRINT1 ("The compiled pattern is: ");
  DEBUG_PRINT1 ("The string to match is: `");
  DEBUG_PRINT_DOUBLE_STRING (d, string1, size1, string2, size2);
  DEBUG_PRINT1 ("'\n");
      DEBUG_PRINT2 ("\n0x%x: ", p);
          DEBUG_PRINT1 ("end of pattern ... ");
          if (d != end_match_2)
              DEBUG_PRINT1 ("backtracking.\n");
                      DEBUG_PRINT1 ("\nSAVING match as best so far.\n");
                      for (mcnt = 1; mcnt < num_regs; mcnt++)
                     end_match_1' while the restored d is in string2.
                  DEBUG_PRINT1 ("Restoring best registers.\n");
                  dend = ((d >= string1 && d <= end1)
		           ? end_match_1 : end_match_2);
		  for (mcnt = 1; mcnt < num_regs; mcnt++)
            } /* d != end_match_2 */
          DEBUG_PRINT1 ("Accepting match.\n");
                     extra element beyond `num_regs' for the `-1' marker
                  regs->num_regs = MAX (RE_NREGS, num_regs + 1);
                    return -2;
                  if (regs->num_regs < num_regs + 1)
                      regs->num_regs = num_regs + 1;
                        return -2;
              if (regs->num_regs > 0)
                  regs->start[0] = pos;
                  regs->end[0] = (MATCHING_IN_FIRST_STRING ? d - string1
			          : d - string2 + size1);
	      for (mcnt = 1; mcnt < MIN (num_regs, regs->num_regs); mcnt++)
                    regs->start[mcnt] = regs->end[mcnt] = -1;
                 were in the pattern, set the extra elements to -1.  If
                 -1 at the end.  */
                regs->start[mcnt] = regs->end[mcnt] = -1;
          DEBUG_PRINT4 ("%u failure points pushed, %u popped (%u remain).\n",
          DEBUG_PRINT2 ("%u registers pushed.\n", num_regs_pushed);
			    ? string1 
			    : string2 - size1);
          DEBUG_PRINT2 ("Returning %d from re_match_2.\n", mcnt);
           currently have n == 0.  */
          DEBUG_PRINT1 ("EXECUTING no_op.\n");
          DEBUG_PRINT2 ("EXECUTING exactn %d.\n", mcnt);
          DEBUG_PRINT1 ("EXECUTING anychar.\n");
              || (bufp->syntax & RE_DOT_NOT_NULL && TRANSLATE (*d) == '\000'))
          DEBUG_PRINT2 ("  Matched `%d'.\n", *d);
	    boolean not = (re_opcode_t) *(p - 1) == charset_not;
            DEBUG_PRINT2 ("EXECUTING charset%s.\n", not ? "_not" : "");
               bit list is a full 32 bytes long.  */
		&& p[1 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
	    p += 1 + *p;
	  DEBUG_PRINT3 ("EXECUTING start_memory %d (%d):\n", *p, p[1]);
	  p1 = p;		/* To send to group_match_null_string_p.  */
              = group_match_null_string_p (&p1, pend, reg_info);
	  DEBUG_PRINT2 ("  old_regstart: %d\n", 
	  DEBUG_PRINT2 ("  regstart: %d\n", POINTER_TO_OFFSET (regstart[*p]));
          IS_ACTIVE (reg_info[*p]) = 1;
          MATCHED_SOMETHING (reg_info[*p]) = 0;
          p += 2;
	  DEBUG_PRINT3 ("EXECUTING stop_memory %d (%d):\n", *p, p[1]);
	  DEBUG_PRINT2 ("      old_regend: %d\n", 
	  DEBUG_PRINT2 ("      regend: %d\n", POINTER_TO_OFFSET (regend[*p]));
          IS_ACTIVE (reg_info[*p]) = 0;
                 (a(b)c(d(e)f)g).  When group 3 ends, after the f), the
                 new highest active register is 1.  */
              unsigned char r = *p - 1;
              while (r > 0 && !IS_ACTIVE (reg_info[r]))
                 registers 1 and 2 as a result of the *, but when we pop
                 back to the second ), we are at the stop_memory 1.
	      if (r == 0)
               || (re_opcode_t) p[-3] == start_memory)
	      && (p + 2) < pend)              
              p1 = p + 2;
              mcnt = 0;
              switch ((re_opcode_t) *p1++)
                    EXTRACT_NUMBER_AND_INCR (mcnt, p1);
		      p1 += 2;
	      p1 += mcnt;
              if (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump
                  && (re_opcode_t) p1[3] == start_memory && p1[4] == *p)
                     regstart[1], and, e.g., with `((a*)*(b*)*)*'
                     against `aba' for regend[3].
                     e.g., `((a*)(b*))*' against `aba' (register 3 would
                      EVER_MATCHED_SOMETHING (reg_info[*p]) = 0;
                      for (r = *p; r < *p + *(p + 1); r++)
		  p1++;
                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
                  PUSH_FAILURE_POINT (p1 + mcnt, d, -2);
          p += 2;
	    register const char *d2, *dend2;
	    DEBUG_PRINT2 ("EXECUTING duplicate %d.\n", regno);
            d2 = regstart[regno];
            dend2 = ((FIRST_STRING_P (regstart[regno]) 
		     ? regend[regno] : end_match_1);
		while (d2 == dend2)
		    if (dend2 == end_match_2) break;
		    if (dend2 == regend[regno]) break;
                    /* End of string1 => advance to string2. */
                    d2 = string2;
                    dend2 = regend[regno];
		if (d2 == dend2) break;
                if (mcnt > dend2 - d2)
		  mcnt = dend2 - d2;
                    ? bcmp_translate (d, d2, mcnt, translate) 
                    : bcmp (d, d2, mcnt))
		d += mcnt, d2 += mcnt;
          DEBUG_PRINT1 ("EXECUTING begline.\n");
          else if (d[-1] == '\n' && bufp->newline_anchor)
          DEBUG_PRINT1 ("EXECUTING endline.\n");
          else if ((d == end1 ? *string2 : *d) == '\n'
          DEBUG_PRINT1 ("EXECUTING begbuf.\n");
          DEBUG_PRINT1 ("EXECUTING endbuf.\n");
          DEBUG_PRINT1 ("EXECUTING on_failure_keep_string_jump");
          DEBUG_PRINT3 (" %d (to 0x%x):\n", mcnt, p + mcnt);
          PUSH_FAILURE_POINT (p + mcnt, NULL, -2);
          DEBUG_PRINT1 ("EXECUTING on_failure_jump");
          DEBUG_PRINT3 (" %d (to 0x%x)", mcnt, p + mcnt);
             For example, in \(a*\)*\1, we need the preceding group,
             and in \(\(a*\)b*\)\2, we need the inner group.  */
          p1 = p;
             the result of a completed succeed_n, as in \(a\)\{1,3\}b\1
          while (p1 < pend && (re_opcode_t) *p1 == no_op)
            p1++;
          if (p1 < pend && (re_opcode_t) *p1 == start_memory)
              highest_active_reg = *(p1 + 1) + *(p1 + 2);
                lowest_active_reg = *(p1 + 1);
          DEBUG_PRINT1 (":\n");
          PUSH_FAILURE_POINT (p + mcnt, d, -2);
          DEBUG_PRINT2 ("EXECUTING maybe_pop_jump %d.\n", mcnt);
	    register unsigned char *p2 = p;
	    while (p2 + 2 < pend
		   && ((re_opcode_t) *p2 == stop_memory
		       || (re_opcode_t) *p2 == start_memory))
	      p2 += 3;			/* Skip over args, too.  */
            if (p2 == pend)
  	        p[-3] = (unsigned char) pop_failure_jump;
                DEBUG_PRINT1
            else if ((re_opcode_t) *p2 == exactn
		     || (bufp->newline_anchor && (re_opcode_t) *p2 == endline))
                  = *p2 == (unsigned char) endline ? '\n' : p2[2];
		p1 = p + mcnt;
                /* p1[0] ... p1[2] are the `on_failure_jump' corresponding
                if ((re_opcode_t) p1[3] == exactn && p1[5] != c)
  		    p[-3] = (unsigned char) pop_failure_jump;
                    DEBUG_PRINT3 ("  %c != %c => pop_failure_jump.\n",
                                  c, p1[5]);
		else if ((re_opcode_t) p1[3] == charset
			 || (re_opcode_t) p1[3] == charset_not)
		    int not = (re_opcode_t) p1[3] == charset_not;
		    if (c < (unsigned char) (p1[4] * BYTEWIDTH)
			&& p1[5 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
                    /* `not' is equal to 1 if c would match, which means
  		        p[-3] = (unsigned char) pop_failure_jump;
                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
	  p -= 2;		/* Point at relative address again.  */
	  if ((re_opcode_t) p[-1] != pop_failure_jump)
	      p[-1] = (unsigned char) jump;
              DEBUG_PRINT1 ("  Match => jump.\n");
            DEBUG_PRINT1 ("EXECUTING pop_failure_jump.\n");
          DEBUG_PRINT2 ("EXECUTING jump %d ", mcnt);
          DEBUG_PRINT2 ("(to 0x%x).\n", p);
          DEBUG_PRINT1 ("EXECUTING jump_past_alt.\n");
          DEBUG_PRINT1 ("EXECUTING dummy_failure_jump.\n");
          PUSH_FAILURE_POINT (0, 0, -2);
          DEBUG_PRINT1 ("EXECUTING push_dummy_failure.\n");
          PUSH_FAILURE_POINT (0, 0, -2);
          EXTRACT_NUMBER (mcnt, p + 2);
          DEBUG_PRINT2 ("EXECUTING succeed_n %d.\n", mcnt);
          assert (mcnt >= 0);
          if (mcnt > 0)
	       p += 2;
               DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p, mcnt);
	  else if (mcnt == 0)
              DEBUG_PRINT2 ("  Setting two bytes from 0x%x to no_op.\n", p+2);
	      p[2] = (unsigned char) no_op;
              p[3] = (unsigned char) no_op;
          EXTRACT_NUMBER (mcnt, p + 2);
          DEBUG_PRINT2 ("EXECUTING jump_n %d.\n", mcnt);
               STORE_NUMBER (p + 2, mcnt);
	    p += 4;		     
            DEBUG_PRINT1 ("EXECUTING set_number_at.\n");
            p1 = p + mcnt;
            DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p1, mcnt);
	    STORE_NUMBER (p1, mcnt);
          DEBUG_PRINT1 ("EXECUTING wordbound.\n");
          DEBUG_PRINT1 ("EXECUTING notwordbound.\n");
          DEBUG_PRINT1 ("EXECUTING wordbeg.\n");
	  if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))
          DEBUG_PRINT1 ("EXECUTING wordend.\n");
	  if (!AT_STRINGS_BEG (d) && WORDCHAR_P (d - 1)
#ifdef emacs19
          DEBUG_PRINT1 ("EXECUTING before_dot.\n");
          DEBUG_PRINT1 ("EXECUTING at_dot.\n");
          DEBUG_PRINT1 ("EXECUTING after_dot.\n");
#else /* not emacs19 */
          DEBUG_PRINT1 ("EXECUTING at_dot.\n");
	  if (PTR_CHAR_POS ((unsigned char *) d) + 1 != point)
#endif /* not emacs19 */
          DEBUG_PRINT2 ("EXECUTING syntaxspec %d.\n", mcnt);
          DEBUG_PRINT1 ("EXECUTING Emacs wordchar.\n");
          DEBUG_PRINT2 ("EXECUTING notsyntaxspec %d.\n", mcnt);
          DEBUG_PRINT1 ("EXECUTING Emacs notwordchar.\n");
          DEBUG_PRINT1 ("EXECUTING non-Emacs wordchar.\n");
          DEBUG_PRINT1 ("EXECUTING non-Emacs notwordchar.\n");
          DEBUG_PRINT1 ("\nFAIL:\n");
                  p1 = p + 1;
                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
                  p1 += mcnt;	
                  if ((is_a_jump_n && (re_opcode_t) *p1 == succeed_n)
                          && (re_opcode_t) *p1 == on_failure_jump))
          if (d >= string1 && d <= end1)
	    dend = end_match_1;
  return -1;         			/* Failure to match.  */
} /* re_match_2 */
/* Subroutine definitions for re_match_2.  */
  unsigned char *p1 = *p + 2;
  while (p1 < end)
      switch ((re_opcode_t) *p1)
          p1++;
          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
	  if (mcnt >= 0)
                 /on_failure_jump/0/6/exactn/1/a/jump_past_alt/0/6
                 /on_failure_jump/0/6/exactn/1/b/jump_past_alt/0/3
                 /exactn/1/c						
                 So, we have to first go through the first (n-1)
              /* Deal with the first (n-1) alternatives, which start
              while ((re_opcode_t) p1[mcnt-3] == jump_past_alt)
                  if (!alt_match_null_string_p (p1, p1 + mcnt - 3, 
                  p1 += mcnt;	
                  if ((re_opcode_t) *p1 != on_failure_jump)
		  p1++;
                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
                  if ((re_opcode_t) p1[mcnt-3] != jump_past_alt)
                      p1 -= 3;
              EXTRACT_NUMBER (mcnt, p1 - 2);
              if (!alt_match_null_string_p (p1, p1 + mcnt, reg_info))
              p1 += mcnt;	/* Get past the n-th alternative.  */
            } /* if mcnt > 0 */
	  assert (p1[1] == **p);
          *p = p1 + 2;
          if (!common_op_match_null_string_p (&p1, end, reg_info))
    } /* while p1 < end */
  unsigned char *p1 = p;
  while (p1 < end)
      switch ((re_opcode_t) *p1)
          p1++;
          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
          p1 += mcnt;
          if (!common_op_match_null_string_p (&p1, end, reg_info))
    }  /* while p1 < end */
  unsigned char *p1 = *p;
  switch ((re_opcode_t) *p1++)
      reg_no = *p1;
      assert (reg_no > 0 && reg_no <= MAX_REGNUM);
      ret = group_match_null_string_p (&p1, end, reg_info);
      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
      if (mcnt >= 0)
        p1 += mcnt;
      p1 += 2;		
      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
      if (mcnt == 0)
          p1 -= 4;
          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
          p1 += mcnt;
      if (!REG_MATCH_NULL_STRING_P (reg_info[*p1]))
      p1 += 4;
  *p = p1;
/* Return zero if TRANSLATE[S1] and TRANSLATE[S2] are identical for LEN
bcmp_translate (s1, s2, len, translate)
     unsigned char *s1, *s2;
  register unsigned char *p1 = s1, *p2 = s2;
      if (translate[*p1++] != translate[*p2++]) return 1;
  return 0;
   Returns 0 if the pattern was valid, otherwise an error string.
     (and at least one extra will be -1).  */
  bufp->no_sub = 0;
  bufp->newline_anchor = 1;
/* Entry points compatible with 4.2 BSD regex library.  We don't define
      return 0;
      re_comp_buf.buffer = (unsigned char *) malloc (200);
      re_comp_buf.allocated = 200;
      re_comp_buf.fastmap = (char *) malloc (1 << BYTEWIDTH);
  re_comp_buf.newline_anchor = 1;
    0 <= re_search (&re_comp_buf, s, len, 0, len, (struct re_registers *) 0);
/* POSIX.2 functions.  Don't define these for Emacs.  */
   It returns 0 if it succeeds, nonzero if it doesn't.  (See regex.h for
  preg->buffer = 0;
  preg->allocated = 0;
  preg->used = 0;
  preg->fastmap = 0;
      for (i = 0; i < CHAR_SET_SIZE; i++)
      preg->newline_anchor = 1;
    preg->newline_anchor = 0;
   We return 0 if we find a match and REG_NOMATCH if not.  */
  boolean want_reg_info = !preg->no_sub && nmatch > 0;
                   /* start: */ 0, /* range: */ len,
                   want_reg_info ? &regs : (struct re_registers *) 0);
      if (ret >= 0)
          for (r = 0; r < nmatch; r++)
  return ret >= 0 ? (int) REG_NOERROR : (int) REG_NOMATCH;
  if (errcode < 0
      || errcode >= (sizeof (re_error_msg) / sizeof (re_error_msg[0])))
  msg_size = strlen (msg) + 1; /* Includes the null.  */
  if (errbuf_size != 0)
          strncpy (errbuf, msg, errbuf_size - 1);
          errbuf[errbuf_size - 1] = 0;
  preg->allocated = 0;
  preg->used = 0;
  preg->fastmap_accurate = 0;
   Copyright (C) 1988 Free Software Foundation, Inc.
   the Free Software Foundation; either version 2, or (at your option)
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
/* Written June, 1988 by Mike Haertel
   Modified July, 1988 by Arthur David Olson to assist BMG speedups  */
#if flag_stdlib==0
#define flag_stdlib 1
#if flag_systypes==0 
#define flag_systypes 1
#if flag_string==0
#define flag_string 1
#if flag_strings==0
#define flag_strings 1
xmalloc_1(n)
  assert(n != 0);
xrealloc_1(p, n)
  assert(n != 0);
#define MALLOC(p, t, n) ((p) = (t *) xmalloc_1((n) * sizeof (t)))
#define REALLOC(p, t, n) ((p) = (t *) xrealloc_1((ptr_t) (p), (n) * sizeof (t)))
	(nalloc) *= 2;				  \
  if (t < 0)
  return c[b / INTBITS] & 1 << b % INTBITS;
  c[b / INTBITS] |= 1 << b % INTBITS;
  c[b / INTBITS] &= ~(1 << b % INTBITS);
  for (i = 0; i < CHARCLASS_INTS; ++i)
  for (i = 0; i < CHARCLASS_INTS; ++i)
    s[i] = 0;
  for (i = 0; i < CHARCLASS_INTS; ++i)
equal(s1, s2)
     charclass s1;
     charclass s2;
  for (i = 0; i < CHARCLASS_INTS; ++i)
    if (s1[i] != s2[i])
      return 0;
  return 1;
  for (i = 0; i < dfa->cindex; ++i)
  syntax_bits_set = 1;
      if (eoferr != 0)	   	      \
  0
    return 0;
  return strncmp(s, lexptr, len) == 0;
  token c, c1, c2;
  int backslash = 0, invert;
  for (i = 0; i < 2; ++i)
      FETCH(c, 0);
	  if (lexleft == 0)
	  backslash = 1;
	      || lexleft == 0
		  ? lexleft > 0 && *lexptr == ')'
		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == ')')
		  ? lexleft > 0 && *lexptr == '|'
		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == '|')
	          && lexleft > 0 && *lexptr == '\n'))
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	      laststart = 0;
	  if (backslash != ((syntax_bits & RE_BK_PLUS_QM) != 0))
	  if (backslash != ((syntax_bits & RE_BK_PLUS_QM) != 0))
	  if (backslash != ((syntax_bits & RE_NO_BK_BRACES) == 0))
	  minrep = maxrep = 0;
	     {,M} - 0 through M
	      minrep = c - '0';
		  minrep = 10 * minrep + c - '0';
		maxrep = 10 * maxrep + c - '0';
	  laststart = 0;
	  if (backslash != ((syntax_bits & RE_NO_BK_VBAR) == 0))
	  laststart = 1;
	  laststart = 1;
	  if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))
	  laststart = 1;
	  if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))
	  if (parens == 0 && syntax_bits & RE_UNMATCHED_RIGHT_PAREN_ORD)
	  laststart = 0;
	    clrbit('\0', ccl);
	  laststart = 0;
	  for (c2 = 0; c2 < NOTCHAR; ++c2)
	    if (ISALNUM(c2))
	      setbit(c2, ccl);
	  laststart = 0;
	      invert = 1;
	    invert = 0;
		for (c1 = 0; prednames[c1].name; ++c1)
		  if (looking_at(prednames[c1].name))
		      for (c2 = 0; c2 < NOTCHAR; ++c2)
			if ((*prednames[c1].pred)(c2))
			  setbit(c2, ccl);
		      lexptr += strlen(prednames[c1].name);
		      lexleft -= strlen(prednames[c1].name);
		      FETCH(c1, "Unbalanced [");
	      FETCH(c1, "Unbalanced [");
	      if (c1 == '-')
		  FETCH(c2, "Unbalanced [");
		  if (c2 == ']')
			 which is left in c1, the lookahead character. */
		      c2 = c;
		      if (c2 == '\\'
			FETCH(c2, "Unbalanced [");
		      FETCH(c1, "Unbalanced [");
		c2 = c;
	      while (c <= c2)
	  while ((c = c1) != ']');
	  laststart = 0;
	  laststart = 0;
  if ((tok >= 0 && tok < NOTCHAR) || tok >= CSET || tok == BACKREF
      regexp(0);
  int ntoks1;
  switch (dfa->tokens[tindex - 1])
      return 1;
      return 1 + nsubtoks(tindex - 1);
      ntoks1 = nsubtoks(tindex - 1);
      return 1 + ntoks1 + nsubtoks(tindex - 1 - ntoks1);
  for (i = 0; i < ntokens; ++i)
	if (maxrep == 0)
	if (minrep == 0)
	for (i = 1; i < minrep; ++i)
  while (tok != RPAREN && tok != OR && tok >= 0)
  laststart = 1;
  parens = 0;
  regexp(1);
  for (i = 0; i < src->nelem; ++i)
  position t1, t2;
  for (i = 0; i < s->nelem && p.index < s->elems[i].index; ++i)
      t1 = p;
	  t2 = s->elems[i];
	  s->elems[i++] = t1;
	  t1 = t2;
merge(s1, s2, m)
     position_set *s1;
     position_set *s2;
  int i = 0, j = 0;
  m->nelem = 0;
  while (i < s1->nelem && j < s2->nelem)
    if (s1->elems[i].index > s2->elems[j].index)
      m->elems[m->nelem++] = s1->elems[i++];
    else if (s1->elems[i].index < s2->elems[j].index)
      m->elems[m->nelem++] = s2->elems[j++];
	m->elems[m->nelem] = s1->elems[i++];
	m->elems[m->nelem++].constraint |= s2->elems[j++].constraint;
  while (i < s1->nelem)
    m->elems[m->nelem++] = s1->elems[i++];
  while (j < s2->nelem)
    m->elems[m->nelem++] = s2->elems[j++];
  for (i = 0; i < s->nelem; ++i)
      s->elems[i] = s->elems[i + 1];
  int hash = 0;
  newline = newline ? 1 : 0;
  letter = letter ? 1 : 0;
  for (i = 0; i < s->nelem; ++i)
  for (i = 0; i < d->sindex; ++i)
      for (j = 0; j < s->nelem; ++j)
  d->states[i].backref = 0;
  d->states[i].constraint = 0;
  d->states[i].first_end = 0;
  for (j = 0; j < s->nelem; ++j)
    if (d->tokens[s->elems[j].index] < 0)
	if (SUCCEEDS_IN_CONTEXT(constraint, newline, 0, letter, 0)
	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 0, letter, 1)
	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 1, letter, 0)
	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 1, letter, 1))
	d->states[i].backref = 1;
  for (i = 0; i < d->tindex; ++i)
    visited[i] = 0;
  for (i = 0; i < s->nelem; ++i)
	visited[old.index] = 1;
	for (j = 0; j < d->follows[old.index].nelem; ++j)
	i = -1;
  for (i = 0; i < d->tindex; ++i)
  for (i = 0; i < d->tindex; ++i)
    nalloc[i] = 0;
  for (i = 0; i < d->tindex; ++i)
	*nullable++ = 1;
	*nfirstpos++ = *nlastpos++ = 0;
	tmp.nelem = nfirstpos[-1];
	for (j = 0; j < nlastpos[-1]; ++j)
				 nalloc[pos[j].index], merged.nelem - 1);
	  nullable[-1] = 1;
	tmp.nelem = nfirstpos[-1];
	pos = lastpos + nlastpos[-1];
	for (j = 0; j < nlastpos[-2]; ++j)
				 nalloc[pos[j].index], merged.nelem - 1);
	if (nullable[-2])
	  nfirstpos[-2] += nfirstpos[-1];
	  firstpos += nfirstpos[-1];
	if (nullable[-1])
	  nlastpos[-2] += nlastpos[-1];
	    pos = lastpos + nlastpos[-2];
	    for (j = nlastpos[-1] - 1; j >= 0; --j)
	    lastpos += nlastpos[-2];
	    nlastpos[-2] = nlastpos[-1];
	nullable[-2] = nullable[-1] && nullable[-2];
	nfirstpos[-2] += nfirstpos[-1];
	nlastpos[-2] += nlastpos[-1];
	nullable[-2] = nullable[-1] || nullable[-2];
	*nfirstpos++ = *nlastpos++ = 1;
	nalloc[i] = 1;
      fprintf(stderr, nullable[-1] ? " nullable: yes\n" : " nullable: no\n");
      for (j = nfirstpos[-1] - 1; j >= 0; --j)
      for (j = nlastpos[-1] - 1; j >= 0; --j)
  for (i = 0; i < d->tindex; ++i)
	for (j = d->follows[i].nelem - 1; j >= 0; --j)
     be the set of positions of state 0. */
  merged.nelem = 0;
  for (i = 0; i < nfirstpos[-1]; ++i)
  /* Check if any of the positions of state 0 will want newline context. */
  wants_newline = 0;
  for (i = 0; i < merged.nelem; ++i)
      wants_newline = 1;
  d->salloc = 1;
  d->sindex = 0;
  state_index(d, &merged, wants_newline, 0);
   0 in every state.
  int ngrps = 0;		/* Number of groups actually used. */
      initialized = 1;
      for (i = 0; i < NOTCHAR; ++i)
  for (i = 0; i < d->states[s].elems.nelem; ++i)
      if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR)
      if (pos.constraint != 0xFF)
					 d->states[s].newline, 1))
					 d->states[s].newline, 0))
	    for (j = 0; j < CHARCLASS_INTS; ++j)
					d->states[s].letter, 1))
	    for (j = 0; j < CHARCLASS_INTS; ++j)
					d->states[s].letter, 0))
	    for (j = 0; j < CHARCLASS_INTS; ++j)
	  for (j = 0; j < CHARCLASS_INTS && !matches[j]; ++j)
      for (j = 0; j < ngrps; ++j)
	  if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR
	  intersectf = 0;
	  for (k = 0; k < CHARCLASS_INTS; ++k)
	    (intersect[k] = matches[k] & labels[j][k]) ? intersectf = 1 : 0;
	  leftoversf = matchesf = 0;
	  for (k = 0; k < CHARCLASS_INTS; ++k)
	      (leftovers[k] = ~match & label) ? leftoversf = 1 : 0;
	      (matches[k] = match & ~label) ? matchesf = 1 : 0;
	  grps[ngrps].nelem = 1;
	  grps[ngrps].elems[0] = pos;
     containing the positions of state 0, otherwise the default transition
      wants_newline = 0;
      wants_letter = 0;
      for (i = 0; i < d->states[0].elems.nelem; ++i)
	  if (PREV_NEWLINE_DEPENDENT(d->states[0].elems.elems[i].constraint))
	    wants_newline = 1;
	  if (PREV_LETTER_DEPENDENT(d->states[0].elems.elems[i].constraint))
	    wants_letter = 1;
      copy(&d->states[0].elems, &follows);
      state = state_index(d, &follows, 0, 0);
	state_newline = state_index(d, &follows, 1, 0);
	state_letter = state_index(d, &follows, 0, 1);
      for (i = 0; i < NOTCHAR; ++i)
    for (i = 0; i < NOTCHAR; ++i)
      trans[i] = -1;
  for (i = 0; i < ngrps; ++i)
      follows.nelem = 0;
      for (j = 0; j < grps[i].nelem; ++j)
	for (k = 0; k < d->follows[grps[i].elems[j].index].nelem; ++k)
	 of state 0 as well. */
	for (j = 0; j < d->states[0].elems.nelem; ++j)
	  insert(d->states[0].elems.elems[j], &follows);
      wants_newline = 0;
	for (j = 0; j < follows.nelem; ++j)
	    wants_newline = 1;
      wants_letter = 0;
      for (j = 0; j < CHARCLASS_INTS; ++j)
	for (j = 0; j < follows.nelem; ++j)
	    wants_letter = 1;
      state = state_index(d, &follows, 0, 0);
	state_newline = state_index(d, &follows, 1, 0);
	state_letter = state_index(d, &follows, 0, 1);
      for (j = 0; j < CHARCLASS_INTS; ++j)
	for (k = 0; k < INTBITS; ++k)
	  if (labels[i][j] & 1 << k)
  for (i = 0; i < ngrps; ++i)
     exist at once.  1024 is arbitrary.  The idea is that the frequently
  if (d->trcount >= 1024)
      for (i = 0; i < d->tralloc; ++i)
      d->trcount = 0;
  d->success[s] = 0;
  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 1, d->states[s].letter, 0,
    d->success[s] |= 4;
  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 0, d->states[s].letter, 1,
    d->success[s] |= 2;
  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 0, d->states[s].letter, 0,
    d->success[s] |= 1;
  for (i = 0; i < NOTCHAR; ++i)
	  d->tralloc *= 2;
	REALLOC(d->realtrans, int *, d->tralloc + 1);
	d->trans = d->realtrans + 1;
  trans['\n'] = -1;
  d->tralloc = 1;
  d->trcount = 0;
  CALLOC(d->realtrans, int *, d->tralloc + 1);
  d->trans = d->realtrans + 1;
  build_state(0, d);
   where we're supposed to store a 1 if backreferencing happened and the
   we store a 0 in *backref. */
  register s, s1, tmp;		/* Current state. */
      sbit_init = 1;
      for (i = 0; i < NOTCHAR; ++i)
	  sbit[i] = 4;
	  sbit[i] = 2;
	  sbit[i] = 1;
  s = s1 = 0;
      if ((t = trans[s]) != 0)
	    s1 = t[*p++];
	    if (! (t = trans[s1]))
        while ((t = trans[s]) != 0);
      goto last_was_s1;
      tmp = s, s = s1, s1 = tmp;
    last_was_s1:
      if (s >= 0 && p <= (unsigned char *) end && d->fails[s])
		  *backref = 1;
		  *backref = 0;
	  s1 = s;
      if (count && (char *) p <= end && p[-1] == '\n')
      if (s >= 0)
      if (p[-1] == '\n' && newline)
	  s = d->newlines[s1];
      s = 0;
  d->calloc = 1;
  d->cindex = 0;
  d->talloc = 1;
  d->tindex = d->depth = d->nleaves = d->nregexps = 0;
  d->searchflag = 0;
  d->tralloc = 0;
  d->musts = 0;
      case_fold = 0;
      for (i = 0; i < len; ++i)
      d->cindex = d->tindex = d->depth = d->nleaves = d->nregexps = 0;
      case_fold = 1;
  for (i = 0; i < d->sindex; ++i)
  for (i = 0; i < d->tindex; ++i)
  for (i = 0; i < d->tralloc; ++i)
  newsize = (new == NULL) ? 0 : strlen(new);
    oldsize = 0;
  else if (newsize == 0)
    result = (char *) malloc(newsize + 1);
    result = (char *) realloc((void *) old, oldsize + newsize + 1);
  for (cp = lookin; *cp != '\0'; ++cp)
    if (strncmp(cp, lookfor, len) == 0)
  for (i = 0; cpp[i] != NULL; ++i)
  new[len] = '\0';
  for (i = 0; cpp[i] != NULL; ++i)
  j = 0;
  cpp = (char **) realloc((char *) cpp, (i + 2) * sizeof *cpp);
  cpp[i + 1] = NULL;
  cpp[0] = NULL;
  for (lcp = left; *lcp != '\0'; ++lcp)
      len = 0;
	  for (i = 1; lcp[i] != '\0' && lcp[i] == rcp[i]; ++i)
	  rcp = index(rcp + 1, *lcp);
      if (len == 0)
  for (i = 0; new[i] != NULL; ++i)
  both[0] = NULL;
  for (lnum = 0; left[lnum] != NULL; ++lnum)
      for (rnum = 0; right[rnum] != NULL; ++rnum)
  mp->left[0] = mp->right[0] = mp->is[0] = '\0';
  static must must0;
  exact = 0;
  musts = (must *) malloc((dfa->tindex + 1) * sizeof *musts);
  for (i = 0; i <= dfa->tindex; ++i)
    mp[i] = must0;
  for (i = 0; i <= dfa->tindex; ++i)
      mp[i].left = malloc(2);
      mp[i].right = malloc(2);
      mp[i].is = malloc(2);
      mp[i].left[0] = mp[i].right[0] = mp[i].is[0] = '\0';
      mp[i].in[0] = NULL;
  for (i = 0; i < dfa->tindex; ++i)
  for (ri = 0; ri < dfa->tindex; ++ri)
	  if (mp < &musts[2])
	    if (strcmp(lmp->is, rmp->is) != 0)
	      lmp->is[0] = '\0';
	    i = 0;
	    while (lmp->left[i] != '\0' && lmp->left[i] == rmp->left[i])
	    lmp->left[i] = '\0';
	    for (i = 0; i < n; ++i)
	      if (lmp->right[ln - i - 1] != rmp->right[rn - i - 1])
	    for (j = 0; j < i; ++j)
	    lmp->right[j] = '\0';
	  mp->is[0] = '\0';
	  if (mp != &musts[1])
	  for (i = 0; musts[0].in[i] != NULL; ++i)
	    if (strlen(musts[0].in[i]) > strlen(result))
	      result = musts[0].in[i];
	  if (strcmp(result, musts[0].is) == 0)
	    exact = 1;
	  if (mp < &musts[2])
	    if (lmp->right[0] != '\0' &&
		rmp->left[0] != '\0')
	    if (lmp->is[0] != '\0')
	    if (rmp->is[0] == '\0')
	      lmp->right[0] = '\0';
	    if (lmp->is[0] != '\0' && rmp->is[0] != '\0')
	      lmp->is[0] = '\0';
	  else if (t == '\0')
	      mp->is[0] = mp->left[0] = mp->right[0] = t;
	      mp->is[1] = mp->left[1] = mp->right[1] = '\0';
	      mp->in = enlist(mp->in, mp->is, 1);
      for (i = 0; mp->in[i]; ++i)
      dm->must = malloc(strlen(result) + 1);
  for (i = 0; i <= dfa->tindex; ++i)
   Copyright 1989 Free Software Foundation
		  Written August 1989 by Mike Haertel.
   the Free Software Foundation; either version 1, or (at your option)
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   IBM-Germany, Scientific Center Heidelberg, Tiergartenstrasse 15, D-6900
   String Matching:  An Aid to Bibliographic Search," CACM June 1975,
   Vol. 18, No. 6, which describes the failure function used below. */
#define flag_limits 1
#if flag_stdlib==0 
#define flag_stdlib 1
#define INT_MAX 2147483647
#define UCHAR_MAX 255
#if flag_systypes==0
#define flag_systypes 1
#if flag_string==0
#define flag_string 1
#if flag_memory==0
#define flag_memory 1
#define NCHAR (UCHAR_MAX + 1)
  int mind2;			/* Used in Boyer-Moore search for one string. */
    return 0;
  kwset->words = 0;
      return 0;
  kwset->trie->accepting = 0;
  kwset->trie->links = 0;
  kwset->trie->parent = 0;
  kwset->trie->next = 0;
  kwset->trie->fail = 0;
  kwset->trie->depth = 0;
  kwset->trie->shift = 0;
  kwset->maxd = -1;
  kwset->target = 0;
  struct tree *links[12];
  enum { L, R } dirs[12];
      links[0] = (struct tree *) &trie->links;
      dirs[0] = L;
      depth = 1;
	  link->llink = 0;
	  link->rlink = 0;
	  link->trie->accepting = 0;
	  link->trie->links = 0;
	  link->trie->next = 0;
	  link->trie->fail = 0;
	  link->trie->depth = trie->depth + 1;
	  link->trie->shift = 0;
	  link->balance = 0;
		case (char) -2:
		  switch (dirs[depth + 1])
		      t->balance = r->balance = 0;
		      l->balance = t->balance != 1 ? 0 : -1;
		      r->balance = t->balance != (char) -1 ? 0 : 1;
		      t->balance = 0;
		case 2:
		  switch (dirs[depth + 1])
		      t->balance = l->balance = 0;
		      l->balance = t->balance != 1 ? 0 : -1;
		      r->balance = t->balance != (char) -1 ? 0 : 1;
		      t->balance = 0;
	      if (dirs[depth - 1] == L)
		links[depth - 1]->llink = t;
		links[depth - 1]->rlink = t;
    trie->accepting = 1 + 2 * kwset->words;
  return 0;
    return 1;
    return 0;
    return 0;
  if (kwset->mind < 256)
    for (i = 0; i < NCHAR; ++i)
    for (i = 0; i < NCHAR; ++i)
      delta[i] = 255;
  if (kwset->words == 1 && kwset->trans == 0)
      for (i = kwset->mind - 1, curr = kwset->trie; i >= 0; --i)
      for (i = 0; i < kwset->mind; ++i)
	delta[(unsigned char) kwset->target[i]] = kwset->mind - (i + 1);
      kwset->mind2 = kwset->mind;
      /* Find the minimal delta2 shift that we might make after
      for (i = 0; i < kwset->mind - 1; ++i)
	if (kwset->target[i] == kwset->target[kwset->mind - 1])
	  kwset->mind2 = kwset->mind - (i + 1);
      for (i = 0; i < NCHAR; ++i)
	next[i] = 0;
      if ((trans = kwset->trans) != 0)
	for (i = 0; i < NCHAR; ++i)
	for (i = 0; i < NCHAR; ++i)
  if ((trans = kwset->trans) != 0)
    for (i = 0; i < NCHAR; ++i)
    for (i = 0; i < NCHAR; ++i)
  return 0;
  register unsigned char *d1;
  register int d, gc, i, len, md2;
  if (len == 0)
    return 0;
  if (len == 1)
    return memchr(text, kwset->target[0], size);
  d1 = kwset->delta;
  gc = U(sp[-2]);
  md2 = kwset->mind2;
  /* Significance of 12: 1 (initial offset) + 10 (skip loop) + 1 (md2). */
  if (size > 12 * len)
    /* 11 is not a bug, the initial offset happens only once. */
    for (ep = text + size - 11 * len;;)
	    d = d1[U(tp[-1])], tp += d;
	    d = d1[U(tp[-1])], tp += d;
	    if (d == 0)
	    d = d1[U(tp[-1])], tp += d;
	    d = d1[U(tp[-1])], tp += d;
	    d = d1[U(tp[-1])], tp += d;
	    if (d == 0)
	    d = d1[U(tp[-1])], tp += d;
	    d = d1[U(tp[-1])], tp += d;
	    d = d1[U(tp[-1])], tp += d;
	    if (d == 0)
	    d = d1[U(tp[-1])], tp += d;
	    d = d1[U(tp[-1])], tp += d;
	if (U(tp[-2]) == gc)
	    for (i = 3; i <= len && U(tp[-i]) == U(sp[-i]); ++i)
	tp += md2;
  d = d1[U(tp[-1])];
      d = d1[U((tp += d)[-1])];
      if (d != 0)
      if (tp[-2] == gc)
	  for (i = 3; i <= len && U(tp[-i]) == U(sp[-i]); ++i)
      d = md2;
  return 0;
    return 0;
  if ((d = kwset->mind) != 0)
    mch = 0;
  if (len >= 4 * kwset->mind)
    qlim = lim - 4 * kwset->mind;
    qlim = 0;
	  end += d - 1;
	d = delta[c = (end += d)[-1]];
      beg = end - 1;
  return 0;
  lmch = 0;
  d = 1;
      if ((d = delta[c = (end += d)[-1]]) != 0)
      beg = end - 1;
	  d = 1;
	d = 1;
      kwsmatch->index = accept->accepting / 2;
      kwsmatch->beg[0] = mch;
      kwsmatch->size[0] = accept->depth;
  if (kwset->words == 1 && kwset->trans == 0)
      if (kwsmatch != 0 && ret != 0)
	  kwsmatch->index = 0;
	  kwsmatch->beg[0] = ret;
	  kwsmatch->size[0] = kwset->mind;
  obstack_free(&kwset->obstack, 0);
   Copyright (C) 1988, 1993 Free Software Foundation, Inc.
Free Software Foundation; either version 2, or (at your option) any
Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
  ((PTR_INT_TYPE) ((char *)&((struct fooalign *) 0)->d - (char *)0))
  } while (0)
/* Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).
   Objects start on multiples of ALIGNMENT (0 means use default).
  if (alignment == 0)
  if (size == 0)
    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
	 and we used a larger request, a whole extra 4096 bytes would be
      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
		    + 4 + DEFAULT_ROUNDING - 1)
		   & ~(DEFAULT_ROUNDING - 1));
      size = 4096 - extra;
  h->alignment_mask = alignment - 1;
  h->use_extra_arg = 0;
  chunk->prev = 0;
  h->maybe_empty_object = 0;
_obstack_begin_1 (h, size, alignment, chunkfun, freefun, arg)
  if (alignment == 0)
  if (size == 0)
    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
	 and we used a larger request, a whole extra 4096 bytes would be
      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
		    + 4 + DEFAULT_ROUNDING - 1)
		   & ~(DEFAULT_ROUNDING - 1));
      size = 4096 - extra;
  h->alignment_mask = alignment - 1;
  h->use_extra_arg = 1;
  chunk->prev = 0;
  h->maybe_empty_object = 0;
  new_size = (obj_size + length) + (obj_size >> 3) + 100;
  if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)
      for (i = obj_size / sizeof (COPYING_UNIT) - 1;
	   i >= 0; i--)
    already = 0;
  h->maybe_empty_object = 0;
  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
  return lp != 0;
  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
      h->maybe_empty_object = 1;
  else if (obj != 0)
  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
      h->maybe_empty_object = 1;
  else if (obj != 0)
#if 0
void (obstack_grow0) (obstack, pointer, length)
  obstack_grow0 (obstack, pointer, length);
void (obstack_1grow) (obstack, character)
  obstack_1grow (obstack, character);
void (obstack_1grow_fast) (obstack, character)
  obstack_1grow_fast (obstack, character);
POINTER (obstack_copy0) (obstack, pointer, length)
  return obstack_copy0 (obstack, pointer, length);
#endif /* 0 */
   Copyright (C) 1992 Free Software Foundation, Inc.
   the Free Software Foundation; either version 2, or (at your option)
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   Written August 1992 by Mike Haertel. */
#if flag_limits==0
#define flag_limits 1
#if flag_stdlib==0
#define flag_stdlib 1
#define UCHAR_MAX 255
#if flag_systypes==0
#define flag_systypes 1
#if flag_string==0
#define flag_string 1
#if flag_memory==0
#define flag_memory 1
#define NCHAR (UCHAR_MAX + 1)
  { 0, 0, 0 },
static struct dfa dfa_1;
  fatal(mesg, 0);
    for (i = 0; i < NCHAR; ++i)
  if (!(kwset = kwsalloc(match_icase ? trans : (char *) 0)))
    fatal("memory exhausted", 0);
  if (dfa_1.musts)
      for (dm = dfa_1.musts; dm; dm = dm->next)
	  if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0)
	    fatal(err, 0);
      for (dm = dfa_1.musts; dm; dm = dm->next)
	  if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0)
	    fatal(err, 0);
      if ((err = kwsprep(kwset)) != 0)
	fatal(err, 0);
  if ((err = re_compile_pattern(pattern, size, &regex)) != 0)
    fatal(err, 0);
  dfainit(&dfa_1);
      char *n = malloc(size + 50);
      int i = 0;
	strcpy(n, "\\(^\\|[^0-9A-Za-z_]\\)\\(");
	strcpy(n + i, "\\)\\([^0-9A-Za-z_]\\|$\\)");
      dfacomp(n, i, &dfa_1, 1);
    dfacomp(pattern, size, &dfa_1, 1);
  if (strcmp(matcher, "posix-egrep") == 0)
  if ((err = re_compile_pattern(pattern, size, &regex)) != 0)
    fatal(err, 0);
  dfainit(&dfa_1);
      char *n = malloc(size + 50);
      int i = 0;
	strcpy(n, "(^|[^0-9A-Za-z_])(");
	strcpy(n + i, ")([^0-9A-Za-z_]|$)");
      dfacomp(n, i, &dfa_1, 1);
    dfacomp(pattern, size, &dfa_1, 1);
  for (beg = end = buf; end < buflim; beg = end + 1)
	  while (beg > buf && beg[-1] != '\n')
	  if (!dfaexec(&dfa_1, beg, end, 0, (int *) 0, &backref))
	  beg = dfaexec(&dfa_1, beg, buflim, 0, (int *) 0, &backref);
	  while (beg > buf && beg[-1] != '\n')
      regex.not_eol = 0;
      if ((start = re_search(&regex, beg, end - beg, 0, end - beg, &regs)) >= 0)
	  len = regs.end[0] - start;
	    while (start >= 0)
		if ((start == 0 || !WCHAR(beg[start - 1]))
		if (len > 0)
		    regex.not_eol = 1;
		if (len <= 0)
		    regex.not_eol = 0;
		    len = regs.end[0] - start;
  return 0;
  *endp = end < buflim ? end + 1 : end;
      if ((err = kwsincr(kwset, beg, lim - beg)) != 0)
	fatal(err, 0);
  if ((err = kwsprep(kwset)) != 0)
    fatal(err, 0);
	return 0;
      len = kwsmatch.size[0];
	  if (beg > buf && beg[-1] != '\n')
	    if (try > buf && WCHAR((unsigned char) try[-1]))
		len = kwsmatch.size[0];
  return 0;
  if ((end = memchr(beg + len, '\n', (buf + size) - (beg + len))) != 0)
  while (beg > buf && beg[-1] != '\n')
3if gout
3eif agout end = buf + size;
3if goutfvf
3eif agoutvf end = buf + size;
