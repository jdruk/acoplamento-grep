   Copyright (C) 1992 Free Software Foundation, Inc.
   the Free Software Foundation; either version 2, or (at your option)
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   Written July 1992 by Mike Haertel.  */
#define GREP 1
#define STDC_HEADERS 1
#define HAVE_STRING_H 1
#define HAVE_SYS_PARAM_H 1
#define HAVE_UNISTD_H 1
#define HAVE_ALLOCA_H 1
#define HAVE_GETPAGESIZE 1
#define HAVE_MEMCHR 1
#define HAVE_STRERROR 1
#define HAVE_VALLOC 1
#define HAVE_WORKING_MMAP 1
#define flag_stdlib 1
#define flag_systypes 1
#define flag_string 1
#define flag_memory 1
#define flag_strings 1
#define flag_systypes 1
  errseen = 1;
  exit(2);
#define flag_systypes 1
      initialized = 1;
      bufsalloc = MAX(8192, getpagesize());
      /* The 1 byte of overflow is a kludge for dfaexec(), which
      buffer = valloc(bufalloc + 1);
      bufmapped = 1;
      bufoffset = lseek(fd, 0, 1);
	bufsalloc *= 2;
      nbuffer = valloc(bufalloc + 1);
      if (maddr == (caddr_t) -1)
	 but it doesn't, at least not on a Sun running 4.1.
  fwrite(beg, 1, lim - beg, stdout);
	  while (p > bp && p[-1] != '\n');
	  prline(p, nl + 1, '-');
	  p = nl + 1;
  used = 1;
      if (b == lim && ((b > beg && b[-1] == '\n') || b == beg))
	  nlines += 1;
      for (lim = buflim; lim > beg && lim[-1] != '\n'; --lim)
	  while (beg > bufbeg && beg[-1] != '\n');
static char version[] = "GNU grep version 2.0";
  exit(2);
   If we find it, install it in compile and execute, and return 1.  */
	return 1;
    prog = strrchr(prog, '/') + 1;
  while ((opt = getopt(argc, argv, "0123456789A:B:CEFGVX:bce:f:hiLlnqsvwxy"))
      case '1':
      case '2':
	out_before = 10 * out_before + opt - '0';
	out_after = 10 * out_after + opt - '0';
	out_before = out_after = 2;
	out_byte = 1;
	out_quiet = 1;
	count_matches = 1;
	keys = xrealloc(keys, keycc + cc + 1);
	keyfound = 1;
	for (keyalloc = 1; keyalloc <= keycc; keyalloc *= 2)
	       && (cc = fread(keys + keycc, 1, keyalloc - keycc, fp)) > 0)
	      keys = xrealloc(keys, keyalloc *= 2);
	if (keycc - oldcc > 0 && keys[keycc - 1] == '\n')
	keyfound = 1;
	no_filenames = 1;
	match_icase = 1;
	out_quiet = 1;
	list_files = -1;
	out_quiet = 1;
	list_files = 1;
	out_line = 1;
	out_quiet = 1;
	suppress_errors = 1;
	out_invert = 1;
	match_words = 1;
	match_lines = 1;
  if (argc - optind > 1 && !no_filenames)
    out_file = 1;
  status = 1;
		if (list_files == 1)
	    else if (list_files == -1)
	  if (list_files == 1)
      else if (list_files == -1)
  exit(errseen ? 2 : status);
   Copyright (C) 1987, 88, 89, 90, 91, 92, 1993
   Free Software Foundation; either version 2, or (at your option) any
   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
#define flag_config 1
#define flag_alloca 1
/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.  */
#define flag_stdlib 1
   long-named option.  Because this is not POSIX.2 compliant, it is
/* XXX 1003.2 says this must be 1 before any call.  */
int opterr = 1;
   as if it were the argument of an option with character code 1.
#define flag_string 1
     Start processing options with ARGV-element 1 (since ARGV-element 0
      first_nonopt = last_nonopt = optind = 1;
		 && (argv[optind][0] != '-' || argv[optind][1] == '\0')
		     || argv[optind][0] != '+' || argv[optind][1] == '\0')
      if ((argv[optind][0] != '-' || argv[optind][1] == '\0')
	      || argv[optind][0] != '+' || argv[optind][1] == '\0')
	  return 1;
      nextchar = (argv[optind] + 1
		  + (longopts != NULL && argv[optind][1] == '-'));
	   && (argv[optind][1] == '-' || long_only))
		exact = 1;
	      ambig = 1;
		optarg = s + 1;
		      if (argv[optind - 1][1] == '-')
			     argv[0], argv[optind - 1][0], pfound->name);
	  else if (pfound->has_arg == 1)
			     argv[0], argv[optind - 1]);
      if (!long_only || argv[optind][1] == '-'
	      if (argv[optind][1] == '-')
	    if (c < 040 || c >= 0177)
	    /* 1003.2 specifies the format of this message.  */
    if (temp[1] == ':')
	if (temp[2] == ':')
		    /* 1003.2 specifies the format of this message.  */
  while (1)
      int this_option_optind = optind ? optind : 1;
      c = getopt (argc, argv, "abc:d:0123456789");
	case '1':
	case '2':
   version 0.12.
   (Implements POSIX draft P10003.2/D11.2, except for
   Copyright (C) 1993 Free Software Foundation, Inc.
   the Free Software Foundation; either version 2, or (at your option)
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
#define flag_systypes 1
#define flag_config 1
#define flag_string 1
#define bcmp(s1, s2, n)	memcmp ((s1), (s2), (n))
#define flag_strings 1
#define flag_stdlib 1
   commands in re_match_2.  */
#define Sword 1
#define CHAR_SET_SIZE 256
   done = 1;
   Defining isascii to 1 should let any compiler worth its salt
#define isascii(c) 1
#define SIGN_EXTEND_CHAR(c) ((((unsigned char) (c)) ^ 128) - 128)
#define flag_alloca 1
/* True if `size1' is non-NULL and PTR is pointing anywhere inside
   `string1' or just past its end.  This works if PTR is NULL, which is
  (size1 && string1 <= (ptr) && (ptr) <= string1 + size1)
#define STREQ(s1, s2) ((strcmp (s1, s2) == 0))
#define true 1
   So regex.h defines a symbol `RE_EXACTN_VALUE' to be 1; the value of
   `exactn' we use here must also be 1.  */
  exactn = 1,
           bit is 1.  A character too large to have a bit in the map is
           of re_match_2.)  */
    (destination)[1] = (number) >> 8;					\
    (destination) += 2;							\
    (destination) += SIGN_EXTEND_CHAR (*((source) + 1)) << 8;		\
  int temp = SIGN_EXTEND_CHAR (*(source + 1)); 
    (source) += 2; 							\
  *source += 2;
#define DEBUG_PRINT1(x) if (debug) printf (x)
#define DEBUG_PRINT2(x1, x2) if (debug) printf (x1, x2)
#define DEBUG_PRINT3(x1, x2, x3) if (debug) printf (x1, x2, x3)
#define DEBUG_PRINT4(x1, x2, x3, x4) if (debug) printf (x1, x2, x3, x4)
#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)			\
  if (debug) print_double_string (w, s1, sz1, s2, sz2)
  while (i < (1 << BYTEWIDTH))
          printchar (i - 1);
          while (i < (1 << BYTEWIDTH)  &&  fastmap[i])
              was_a_range = 1;
              printchar (i - 1);
  int mcnt, mcnt2;
            register int c, last = -100;
	            (re_opcode_t) *(p - 1) == charset_not ? "^" : "");
            for (c = 0; c < 256; c++)
		  && (p[1 + (c/8)] & (1 << (c % 8))))
		  if (last + 1 == c && ! in_range)
		      in_range = 1;
		  else if (last + 1 != c && in_range)
	    p += 1 + *p;
          extract_number_and_incr (&mcnt2, &p);
	  printf ("/succeed_n to %d, %d times", p + mcnt - start, mcnt2);
          extract_number_and_incr (&mcnt2, &p);
	  printf ("/jump_n to %d, %d times", p + mcnt - start, mcnt2);
          extract_number_and_incr (&mcnt2, &p);
	  printf ("/set_number_at location %d to %d", p + mcnt - start, mcnt2);
          printf ("?%d", *(p-1));
print_double_string (where, string1, size1, string2, size2)
    const char *string1;
    const char *string2;
    int size1;
    int size2;
          for (this_char = where - string1; this_char < size1; this_char++)
            printchar (string1[this_char]);
          where = string2;    
      for (this_char = where - string2; this_char < size2; this_char++)
        printchar (string2[this_char]);
#define DEBUG_PRINT1(x)
#define DEBUG_PRINT2(x1, x2)
#define DEBUG_PRINT3(x1, x2, x3)
#define DEBUG_PRINT4(x1, x2, x3, x4)
#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)
static void store_op1 (), store_op2 ();
static void insert_op1 (), insert_op2 ();
#define INIT_BUF_SIZE  32
    GET_BUFFER_SPACE (1);						\
/* Ensure we have two more bytes of buffer space and then append C1 and C2.  */
#define BUF_PUSH_2(c1, c2)						\
    GET_BUFFER_SPACE (2);						\
    *b++ = (unsigned char) (c1);					\
    *b++ = (unsigned char) (c2);					\
/* As with BUF_PUSH_2, except for three bytes.  */
#define BUF_PUSH_3(c1, c2, c3)						\
    *b++ = (unsigned char) (c1);					\
    *b++ = (unsigned char) (c2);					\
  store_op1 (op, loc, (to) - (loc) - 3)
#define STORE_JUMP2(op, loc, to, arg) \
  store_op2 (op, loc, (to) - (loc) - 3, arg)
  insert_op1 (op, loc, (to) - (loc) - 3, b)
/* Like `STORE_JUMP2', but for inserting.  Assume `b' is the buffer end.  */
#define INSERT_JUMP2(op, loc, to, arg) \
  insert_op2 (op, loc, (to) - (loc) - 3, arg, b)
   into the pattern are two bytes long.  So if 2^16 bytes turns out to
#define MAX_BUF_SIZE (1L << 16)
    bufp->allocated <<= 1;						\
#define MAX_REGNUM 255
   be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
#define INIT_COMPILE_STACK_SIZE 32
   |= 1 << (((unsigned char) c) % BYTEWIDTH))
           num = num * 10 + c - '0'; 					\
  register unsigned char c, c1;
  const char *p1;
  DEBUG_PRINT1 ("\nCompiling pattern: ");
                   p == pattern + 1
            /* 1 means zero (many) matches is allowed.  */
               interval operators with these because of, e.g., `a{2}*',
                    PATFETCH (c1);
                    if (!(c1 == '+' || c1 == '?'))
                    c = c1;
                assert (p - 1 > pattern);
                if (TRANSLATE (*(p - 2)) == TRANSLATE ('.')
            p1 = p;
            BUF_PUSH ((1 << BYTEWIDTH) / BYTEWIDTH);
            bzero (b, (1 << BYTEWIDTH) / BYTEWIDTH);
            if ((re_opcode_t) b[-2] == charset_not
                    PATFETCH (c1);
                    SET_LIST_BIT (c1);
                if (c == ']' && p != p1 + 1)
                    && !(p - 2 >= pattern && p[-2] == '[') 
                    && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^')
                else if (p[0] == '-' && p[1] != ']')
                    PATFETCH (c1);
                    char str[CHAR_CLASS_MAX_LENGTH + 1];
                    c1 = 0;
                            || c1 == CHAR_CLASS_MAX_LENGTH)
                        str[c1++] = c;
                    str[c1] = '\0';
                        for (ch = 0; ch < 1 << BYTEWIDTH; ch++)
                        c1++;
                        while (c1--)    
            while ((int) b[-1] > 0 && b[b[-1] - 1] == 0) 
              b[-1]--; 
            b += b[-1];
                  RETALLOC (compile_stack.stack, compile_stack.size << 1,
                  compile_stack.size <<= 1;
                = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
                  COMPILE_STACK_TOP.inner_group_offset = b - bufp->buffer + 2;
                     `push_dummy_failure' in `re_match_2'.  */
                  STORE_JUMP (jump_past_alt, fixup_alt_jump, b - 1);
                   as in `(ab)c(de)' -- the second group is #2.  */
                    ? bufp->buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1 
                  || (p - 2 == pattern  &&  p == pend))
                int lower_bound = -1, upper_bound = -1;
                beg_interval = p - 1;
                  /* Interval such as `{1}' => match exactly once. */
                    `upper_bound' is 1, though.)  */
                   { /* If the upper bound is > 1, we need to insert
                     unsigned nbytes = 10 + (upper_bound > 1) * 10;
                     INSERT_JUMP2 (succeed_n, laststart,
                                   b + 5 + (upper_bound > 1) * 5,
                     insert_op2 (set_number_at, laststart, 5, lower_bound, b);
                     if (upper_bound > 1)
                            jump back only `upper_bound - 1' times.  */
                         STORE_JUMP2 (jump_n, b, laststart + 5,
                                      upper_bound - 1);
                            parameter of the `jump_n'; that is `b-2' as
                            Conclusion: (b - 2) - (laststart + 3) + 5,
                         insert_op2 (set_number_at, laststart, b - laststart,
                                     upper_bound - 1, b);
                   if (p > pattern  &&  p[-1] == '\\')
              BUF_PUSH_2 (syntaxspec, syntax_spec_code[c]);
              BUF_PUSH_2 (notsyntaxspec, syntax_spec_code[c]);
            case '1': case '2': case '3': case '4': case '5':
              c1 = c - '0';
              if (c1 > regnum)
              if (group_in_compile_stack (compile_stack, c1))
              BUF_PUSH_2 (duplicate, c1);
              || pending_exact + *pending_exact + 1 != b
	      || *pending_exact == (1 << BYTEWIDTH) - 1
		  ? *p == '\\' && (p[1] == '+' || p[1] == '?')
                      : (p[0] == '\\' && p[1] == '{'))))
	      BUF_PUSH_2 (exactn, 0);
	      pending_exact = b - 1;
      DEBUG_PRINT1 ("\nCompiled pattern: \n");
store_op1 (op, loc, arg)
  STORE_NUMBER (loc + 1, arg);
/* Like `store_op1', but" for 'two two-byte parameters ARG1 and ARG2.  */
store_op2 (op, loc, arg1, arg2)
    int arg1, arg2;
  STORE_NUMBER (loc + 1, arg1);
  STORE_NUMBER (loc + 3, arg2);
insert_op1 (op, loc, arg, end)
  store_op1 (op, loc, arg);
/* Like `insert_op1', but for two two-byte parameters ARG1 and ARG2.  */
insert_op2 (op, loc, arg1, arg2, end)
    int arg1, arg2;
  store_op2 (op, loc, arg1, arg2);
  const char *prev = p - 2;
  boolean prev_prev_backslash = prev > pattern && prev[-1] == '\\';
  const char *next_next = p + 1 < pend ? p + 1 : NULL;
  for (this_element = compile_stack.avail - 1;  
   starting character is in `P[-2]'.  (`P[-1]' is the character `-'.)
  range_start = ((unsigned char *) p)[-2];
   re_match_2 use a failure stack.  These have to be macros because of
int re_max_failures = 2000;
/* Initialize `fail_stack'.  Do `return -2' if the alloc fails.  */
      return -2;							\
   Return 1 if succeeds, and 0 if either ran out of memory
          ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),	\
      : ((fail_stack).size <<= 1, 					\
         1)))
   Return 1 if was able to do so and 0 if ran out of memory allocating
       1))
       of 0 + -1 isn't done as unsigned.  */				\
    DEBUG_PRINT2 ("\nPUSH_FAILURE_POINT #%u:\n", failure_id);		\
    DEBUG_PRINT2 ("  Before push, next avail: %d\n", (fail_stack).avail);\
    DEBUG_PRINT2 ("                     size: %d\n", (fail_stack).size);\
    DEBUG_PRINT2 ("  slots needed: %d\n", NUM_FAILURE_ITEMS);		\
    DEBUG_PRINT2 ("     available: %d\n", REMAINING_AVAIL_SLOTS);	\
        DEBUG_PRINT2 ("\n  Doubled stack; size now: %d\n",		\
        DEBUG_PRINT2 ("  slots available: %d\n", REMAINING_AVAIL_SLOTS);\
    DEBUG_PRINT1 ("\n");						\
	DEBUG_PRINT2 ("  Pushing reg: %d\n", this_reg);			\
	DEBUG_PRINT2 ("    start: 0x%x\n", regstart[this_reg]);		\
	DEBUG_PRINT2 ("    end: 0x%x\n", regend[this_reg]);		\
	DEBUG_PRINT2 ("    info: 0x%x\n      ", reg_info[this_reg]);	\
        DEBUG_PRINT2 (" match_null=%d",					\
        DEBUG_PRINT2 (" active=%d", IS_ACTIVE (reg_info[this_reg]));	\
        DEBUG_PRINT2 (" matched_something=%d",				\
        DEBUG_PRINT2 (" ever_matched=%d",				\
	DEBUG_PRINT1 ("\n");						\
    DEBUG_PRINT2 ("  Pushing  low active reg: %d\n", lowest_active_reg);\
    DEBUG_PRINT2 ("  Pushing high active reg: %d\n", highest_active_reg);\
    DEBUG_PRINT2 ("  Pushing pattern 0x%x: ", pattern_place);		\
    DEBUG_PRINT2 ("  Pushing string 0x%x: `", string_place);		\
    DEBUG_PRINT_DOUBLE_STRING (string_place, string1, size1, string2,   \
				 size2);				\
    DEBUG_PRINT1 ("'\n");						\
    DEBUG_PRINT2 ("  Pushing failure id: %u\n", failure_id);		\
#define MAX_FAILURE_ITEMS ((num_regs - 1) * NUM_REG_ITEMS + NUM_NONREG_ITEMS)
  ((highest_active_reg - lowest_active_reg + 1) * NUM_REG_ITEMS 	\
   `pend', `string1', `size1', `string2', and `size2'.  */
  DEBUG_PRINT1 ("POP_FAILURE_POINT:\n");				\
  DEBUG_PRINT2 ("  Before pop, next avail: %d\n", fail_stack.avail);	\
  DEBUG_PRINT2 ("                    size: %d\n", fail_stack.size);	\
  DEBUG_PRINT2 ("  Popping failure id: %u\n", failure_id);		\
  DEBUG_PRINT2 ("  Popping string 0x%x: `", str);			\
  DEBUG_PRINT_DOUBLE_STRING (str, string1, size1, string2, size2);	\
  DEBUG_PRINT1 ("'\n");							\
  DEBUG_PRINT2 ("  Popping pattern 0x%x: ", pat);			\
  DEBUG_PRINT2 ("  Popping high active reg: %d\n", high_reg);		\
  DEBUG_PRINT2 ("  Popping  low active reg: %d\n", low_reg);		\
      DEBUG_PRINT2 ("    Popping reg: %d\n", this_reg);			\
      DEBUG_PRINT2 ("      info: 0x%x\n", reg_info[this_reg]);		\
      DEBUG_PRINT2 ("      end: 0x%x\n", regend[this_reg]);		\
      DEBUG_PRINT2 ("      start: 0x%x\n", regstart[this_reg]);		\
   BUFP.  A fastmap records which of the (1 << BYTEWIDTH) possible
   The caller must supply the address of a (1 << BYTEWIDTH)-byte data
   Returns 0 if we succeed, -2 if an internal error.   */
  bzero (fastmap, 1 << BYTEWIDTH);  /* Assume nothing's valid.  */
  bufp->fastmap_accurate = 1;	    /* It will be when we're done.  */
           `can_be_null' stops `re_search_2' from using the fastmap, so
	  bufp->can_be_null = 1;
          fastmap[p[1]] = 1;
          for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
	    if (p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH)))
              fastmap[j] = 1;
	  for (j = *p * BYTEWIDTH; j < (1 << BYTEWIDTH); j++)
            fastmap[j] = 1;
	  for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
	    if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))))
              fastmap[j] = 1;
	  for (j = 0; j < (1 << BYTEWIDTH); j++)
	      fastmap[j] = 1;
	  for (j = 0; j < (1 << BYTEWIDTH); j++)
	      fastmap[j] = 1;
	  for (j = 0; j < (1 << BYTEWIDTH); j++)
            fastmap[j] = 1;
	  for (j = 0; j < (1 << BYTEWIDTH); j++)
	      fastmap[j] = 1;
	  for (j = 0; j < (1 << BYTEWIDTH); j++)
	      fastmap[j] = 1;
	      && fail_stack.stack[fail_stack.avail - 1] == p)
                return -2;
            bufp->can_be_null = 1;
          p += 2;		
	  p += 2;
/* Like re_search_2, below, but only one string is specified, and
  return re_search_2 (bufp, NULL, 0, string, size, startpos, range, 
   virtual concatenation of STRING1 and STRING2, starting first at index
   STARTPOS, then at STARTPOS + 1, and so on.
   STRING1 and STRING2 have length SIZE1 and SIZE2, respectively.
   In REGS, return the indices of the virtual concatenation of STRING1
   and STRING2 that matched the entire BUFP->buffer and its contained
   concatenation of STRING1 and STRING2.
   found, -1 if no match, or -2 if error (such as failure
re_search_2 (bufp, string1, size1, string2, size2, startpos, range, regs, stop)
     const char *string1, *string2;
     int size1, size2;
  int total_size = size1 + size2;
    return -1;
     the virtual concatenation of STRING1 and STRING2.  */
  if (endpos < -1)
    range = -1 - startpos;
	return -1;
	range = 1;
    if (re_compile_fastmap (bufp) == -2)
      return -2;
              if (startpos < size1 && startpos + range >= size1)
                lim = range - (size1 - startpos);
	      d = (startpos >= size1 ? string2 - size1 : string1) + startpos;
	      register char c = (size1 == 0 || startpos >= size1
                                 ? string2[startpos - size1] 
                                 : string1[startpos]);
	return -1;
      val = re_match_2 (bufp, string1, size1, string2, size2,
      if (val == -2)
	return -2;
  return -1;
} /* re_search_2 */
/* Declarations and macros for re_match_2.  */
    unsigned match_null_string_p : 2;
    unsigned is_active : 1;
    unsigned matched_something : 1;
    unsigned ever_matched_something : 1;
            = 1;							\
/* This converts PTR, a pointer into one of the search strings `string1'
   and `string2' into an offset from the beginning of that string.  */
  (FIRST_STRING_P (ptr) ? (ptr) - string1 : (ptr) - string2 + size1)
#define REG_UNSET_VALUE ((char *) -1)
/* Macros for dealing with the split strings in re_match_2.  */
#define MATCHING_IN_FIRST_STRING  (dend == end_match_1)
   string2 if necessary.  */
      /* End of string2 => fail.  */					\
      if (dend == end_match_2) 						\
      /* End of string1 => advance to string2.  */ 			\
      d = string2;						        \
      dend = end_match_2;						\
   of `string1' and `string2'.  If only one string, it's `string2'.  */
#define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)
#define AT_STRINGS_END(d) ((d) == end2)	
   two special cases to check for: if past the end of string1, look at
   the first character in string2; and if before the beginning of
   string2, look at the last character in string1.  */
  (SYNTAX ((d) == end1 ? *string2					\
           : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\
   || WORDCHAR_P (d - 1) != WORDCHAR_P (d))
   register values; since we have a limit of 255 registers (because
   use numbers larger than 255.  They must differ by 1, because of
#define NO_HIGHEST_ACTIVE_REG (1 << BYTEWIDTH)
#define NO_LOWEST_ACTIVE_REG (NO_HIGHEST_ACTIVE_REG + 1)
/* re_match is like re_match_2 except it takes only a single string.  */
  return re_match_2 (bufp, NULL, 0, string, size, pos, regs, size); 
/* re_match_2 matches the compiled pattern in BUFP against the
   the (virtual) concatenation of STRING1 and STRING2 (of length SIZE1
   and SIZE2, respectively).  We start matching at POS, and stop
   We return -1 if no match, -2 if an internal error (such as the
re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
     const char *string1, *string2;
     int size1, size2;
  unsigned char *p1;
  const char *end1, *end2;
  /* Pointers into string1 and string2, just past the last characters in
  const char *end_match_1, *end_match_2;
  unsigned num_regs = bufp->re_nsub + 1;
  DEBUG_PRINT1 ("\n\nEntering re_match_2.\n");
          return -2;
  if (pos < 0 || pos > size1 + size2)
      return -1;
  /* Initialize subexpression text positions to -1 to mark ones that no
  for (mcnt = 1; mcnt < num_regs; mcnt++)
  /* We move `string1' into `string2' if the latter's empty -- but not if
     `string1' is null.  */
  if (size2 == 0 && string1 != NULL)
      string2 = string1;
      size2 = size1;
      string1 = 0;
      size1 = 0;
  end1 = string1 + size1;
  end2 = string2 + size2;
  if (stop <= size1)
      end_match_1 = string1 + stop;
      end_match_2 = string2;
      end_match_1 = end1;
      end_match_2 = string2 + stop - size1;
     equal `string2'.  */
  if (size1 > 0 && pos <= size1)
      d = string1 + pos;
      dend = end_match_1;
      d = string2 + pos - size1;
      dend = end_match_2;
  DEBUG_PRINT1 ("The compiled pattern is: ");
  DEBUG_PRINT1 ("The string to match is: `");
  DEBUG_PRINT_DOUBLE_STRING (d, string1, size1, string2, size2);
  DEBUG_PRINT1 ("'\n");
      DEBUG_PRINT2 ("\n0x%x: ", p);
          DEBUG_PRINT1 ("end of pattern ... ");
          if (d != end_match_2)
              DEBUG_PRINT1 ("backtracking.\n");
                      DEBUG_PRINT1 ("\nSAVING match as best so far.\n");
                      for (mcnt = 1; mcnt < num_regs; mcnt++)
                     end_match_1' while the restored d is in string2.
                  DEBUG_PRINT1 ("Restoring best registers.\n");
                  dend = ((d >= string1 && d <= end1)
		           ? end_match_1 : end_match_2);
		  for (mcnt = 1; mcnt < num_regs; mcnt++)
            } /* d != end_match_2 */
          DEBUG_PRINT1 ("Accepting match.\n");
                     extra element beyond `num_regs' for the `-1' marker
                  regs->num_regs = MAX (RE_NREGS, num_regs + 1);
                    return -2;
                  if (regs->num_regs < num_regs + 1)
                      regs->num_regs = num_regs + 1;
                        return -2;
                  regs->end[0] = (MATCHING_IN_FIRST_STRING ? d - string1
			          : d - string2 + size1);
	      for (mcnt = 1; mcnt < MIN (num_regs, regs->num_regs); mcnt++)
                    regs->start[mcnt] = regs->end[mcnt] = -1;
                 were in the pattern, set the extra elements to -1.  If
                 -1 at the end.  */
                regs->start[mcnt] = regs->end[mcnt] = -1;
          DEBUG_PRINT2 ("%u registers pushed.\n", num_regs_pushed);
			    ? string1 
			    : string2 - size1);
          DEBUG_PRINT2 ("Returning %d from re_match_2.\n", mcnt);
          DEBUG_PRINT1 ("EXECUTING no_op.\n");
          DEBUG_PRINT2 ("EXECUTING exactn %d.\n", mcnt);
          DEBUG_PRINT1 ("EXECUTING anychar.\n");
          DEBUG_PRINT2 ("  Matched `%d'.\n", *d);
	    boolean not = (re_opcode_t) *(p - 1) == charset_not;
            DEBUG_PRINT2 ("EXECUTING charset%s.\n", not ? "_not" : "");
               bit list is a full 32 bytes long.  */
		&& p[1 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
	    p += 1 + *p;
	  DEBUG_PRINT3 ("EXECUTING start_memory %d (%d):\n", *p, p[1]);
	  p1 = p;		/* To send to group_match_null_string_p.  */
              = group_match_null_string_p (&p1, pend, reg_info);
	  DEBUG_PRINT2 ("  old_regstart: %d\n", 
	  DEBUG_PRINT2 ("  regstart: %d\n", POINTER_TO_OFFSET (regstart[*p]));
          IS_ACTIVE (reg_info[*p]) = 1;
          p += 2;
	  DEBUG_PRINT3 ("EXECUTING stop_memory %d (%d):\n", *p, p[1]);
	  DEBUG_PRINT2 ("      old_regend: %d\n", 
	  DEBUG_PRINT2 ("      regend: %d\n", POINTER_TO_OFFSET (regend[*p]));
                 new highest active register is 1.  */
              unsigned char r = *p - 1;
                 registers 1 and 2 as a result of the *, but when we pop
                 back to the second ), we are at the stop_memory 1.
	      && (p + 2) < pend)              
              p1 = p + 2;
              switch ((re_opcode_t) *p1++)
                    EXTRACT_NUMBER_AND_INCR (mcnt, p1);
		      p1 += 2;
	      p1 += mcnt;
              if (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump
                  && (re_opcode_t) p1[3] == start_memory && p1[4] == *p)
                     regstart[1], and, e.g., with `((a*)*(b*)*)*'
                      for (r = *p; r < *p + *(p + 1); r++)
		  p1++;
                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
                  PUSH_FAILURE_POINT (p1 + mcnt, d, -2);
          p += 2;
	    register const char *d2, *dend2;
	    DEBUG_PRINT2 ("EXECUTING duplicate %d.\n", regno);
            d2 = regstart[regno];
            dend2 = ((FIRST_STRING_P (regstart[regno]) 
		     ? regend[regno] : end_match_1);
		while (d2 == dend2)
		    if (dend2 == end_match_2) break;
		    if (dend2 == regend[regno]) break;
                    /* End of string1 => advance to string2. */
                    d2 = string2;
                    dend2 = regend[regno];
		if (d2 == dend2) break;
                if (mcnt > dend2 - d2)
		  mcnt = dend2 - d2;
                    ? bcmp_translate (d, d2, mcnt, translate) 
                    : bcmp (d, d2, mcnt))
		d += mcnt, d2 += mcnt;
          DEBUG_PRINT1 ("EXECUTING begline.\n");
          else if (d[-1] == '\n' && bufp->newline_anchor)
          DEBUG_PRINT1 ("EXECUTING endline.\n");
          else if ((d == end1 ? *string2 : *d) == '\n'
          DEBUG_PRINT1 ("EXECUTING begbuf.\n");
          DEBUG_PRINT1 ("EXECUTING endbuf.\n");
          DEBUG_PRINT1 ("EXECUTING on_failure_keep_string_jump");
          PUSH_FAILURE_POINT (p + mcnt, NULL, -2);
          DEBUG_PRINT1 ("EXECUTING on_failure_jump");
             For example, in \(a*\)*\1, we need the preceding group,
             and in \(\(a*\)b*\)\2, we need the inner group.  */
          p1 = p;
             the result of a completed succeed_n, as in \(a\)\{1,3\}b\1
          while (p1 < pend && (re_opcode_t) *p1 == no_op)
            p1++;
          if (p1 < pend && (re_opcode_t) *p1 == start_memory)
              highest_active_reg = *(p1 + 1) + *(p1 + 2);
                lowest_active_reg = *(p1 + 1);
          DEBUG_PRINT1 (":\n");
          PUSH_FAILURE_POINT (p + mcnt, d, -2);
          DEBUG_PRINT2 ("EXECUTING maybe_pop_jump %d.\n", mcnt);
	    register unsigned char *p2 = p;
	    while (p2 + 2 < pend
		   && ((re_opcode_t) *p2 == stop_memory
		       || (re_opcode_t) *p2 == start_memory))
	      p2 += 3;			/* Skip over args, too.  */
            if (p2 == pend)
                DEBUG_PRINT1
            else if ((re_opcode_t) *p2 == exactn
		     || (bufp->newline_anchor && (re_opcode_t) *p2 == endline))
                  = *p2 == (unsigned char) endline ? '\n' : p2[2];
		p1 = p + mcnt;
                /* p1[0] ... p1[2] are the `on_failure_jump' corresponding
                if ((re_opcode_t) p1[3] == exactn && p1[5] != c)
                                  c, p1[5]);
		else if ((re_opcode_t) p1[3] == charset
			 || (re_opcode_t) p1[3] == charset_not)
		    int not = (re_opcode_t) p1[3] == charset_not;
		    if (c < (unsigned char) (p1[4] * BYTEWIDTH)
			&& p1[5 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
                    /* `not' is equal to 1 if c would match, which means
                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
	  p -= 2;		/* Point at relative address again.  */
	  if ((re_opcode_t) p[-1] != pop_failure_jump)
	      p[-1] = (unsigned char) jump;
              DEBUG_PRINT1 ("  Match => jump.\n");
            DEBUG_PRINT1 ("EXECUTING pop_failure_jump.\n");
          DEBUG_PRINT2 ("EXECUTING jump %d ", mcnt);
          DEBUG_PRINT2 ("(to 0x%x).\n", p);
          DEBUG_PRINT1 ("EXECUTING jump_past_alt.\n");
          DEBUG_PRINT1 ("EXECUTING dummy_failure_jump.\n");
          PUSH_FAILURE_POINT (0, 0, -2);
          DEBUG_PRINT1 ("EXECUTING push_dummy_failure.\n");
          PUSH_FAILURE_POINT (0, 0, -2);
          EXTRACT_NUMBER (mcnt, p + 2);
          DEBUG_PRINT2 ("EXECUTING succeed_n %d.\n", mcnt);
	       p += 2;
              DEBUG_PRINT2 ("  Setting two bytes from 0x%x to no_op.\n", p+2);
	      p[2] = (unsigned char) no_op;
          EXTRACT_NUMBER (mcnt, p + 2);
          DEBUG_PRINT2 ("EXECUTING jump_n %d.\n", mcnt);
               STORE_NUMBER (p + 2, mcnt);
            DEBUG_PRINT1 ("EXECUTING set_number_at.\n");
            p1 = p + mcnt;
            DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p1, mcnt);
	    STORE_NUMBER (p1, mcnt);
          DEBUG_PRINT1 ("EXECUTING wordbound.\n");
          DEBUG_PRINT1 ("EXECUTING notwordbound.\n");
          DEBUG_PRINT1 ("EXECUTING wordbeg.\n");
	  if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))
          DEBUG_PRINT1 ("EXECUTING wordend.\n");
	  if (!AT_STRINGS_BEG (d) && WORDCHAR_P (d - 1)
#ifdef emacs19
          DEBUG_PRINT1 ("EXECUTING before_dot.\n");
          DEBUG_PRINT1 ("EXECUTING at_dot.\n");
          DEBUG_PRINT1 ("EXECUTING after_dot.\n");
#else /* not emacs19 */
          DEBUG_PRINT1 ("EXECUTING at_dot.\n");
	  if (PTR_CHAR_POS ((unsigned char *) d) + 1 != point)
#endif /* not emacs19 */
          DEBUG_PRINT2 ("EXECUTING syntaxspec %d.\n", mcnt);
          DEBUG_PRINT1 ("EXECUTING Emacs wordchar.\n");
          DEBUG_PRINT2 ("EXECUTING notsyntaxspec %d.\n", mcnt);
          DEBUG_PRINT1 ("EXECUTING Emacs notwordchar.\n");
          DEBUG_PRINT1 ("EXECUTING non-Emacs wordchar.\n");
          DEBUG_PRINT1 ("EXECUTING non-Emacs notwordchar.\n");
          DEBUG_PRINT1 ("\nFAIL:\n");
                  p1 = p + 1;
                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
                  p1 += mcnt;	
                  if ((is_a_jump_n && (re_opcode_t) *p1 == succeed_n)
                          && (re_opcode_t) *p1 == on_failure_jump))
          if (d >= string1 && d <= end1)
	    dend = end_match_1;
  return -1;         			/* Failure to match.  */
} /* re_match_2 */
/* Subroutine definitions for re_match_2.  */
  unsigned char *p1 = *p + 2;
  while (p1 < end)
      switch ((re_opcode_t) *p1)
          p1++;
          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
                 /on_failure_jump/0/6/exactn/1/a/jump_past_alt/0/6
                 /on_failure_jump/0/6/exactn/1/b/jump_past_alt/0/3
                 /exactn/1/c						
                 So, we have to first go through the first (n-1)
              /* Deal with the first (n-1) alternatives, which start
              while ((re_opcode_t) p1[mcnt-3] == jump_past_alt)
                  if (!alt_match_null_string_p (p1, p1 + mcnt - 3, 
                  p1 += mcnt;	
                  if ((re_opcode_t) *p1 != on_failure_jump)
		  p1++;
                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
                  if ((re_opcode_t) p1[mcnt-3] != jump_past_alt)
                      p1 -= 3;
              EXTRACT_NUMBER (mcnt, p1 - 2);
              if (!alt_match_null_string_p (p1, p1 + mcnt, reg_info))
              p1 += mcnt;	/* Get past the n-th alternative.  */
	  assert (p1[1] == **p);
          *p = p1 + 2;
          if (!common_op_match_null_string_p (&p1, end, reg_info))
    } /* while p1 < end */
  unsigned char *p1 = p;
  while (p1 < end)
      switch ((re_opcode_t) *p1)
          p1++;
          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
          p1 += mcnt;
          if (!common_op_match_null_string_p (&p1, end, reg_info))
    }  /* while p1 < end */
  unsigned char *p1 = *p;
  switch ((re_opcode_t) *p1++)
      reg_no = *p1;
      ret = group_match_null_string_p (&p1, end, reg_info);
      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
        p1 += mcnt;
      p1 += 2;		
      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
          p1 -= 4;
          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
          p1 += mcnt;
      if (!REG_MATCH_NULL_STRING_P (reg_info[*p1]))
      p1 += 4;
  *p = p1;
/* Return zero if TRANSLATE[S1] and TRANSLATE[S2] are identical for LEN
bcmp_translate (s1, s2, len, translate)
     unsigned char *s1, *s2;
  register unsigned char *p1 = s1, *p2 = s2;
      if (translate[*p1++] != translate[*p2++]) return 1;
     (and at least one extra will be -1).  */
  bufp->newline_anchor = 1;
/* Entry points compatible with 4.2 BSD regex library.  We don't define
      re_comp_buf.buffer = (unsigned char *) malloc (200);
      re_comp_buf.allocated = 200;
      re_comp_buf.fastmap = (char *) malloc (1 << BYTEWIDTH);
  re_comp_buf.newline_anchor = 1;
/* POSIX.2 functions.  Don't define these for Emacs.  */
      preg->newline_anchor = 1;
  msg_size = strlen (msg) + 1; /* Includes the null.  */
          strncpy (errbuf, msg, errbuf_size - 1);
          errbuf[errbuf_size - 1] = 0;
   Copyright (C) 1988 Free Software Foundation, Inc.
   the Free Software Foundation; either version 2, or (at your option)
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
/* Written June, 1988 by Mike Haertel
   Modified July, 1988 by Arthur David Olson to assist BMG speedups  */
#define flag_stdlib 1
#define flag_systypes 1
#define flag_string 1
#define flag_strings 1
xmalloc_1(n)
xrealloc_1(p, n)
#define MALLOC(p, t, n) ((p) = (t *) xmalloc_1((n) * sizeof (t)))
#define REALLOC(p, t, n) ((p) = (t *) xrealloc_1((ptr_t) (p), (n) * sizeof (t)))
	(nalloc) *= 2;				  \
  return c[b / INTBITS] & 1 << b % INTBITS;
  c[b / INTBITS] |= 1 << b % INTBITS;
  c[b / INTBITS] &= ~(1 << b % INTBITS);
equal(s1, s2)
     charclass s1;
     charclass s2;
    if (s1[i] != s2[i])
  return 1;
  syntax_bits_set = 1;
  token c, c1, c2;
  for (i = 0; i < 2; ++i)
	  backslash = 1;
		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == ')')
		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == '|')
	case '1':
	case '2':
		  minrep = 10 * minrep + c - '0';
		maxrep = 10 * maxrep + c - '0';
	  laststart = 1;
	  laststart = 1;
	  laststart = 1;
	  for (c2 = 0; c2 < NOTCHAR; ++c2)
	    if (ISALNUM(c2))
	      setbit(c2, ccl);
	      invert = 1;
		for (c1 = 0; prednames[c1].name; ++c1)
		  if (looking_at(prednames[c1].name))
		      for (c2 = 0; c2 < NOTCHAR; ++c2)
			if ((*prednames[c1].pred)(c2))
			  setbit(c2, ccl);
		      lexptr += strlen(prednames[c1].name);
		      lexleft -= strlen(prednames[c1].name);
		      FETCH(c1, "Unbalanced [");
	      FETCH(c1, "Unbalanced [");
	      if (c1 == '-')
		  FETCH(c2, "Unbalanced [");
		  if (c2 == ']')
			 which is left in c1, the lookahead character. */
		      c2 = c;
		      if (c2 == '\\'
			FETCH(c2, "Unbalanced [");
		      FETCH(c1, "Unbalanced [");
		c2 = c;
	      while (c <= c2)
	  while ((c = c1) != ']');
  int ntoks1;
  switch (dfa->tokens[tindex - 1])
      return 1;
      return 1 + nsubtoks(tindex - 1);
      ntoks1 = nsubtoks(tindex - 1);
      return 1 + ntoks1 + nsubtoks(tindex - 1 - ntoks1);
	for (i = 1; i < minrep; ++i)
  laststart = 1;
  regexp(1);
  position t1, t2;
      t1 = p;
	  t2 = s->elems[i];
	  s->elems[i++] = t1;
	  t1 = t2;
merge(s1, s2, m)
     position_set *s1;
     position_set *s2;
  while (i < s1->nelem && j < s2->nelem)
    if (s1->elems[i].index > s2->elems[j].index)
      m->elems[m->nelem++] = s1->elems[i++];
    else if (s1->elems[i].index < s2->elems[j].index)
      m->elems[m->nelem++] = s2->elems[j++];
	m->elems[m->nelem] = s1->elems[i++];
	m->elems[m->nelem++].constraint |= s2->elems[j++].constraint;
  while (i < s1->nelem)
    m->elems[m->nelem++] = s1->elems[i++];
  while (j < s2->nelem)
    m->elems[m->nelem++] = s2->elems[j++];
      s->elems[i] = s->elems[i + 1];
  newline = newline ? 1 : 0;
  letter = letter ? 1 : 0;
	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 0, letter, 1)
	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 1, letter, 0)
	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 1, letter, 1))
	d->states[i].backref = 1;
	visited[old.index] = 1;
	i = -1;
	*nullable++ = 1;
	tmp.nelem = nfirstpos[-1];
	for (j = 0; j < nlastpos[-1]; ++j)
				 nalloc[pos[j].index], merged.nelem - 1);
	  nullable[-1] = 1;
	tmp.nelem = nfirstpos[-1];
	pos = lastpos + nlastpos[-1];
	for (j = 0; j < nlastpos[-2]; ++j)
				 nalloc[pos[j].index], merged.nelem - 1);
	if (nullable[-2])
	  nfirstpos[-2] += nfirstpos[-1];
	  firstpos += nfirstpos[-1];
	if (nullable[-1])
	  nlastpos[-2] += nlastpos[-1];
	    pos = lastpos + nlastpos[-2];
	    for (j = nlastpos[-1] - 1; j >= 0; --j)
	    lastpos += nlastpos[-2];
	    nlastpos[-2] = nlastpos[-1];
	nullable[-2] = nullable[-1] && nullable[-2];
	nfirstpos[-2] += nfirstpos[-1];
	nlastpos[-2] += nlastpos[-1];
	nullable[-2] = nullable[-1] || nullable[-2];
	*nfirstpos++ = *nlastpos++ = 1;
	nalloc[i] = 1;
      fprintf(stderr, nullable[-1] ? " nullable: yes\n" : " nullable: no\n");
      for (j = nfirstpos[-1] - 1; j >= 0; --j)
      for (j = nlastpos[-1] - 1; j >= 0; --j)
	for (j = d->follows[i].nelem - 1; j >= 0; --j)
  for (i = 0; i < nfirstpos[-1]; ++i)
      wants_newline = 1;
  d->salloc = 1;
      initialized = 1;
					 d->states[s].newline, 1))
					d->states[s].letter, 1))
	    (intersect[k] = matches[k] & labels[j][k]) ? intersectf = 1 : 0;
	      (leftovers[k] = ~match & label) ? leftoversf = 1 : 0;
	      (matches[k] = match & ~label) ? matchesf = 1 : 0;
	  grps[ngrps].nelem = 1;
	    wants_newline = 1;
	    wants_letter = 1;
	state_newline = state_index(d, &follows, 1, 0);
	state_letter = state_index(d, &follows, 0, 1);
      trans[i] = -1;
	    wants_newline = 1;
	    wants_letter = 1;
	state_newline = state_index(d, &follows, 1, 0);
	state_letter = state_index(d, &follows, 0, 1);
	  if (labels[i][j] & 1 << k)
     exist at once.  1024 is arbitrary.  The idea is that the frequently
  if (d->trcount >= 1024)
  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 1, d->states[s].letter, 0,
  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 0, d->states[s].letter, 1,
    d->success[s] |= 2;
    d->success[s] |= 1;
	  d->tralloc *= 2;
	REALLOC(d->realtrans, int *, d->tralloc + 1);
	d->trans = d->realtrans + 1;
  trans['\n'] = -1;
  d->tralloc = 1;
  CALLOC(d->realtrans, int *, d->tralloc + 1);
  d->trans = d->realtrans + 1;
   where we're supposed to store a 1 if backreferencing happened and the
  register s, s1, tmp;		/* Current state. */
      sbit_init = 1;
	  sbit[i] = 2;
	  sbit[i] = 1;
  s = s1 = 0;
	    s1 = t[*p++];
	    if (! (t = trans[s1]))
      goto last_was_s1;
      tmp = s, s = s1, s1 = tmp;
    last_was_s1:
		  *backref = 1;
	  s1 = s;
      if (count && (char *) p <= end && p[-1] == '\n')
      if (p[-1] == '\n' && newline)
	  s = d->newlines[s1];
  d->calloc = 1;
  d->talloc = 1;
      case_fold = 1;
    result = (char *) malloc(newsize + 1);
    result = (char *) realloc((void *) old, oldsize + newsize + 1);
  cpp = (char **) realloc((char *) cpp, (i + 2) * sizeof *cpp);
  cpp[i + 1] = NULL;
	  for (i = 1; lcp[i] != '\0' && lcp[i] == rcp[i]; ++i)
	  rcp = index(rcp + 1, *lcp);
  musts = (must *) malloc((dfa->tindex + 1) * sizeof *musts);
      mp[i].left = malloc(2);
      mp[i].right = malloc(2);
      mp[i].is = malloc(2);
	  if (mp < &musts[2])
	      if (lmp->right[ln - i - 1] != rmp->right[rn - i - 1])
	  if (mp != &musts[1])
	    exact = 1;
	  if (mp < &musts[2])
	      mp->is[1] = mp->left[1] = mp->right[1] = '\0';
	      mp->in = enlist(mp->in, mp->is, 1);
      dm->must = malloc(strlen(result) + 1);
   Copyright 1989 Free Software Foundation
		  Written August 1989 by Mike Haertel.
   the Free Software Foundation; either version 1, or (at your option)
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   IBM-Germany, Scientific Center Heidelberg, Tiergartenstrasse 15, D-6900
   String Matching:  An Aid to Bibliographic Search," CACM June 1975,
   Vol. 18, No. 6, which describes the failure function used below. */
#define flag_limits 1
#define flag_stdlib 1
#define INT_MAX 2147483647
#define UCHAR_MAX 255
#define flag_systypes 1
#define flag_string 1
#define flag_memory 1
#define NCHAR (UCHAR_MAX + 1)
  int mind2;			/* Used in Boyer-Moore search for one string. */
  kwset->maxd = -1;
  struct tree *links[12];
  enum { L, R } dirs[12];
      depth = 1;
	  link->trie->depth = trie->depth + 1;
		case (char) -2:
		  switch (dirs[depth + 1])
		      l->balance = t->balance != 1 ? 0 : -1;
		      r->balance = t->balance != (char) -1 ? 0 : 1;
		case 2:
		  switch (dirs[depth + 1])
		      l->balance = t->balance != 1 ? 0 : -1;
		      r->balance = t->balance != (char) -1 ? 0 : 1;
	      if (dirs[depth - 1] == L)
		links[depth - 1]->llink = t;
		links[depth - 1]->rlink = t;
    trie->accepting = 1 + 2 * kwset->words;
    return 1;
  if (kwset->mind < 256)
      delta[i] = 255;
  if (kwset->words == 1 && kwset->trans == 0)
      for (i = kwset->mind - 1, curr = kwset->trie; i >= 0; --i)
	delta[(unsigned char) kwset->target[i]] = kwset->mind - (i + 1);
      kwset->mind2 = kwset->mind;
      /* Find the minimal delta2 shift that we might make after
      for (i = 0; i < kwset->mind - 1; ++i)
	if (kwset->target[i] == kwset->target[kwset->mind - 1])
	  kwset->mind2 = kwset->mind - (i + 1);
  register unsigned char *d1;
  register int d, gc, i, len, md2;
  if (len == 1)
  d1 = kwset->delta;
  gc = U(sp[-2]);
  md2 = kwset->mind2;
  /* Significance of 12: 1 (initial offset) + 10 (skip loop) + 1 (md2). */
  if (size > 12 * len)
    /* 11 is not a bug, the initial offset happens only once. */
    for (ep = text + size - 11 * len;;)
	    d = d1[U(tp[-1])], tp += d;
	    d = d1[U(tp[-1])], tp += d;
	    d = d1[U(tp[-1])], tp += d;
	    d = d1[U(tp[-1])], tp += d;
	    d = d1[U(tp[-1])], tp += d;
	    d = d1[U(tp[-1])], tp += d;
	    d = d1[U(tp[-1])], tp += d;
	    d = d1[U(tp[-1])], tp += d;
	    d = d1[U(tp[-1])], tp += d;
	    d = d1[U(tp[-1])], tp += d;
	if (U(tp[-2]) == gc)
	tp += md2;
  d = d1[U(tp[-1])];
      d = d1[U((tp += d)[-1])];
      if (tp[-2] == gc)
      d = md2;
	  end += d - 1;
	d = delta[c = (end += d)[-1]];
      beg = end - 1;
  d = 1;
      if ((d = delta[c = (end += d)[-1]]) != 0)
      beg = end - 1;
	  d = 1;
	d = 1;
      kwsmatch->index = accept->accepting / 2;
  if (kwset->words == 1 && kwset->trans == 0)
   Copyright (C) 1988, 1993 Free Software Foundation, Inc.
Free Software Foundation; either version 2, or (at your option) any
Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
		    + 4 + DEFAULT_ROUNDING - 1)
		   & ~(DEFAULT_ROUNDING - 1));
  h->alignment_mask = alignment - 1;
_obstack_begin_1 (h, size, alignment, chunkfun, freefun, arg)
      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
		    + 4 + DEFAULT_ROUNDING - 1)
		   & ~(DEFAULT_ROUNDING - 1));
  h->alignment_mask = alignment - 1;
  h->use_extra_arg = 1;
  new_size = (obj_size + length) + (obj_size >> 3) + 100;
  if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)
      for (i = obj_size / sizeof (COPYING_UNIT) - 1;
      h->maybe_empty_object = 1;
      h->maybe_empty_object = 1;
void (obstack_1grow) (obstack, character)
  obstack_1grow (obstack, character);
void (obstack_1grow_fast) (obstack, character)
  obstack_1grow_fast (obstack, character);
   Copyright (C) 1992 Free Software Foundation, Inc.
   the Free Software Foundation; either version 2, or (at your option)
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   Written August 1992 by Mike Haertel. */
#define flag_limits 1
#define flag_stdlib 1
#define UCHAR_MAX 255
#define flag_systypes 1
#define flag_string 1
#define flag_memory 1
#define NCHAR (UCHAR_MAX + 1)
static struct dfa dfa_1;
  if (dfa_1.musts)
      for (dm = dfa_1.musts; dm; dm = dm->next)
      for (dm = dfa_1.musts; dm; dm = dm->next)
  dfainit(&dfa_1);
      dfacomp(n, i, &dfa_1, 1);
    dfacomp(pattern, size, &dfa_1, 1);
  dfainit(&dfa_1);
      dfacomp(n, i, &dfa_1, 1);
    dfacomp(pattern, size, &dfa_1, 1);
  for (beg = end = buf; end < buflim; beg = end + 1)
	  while (beg > buf && beg[-1] != '\n')
	  if (!dfaexec(&dfa_1, beg, end, 0, (int *) 0, &backref))
	  beg = dfaexec(&dfa_1, beg, buflim, 0, (int *) 0, &backref);
	  while (beg > buf && beg[-1] != '\n')
		if ((start == 0 || !WCHAR(beg[start - 1]))
		    regex.not_eol = 1;
  *endp = end < buflim ? end + 1 : end;
	  if (beg > buf && beg[-1] != '\n')
	    if (try > buf && WCHAR((unsigned char) try[-1]))
  while (beg > buf && beg[-1] != '\n')
