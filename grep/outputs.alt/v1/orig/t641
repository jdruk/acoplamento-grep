target1: 12345: No such file or directory
../inputs/grep1.dat:/* grep.c - main driver file for grep.
../inputs/grep1.dat:  for (p = (unsigned char *) vp; n--; ++p)
../inputs/grep1.dat:static char *bufbeg;		/* Beginning of user-visible stuff. */
../inputs/grep1.dat:static char *buflim;		/* Limit of user-visible stuff. */
../inputs/grep1.dat:  sp = buflim - save;
../inputs/grep1.dat:  dp = nbuffer + bufsalloc - save;
../inputs/grep1.dat:  while (save--)
../inputs/grep1.dat:      && bufstat.st_size - bufoffset >= bufalloc - bufsalloc)
../inputs/grep1.dat:      maddr = mmap(maddr, bufalloc - bufsalloc, PROT_READ | PROT_WRITE,
../inputs/grep1.dat:      if (maddr == (caddr_t) -1)
../inputs/grep1.dat:      madvise(maddr, bufalloc - bufsalloc, MADV_SEQUENTIAL);
../inputs/grep1.dat:      cc = bufalloc - bufsalloc;
../inputs/grep1.dat:      cc = read(bufdesc, buffer + bufsalloc, bufalloc - bufsalloc);
../inputs/grep1.dat:  cc = read(bufdesc, buffer + bufsalloc, bufalloc - bufsalloc);
../inputs/grep1.dat:    printf("%lu%c", totalcc + (beg - bufbeg), sep);
../inputs/grep1.dat:  fwrite(beg, 1, lim - beg, stdout);
../inputs/grep1.dat:      --pending;
../inputs/grep1.dat:      if ((nl = memchr(lastout, '\n', lim - lastout)) != 0)
../inputs/grep1.dat:      prline(lastout, nl, '-');
../inputs/grep1.dat:   If NLINESP is non-null, store a count of lines between BEG and LIM. */
../inputs/grep1.dat:  static int used;		/* avoid printing "--" before any output */
../inputs/grep1.dat:	    --p;
../inputs/grep1.dat:	  while (p > bp && p[-1] != '\n');
../inputs/grep1.dat:      /* We only print the "--" separator if our output is
../inputs/grep1.dat:	puts("--");
../inputs/grep1.dat:	  nl = memchr(p, '\n', beg - p);
../inputs/grep1.dat:	  prline(p, nl + 1, '-');
../inputs/grep1.dat:	  if ((nl = memchr(p, '\n', lim - p)) != 0)
../inputs/grep1.dat:  while ((b = (*execute)(p, lim - p, &endp)) != 0)
../inputs/grep1.dat:      if (b == lim && ((b > beg && b[-1] == '\n') || b == beg))
../inputs/grep1.dat:      if (buflim - bufbeg == save)
../inputs/grep1.dat:      beg = bufbeg + save - residue;
../inputs/grep1.dat:      for (lim = buflim; lim > beg && lim[-1] != '\n'; --lim)
../inputs/grep1.dat:      residue = buflim - lim;
../inputs/grep1.dat:	    --beg;
../inputs/grep1.dat:	  while (beg > bufbeg && beg[-1] != '\n');
../inputs/grep1.dat:      save = residue + lim - beg;
../inputs/grep1.dat:      totalcc += buflim - bufbeg - save;
../inputs/grep1.dat:      nlines += grepbuf(bufbeg + save - residue, buflim);
../inputs/grep1.dat:  "usage: %s [-[[AB] ]<num>] [-[CEFGVchilnqsvwx]] [-[ef]] <expr> [<files...>]\n"
../inputs/grep1.dat:	out_before = 10 * out_before + opt - '0';
../inputs/grep1.dat:	out_after = 10 * out_after + opt - '0';
../inputs/grep1.dat:	  fatal("you may specify only one of -E, -F, or -G", 0);
../inputs/grep1.dat:	matcher = "posix-egrep";
../inputs/grep1.dat:	  fatal("you may specify only one of -E, -F, or -G", 0);;
../inputs/grep1.dat:	  fatal("you may specify only one of -E, -F, or -G", 0);
../inputs/grep1.dat:	fp = strcmp(optarg, "-") != 0 ? fopen(optarg, "r") : stdin;
../inputs/grep1.dat:	       && (cc = fread(keys + keycc, 1, keyalloc - keycc, fp)) > 0)
../inputs/grep1.dat:	if (keycc - oldcc > 0 && keys[keycc - 1] == '\n')
../inputs/grep1.dat:	  --keycc;
../inputs/grep1.dat:      case 'y':			/* For old-timers . . . */
../inputs/grep1.dat:	/* Like -l, except list files that don't contain matches.
../inputs/grep1.dat:	list_files = -1;
../inputs/grep1.dat:  if (argc - optind > 1 && !no_filenames)
../inputs/grep1.dat:	desc = strcmp(argv[optind], "-") ? open(argv[optind], O_RDONLY) : 0;
../inputs/grep1.dat:	    else if (list_files == -1)
../inputs/grep1.dat:      else if (list_files == -1)
../inputs/grep1.dat:   "Keep this file name-space clean" means, talk to roland@gnu.ai.mit.edu
../inputs/grep1.dat:   program understand `configure --with-gnu-libc' and omit the object files,
../inputs/grep1.dat:/* Don't include stdlib.h for non-GNU C libraries because some of them
../inputs/grep1.dat:/* If GETOPT_COMPAT is defined, `+' as well as `--' can introduce a
../inputs/grep1.dat:   long-named option.  Because this is not POSIX.2 compliant, it is
../inputs/grep1.dat:   each non-option ARGV-element is returned here.  */
../inputs/grep1.dat:   non-option elements that the caller should itself scan.
../inputs/grep1.dat:/* The next char to be scanned in the option-element
../inputs/grep1.dat:   by advancing to the next ARGV-element.  */
../inputs/grep1.dat:/* Describe how to deal with options that follow non-option ARGV-elements.
../inputs/grep1.dat:   stop option processing when the first non-option is seen.
../inputs/grep1.dat:   so that eventually all the non-options are at the end.  This allows options
../inputs/grep1.dat:   to expect options and other ARGV-elements in any order and that care about
../inputs/grep1.dat:   the ordering of the two.  We describe each non-option ARGV-element
../inputs/grep1.dat:   Using `-' as the first character of the list of option characters
../inputs/grep1.dat:   The special argument `--' forces an end of option-scanning regardless
../inputs/grep1.dat:   `--' can cause `getopt' to return EOF with `optind' != ARGC.  */
../inputs/grep1.dat:/* We want to avoid inclusion of string.h with non-GNU libraries
../inputs/grep1.dat:/* Describe the part of ARGV that contains non-options that have
../inputs/grep1.dat:   which contains all the non-options that have been skipped so far.
../inputs/grep1.dat:   the options processed since those non-options were skipped.
../inputs/grep1.dat:   the new indices of the non-options in ARGV after they are moved.  */
../inputs/grep1.dat:  int nonopts_size = (last_nonopt - first_nonopt) * sizeof (char *);
../inputs/grep1.dat:	    (optind - last_nonopt) * sizeof (char *));
../inputs/grep1.dat:	    (char *) &argv[first_nonopt + optind - last_nonopt],
../inputs/grep1.dat:  /* Update records for the slots the non-options now occupy.  */
../inputs/grep1.dat:  first_nonopt += (optind - last_nonopt);
../inputs/grep1.dat:   If an element of ARGV starts with '-', and is not exactly "-" or "--",
../inputs/grep1.dat:   (aside from the initial '-') are option characters.  If `getopt'
../inputs/grep1.dat:   resume the scan with the following option character or ARGV-element.
../inputs/grep1.dat:   Then `optind' is the index in ARGV of the first ARGV-element
../inputs/grep1.dat:   that is not an option.  (The ARGV-elements have been permuted
../inputs/grep1.dat:   so the following text in the same ARGV-element, or the text of the following
../inputs/grep1.dat:   ARGV-element, is returned in `optarg'.  Two colons mean an option that
../inputs/grep1.dat:   wants an optional arg; if there is text in the current ARGV-element,
../inputs/grep1.dat:   If OPTSTRING starts with `-' or `+', it requests different methods of
../inputs/grep1.dat:   handling the non-option ARGV-elements.
../inputs/grep1.dat:   Long-named options begin with `--' instead of `-'.
../inputs/grep1.dat:   argument, it follows the option name in the same ARGV-element, separated
../inputs/grep1.dat:   from the option name by a `=', or else the in next ARGV-element.
../inputs/grep1.dat:   When `getopt' finds a long-named option, it returns 0 if that option's
../inputs/grep1.dat:   LONGIND returns the index in LONGOPT of the long-named option found.
../inputs/grep1.dat:   It is only valid when a long-named option has been found by the most
../inputs/grep1.dat:   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
../inputs/grep1.dat:   long-named options.  */
../inputs/grep1.dat:     Start processing options with ARGV-element 1 (since ARGV-element 0
../inputs/grep1.dat:     non-option ARGV-elements is empty.  */
../inputs/grep1.dat:      if (optstring[0] == '-')
../inputs/grep1.dat:	  /* If we have just processed some options following some non-options,
../inputs/grep1.dat:	  /* Now skip any additional non-options
../inputs/grep1.dat:	     and extend the range of non-options previously skipped.  */
../inputs/grep1.dat:		 && (argv[optind][0] != '-' || argv[optind][1] == '\0')
../inputs/grep1.dat:      /* Special ARGV-element `--' means premature end of options.
../inputs/grep1.dat:	 then exchange with previous non-options as if it were an option,
../inputs/grep1.dat:	 then skip everything else like a non-option.  */
../inputs/grep1.dat:      if (optind != argc && !strcmp (argv[optind], "--"))
../inputs/grep1.dat:      /* If we have done all the ARGV-elements, stop the scan
../inputs/grep1.dat:	 and back over any non-options that we skipped and permuted.  */
../inputs/grep1.dat:	  /* Set the next-arg-index to point at the non-options
../inputs/grep1.dat:      /* If we have come to a non-option and did not permute it,
../inputs/grep1.dat:      if ((argv[optind][0] != '-' || argv[optind][1] == '\0')
../inputs/grep1.dat:      /* We have found another option-ARGV-element.
../inputs/grep1.dat:		  + (longopts != NULL && argv[optind][1] == '-'));
../inputs/grep1.dat:      && ((argv[optind][0] == '-'
../inputs/grep1.dat:	   && (argv[optind][1] == '-' || long_only))
../inputs/grep1.dat:      for (p = longopts, option_index = 0; p->name;
../inputs/grep1.dat:	if (!strncmp (p->name, nextchar, s - nextchar))
../inputs/grep1.dat:	    if (s - nextchar == strlen (p->name))
../inputs/grep1.dat:	      if (pfound->has_arg)
../inputs/grep1.dat:		      if (argv[optind - 1][1] == '-')
../inputs/grep1.dat:			/* --option */
../inputs/grep1.dat:				 "%s: option `--%s' doesn't allow an argument\n",
../inputs/grep1.dat:				 argv[0], pfound->name);
../inputs/grep1.dat:			/* +option or -option */
../inputs/grep1.dat:			     argv[0], argv[optind - 1][0], pfound->name);
../inputs/grep1.dat:	  else if (pfound->has_arg == 1)
../inputs/grep1.dat:			     argv[0], argv[optind - 1]);
../inputs/grep1.dat:	  if (pfound->flag)
../inputs/grep1.dat:	      *(pfound->flag) = pfound->val;
../inputs/grep1.dat:	  return pfound->val;
../inputs/grep1.dat:	 or the option starts with '--' or is not a valid short
../inputs/grep1.dat:      if (!long_only || argv[optind][1] == '-'
../inputs/grep1.dat:	      if (argv[optind][1] == '-')
../inputs/grep1.dat:		/* --option */
../inputs/grep1.dat:		fprintf (stderr, "%s: unrecognized option `--%s'\n",
../inputs/grep1.dat:		/* +option or -option */
../inputs/grep1.dat:  /* Look at and handle the next option-character.  */
../inputs/grep1.dat:	      fprintf (stderr, "%s: unrecognized option `-%c'\n", argv[0], c);
../inputs/grep1.dat:	    fprintf (stderr, "%s: illegal option -- %c\n", argv[0], c);
../inputs/grep1.dat:		/* If we end this ARGV-element by taking the rest as an arg,
../inputs/grep1.dat:		    fprintf (stderr, "%s: option `-%c' requires an argument\n",
../inputs/grep1.dat:		    fprintf (stderr, "%s: option requires an argument -- %c\n",
../inputs/grep1.dat:		 increment it again when taking next ARGV-elt as argument.  */
../inputs/grep1.dat:/* Compile with -DTEST to make an executable for use in testing
../inputs/grep1.dat:	    printf ("digits occur in two different argv-elements.\n");
../inputs/grep1.dat:      printf ("non-option ARGV-elements: ");
../inputs/grep1.dat:   isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
../inputs/grep1.dat:#define SIGN_EXTEND_CHAR(c) ((((unsigned char) (c)) ^ 128) - 128)
../inputs/grep1.dat:   re_search* or re_match* could cause memory leaks when C-g is used in
../inputs/grep1.dat:   not functions -- `alloca'-allocated space disappears at the end of the
../inputs/grep1.dat:/* True if `size1' is non-NULL and PTR is pointing anywhere inside
../inputs/grep1.dat:           are ordered low-bit-first.  A character is in the set if its
../inputs/grep1.dat:        /* Followed by two-byte relative address of place to resume at
../inputs/grep1.dat:           two-byte relative address.  */
../inputs/grep1.dat:           Followed by two-byte address.  */
../inputs/grep1.dat:        /* Jump to following two-byte address, and push a dummy failure
../inputs/grep1.dat:        /* Followed by two-byte relative address and two-byte number n.
../inputs/grep1.dat:        /* Followed by two-byte relative address, and two-byte number n.
../inputs/grep1.dat:        /* Set the following two-byte relative address to the
../inputs/grep1.dat:           subsequent two-byte number.  The address *includes* the two
../inputs/grep1.dat:  wordchar,	/* Matches any word-constituent character.  */
../inputs/grep1.dat:  notwordchar,	/* Matches any char that is not a word-constituent.  */
../inputs/grep1.dat:   the other test files, you can run the already-written tests.  */
../inputs/grep1.dat:/* Print the fastmap in human-readable form.  */
../inputs/grep1.dat:          printchar (i - 1);
../inputs/grep1.dat:              printf ("-");
../inputs/grep1.dat:              printchar (i - 1);
../inputs/grep1.dat:/* Print a compiled pattern string in human-readable form, starting at
../inputs/grep1.dat:      printf ("%d:\t", p - start);
../inputs/grep1.dat:          while (--mcnt);
../inputs/grep1.dat:            register int c, last = -100;
../inputs/grep1.dat:	            (re_opcode_t) *(p - 1) == charset_not ? "^" : "");
../inputs/grep1.dat:		      putchar ('-');
../inputs/grep1.dat:  	  printf ("/on_failure_jump to %d", p + mcnt - start);
../inputs/grep1.dat:  	  printf ("/on_failure_keep_string_jump to %d", p + mcnt - start);
../inputs/grep1.dat:  	  printf ("/dummy_failure_jump to %d", p + mcnt - start);
../inputs/grep1.dat:  	  printf ("/maybe_pop_jump to %d", p + mcnt - start);
../inputs/grep1.dat:  	  printf ("/pop_failure_jump to %d", p + mcnt - start);
../inputs/grep1.dat:  	  printf ("/jump_past_alt to %d", p + mcnt - start);
../inputs/grep1.dat:  	  printf ("/jump to %d", p + mcnt - start);
../inputs/grep1.dat:	  printf ("/succeed_n to %d, %d times", p + mcnt - start, mcnt2);
../inputs/grep1.dat:	  printf ("/jump_n to %d, %d times", p + mcnt - start, mcnt2);
../inputs/grep1.dat:	  printf ("/set_number_at location %d to %d", p + mcnt - start, mcnt2);
../inputs/grep1.dat:          printf ("?%d", *(p-1));
../inputs/grep1.dat:  printf ("%d:\tend of pattern.\n", p - start);
../inputs/grep1.dat:  unsigned char *buffer = bufp->buffer;
../inputs/grep1.dat:  print_partial_compiled_pattern (buffer, buffer + bufp->used);
../inputs/grep1.dat:  printf ("%d bytes used/%d bytes allocated.\n", bufp->used, bufp->allocated);
../inputs/grep1.dat:  if (bufp->fastmap_accurate && bufp->fastmap)
../inputs/grep1.dat:      print_fastmap (bufp->fastmap);
../inputs/grep1.dat:  printf ("re_nsub: %d\t", bufp->re_nsub);
../inputs/grep1.dat:  printf ("regs_alloc: %d\t", bufp->regs_allocated);
../inputs/grep1.dat:  printf ("can_be_null: %d\t", bufp->can_be_null);
../inputs/grep1.dat:  printf ("newline_anchor: %d\n", bufp->newline_anchor);
../inputs/grep1.dat:  printf ("no_sub: %d\t", bufp->no_sub);
../inputs/grep1.dat:  printf ("not_bol: %d\t", bufp->not_bol);
../inputs/grep1.dat:  printf ("not_eol: %d\t", bufp->not_eol);
../inputs/grep1.dat:  printf ("syntax: %d\n", bufp->syntax);
../inputs/grep1.dat:          for (this_char = where - string1; this_char < size1; this_char++)
../inputs/grep1.dat:      for (this_char = where - string2; this_char < size2; this_char++)
../inputs/grep1.dat:/* Fetch the next character in the uncompiled pattern---translating it 
../inputs/grep1.dat:#define PATUNFETCH p--
../inputs/grep1.dat:/* If `translate' is non-null, return translate[D], else just D.  We
../inputs/grep1.dat:    while (b - bufp->buffer + (n) > bufp->allocated)			\
../inputs/grep1.dat:  store_op1 (op, loc, (to) - (loc) - 3)
../inputs/grep1.dat:/* Likewise, for a two-argument jump.  */
../inputs/grep1.dat:  store_op2 (op, loc, (to) - (loc) - 3, arg)
../inputs/grep1.dat:  insert_op1 (op, loc, (to) - (loc) - 3, b)
../inputs/grep1.dat:  insert_op2 (op, loc, (to) - (loc) - 3, arg, b)
../inputs/grep1.dat:    unsigned char *old_buffer = bufp->buffer;				\
../inputs/grep1.dat:    if (bufp->allocated == MAX_BUF_SIZE) 				\
../inputs/grep1.dat:    bufp->allocated <<= 1;						\
../inputs/grep1.dat:    if (bufp->allocated > MAX_BUF_SIZE)					\
../inputs/grep1.dat:      bufp->allocated = MAX_BUF_SIZE; 					\
../inputs/grep1.dat:    bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated);\
../inputs/grep1.dat:    if (bufp->buffer == NULL)						\
../inputs/grep1.dat:    if (old_buffer != bufp->buffer)					\
../inputs/grep1.dat:        b = (b - old_buffer) + bufp->buffer;				\
../inputs/grep1.dat:        begalt = (begalt - old_buffer) + bufp->buffer;			\
../inputs/grep1.dat:          fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;\
../inputs/grep1.dat:          laststart = (laststart - old_buffer) + bufp->buffer;		\
../inputs/grep1.dat:          pending_exact = (pending_exact - old_buffer) + bufp->buffer;	\
../inputs/grep1.dat:   be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
../inputs/grep1.dat:           num = num * 10 + c - '0'; 					\
../inputs/grep1.dat:  char *translate = bufp->translate;
../inputs/grep1.dat:  /* Address of the count-byte of the most recently inserted `exactn'
../inputs/grep1.dat:     command.  This makes it possible to tell if a new exact-match
../inputs/grep1.dat:     the containing expression.  Each alternative of an `or' -- except the
../inputs/grep1.dat:     last -- ends with a forward jump of this sort.  */
../inputs/grep1.dat:  /* Counts open-groups as they are encountered.  Remembered for the
../inputs/grep1.dat:     matching close-group on the compile stack, so the same register
../inputs/grep1.dat:  bufp->syntax = syntax;
../inputs/grep1.dat:  bufp->fastmap_accurate = 0;
../inputs/grep1.dat:  bufp->not_bol = bufp->not_eol = 0;
../inputs/grep1.dat:  bufp->used = 0;
../inputs/grep1.dat:  /* Always count groups, whether or not bufp->no_sub is set.  */
../inputs/grep1.dat:  bufp->re_nsub = 0;				
../inputs/grep1.dat:  if (bufp->allocated == 0)
../inputs/grep1.dat:      if (bufp->buffer)
../inputs/grep1.dat:	{ /* If zero allocated, but buffer is non-null, try to realloc
../inputs/grep1.dat:          RETALLOC (bufp->buffer, INIT_BUF_SIZE, unsigned char);
../inputs/grep1.dat:          bufp->buffer = TALLOC (INIT_BUF_SIZE, unsigned char);
../inputs/grep1.dat:      if (!bufp->buffer) return REG_ESPACE;
../inputs/grep1.dat:      bufp->allocated = INIT_BUF_SIZE;
../inputs/grep1.dat:  begalt = b = bufp->buffer;
../inputs/grep1.dat:                assert (p - 1 > pattern);
../inputs/grep1.dat:                if (TRANSLATE (*(p - 2)) == TRANSLATE ('.')
../inputs/grep1.dat:                  STORE_JUMP (maybe_pop_jump, b, laststart - 3);
../inputs/grep1.dat:            if ((re_opcode_t) b[-2] == charset_not
../inputs/grep1.dat:                if (had_char_class && c == '-' && *p != ']')
../inputs/grep1.dat:                if (c == '-' 
../inputs/grep1.dat:                    && !(p - 2 >= pattern && p[-2] == '[') 
../inputs/grep1.dat:                    && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^')
../inputs/grep1.dat:                else if (p[0] == '-' && p[1] != ']')
../inputs/grep1.dat:		    /* Move past the `-'.  */
../inputs/grep1.dat:                        while (c1--)    
../inputs/grep1.dat:               end of the map.  Decrease the map-length byte too.  */
../inputs/grep1.dat:            while ((int) b[-1] > 0 && b[b[-1] - 1] == 0) 
../inputs/grep1.dat:              b[-1]--; 
../inputs/grep1.dat:            b += b[-1];
../inputs/grep1.dat:              bufp->re_nsub++;
../inputs/grep1.dat:              COMPILE_STACK_TOP.begalt_offset = begalt - bufp->buffer;
../inputs/grep1.dat:                = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
../inputs/grep1.dat:              COMPILE_STACK_TOP.laststart_offset = b - bufp->buffer;
../inputs/grep1.dat:                  COMPILE_STACK_TOP.inner_group_offset = b - bufp->buffer + 2;
../inputs/grep1.dat:                  STORE_JUMP (jump_past_alt, fixup_alt_jump, b - 1);
../inputs/grep1.dat:                   as in `(ab)c(de)' -- the second group is #2.  */
../inputs/grep1.dat:                compile_stack.avail--;		
../inputs/grep1.dat:                begalt = bufp->buffer + COMPILE_STACK_TOP.begalt_offset;
../inputs/grep1.dat:                    ? bufp->buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1 
../inputs/grep1.dat:                laststart = bufp->buffer + COMPILE_STACK_TOP.laststart_offset;
../inputs/grep1.dat:                      = bufp->buffer + COMPILE_STACK_TOP.inner_group_offset;
../inputs/grep1.dat:                    *inner_group_loc = regnum - this_group_regnum;
../inputs/grep1.dat:                                regnum - this_group_regnum);
../inputs/grep1.dat:                 three-byte space after `a'.  We'll put in the jump, set
../inputs/grep1.dat:                     /* If we're at `\{' and it's not the open-interval 
../inputs/grep1.dat:                  || (p - 2 == pattern  &&  p == pend))
../inputs/grep1.dat:                int lower_bound = -1, upper_bound = -1;
../inputs/grep1.dat:                beg_interval = p - 1;
../inputs/grep1.dat:                            jump back only `upper_bound - 1' times.  */
../inputs/grep1.dat:                                      upper_bound - 1);
../inputs/grep1.dat:                            parameter of the `jump_n'; that is `b-2' as
../inputs/grep1.dat:                            inserting into the middle of the pattern --
../inputs/grep1.dat:                            Conclusion: (b - 2) - (laststart + 3) + 5,
../inputs/grep1.dat:                            i.e., b - laststart.
../inputs/grep1.dat:                         insert_op2 (set_number_at, laststart, b - laststart,
../inputs/grep1.dat:                                     upper_bound - 1, b);
../inputs/grep1.dat:                   if (p > pattern  &&  p[-1] == '\\')
../inputs/grep1.dat:               operators.  rms says this is ok.  --karl  */
../inputs/grep1.dat:              c1 = c - '0';
../inputs/grep1.dat:	      || *pending_exact == (1 << BYTEWIDTH) - 1
../inputs/grep1.dat:	      pending_exact = b - 1;
../inputs/grep1.dat:  bufp->used = b - bufp->buffer;
../inputs/grep1.dat:/* Store OP at LOC followed by two-byte integer parameter ARG.  */
../inputs/grep1.dat:/* Like `store_op1', but" for 'two two-byte parameters ARG1 and ARG2.  */
../inputs/grep1.dat:   for OP followed by two-byte integer parameter ARG.  */
../inputs/grep1.dat:    *--pto = *--pfrom;
../inputs/grep1.dat:/* Like `insert_op1', but for two two-byte parameters ARG1 and ARG2.  */
../inputs/grep1.dat:    *--pto = *--pfrom;
../inputs/grep1.dat:   after an alternative or a begin-subexpression.  We assume there is at
../inputs/grep1.dat:  const char *prev = p - 2;
../inputs/grep1.dat:  boolean prev_prev_backslash = prev > pattern && prev[-1] == '\\';
../inputs/grep1.dat:  for (this_element = compile_stack.avail - 1;  
../inputs/grep1.dat:       this_element--)
../inputs/grep1.dat:   starting character is in `P[-2]'.  (`P[-1]' is the character `-'.)
../inputs/grep1.dat:     appropriate translation is done in the bit-setting loop below.  */
../inputs/grep1.dat:  range_start = ((unsigned char *) p)[-2];
../inputs/grep1.dat:     char' -- the range is inclusive, so if `range_end' == 0xff
../inputs/grep1.dat:     (assuming 8-bit characters), we would otherwise go into an infinite
../inputs/grep1.dat:#define FAIL_STACK_PTR_EMPTY() (fail_stack_ptr->avail == 0)
../inputs/grep1.dat:/* Initialize `fail_stack'.  Do `return -2' if the alloc fails.  */
../inputs/grep1.dat:      return -2;							\
../inputs/grep1.dat:/* This pushes an item onto the failure stack.  Must be a four-byte
../inputs/grep1.dat:#define POP_FAILURE_ITEM() fail_stack.stack[--fail_stack.avail]
../inputs/grep1.dat:       of 0 + -1 isn't done as unsigned.  */				\
../inputs/grep1.dat:#define MAX_FAILURE_ITEMS ((num_regs - 1) * NUM_REG_ITEMS + NUM_NONREG_ITEMS)
../inputs/grep1.dat:  ((highest_active_reg - lowest_active_reg + 1) * NUM_REG_ITEMS 	\
../inputs/grep1.dat:#define REMAINING_AVAIL_SLOTS ((fail_stack).size - (fail_stack).avail)
../inputs/grep1.dat:     STR -- the saved data position.
../inputs/grep1.dat:     PAT -- the saved pattern position.
../inputs/grep1.dat:     LOW_REG, HIGH_REG -- the highest and lowest active registers.
../inputs/grep1.dat:     REGSTART, REGEND -- arrays of string positions.
../inputs/grep1.dat:     REG_INFO -- array of information about each subexpression.
../inputs/grep1.dat:  for (this_reg = high_reg; this_reg >= low_reg; this_reg--)		\
../inputs/grep1.dat:   The caller must supply the address of a (1 << BYTEWIDTH)-byte data
../inputs/grep1.dat:   area as BUFP->fastmap.
../inputs/grep1.dat:   Returns 0 if we succeed, -2 if an internal error.   */
../inputs/grep1.dat:  register char *fastmap = bufp->fastmap;
../inputs/grep1.dat:  unsigned char *pattern = bufp->buffer;
../inputs/grep1.dat:  unsigned long size = bufp->used;
../inputs/grep1.dat:  bufp->fastmap_accurate = 1;	    /* It will be when we're done.  */
../inputs/grep1.dat:  bufp->can_be_null = 0;
../inputs/grep1.dat:          bufp->can_be_null |= path_can_be_null;
../inputs/grep1.dat:          p = fail_stack.stack[--fail_stack.avail];
../inputs/grep1.dat:	  bufp->can_be_null = 1;
../inputs/grep1.dat:          for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
../inputs/grep1.dat:	  for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
../inputs/grep1.dat:          if (!(bufp->syntax & RE_DOT_NEWLINE))
../inputs/grep1.dat:	  else if (bufp->can_be_null)
../inputs/grep1.dat:	      && fail_stack.stack[fail_stack.avail - 1] == p)
../inputs/grep1.dat:            fail_stack.avail--;
../inputs/grep1.dat:                return -2;
../inputs/grep1.dat:            bufp->can_be_null = 1;
../inputs/grep1.dat:              p -= 4;
../inputs/grep1.dat:         characters for one path of the pattern -- and that the empty
../inputs/grep1.dat:  bufp->can_be_null |= path_can_be_null;
../inputs/grep1.dat:      bufp->regs_allocated = REGS_REALLOCATE;
../inputs/grep1.dat:      regs->num_regs = num_regs;
../inputs/grep1.dat:      regs->start = starts;
../inputs/grep1.dat:      regs->end = ends;
../inputs/grep1.dat:      bufp->regs_allocated = REGS_UNALLOCATED;
../inputs/grep1.dat:      regs->num_regs = 0;
../inputs/grep1.dat:      regs->start = regs->end = (regoff_t) 0;
../inputs/grep1.dat:/* Using the compiled pattern in BUFP->buffer, first tries to match the
../inputs/grep1.dat:   and STRING2 that matched the entire BUFP->buffer and its contained
../inputs/grep1.dat:   found, -1 if no match, or -2 if error (such as failure
../inputs/grep1.dat:  register char *fastmap = bufp->fastmap;
../inputs/grep1.dat:  register char *translate = bufp->translate;
../inputs/grep1.dat:  /* Check for out-of-range STARTPOS.  */
../inputs/grep1.dat:    return -1;
../inputs/grep1.dat:  if (endpos < -1)
../inputs/grep1.dat:    range = -1 - startpos;
../inputs/grep1.dat:    range = total_size - startpos;
../inputs/grep1.dat:  if (bufp->used > 0 && (re_opcode_t) bufp->buffer[0] == begbuf && range > 0)
../inputs/grep1.dat:	return -1;
../inputs/grep1.dat:  if (fastmap && !bufp->fastmap_accurate)
../inputs/grep1.dat:    if (re_compile_fastmap (bufp) == -2)
../inputs/grep1.dat:      return -2;
../inputs/grep1.dat:      if (fastmap && startpos < total_size && !bufp->can_be_null)
../inputs/grep1.dat:                lim = range - (size1 - startpos);
../inputs/grep1.dat:	      d = (startpos >= size1 ? string2 - size1 : string1) + startpos;
../inputs/grep1.dat:              /* Written out as an if-else to avoid testing `translate'
../inputs/grep1.dat:                  range--;
../inputs/grep1.dat:                  range--;
../inputs/grep1.dat:	      startpos += irange - range;
../inputs/grep1.dat:                                 ? string2[startpos - size1] 
../inputs/grep1.dat:          && !bufp->can_be_null)
../inputs/grep1.dat:	return -1;
../inputs/grep1.dat:      if (val == -2)
../inputs/grep1.dat:	return -2;
../inputs/grep1.dat:          range--; 
../inputs/grep1.dat:          startpos--;
../inputs/grep1.dat:  return -1;
../inputs/grep1.dat:/* Structure for per-register (a.k.a. per-group) information.
../inputs/grep1.dat:  (FIRST_STRING_P (ptr) ? (ptr) - string1 : (ptr) - string2 + size1)
../inputs/grep1.dat:#define REG_UNSET_VALUE ((char *) -1)
../inputs/grep1.dat:/* Test if D points to a character which is word-constituent.  We have
../inputs/grep1.dat:           : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\
../inputs/grep1.dat:   to being word-constituent.  */
../inputs/grep1.dat:   || WORDCHAR_P (d - 1) != WORDCHAR_P (d))
../inputs/grep1.dat:   If REGS is non-null and the `no_sub' field of BUFP is nonzero, we
../inputs/grep1.dat:   We return -1 if no match, -2 if an internal error (such as the
../inputs/grep1.dat:  unsigned char *p = bufp->buffer;
../inputs/grep1.dat:  register unsigned char *pend = p + bufp->used;
../inputs/grep1.dat:  char *translate = bufp->translate;
../inputs/grep1.dat:  unsigned num_regs = bufp->re_nsub + 1;
../inputs/grep1.dat:     regnum-th regstart pointer points to where in the pattern we began
../inputs/grep1.dat:     matching and the regnum-th regend points to right after where we
../inputs/grep1.dat:     stopped matching the regnum-th subexpression.  (The zeroth register
../inputs/grep1.dat:     are when we last see its open-group operator.  Similarly for a
../inputs/grep1.dat:     matched any of the pattern so far this time through the reg_num-th
../inputs/grep1.dat:  if (bufp->re_nsub)
../inputs/grep1.dat:          return -2;
../inputs/grep1.dat:      return -1;
../inputs/grep1.dat:  /* Initialize subexpression text positions to -1 to mark ones that no
../inputs/grep1.dat:  /* We move `string1' into `string2' if the latter's empty -- but not if
../inputs/grep1.dat:      end_match_2 = string2 + stop - size1;
../inputs/grep1.dat:      d = string2 + pos - size1;
../inputs/grep1.dat:                     strings `x-' and `y-z-', if the two strings are
../inputs/grep1.dat:          if (regs && !bufp->no_sub)
../inputs/grep1.dat:              if (bufp->regs_allocated == REGS_UNALLOCATED)
../inputs/grep1.dat:                     extra element beyond `num_regs' for the `-1' marker
../inputs/grep1.dat:                  regs->num_regs = MAX (RE_NREGS, num_regs + 1);
../inputs/grep1.dat:                  regs->start = TALLOC (regs->num_regs, regoff_t);
../inputs/grep1.dat:                  regs->end = TALLOC (regs->num_regs, regoff_t);
../inputs/grep1.dat:                  if (regs->start == NULL || regs->end == NULL)
../inputs/grep1.dat:                    return -2;
../inputs/grep1.dat:                  bufp->regs_allocated = REGS_REALLOCATE;
../inputs/grep1.dat:              else if (bufp->regs_allocated == REGS_REALLOCATE)
../inputs/grep1.dat:                  if (regs->num_regs < num_regs + 1)
../inputs/grep1.dat:                      regs->num_regs = num_regs + 1;
../inputs/grep1.dat:                      RETALLOC (regs->start, regs->num_regs, regoff_t);
../inputs/grep1.dat:                      RETALLOC (regs->end, regs->num_regs, regoff_t);
../inputs/grep1.dat:                      if (regs->start == NULL || regs->end == NULL)
../inputs/grep1.dat:                        return -2;
../inputs/grep1.dat:		  /* These braces fend off a "empty body in an else-statement"
../inputs/grep1.dat:		  assert (bufp->regs_allocated == REGS_FIXED);
../inputs/grep1.dat:              if (regs->num_regs > 0)
../inputs/grep1.dat:                  regs->start[0] = pos;
../inputs/grep1.dat:                  regs->end[0] = (MATCHING_IN_FIRST_STRING ? d - string1
../inputs/grep1.dat:			          : d - string2 + size1);
../inputs/grep1.dat:              /* Go through the first `min (num_regs, regs->num_regs)'
../inputs/grep1.dat:	      for (mcnt = 1; mcnt < MIN (num_regs, regs->num_regs); mcnt++)
../inputs/grep1.dat:                    regs->start[mcnt] = regs->end[mcnt] = -1;
../inputs/grep1.dat:		      regs->start[mcnt] = POINTER_TO_OFFSET (regstart[mcnt]);
../inputs/grep1.dat:                      regs->end[mcnt] = POINTER_TO_OFFSET (regend[mcnt]);
../inputs/grep1.dat:                 were in the pattern, set the extra elements to -1.  If
../inputs/grep1.dat:                 -1 at the end.  */
../inputs/grep1.dat:              for (mcnt = num_regs; mcnt < regs->num_regs; mcnt++)
../inputs/grep1.dat:                regs->start[mcnt] = regs->end[mcnt] = -1;
../inputs/grep1.dat:	    } /* regs && !bufp->no_sub */
../inputs/grep1.dat:                        nfailure_points_pushed - nfailure_points_popped);
../inputs/grep1.dat:          mcnt = d - pos - (MATCHING_IN_FIRST_STRING 
../inputs/grep1.dat:			    : string2 - size1);
../inputs/grep1.dat:          /* This is written out as an if-else so we don't waste time
../inputs/grep1.dat:	      while (--mcnt);
../inputs/grep1.dat:	      while (--mcnt);
../inputs/grep1.dat:          if ((!(bufp->syntax & RE_DOT_NEWLINE) && TRANSLATE (*d) == '\n')
../inputs/grep1.dat:              || (bufp->syntax & RE_DOT_NOT_NULL && TRANSLATE (*d) == '\000'))
../inputs/grep1.dat:	    boolean not = (re_opcode_t) *(p - 1) == charset_not;
../inputs/grep1.dat:             we were at this open-group operator in case the group is
../inputs/grep1.dat:             this close-group operator in case the group is operated
../inputs/grep1.dat:              unsigned char r = *p - 1;
../inputs/grep1.dat:                r--;
../inputs/grep1.dat:               || (re_opcode_t) p[-3] == start_memory)
../inputs/grep1.dat:                  PUSH_FAILURE_POINT (p1 + mcnt, d, -2);
../inputs/grep1.dat:		mcnt = dend - d;
../inputs/grep1.dat:                if (mcnt > dend2 - d2)
../inputs/grep1.dat:		  mcnt = dend2 - d2;
../inputs/grep1.dat:              if (!bufp->not_bol) break;
../inputs/grep1.dat:          else if (d[-1] == '\n' && bufp->newline_anchor)
../inputs/grep1.dat:              if (!bufp->not_eol) break;
../inputs/grep1.dat:                   && bufp->newline_anchor)
../inputs/grep1.dat:          PUSH_FAILURE_POINT (p + mcnt, NULL, -2);
../inputs/grep1.dat:          PUSH_FAILURE_POINT (p + mcnt, d, -2);
../inputs/grep1.dat:	    /* Skip over open/close-group commands.  */
../inputs/grep1.dat:  	        p[-3] = (unsigned char) pop_failure_jump;
../inputs/grep1.dat:		     || (bufp->newline_anchor && (re_opcode_t) *p2 == endline))
../inputs/grep1.dat:  		    p[-3] = (unsigned char) pop_failure_jump;
../inputs/grep1.dat:  		        p[-3] = (unsigned char) pop_failure_jump;
../inputs/grep1.dat:	  p -= 2;		/* Point at relative address again.  */
../inputs/grep1.dat:	  if ((re_opcode_t) p[-1] != pop_failure_jump)
../inputs/grep1.dat:	      p[-1] = (unsigned char) jump;
../inputs/grep1.dat:          PUSH_FAILURE_POINT (0, 0, -2);
../inputs/grep1.dat:          PUSH_FAILURE_POINT (0, 0, -2);
../inputs/grep1.dat:               mcnt--;
../inputs/grep1.dat:               mcnt--;
../inputs/grep1.dat:	  if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))
../inputs/grep1.dat:	  if (!AT_STRINGS_BEG (d) && WORDCHAR_P (d - 1)
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING non-Emacs wordchar.\n");
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING non-Emacs notwordchar.\n");
../inputs/grep1.dat:  return -1;         			/* Failure to match.  */
../inputs/grep1.dat:                 So, we have to first go through the first (n-1)
../inputs/grep1.dat:              /* Deal with the first (n-1) alternatives, which start
../inputs/grep1.dat:              while ((re_opcode_t) p1[mcnt-3] == jump_past_alt)
../inputs/grep1.dat:                  if (!alt_match_null_string_p (p1, p1 + mcnt - 3, 
../inputs/grep1.dat:                  /* Break if it's the beginning of an n-th alternative
../inputs/grep1.dat:		  /* Still have to check that it's not an n-th
../inputs/grep1.dat:                  if ((re_opcode_t) p1[mcnt-3] != jump_past_alt)
../inputs/grep1.dat:		      /* Get to the beginning of the n-th alternative.  */
../inputs/grep1.dat:                      p1 -= 3;
../inputs/grep1.dat:              EXTRACT_NUMBER (mcnt, p1 - 2);
../inputs/grep1.dat:              p1 += mcnt;	/* Get past the n-th alternative.  */
../inputs/grep1.dat:          p1 -= 4;
../inputs/grep1.dat:      len--;
../inputs/grep1.dat:     (and at least one extra will be -1).  */
../inputs/grep1.dat:  bufp->regs_allocated = REGS_UNALLOCATED;
../inputs/grep1.dat:  bufp->no_sub = 0;
../inputs/grep1.dat:  bufp->newline_anchor = 1;
../inputs/grep1.dat:     If REG_ICASE is set, then we considers upper- and lowercase
../inputs/grep1.dat:  preg->buffer = 0;
../inputs/grep1.dat:  preg->allocated = 0;
../inputs/grep1.dat:  preg->used = 0;
../inputs/grep1.dat:  preg->fastmap = 0;
../inputs/grep1.dat:      preg->translate = (char *) malloc (CHAR_SET_SIZE);
../inputs/grep1.dat:      if (preg->translate == NULL)
../inputs/grep1.dat:        preg->translate[i] = ISUPPER (i) ? tolower (i) : i;
../inputs/grep1.dat:    preg->translate = NULL;
../inputs/grep1.dat:      preg->newline_anchor = 1;
../inputs/grep1.dat:    preg->newline_anchor = 0;
../inputs/grep1.dat:  preg->no_sub = !!(cflags & REG_NOSUB);
../inputs/grep1.dat:  /* POSIX doesn't distinguish between an unmatched open-group and an
../inputs/grep1.dat:     unmatched close-group: both are REG_EPAREN.  */
../inputs/grep1.dat:  boolean want_reg_info = !preg->no_sub && nmatch > 0;
../inputs/grep1.dat:          strncpy (errbuf, msg, errbuf_size - 1);
../inputs/grep1.dat:          errbuf[errbuf_size - 1] = 0;
../inputs/grep1.dat:  if (preg->buffer != NULL)
../inputs/grep1.dat:    free (preg->buffer);
../inputs/grep1.dat:  preg->buffer = NULL;
../inputs/grep1.dat:  preg->allocated = 0;
../inputs/grep1.dat:  preg->used = 0;
../inputs/grep1.dat:  if (preg->fastmap != NULL)
../inputs/grep1.dat:    free (preg->fastmap);
../inputs/grep1.dat:  preg->fastmap = NULL;
../inputs/grep1.dat:  preg->fastmap_accurate = 0;
../inputs/grep1.dat:  if (preg->translate != NULL)
../inputs/grep1.dat:    free (preg->translate);
../inputs/grep1.dat:  preg->translate = NULL;
../inputs/grep1.dat:make-backup-files: t
../inputs/grep1.dat:version-control: t
../inputs/grep1.dat:trim-versions-without-asking: nil
../inputs/grep1.dat:/* dfa.c - deterministic extended regexp routines for GNU
../inputs/grep1.dat:/* Find the index of charclass s in dfa->charclasses, or allocate a new charclass. */
../inputs/grep1.dat:  for (i = 0; i < dfa->cindex; ++i)
../inputs/grep1.dat:    if (equal(s, dfa->charclasses[i]))
../inputs/grep1.dat:  REALLOC_IF_NECESSARY(dfa->charclasses, charclass, dfa->calloc, dfa->cindex);
../inputs/grep1.dat:  ++dfa->cindex;
../inputs/grep1.dat:  copyset(s, dfa->charclasses[i]);
../inputs/grep1.dat:/* Flag for case-folding letters into sets. */
../inputs/grep1.dat:				   only by zero-width characters. */
../inputs/grep1.dat:    --lexleft;		   	      \
../inputs/grep1.dat:	     {M} - exact count
../inputs/grep1.dat:	     {M,} - minimum count, maximum is infinity
../inputs/grep1.dat:	     {,M} - 0 through M
../inputs/grep1.dat:	     {M,N} - M through N */
../inputs/grep1.dat:	      minrep = c - '0';
../inputs/grep1.dat:		  minrep = 10 * minrep + c - '0';
../inputs/grep1.dat:		maxrep = 10 * maxrep + c - '0';
../inputs/grep1.dat:	  --parens;
../inputs/grep1.dat:	      /* Nobody ever said this had to be fast. :-)
../inputs/grep1.dat:		      lexleft -= strlen(prednames[c1].name);
../inputs/grep1.dat:	      if (c1 == '-')
../inputs/grep1.dat:		      /* In the case [x-], the - is an ordinary hyphen,
../inputs/grep1.dat:		      --lexptr;
../inputs/grep1.dat:  REALLOC_IF_NECESSARY(dfa->tokens, token, dfa->talloc, dfa->tindex);
../inputs/grep1.dat:  dfa->tokens[dfa->tindex++] = t;
../inputs/grep1.dat:      --depth;
../inputs/grep1.dat:      ++dfa->nleaves;
../inputs/grep1.dat:  if (depth > dfa->depth)
../inputs/grep1.dat:    dfa->depth = depth;
../inputs/grep1.dat:  switch (dfa->tokens[tindex - 1])
../inputs/grep1.dat:      return 1 + nsubtoks(tindex - 1);
../inputs/grep1.dat:      ntoks1 = nsubtoks(tindex - 1);
../inputs/grep1.dat:      return 1 + ntoks1 + nsubtoks(tindex - 1 - ntoks1);
../inputs/grep1.dat:    addtok(dfa->tokens[tindex + i]);
../inputs/grep1.dat:	ntokens = nsubtoks(dfa->tindex);
../inputs/grep1.dat:	tindex = dfa->tindex - ntokens;
../inputs/grep1.dat:  depth = d->depth;
../inputs/grep1.dat:  addtok(END - d->nregexps);
../inputs/grep1.dat:  if (d->nregexps)
../inputs/grep1.dat:  ++d->nregexps;
../inputs/grep1.dat:  for (i = 0; i < src->nelem; ++i)
../inputs/grep1.dat:    dst->elems[i] = src->elems[i];
../inputs/grep1.dat:  dst->nelem = src->nelem;
../inputs/grep1.dat:   S->elems must point to an array large enough to hold the resulting set. */
../inputs/grep1.dat:  for (i = 0; i < s->nelem && p.index < s->elems[i].index; ++i)
../inputs/grep1.dat:  if (i < s->nelem && p.index == s->elems[i].index)
../inputs/grep1.dat:    s->elems[i].constraint |= p.constraint;
../inputs/grep1.dat:      ++s->nelem;
../inputs/grep1.dat:      while (i < s->nelem)
../inputs/grep1.dat:	  t2 = s->elems[i];
../inputs/grep1.dat:	  s->elems[i++] = t1;
../inputs/grep1.dat:  m->nelem = 0;
../inputs/grep1.dat:  while (i < s1->nelem && j < s2->nelem)
../inputs/grep1.dat:    if (s1->elems[i].index > s2->elems[j].index)
../inputs/grep1.dat:      m->elems[m->nelem++] = s1->elems[i++];
../inputs/grep1.dat:    else if (s1->elems[i].index < s2->elems[j].index)
../inputs/grep1.dat:      m->elems[m->nelem++] = s2->elems[j++];
../inputs/grep1.dat:	m->elems[m->nelem] = s1->elems[i++];
../inputs/grep1.dat:	m->elems[m->nelem++].constraint |= s2->elems[j++].constraint;
../inputs/grep1.dat:  while (i < s1->nelem)
../inputs/grep1.dat:    m->elems[m->nelem++] = s1->elems[i++];
../inputs/grep1.dat:  while (j < s2->nelem)
../inputs/grep1.dat:    m->elems[m->nelem++] = s2->elems[j++];
../inputs/grep1.dat:  for (i = 0; i < s->nelem; ++i)
../inputs/grep1.dat:    if (p.index == s->elems[i].index)
../inputs/grep1.dat:  if (i < s->nelem)
../inputs/grep1.dat:    for (--s->nelem; i < s->nelem; ++i)
../inputs/grep1.dat:      s->elems[i] = s->elems[i + 1];
../inputs/grep1.dat:  for (i = 0; i < s->nelem; ++i)
../inputs/grep1.dat:    hash ^= s->elems[i].index + s->elems[i].constraint;
../inputs/grep1.dat:  for (i = 0; i < d->sindex; ++i)
../inputs/grep1.dat:      if (hash != d->states[i].hash || s->nelem != d->states[i].elems.nelem
../inputs/grep1.dat:	  || newline != d->states[i].newline || letter != d->states[i].letter)
../inputs/grep1.dat:      for (j = 0; j < s->nelem; ++j)
../inputs/grep1.dat:	if (s->elems[j].constraint
../inputs/grep1.dat:	    != d->states[i].elems.elems[j].constraint
../inputs/grep1.dat:	    || s->elems[j].index != d->states[i].elems.elems[j].index)
../inputs/grep1.dat:      if (j == s->nelem)
../inputs/grep1.dat:  REALLOC_IF_NECESSARY(d->states, dfa_state, d->salloc, d->sindex);
../inputs/grep1.dat:  d->states[i].hash = hash;
../inputs/grep1.dat:  MALLOC(d->states[i].elems.elems, position, s->nelem);
../inputs/grep1.dat:  copy(s, &d->states[i].elems);
../inputs/grep1.dat:  d->states[i].newline = newline;
../inputs/grep1.dat:  d->states[i].letter = letter;
../inputs/grep1.dat:  d->states[i].backref = 0;
../inputs/grep1.dat:  d->states[i].constraint = 0;
../inputs/grep1.dat:  d->states[i].first_end = 0;
../inputs/grep1.dat:  for (j = 0; j < s->nelem; ++j)
../inputs/grep1.dat:    if (d->tokens[s->elems[j].index] < 0)
../inputs/grep1.dat:	constraint = s->elems[j].constraint;
../inputs/grep1.dat:	  d->states[i].constraint |= constraint;
../inputs/grep1.dat:	if (! d->states[i].first_end)
../inputs/grep1.dat:	  d->states[i].first_end = d->tokens[s->elems[j].index];
../inputs/grep1.dat:    else if (d->tokens[s->elems[j].index] == BACKREF)
../inputs/grep1.dat:	d->states[i].constraint = NO_CONSTRAINT;
../inputs/grep1.dat:	d->states[i].backref = 1;
../inputs/grep1.dat:  ++d->sindex;
../inputs/grep1.dat:   S->elems must be large enough to hold the result. */
../inputs/grep1.dat:  MALLOC(visited, int, d->tindex);
../inputs/grep1.dat:  for (i = 0; i < d->tindex; ++i)
../inputs/grep1.dat:  for (i = 0; i < s->nelem; ++i)
../inputs/grep1.dat:    if (d->tokens[s->elems[i].index] >= NOTCHAR
../inputs/grep1.dat:	&& d->tokens[s->elems[i].index] != BACKREF
../inputs/grep1.dat:	&& d->tokens[s->elems[i].index] < CSET)
../inputs/grep1.dat:	old = s->elems[i];
../inputs/grep1.dat:	delete(s->elems[i], s);
../inputs/grep1.dat:	    --i;
../inputs/grep1.dat:	switch (d->tokens[old.index])
../inputs/grep1.dat:	for (j = 0; j < d->follows[old.index].nelem; ++j)
../inputs/grep1.dat:	    p.index = d->follows[old.index].elems[j].index;
../inputs/grep1.dat:	i = -1;
../inputs/grep1.dat:/* Perform bottom-up analysis on the parse tree, computing various functions.
../inputs/grep1.dat:   Because of the postfix representation of the parse tree, the depth-first
../inputs/grep1.dat:   Sets are stored as arrays of the elements, obeying a stack-like allocation
../inputs/grep1.dat:  for (i = 0; i < d->tindex; ++i)
../inputs/grep1.dat:      prtok(d->tokens[i]);
../inputs/grep1.dat:  d->searchflag = searchflag;
../inputs/grep1.dat:  MALLOC(nullable, int, d->depth);
../inputs/grep1.dat:  MALLOC(nfirstpos, int, d->depth);
../inputs/grep1.dat:  MALLOC(firstpos, position, d->nleaves);
../inputs/grep1.dat:  o_firstpos = firstpos, firstpos += d->nleaves;
../inputs/grep1.dat:  MALLOC(nlastpos, int, d->depth);
../inputs/grep1.dat:  MALLOC(lastpos, position, d->nleaves);
../inputs/grep1.dat:  o_lastpos = lastpos, lastpos += d->nleaves;
../inputs/grep1.dat:  MALLOC(nalloc, int, d->tindex);
../inputs/grep1.dat:  for (i = 0; i < d->tindex; ++i)
../inputs/grep1.dat:  MALLOC(merged.elems, position, d->nleaves);
../inputs/grep1.dat:  CALLOC(d->follows, position_set, d->tindex);
../inputs/grep1.dat:  for (i = 0; i < d->tindex; ++i)
../inputs/grep1.dat:    switch (d->tokens[i])
../inputs/grep1.dat:	tmp.nelem = nfirstpos[-1];
../inputs/grep1.dat:	for (j = 0; j < nlastpos[-1]; ++j)
../inputs/grep1.dat:	    merge(&tmp, &d->follows[pos[j].index], &merged);
../inputs/grep1.dat:	    REALLOC_IF_NECESSARY(d->follows[pos[j].index].elems, position,
../inputs/grep1.dat:				 nalloc[pos[j].index], merged.nelem - 1);
../inputs/grep1.dat:	    copy(&merged, &d->follows[pos[j].index]);
../inputs/grep1.dat:	if (d->tokens[i] != PLUS)
../inputs/grep1.dat:	  nullable[-1] = 1;
../inputs/grep1.dat:	tmp.nelem = nfirstpos[-1];
../inputs/grep1.dat:	pos = lastpos + nlastpos[-1];
../inputs/grep1.dat:	for (j = 0; j < nlastpos[-2]; ++j)
../inputs/grep1.dat:	    merge(&tmp, &d->follows[pos[j].index], &merged);
../inputs/grep1.dat:	    REALLOC_IF_NECESSARY(d->follows[pos[j].index].elems, position,
../inputs/grep1.dat:				 nalloc[pos[j].index], merged.nelem - 1);
../inputs/grep1.dat:	    copy(&merged, &d->follows[pos[j].index]);
../inputs/grep1.dat:	if (nullable[-2])
../inputs/grep1.dat:	  nfirstpos[-2] += nfirstpos[-1];
../inputs/grep1.dat:	  firstpos += nfirstpos[-1];
../inputs/grep1.dat:	--nfirstpos;
../inputs/grep1.dat:	if (nullable[-1])
../inputs/grep1.dat:	  nlastpos[-2] += nlastpos[-1];
../inputs/grep1.dat:	    pos = lastpos + nlastpos[-2];
../inputs/grep1.dat:	    for (j = nlastpos[-1] - 1; j >= 0; --j)
../inputs/grep1.dat:	    lastpos += nlastpos[-2];
../inputs/grep1.dat:	    nlastpos[-2] = nlastpos[-1];
../inputs/grep1.dat:	--nlastpos;
../inputs/grep1.dat:	nullable[-2] = nullable[-1] && nullable[-2];
../inputs/grep1.dat:	--nullable;
../inputs/grep1.dat:	nfirstpos[-2] += nfirstpos[-1];
../inputs/grep1.dat:	--nfirstpos;
../inputs/grep1.dat:	nlastpos[-2] += nlastpos[-1];
../inputs/grep1.dat:	--nlastpos;
../inputs/grep1.dat:	nullable[-2] = nullable[-1] || nullable[-2];
../inputs/grep1.dat:	--nullable;
../inputs/grep1.dat:	*nullable++ = d->tokens[i] == BACKREF;
../inputs/grep1.dat:	--firstpos, --lastpos;
../inputs/grep1.dat:	firstpos->index = lastpos->index = i;
../inputs/grep1.dat:	firstpos->constraint = lastpos->constraint = NO_CONSTRAINT;
../inputs/grep1.dat:	MALLOC(d->follows[i].elems, position, nalloc[i]);
../inputs/grep1.dat:      prtok(d->tokens[i]);
../inputs/grep1.dat:      fprintf(stderr, nullable[-1] ? " nullable: yes\n" : " nullable: no\n");
../inputs/grep1.dat:      for (j = nfirstpos[-1] - 1; j >= 0; --j)
../inputs/grep1.dat:	  prtok(d->tokens[firstpos[j].index]);
../inputs/grep1.dat:      for (j = nlastpos[-1] - 1; j >= 0; --j)
../inputs/grep1.dat:	  prtok(d->tokens[lastpos[j].index]);
../inputs/grep1.dat:  for (i = 0; i < d->tindex; ++i)
../inputs/grep1.dat:    if (d->tokens[i] < NOTCHAR || d->tokens[i] == BACKREF
../inputs/grep1.dat:	|| d->tokens[i] >= CSET)
../inputs/grep1.dat:	prtok(d->tokens[i]);
../inputs/grep1.dat:	for (j = d->follows[i].nelem - 1; j >= 0; --j)
../inputs/grep1.dat:	    fprintf(stderr, " %d:", d->follows[i].elems[j].index);
../inputs/grep1.dat:	    prtok(d->tokens[d->follows[i].elems[j].index]);
../inputs/grep1.dat:	copy(&d->follows[i], &merged);
../inputs/grep1.dat:	if (d->follows[i].nelem < merged.nelem)
../inputs/grep1.dat:	  REALLOC(d->follows[i].elems, position, merged.nelem);
../inputs/grep1.dat:	copy(&merged, &d->follows[i]);
../inputs/grep1.dat:  for (i = 0; i < nfirstpos[-1]; ++i)
../inputs/grep1.dat:  d->salloc = 1;
../inputs/grep1.dat:  d->sindex = 0;
../inputs/grep1.dat:  MALLOC(d->states, dfa_state, d->salloc);
../inputs/grep1.dat:   The collection of groups is constructed by building an equivalence-class
../inputs/grep1.dat:   intersection with C.  If L - C is nonempty, create a new group labeled
../inputs/grep1.dat:   L - C and having the same positions as the current group, and set L to
../inputs/grep1.dat:   C = C - L, and resume scanning.
../inputs/grep1.dat:  for (i = 0; i < d->states[s].elems.nelem; ++i)
../inputs/grep1.dat:      pos = d->states[s].elems.elems[i];
../inputs/grep1.dat:      if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR)
../inputs/grep1.dat:	setbit(d->tokens[pos.index], matches);
../inputs/grep1.dat:      else if (d->tokens[pos.index] >= CSET)
../inputs/grep1.dat:	copyset(d->charclasses[d->tokens[pos.index] - CSET], matches);
../inputs/grep1.dat:					 d->states[s].newline, 1))
../inputs/grep1.dat:					 d->states[s].newline, 0))
../inputs/grep1.dat:					d->states[s].letter, 1))
../inputs/grep1.dat:					d->states[s].letter, 0))
../inputs/grep1.dat:	  if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR
../inputs/grep1.dat:	      && !tstbit(d->tokens[pos.index], labels[j]))
../inputs/grep1.dat:	      MALLOC(grps[ngrps].elems, position, d->nleaves);
../inputs/grep1.dat:	  MALLOC(grps[ngrps].elems, position, d->nleaves);
../inputs/grep1.dat:  MALLOC(follows.elems, position, d->nleaves);
../inputs/grep1.dat:  MALLOC(tmp.elems, position, d->nleaves);
../inputs/grep1.dat:  if (d->searchflag)
../inputs/grep1.dat:      for (i = 0; i < d->states[0].elems.nelem; ++i)
../inputs/grep1.dat:	  if (PREV_NEWLINE_DEPENDENT(d->states[0].elems.elems[i].constraint))
../inputs/grep1.dat:	  if (PREV_LETTER_DEPENDENT(d->states[0].elems.elems[i].constraint))
../inputs/grep1.dat:      copy(&d->states[0].elems, &follows);
../inputs/grep1.dat:      trans[i] = -1;
../inputs/grep1.dat:	for (k = 0; k < d->follows[grps[i].elems[j].index].nelem; ++k)
../inputs/grep1.dat:	  insert(d->follows[grps[i].elems[j].index].elems[k], &follows);
../inputs/grep1.dat:      if (d->searchflag)
../inputs/grep1.dat:	for (j = 0; j < d->states[0].elems.nelem; ++j)
../inputs/grep1.dat:	  insert(d->states[0].elems.elems[j], &follows);
../inputs/grep1.dat:   is a non-accepting state, then d->trans[state] points to its table.
../inputs/grep1.dat:   If it is an accepting state then d->fails[state] points to its table.
../inputs/grep1.dat:   If it has no table at all, then d->trans[state] is NULL.
../inputs/grep1.dat:  if (d->trcount >= 1024)
../inputs/grep1.dat:      for (i = 0; i < d->tralloc; ++i)
../inputs/grep1.dat:	if (d->trans[i])
../inputs/grep1.dat:	    free((ptr_t) d->trans[i]);
../inputs/grep1.dat:	    d->trans[i] = NULL;
../inputs/grep1.dat:	else if (d->fails[i])
../inputs/grep1.dat:	    free((ptr_t) d->fails[i]);
../inputs/grep1.dat:	    d->fails[i] = NULL;
../inputs/grep1.dat:      d->trcount = 0;
../inputs/grep1.dat:  ++d->trcount;
../inputs/grep1.dat:  d->success[s] = 0;
../inputs/grep1.dat:  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 1, d->states[s].letter, 0,
../inputs/grep1.dat:    d->success[s] |= 4;
../inputs/grep1.dat:  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 0, d->states[s].letter, 1,
../inputs/grep1.dat:    d->success[s] |= 2;
../inputs/grep1.dat:  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 0, d->states[s].letter, 0,
../inputs/grep1.dat:    d->success[s] |= 1;
../inputs/grep1.dat:    if (trans[i] >= d->tralloc)
../inputs/grep1.dat:	int oldalloc = d->tralloc;
../inputs/grep1.dat:	while (trans[i] >= d->tralloc)
../inputs/grep1.dat:	  d->tralloc *= 2;
../inputs/grep1.dat:	REALLOC(d->realtrans, int *, d->tralloc + 1);
../inputs/grep1.dat:	d->trans = d->realtrans + 1;
../inputs/grep1.dat:	REALLOC(d->fails, int *, d->tralloc);
../inputs/grep1.dat:	REALLOC(d->success, int, d->tralloc);
../inputs/grep1.dat:	REALLOC(d->newlines, int, d->tralloc);
../inputs/grep1.dat:	while (oldalloc < d->tralloc)
../inputs/grep1.dat:	    d->trans[oldalloc] = NULL;
../inputs/grep1.dat:	    d->fails[oldalloc++] = NULL;
../inputs/grep1.dat:  d->newlines[s] = trans['\n'];
../inputs/grep1.dat:  trans['\n'] = -1;
../inputs/grep1.dat:    d->fails[s] = trans;
../inputs/grep1.dat:    d->trans[s] = trans;
../inputs/grep1.dat:  d->tralloc = 1;
../inputs/grep1.dat:  d->trcount = 0;
../inputs/grep1.dat:  CALLOC(d->realtrans, int *, d->tralloc + 1);
../inputs/grep1.dat:  d->trans = d->realtrans + 1;
../inputs/grep1.dat:  CALLOC(d->fails, int *, d->tralloc);
../inputs/grep1.dat:  MALLOC(d->success, int, d->tralloc);
../inputs/grep1.dat:  MALLOC(d->newlines, int, d->tralloc);
../inputs/grep1.dat:   allow newlines to be in the matching string.  If count is non-
../inputs/grep1.dat:   see a newline.  Finally, if backref is non-NULL it points to a place
../inputs/grep1.dat:  register **trans, *t;		/* Copy of d->trans so it can be optimized
../inputs/grep1.dat:  static sbit[NOTCHAR];	/* Table for anding with d->success. */
../inputs/grep1.dat:  if (! d->tralloc)
../inputs/grep1.dat:  trans = d->trans;
../inputs/grep1.dat:      if (s >= 0 && p <= (unsigned char *) end && d->fails[s])
../inputs/grep1.dat:	  if (d->success[s] & sbit[*p])
../inputs/grep1.dat:		if (d->states[s].backref)
../inputs/grep1.dat:	  s = d->fails[s][*p++];
../inputs/grep1.dat:      if (count && (char *) p <= end && p[-1] == '\n')
../inputs/grep1.dat:	  trans = d->trans;
../inputs/grep1.dat:      if (p[-1] == '\n' && newline)
../inputs/grep1.dat:	  s = d->newlines[s1];
../inputs/grep1.dat:  d->calloc = 1;
../inputs/grep1.dat:  MALLOC(d->charclasses, charclass, d->calloc);
../inputs/grep1.dat:  d->cindex = 0;
../inputs/grep1.dat:  d->talloc = 1;
../inputs/grep1.dat:  MALLOC(d->tokens, token, d->talloc);
../inputs/grep1.dat:  d->tindex = d->depth = d->nleaves = d->nregexps = 0;
../inputs/grep1.dat:  d->searchflag = 0;
../inputs/grep1.dat:  d->tralloc = 0;
../inputs/grep1.dat:  d->musts = 0;
../inputs/grep1.dat:      d->cindex = d->tindex = d->depth = d->nleaves = d->nregexps = 0;
../inputs/grep1.dat:  free((ptr_t) d->charclasses);
../inputs/grep1.dat:  free((ptr_t) d->tokens);
../inputs/grep1.dat:  for (i = 0; i < d->sindex; ++i)
../inputs/grep1.dat:    free((ptr_t) d->states[i].elems.elems);
../inputs/grep1.dat:  free((ptr_t) d->states);
../inputs/grep1.dat:  for (i = 0; i < d->tindex; ++i)
../inputs/grep1.dat:    if (d->follows[i].elems)
../inputs/grep1.dat:      free((ptr_t) d->follows[i].elems);
../inputs/grep1.dat:  free((ptr_t) d->follows);
../inputs/grep1.dat:  for (i = 0; i < d->tralloc; ++i)
../inputs/grep1.dat:    if (d->trans[i])
../inputs/grep1.dat:      free((ptr_t) d->trans[i]);
../inputs/grep1.dat:    else if (d->fails[i])
../inputs/grep1.dat:      free((ptr_t) d->fails[i]);
../inputs/grep1.dat:  free((ptr_t) d->realtrans);
../inputs/grep1.dat:  free((ptr_t) d->fails);
../inputs/grep1.dat:  free((ptr_t) d->newlines);
../inputs/grep1.dat:  for (dm = d->musts; dm; dm = ndm)
../inputs/grep1.dat:      ndm = dm->next;
../inputs/grep1.dat:      free(dm->must);
../inputs/grep1.dat:   (Take "(ab|a)b"--please.)
../inputs/grep1.dat:   We do a bottom-up calculation of sequences of characters that must appear
../inputs/grep1.dat:   d->must (where "d" is the single argument passed to "dfamust");
../inputs/grep1.dat:   the length of the sequence is returned in d->mustn.
../inputs/grep1.dat:   are shown below.  "p" is the operand of unary operators (and the left-hand
../inputs/grep1.dat:   operand of binary operators); "q" is the right-hand operand of binary
../inputs/grep1.dat:   "ZERO" means "a zero-length sequence" below.
../inputs/grep1.dat:	----	----		-----		--		--
../inputs/grep1.dat:	PLUS	p->left		p->right	ZERO		p->in
../inputs/grep1.dat:	CAT	(p->is==ZERO)?	(q->is==ZERO)?	(p->is!=ZERO &&	p->in plus
../inputs/grep1.dat:		p->left :	q->right :	q->is!=ZERO) ?	q->in plus
../inputs/grep1.dat:		p->is##q->left	p->right##q->is	p->is##q->is :	p->right##q->left
../inputs/grep1.dat:	OR	longest common	longest common	(do p->is and	substrings common to
../inputs/grep1.dat:		leading		trailing	q->is have same	p->in and q->in
../inputs/grep1.dat:		of p->left	of p->right	content) ?	
../inputs/grep1.dat:		and q->left	and q->right	p->is : NULL	
../inputs/grep1.dat:   to zero-length sequences.  If there's something we don't recognize in the tree,
../inputs/grep1.dat:   we just return a zero-length sequence.
../inputs/grep1.dat:	egrep 'psi|epsilon'	->	egrep 'psi'
../inputs/grep1.dat:	egrep 'pepsi|epsilon'	->	egrep 'epsi'
../inputs/grep1.dat:	grep '[c]'		->	grep 'c'
../inputs/grep1.dat:	grep '(ab|a)b'		->	grep 'ab'
../inputs/grep1.dat:	grep 'ab*'		->	grep 'a'
../inputs/grep1.dat:	grep 'a*b'		->	grep 'b'
../inputs/grep1.dat:   Are optimizable r.e.'s likely to be used in real-life situations
../inputs/grep1.dat:	if (--i == j)
../inputs/grep1.dat:  mp->left[0] = mp->right[0] = mp->is[0] = '\0';
../inputs/grep1.dat:  freelist(mp->in);
../inputs/grep1.dat:  musts = (must *) malloc((dfa->tindex + 1) * sizeof *musts);
../inputs/grep1.dat:  for (i = 0; i <= dfa->tindex; ++i)
../inputs/grep1.dat:  for (i = 0; i <= dfa->tindex; ++i)
../inputs/grep1.dat:  for (i = 0; i < dfa->tindex; ++i)
../inputs/grep1.dat:      prtok(dfa->tokens[i]);
../inputs/grep1.dat:  for (ri = 0; ri < dfa->tindex; ++ri)
../inputs/grep1.dat:      switch (t = dfa->tokens[ri])
../inputs/grep1.dat:	  --mp;
../inputs/grep1.dat:	    rmp = --mp;
../inputs/grep1.dat:	    lmp = --mp;
../inputs/grep1.dat:	    if (strcmp(lmp->is, rmp->is) != 0)
../inputs/grep1.dat:	      lmp->is[0] = '\0';
../inputs/grep1.dat:	    /* Left side--easy */
../inputs/grep1.dat:	    while (lmp->left[i] != '\0' && lmp->left[i] == rmp->left[i])
../inputs/grep1.dat:	    lmp->left[i] = '\0';
../inputs/grep1.dat:	    ln = strlen(lmp->right);
../inputs/grep1.dat:	    rn = strlen(rmp->right);
../inputs/grep1.dat:	      if (lmp->right[ln - i - 1] != rmp->right[rn - i - 1])
../inputs/grep1.dat:	      lmp->right[j] = lmp->right[(ln - i) + j];
../inputs/grep1.dat:	    lmp->right[j] = '\0';
../inputs/grep1.dat:	    new = inboth(lmp->in, rmp->in);
../inputs/grep1.dat:	    freelist(lmp->in);
../inputs/grep1.dat:	    free((char *) lmp->in);
../inputs/grep1.dat:	    lmp->in = new;
../inputs/grep1.dat:	  --mp;
../inputs/grep1.dat:	  mp->is[0] = '\0';
../inputs/grep1.dat:	    rmp = --mp;
../inputs/grep1.dat:	    lmp = --mp;
../inputs/grep1.dat:	    lmp->in = addlists(lmp->in, rmp->in);
../inputs/grep1.dat:	    if (lmp->in == NULL)
../inputs/grep1.dat:	    if (lmp->right[0] != '\0' &&
../inputs/grep1.dat:		rmp->left[0] != '\0')
../inputs/grep1.dat:		tp = icpyalloc(lmp->right);
../inputs/grep1.dat:		tp = icatalloc(tp, rmp->left);
../inputs/grep1.dat:		lmp->in = enlist(lmp->in, tp,
../inputs/grep1.dat:		if (lmp->in == NULL)
../inputs/grep1.dat:	    /* Left-hand */
../inputs/grep1.dat:	    if (lmp->is[0] != '\0')
../inputs/grep1.dat:		lmp->left = icatalloc(lmp->left,
../inputs/grep1.dat:				      rmp->left);
../inputs/grep1.dat:		if (lmp->left == NULL)
../inputs/grep1.dat:	    /* Right-hand */
../inputs/grep1.dat:	    if (rmp->is[0] == '\0')
../inputs/grep1.dat:	      lmp->right[0] = '\0';
../inputs/grep1.dat:	    lmp->right = icatalloc(lmp->right, rmp->right);
../inputs/grep1.dat:	    if (lmp->right == NULL)
../inputs/grep1.dat:	    if (lmp->is[0] != '\0' && rmp->is[0] != '\0')
../inputs/grep1.dat:		lmp->is = icatalloc(lmp->is, rmp->is);
../inputs/grep1.dat:		if (lmp->is == NULL)
../inputs/grep1.dat:	      lmp->is[0] = '\0';
../inputs/grep1.dat:	      mp->is[0] = mp->left[0] = mp->right[0] = t;
../inputs/grep1.dat:	      mp->is[1] = mp->left[1] = mp->right[1] = '\0';
../inputs/grep1.dat:	      mp->in = enlist(mp->in, mp->is, 1);
../inputs/grep1.dat:	      if (mp->in == NULL)
../inputs/grep1.dat:      prtok(dfa->tokens[ri]);
../inputs/grep1.dat:      for (i = 0; mp->in[i]; ++i)
../inputs/grep1.dat:	fprintf(stderr, " \"%s\"", mp->in[i]);
../inputs/grep1.dat:      fprintf(stderr, "\n  is: \"%s\"\n", mp->is);
../inputs/grep1.dat:      fprintf(stderr, "  left: \"%s\"\n", mp->left);
../inputs/grep1.dat:      fprintf(stderr, "  right: \"%s\"\n", mp->right);
../inputs/grep1.dat:      dm->exact = exact;
../inputs/grep1.dat:      dm->must = malloc(strlen(result) + 1);
../inputs/grep1.dat:      strcpy(dm->must, result);
../inputs/grep1.dat:      dm->next = dfa->musts;
../inputs/grep1.dat:      dfa->musts = dm;
../inputs/grep1.dat:  for (i = 0; i <= dfa->tindex; ++i)
../inputs/grep1.dat:/* kwset.c - search for any of a set of keywords.
../inputs/grep1.dat:   to one discovered by Beate Commentz-Walter, although it is not identical.
../inputs/grep1.dat:   IBM-Germany, Scientific Center Heidelberg, Tiergartenstrasse 15, D-6900
../inputs/grep1.dat:  struct trie *fail;		/* Aho-Corasick failure function. */
../inputs/grep1.dat:  int mind2;			/* Used in Boyer-Moore search for one string. */
../inputs/grep1.dat:  obstack_init(&kwset->obstack);
../inputs/grep1.dat:  kwset->words = 0;
../inputs/grep1.dat:  kwset->trie
../inputs/grep1.dat:    = (struct trie *) obstack_alloc(&kwset->obstack, sizeof (struct trie));
../inputs/grep1.dat:  if (!kwset->trie)
../inputs/grep1.dat:  kwset->trie->accepting = 0;
../inputs/grep1.dat:  kwset->trie->links = 0;
../inputs/grep1.dat:  kwset->trie->parent = 0;
../inputs/grep1.dat:  kwset->trie->next = 0;
../inputs/grep1.dat:  kwset->trie->fail = 0;
../inputs/grep1.dat:  kwset->trie->depth = 0;
../inputs/grep1.dat:  kwset->trie->shift = 0;
../inputs/grep1.dat:  kwset->mind = INT_MAX;
../inputs/grep1.dat:  kwset->maxd = -1;
../inputs/grep1.dat:  kwset->target = 0;
../inputs/grep1.dat:  kwset->trans = trans;
../inputs/grep1.dat:  trie = kwset->trie;
../inputs/grep1.dat:  /* Descend the trie (built of reversed keywords) character-by-character,
../inputs/grep1.dat:  while (len--)
../inputs/grep1.dat:      label = kwset->trans ? kwset->trans[(unsigned char) *--text] : *--text;
../inputs/grep1.dat:      link = trie->links;
../inputs/grep1.dat:      links[0] = (struct tree *) &trie->links;
../inputs/grep1.dat:      while (link && label != link->label)
../inputs/grep1.dat:	  if (label < link->label)
../inputs/grep1.dat:	    dirs[depth++] = L, link = link->llink;
../inputs/grep1.dat:	    dirs[depth++] = R, link = link->rlink;
../inputs/grep1.dat:	  link = (struct tree *) obstack_alloc(&kwset->obstack,
../inputs/grep1.dat:	  link->llink = 0;
../inputs/grep1.dat:	  link->rlink = 0;
../inputs/grep1.dat:	  link->trie = (struct trie *) obstack_alloc(&kwset->obstack,
../inputs/grep1.dat:	  if (!link->trie)
../inputs/grep1.dat:	  link->trie->accepting = 0;
../inputs/grep1.dat:	  link->trie->links = 0;
../inputs/grep1.dat:	  link->trie->parent = trie;
../inputs/grep1.dat:	  link->trie->next = 0;
../inputs/grep1.dat:	  link->trie->fail = 0;
../inputs/grep1.dat:	  link->trie->depth = trie->depth + 1;
../inputs/grep1.dat:	  link->trie->shift = 0;
../inputs/grep1.dat:	  link->label = label;
../inputs/grep1.dat:	  link->balance = 0;
../inputs/grep1.dat:	  if (dirs[--depth] == L)
../inputs/grep1.dat:	    links[depth]->llink = link;
../inputs/grep1.dat:	    links[depth]->rlink = link;
../inputs/grep1.dat:	  while (depth && !links[depth]->balance)
../inputs/grep1.dat:		--links[depth]->balance;
../inputs/grep1.dat:		++links[depth]->balance;
../inputs/grep1.dat:	      --depth;
../inputs/grep1.dat:	  if (depth && ((dirs[depth] == L && --links[depth]->balance)
../inputs/grep1.dat:			|| (dirs[depth] == R && ++links[depth]->balance)))
../inputs/grep1.dat:	      switch (links[depth]->balance)
../inputs/grep1.dat:		case (char) -2:
../inputs/grep1.dat:		      r = links[depth], t = r->llink, rl = t->rlink;
../inputs/grep1.dat:		      t->rlink = r, r->llink = rl;
../inputs/grep1.dat:		      t->balance = r->balance = 0;
../inputs/grep1.dat:		      r = links[depth], l = r->llink, t = l->rlink;
../inputs/grep1.dat:		      rl = t->rlink, lr = t->llink;
../inputs/grep1.dat:		      t->llink = l, l->rlink = lr, t->rlink = r, r->llink = rl;
../inputs/grep1.dat:		      l->balance = t->balance != 1 ? 0 : -1;
../inputs/grep1.dat:		      r->balance = t->balance != (char) -1 ? 0 : 1;
../inputs/grep1.dat:		      t->balance = 0;
../inputs/grep1.dat:		      l = links[depth], t = l->rlink, lr = t->llink;
../inputs/grep1.dat:		      t->llink = l, l->rlink = lr;
../inputs/grep1.dat:		      t->balance = l->balance = 0;
../inputs/grep1.dat:		      l = links[depth], r = l->rlink, t = r->llink;
../inputs/grep1.dat:		      lr = t->llink, rl = t->rlink;
../inputs/grep1.dat:		      t->llink = l, l->rlink = lr, t->rlink = r, r->llink = rl;
../inputs/grep1.dat:		      l->balance = t->balance != 1 ? 0 : -1;
../inputs/grep1.dat:		      r->balance = t->balance != (char) -1 ? 0 : 1;
../inputs/grep1.dat:		      t->balance = 0;
../inputs/grep1.dat:	      if (dirs[depth - 1] == L)
../inputs/grep1.dat:		links[depth - 1]->llink = t;
../inputs/grep1.dat:		links[depth - 1]->rlink = t;
../inputs/grep1.dat:      trie = link->trie;
../inputs/grep1.dat:  if (!trie->accepting)
../inputs/grep1.dat:    trie->accepting = 1 + 2 * kwset->words;
../inputs/grep1.dat:  ++kwset->words;
../inputs/grep1.dat:  if (trie->depth < kwset->mind)
../inputs/grep1.dat:    kwset->mind = trie->depth;
../inputs/grep1.dat:  if (trie->depth > kwset->maxd)
../inputs/grep1.dat:    kwset->maxd = trie->depth;
../inputs/grep1.dat:  enqueue(tree->llink, last);
../inputs/grep1.dat:  enqueue(tree->rlink, last);
../inputs/grep1.dat:  (*last) = (*last)->next = tree->trie;
../inputs/grep1.dat:/* Compute the Aho-Corasick failure function for the trie nodes referenced
../inputs/grep1.dat:  treefails(tree->llink, fail, recourse);
../inputs/grep1.dat:  treefails(tree->rlink, fail, recourse);
../inputs/grep1.dat:      link = fail->links;
../inputs/grep1.dat:      while (link && tree->label != link->label)
../inputs/grep1.dat:	if (tree->label < link->label)
../inputs/grep1.dat:	  link = link->llink;
../inputs/grep1.dat:	  link = link->rlink;
../inputs/grep1.dat:	  tree->trie->fail = link->trie;
../inputs/grep1.dat:      fail = fail->fail;
../inputs/grep1.dat:  tree->trie->fail = recourse;
../inputs/grep1.dat:  treedelta(tree->llink, depth, delta);
../inputs/grep1.dat:  treedelta(tree->rlink, depth, delta);
../inputs/grep1.dat:  if (depth < delta[tree->label])
../inputs/grep1.dat:    delta[tree->label] = depth;
../inputs/grep1.dat:  if (!hasevery(a, b->llink))
../inputs/grep1.dat:  if (!hasevery(a, b->rlink))
../inputs/grep1.dat:  while (a && b->label != a->label)
../inputs/grep1.dat:    if (b->label < a->label)
../inputs/grep1.dat:      a = a->llink;
../inputs/grep1.dat:      a = a->rlink;
../inputs/grep1.dat:  treenext(tree->llink, next);
../inputs/grep1.dat:  treenext(tree->rlink, next);
../inputs/grep1.dat:  next[tree->label] = tree->trie;
../inputs/grep1.dat:  if (kwset->mind < 256)
../inputs/grep1.dat:      delta[i] = kwset->mind;
../inputs/grep1.dat:  /* Check if we can use the simple boyer-moore algorithm, instead
../inputs/grep1.dat:     of the hairy commentz-walter algorithm. */
../inputs/grep1.dat:  if (kwset->words == 1 && kwset->trans == 0)
../inputs/grep1.dat:      kwset->target = obstack_alloc(&kwset->obstack, kwset->mind);
../inputs/grep1.dat:      for (i = kwset->mind - 1, curr = kwset->trie; i >= 0; --i)
../inputs/grep1.dat:	  kwset->target[i] = curr->links->label;
../inputs/grep1.dat:	  curr = curr->links->trie;
../inputs/grep1.dat:      for (i = 0; i < kwset->mind; ++i)
../inputs/grep1.dat:	delta[(unsigned char) kwset->target[i]] = kwset->mind - (i + 1);
../inputs/grep1.dat:      kwset->mind2 = kwset->mind;
../inputs/grep1.dat:      for (i = 0; i < kwset->mind - 1; ++i)
../inputs/grep1.dat:	if (kwset->target[i] == kwset->target[kwset->mind - 1])
../inputs/grep1.dat:	  kwset->mind2 = kwset->mind - (i + 1);
../inputs/grep1.dat:      for (curr = last = kwset->trie; curr; curr = curr->next)
../inputs/grep1.dat:	  enqueue(curr->links, &last);
../inputs/grep1.dat:	  curr->shift = kwset->mind;
../inputs/grep1.dat:	  curr->maxshift = kwset->mind;
../inputs/grep1.dat:	  treedelta(curr->links, curr->depth, delta);
../inputs/grep1.dat:	  treefails(curr->links, curr->fail, kwset->trie);
../inputs/grep1.dat:	  for (fail = curr->fail; fail; fail = fail->fail)
../inputs/grep1.dat:	      if (!hasevery(fail->links, curr->links))
../inputs/grep1.dat:		if (curr->depth - fail->depth < fail->shift)
../inputs/grep1.dat:		  fail->shift = curr->depth - fail->depth;
../inputs/grep1.dat:	      if (curr->accepting && fail->maxshift > curr->depth - fail->depth)
../inputs/grep1.dat:		fail->maxshift = curr->depth - fail->depth;
../inputs/grep1.dat:      for (curr = kwset->trie->next; curr; curr = curr->next)
../inputs/grep1.dat:	  if (curr->maxshift > curr->parent->maxshift)
../inputs/grep1.dat:	    curr->maxshift = curr->parent->maxshift;
../inputs/grep1.dat:	  if (curr->shift > curr->maxshift)
../inputs/grep1.dat:	    curr->shift = curr->maxshift;
../inputs/grep1.dat:      treenext(kwset->trie->links, next);
../inputs/grep1.dat:      if ((trans = kwset->trans) != 0)
../inputs/grep1.dat:	  kwset->next[i] = next[(unsigned char) trans[i]];
../inputs/grep1.dat:	  kwset->next[i] = next[i];
../inputs/grep1.dat:  if ((trans = kwset->trans) != 0)
../inputs/grep1.dat:      kwset->delta[i] = delta[(unsigned char) trans[i]];
../inputs/grep1.dat:      kwset->delta[i] = delta[i];
../inputs/grep1.dat:/* Fast boyer-moore search. */
../inputs/grep1.dat:  len = kwset->mind;
../inputs/grep1.dat:    return memchr(text, kwset->target[0], size);
../inputs/grep1.dat:  d1 = kwset->delta;
../inputs/grep1.dat:  sp = kwset->target + len;
../inputs/grep1.dat:  gc = U(sp[-2]);
../inputs/grep1.dat:  md2 = kwset->mind2;
../inputs/grep1.dat:    for (ep = text + size - 11 * len;;)
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	if (U(tp[-2]) == gc)
../inputs/grep1.dat:	    for (i = 3; i <= len && U(tp[-i]) == U(sp[-i]); ++i)
../inputs/grep1.dat:	      return tp - len;
../inputs/grep1.dat:     carefully avoid ever producing an out-of-bounds pointer. */
../inputs/grep1.dat:  d = d1[U(tp[-1])];
../inputs/grep1.dat:  while (d <= ep - tp)
../inputs/grep1.dat:      d = d1[U((tp += d)[-1])];
../inputs/grep1.dat:      if (tp[-2] == gc)
../inputs/grep1.dat:	  for (i = 3; i <= len && U(tp[-i]) == U(sp[-i]); ++i)
../inputs/grep1.dat:	    return tp - len;
../inputs/grep1.dat:  if (len < kwset->mind)
../inputs/grep1.dat:  next = kwset->next;
../inputs/grep1.dat:  delta = kwset->delta;
../inputs/grep1.dat:  trans = kwset->trans;
../inputs/grep1.dat:  if ((d = kwset->mind) != 0)
../inputs/grep1.dat:      mch = text, accept = kwset->trie;
../inputs/grep1.dat:  if (len >= 4 * kwset->mind)
../inputs/grep1.dat:    qlim = lim - 4 * kwset->mind;
../inputs/grep1.dat:  while (lim - end >= d)
../inputs/grep1.dat:	  end += d - 1;
../inputs/grep1.dat:	d = delta[c = (end += d)[-1]];
../inputs/grep1.dat:      beg = end - 1;
../inputs/grep1.dat:      if (trie->accepting)
../inputs/grep1.dat:      d = trie->shift;
../inputs/grep1.dat:	  c = trans ? trans[(unsigned char) *--beg] : *--beg;
../inputs/grep1.dat:	  tree = trie->links;
../inputs/grep1.dat:	  while (tree && c != tree->label)
../inputs/grep1.dat:	    if (c < tree->label)
../inputs/grep1.dat:	      tree = tree->llink;
../inputs/grep1.dat:	      tree = tree->rlink;
../inputs/grep1.dat:	      trie = tree->trie;
../inputs/grep1.dat:	      if (trie->accepting)
../inputs/grep1.dat:	  d = trie->shift;
../inputs/grep1.dat:  if (lim - mch > kwset->maxd)
../inputs/grep1.dat:    lim = mch + kwset->maxd;
../inputs/grep1.dat:  while (lim - end >= d)
../inputs/grep1.dat:      if ((d = delta[c = (end += d)[-1]]) != 0)
../inputs/grep1.dat:      beg = end - 1;
../inputs/grep1.dat:      if (trie->accepting && beg <= mch)
../inputs/grep1.dat:      d = trie->shift;
../inputs/grep1.dat:	  c = trans ? trans[(unsigned char) *--beg] : *--beg;
../inputs/grep1.dat:	  tree = trie->links;
../inputs/grep1.dat:	  while (tree && c != tree->label)
../inputs/grep1.dat:	    if (c < tree->label)
../inputs/grep1.dat:	      tree = tree->llink;
../inputs/grep1.dat:	      tree = tree->rlink;
../inputs/grep1.dat:	      trie = tree->trie;
../inputs/grep1.dat:	      if (trie->accepting && beg <= mch)
../inputs/grep1.dat:	  d = trie->shift;
../inputs/grep1.dat:      kwsmatch->index = accept->accepting / 2;
../inputs/grep1.dat:      kwsmatch->beg[0] = mch;
../inputs/grep1.dat:      kwsmatch->size[0] = accept->depth;
../inputs/grep1.dat:   is non-NULL store in the referenced location the length of the
../inputs/grep1.dat:   matching substring.  Similarly, if FOUNDIDX is non-NULL, store
../inputs/grep1.dat:  if (kwset->words == 1 && kwset->trans == 0)
../inputs/grep1.dat:	  kwsmatch->index = 0;
../inputs/grep1.dat:	  kwsmatch->beg[0] = ret;
../inputs/grep1.dat:	  kwsmatch->size[0] = kwset->mind;
../inputs/grep1.dat:  obstack_free(&kwset->obstack, 0);
../inputs/grep1.dat:/* obstack.c - subroutines used implicitly by object stack macros
../inputs/grep1.dat:   program understand `configure --with-gnu-libc' and omit the object files,
../inputs/grep1.dat:  ((PTR_INT_TYPE) ((char *)&((struct fooalign *) 0)->d - (char *)0))
../inputs/grep1.dat:/* The non-GNU-C macros copy the obstack into this global variable
../inputs/grep1.dat:  (((h) -> use_extra_arg) \
../inputs/grep1.dat:   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
../inputs/grep1.dat:   : (*(h)->chunkfun) ((size)))
../inputs/grep1.dat:    if ((h) -> use_extra_arg) \
../inputs/grep1.dat:      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
../inputs/grep1.dat:      (*(h)->freefun) ((old_chunk)); \
../inputs/grep1.dat:    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
../inputs/grep1.dat:      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
../inputs/grep1.dat:		    + 4 + DEFAULT_ROUNDING - 1)
../inputs/grep1.dat:		   & ~(DEFAULT_ROUNDING - 1));
../inputs/grep1.dat:      size = 4096 - extra;
../inputs/grep1.dat:  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
../inputs/grep1.dat:  h->freefun = freefun;
../inputs/grep1.dat:  h->chunk_size = size;
../inputs/grep1.dat:  h->alignment_mask = alignment - 1;
../inputs/grep1.dat:  h->use_extra_arg = 0;
../inputs/grep1.dat:  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
../inputs/grep1.dat:  h->next_free = h->object_base = chunk->contents;
../inputs/grep1.dat:  h->chunk_limit = chunk->limit
../inputs/grep1.dat:    = (char *) chunk + h->chunk_size;
../inputs/grep1.dat:  chunk->prev = 0;
../inputs/grep1.dat:  h->maybe_empty_object = 0;
../inputs/grep1.dat:    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
../inputs/grep1.dat:      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
../inputs/grep1.dat:		    + 4 + DEFAULT_ROUNDING - 1)
../inputs/grep1.dat:		   & ~(DEFAULT_ROUNDING - 1));
../inputs/grep1.dat:      size = 4096 - extra;
../inputs/grep1.dat:  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
../inputs/grep1.dat:  h->freefun = freefun;
../inputs/grep1.dat:  h->chunk_size = size;
../inputs/grep1.dat:  h->alignment_mask = alignment - 1;
../inputs/grep1.dat:  h->extra_arg = arg;
../inputs/grep1.dat:  h->use_extra_arg = 1;
../inputs/grep1.dat:  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
../inputs/grep1.dat:  h->next_free = h->object_base = chunk->contents;
../inputs/grep1.dat:  h->chunk_limit = chunk->limit
../inputs/grep1.dat:    = (char *) chunk + h->chunk_size;
../inputs/grep1.dat:  chunk->prev = 0;
../inputs/grep1.dat:  h->maybe_empty_object = 0;
../inputs/grep1.dat:  register struct _obstack_chunk*	old_chunk = h->chunk;
../inputs/grep1.dat:  register int obj_size = h->next_free - h->object_base;
../inputs/grep1.dat:  if (new_size < h->chunk_size)
../inputs/grep1.dat:    new_size = h->chunk_size;
../inputs/grep1.dat:  new_chunk = h->chunk = CALL_CHUNKFUN (h, new_size);
../inputs/grep1.dat:  new_chunk->prev = old_chunk;
../inputs/grep1.dat:  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;
../inputs/grep1.dat:  if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)
../inputs/grep1.dat:      for (i = obj_size / sizeof (COPYING_UNIT) - 1;
../inputs/grep1.dat:	   i >= 0; i--)
../inputs/grep1.dat:	((COPYING_UNIT *)new_chunk->contents)[i]
../inputs/grep1.dat:	  = ((COPYING_UNIT *)h->object_base)[i];
../inputs/grep1.dat:    new_chunk->contents[i] = h->object_base[i];
../inputs/grep1.dat:  if (h->object_base == old_chunk->contents && ! h->maybe_empty_object)
../inputs/grep1.dat:      new_chunk->prev = old_chunk->prev;
../inputs/grep1.dat:  h->object_base = new_chunk->contents;
../inputs/grep1.dat:  h->next_free = h->object_base + obj_size;
../inputs/grep1.dat:  h->maybe_empty_object = 0;
../inputs/grep1.dat:  lp = (h)->chunk;
../inputs/grep1.dat:  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
../inputs/grep1.dat:      plp = lp->prev;
../inputs/grep1.dat:   This is the first one, called from non-ANSI code.  */
../inputs/grep1.dat:  lp = h->chunk;
../inputs/grep1.dat:  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
../inputs/grep1.dat:      plp = lp->prev;
../inputs/grep1.dat:      h->maybe_empty_object = 1;
../inputs/grep1.dat:      h->object_base = h->next_free = (char *)(obj);
../inputs/grep1.dat:      h->chunk_limit = lp->limit;
../inputs/grep1.dat:      h->chunk = lp;
../inputs/grep1.dat:  lp = h->chunk;
../inputs/grep1.dat:  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
../inputs/grep1.dat:      plp = lp->prev;
../inputs/grep1.dat:      h->maybe_empty_object = 1;
../inputs/grep1.dat:      h->object_base = h->next_free = (char *)(obj);
../inputs/grep1.dat:      h->chunk_limit = lp->limit;
../inputs/grep1.dat:      h->chunk = lp;
../inputs/grep1.dat:/* These function definitions do not work with non-ANSI preprocessors;
../inputs/grep1.dat:   the macro-definitions of the names from being expanded there.  */
../inputs/grep1.dat:/* search.c - searching subroutines using dfa, kwset and regex for grep.
../inputs/grep1.dat:  { "posix-egrep", Ecompile, EGexecute },
../inputs/grep1.dat:/* For -w, we also consider _ to be word constituent.  */
../inputs/grep1.dat:      for (dm = dfa_1.musts; dm; dm = dm->next)
../inputs/grep1.dat:	  if (!dm->exact)
../inputs/grep1.dat:	  if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0)
../inputs/grep1.dat:      for (dm = dfa_1.musts; dm; dm = dm->next)
../inputs/grep1.dat:	  if (dm->exact)
../inputs/grep1.dat:	  if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0)
../inputs/grep1.dat:      /* In the whole-word case, we use the pattern:
../inputs/grep1.dat:	 (^|[^A-Za-z_])(userpattern)([^A-Za-z_]|$).
../inputs/grep1.dat:	 In the whole-line case, we use the pattern:
../inputs/grep1.dat:	 BUG: Using [A-Za-z_] is locale-dependent!  */
../inputs/grep1.dat:	strcpy(n, "\\(^\\|[^0-9A-Za-z_]\\)\\(");
../inputs/grep1.dat:	strcpy(n + i, "\\)\\([^0-9A-Za-z_]\\|$\\)");
../inputs/grep1.dat:  if (strcmp(matcher, "posix-egrep") == 0)
../inputs/grep1.dat:      /* In the whole-word case, we use the pattern:
../inputs/grep1.dat:	 (^|[^A-Za-z_])(userpattern)([^A-Za-z_]|$).
../inputs/grep1.dat:	 In the whole-line case, we use the pattern:
../inputs/grep1.dat:	 BUG: Using [A-Za-z_] is locale-dependent!  */
../inputs/grep1.dat:	strcpy(n, "(^|[^0-9A-Za-z_])(");
../inputs/grep1.dat:	strcpy(n + i, ")([^0-9A-Za-z_]|$)");
../inputs/grep1.dat:  static struct re_registers regs; /* This is static on account of a BRAIN-DEAD
../inputs/grep1.dat:	  beg = kwsexec(kwset, beg, buflim - beg, &kwsm);
../inputs/grep1.dat:	  end = memchr(beg, '\n', buflim - beg);
../inputs/grep1.dat:	  while (beg > buf && beg[-1] != '\n')
../inputs/grep1.dat:	    --beg;
../inputs/grep1.dat:	  end = memchr(beg, '\n', buflim - beg);
../inputs/grep1.dat:	  while (beg > buf && beg[-1] != '\n')
../inputs/grep1.dat:	    --beg;
../inputs/grep1.dat:      if ((start = re_search(&regex, beg, end - beg, 0, end - beg, &regs)) >= 0)
../inputs/grep1.dat:	  len = regs.end[0] - start;
../inputs/grep1.dat:	  if (!match_lines && !match_words || match_lines && len == end - beg)
../inputs/grep1.dat:	  /* If -w, check if the match aligns with word boundaries.
../inputs/grep1.dat:		if ((start == 0 || !WCHAR(beg[start - 1]))
../inputs/grep1.dat:		    && (len == end - beg || !WCHAR(beg[start + len])))
../inputs/grep1.dat:		    --len;
../inputs/grep1.dat:		    if (start == end - beg)
../inputs/grep1.dat:		    start = re_search(&regex, beg, end - beg,
../inputs/grep1.dat:				      start, end - beg - start, &regs);
../inputs/grep1.dat:		    len = regs.end[0] - start;
../inputs/grep1.dat:      if ((err = kwsincr(kwset, beg, lim - beg)) != 0)
../inputs/grep1.dat:      if (!(beg = kwsexec(kwset, beg, buf + size - beg, &kwsmatch)))
../inputs/grep1.dat:	  if (beg > buf && beg[-1] != '\n')
../inputs/grep1.dat:	    if (try > buf && WCHAR((unsigned char) try[-1]))
../inputs/grep1.dat:		try = kwsexec(kwset, beg, --len, &kwsmatch);
../inputs/grep1.dat:  if ((end = memchr(beg + len, '\n', (buf + size) - (beg + len))) != 0)
../inputs/grep1.dat:  while (beg > buf && beg[-1] != '\n')
../inputs/grep1.dat:    --beg;
