0:/* grep.c - main driver file for grep.
39:   Copyright (C) 1992 Free Software Foundation, Inc.
92:
93:   This program is free software; you can redistribute it and/or modify
165:   it under the terms of the GNU General Public License as published by
237:   the Free Software Foundation; either version 2, or (at your option)
308:   any later version.
330:
331:   This program is distributed in the hope that it will be useful,
398:   but WITHOUT ANY WARRANTY; without even the implied warranty of
464:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
529:   GNU General Public License for more details.
577:
578:   You should have received a copy of the GNU General Public License
647:   along with this program; if not, write to the Free Software
710:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
771:
772:   Written July 1992 by Mike Haertel.  */
814:
815:
816:/* I added a series define from makefile here in order to run cfe */
885:#define GREP 1
900:#define STDC_HEADERS 1
923:#define HAVE_STRING_H 1
947:#define HAVE_SYS_PARAM_H 1
974:#define HAVE_UNISTD_H 1
998:#define HAVE_ALLOCA_H 1
1022:#define HAVE_GETPAGESIZE 1
1049:#define HAVE_MEMCHR 1
1071:#define HAVE_STRERROR 1
1095:#define HAVE_VALLOC 1
1117:#define HAVE_WORKING_MMAP 1
1145:/*** end of cfe purpose **/
1173:
1212:
1213:#ifndef errno
1227:extern int errno;
1245:#endif
1252:
1253:#ifdef STDC_HEADERS
1293:#define flag_stdlib 1
1315:#else
1344:#define flag_systypes 1
1368:extern char *malloc(), *realloc();
1403:extern void free();
1423:#endif
1430:
1431:#if defined(STDC_HEADERS) || defined(HAVE_STRING_H)
1503:#define flag_string 1
1525:#ifdef NEED_MEMORY_H
1566:#define flag_memory 1
1588:#endif
1595:#else
1622:#define flag_strings 1
1645:#ifdef __STDC__
1661:extern void *memchr();
1684:#else
1690:extern char *memchr();
1713:#endif
1720:#define strrchr rindex
1743:#endif
1750:
1751:#ifdef HAVE_UNISTD_H
1772:#if flag_systypes==0
1816:#define flag_systypes 1
1840:#endif
1886:#else
1892:#define O_RDONLY 0
1911:extern int open(), read(), close();
1947:#endif
1954:
1998:
1999:#undef MAX
2010:#define MAX(A,B) ((A) > (B) ? (A) : (B))
2051:
2052:/* Provide missing ANSI features if necessary. */
2102:
2103:#ifndef HAVE_STRERROR
2125:extern int sys_nerr;
2146:extern char *sys_errlist[];
2174:#define strerror(E) ((E) < sys_nerr ? sys_errlist[(E)] : "bogus error number")
2253:#endif
2260:
2261:#ifndef HAVE_MEMCHR
2281:#ifdef __STDC__
2297:#define VOID void
2315:#else
2321:#define VOID char
2339:#endif
2346:VOID *
2353:memchr(vp, c, n)
2370:     VOID *vp;
2385:     int c;
2397:     size_t n;
2412:{
2414:  unsigned char *p;
2434:
2435:  for (p = (unsigned char *) vp; n--; ++p)
2478:    if (*p == c)
2495:      return (VOID *) p;
2520:  return 0;
2532:}
2534:#endif
2541:    
2546:/* Define flags declared in grep.h. */
2585:char *matcher;
2600:int match_icase;
2617:int match_words;
2634:int match_lines;
2651:
2652:/* Functions we'll use to search. */
2689:static void (*compile)();
2715:static char *(*execute)();
2742:
2743:/* For error messages. */
2769:static char *prog;
2788:static char *filename;
2811:static int errseen;
2831:
2832:/* Print a message and possibly an error string.  Remember
2891:   that something awful happened. */
2928:static void
2940:error(mesg, errnum)
2960:#ifdef __STDC__
2976:     const
2987:#endif
2994:     char *mesg;
3011:     int errnum;
3028:{
3030:  if (errnum)
3044:    fprintf(stderr, "%s: %s: %s\n", prog, mesg, strerror(errnum));
3111:  else
3118:    fprintf(stderr, "%s: %s\n", prog, mesg);
3163:  errseen = 1;
3178:}
3180:
3181:/* Like error(), but die horribly after printing. */
3234:void
3239:fatal(mesg, errnum)
3259:#ifdef __STDC__
3275:     const
3286:#endif
3293:     char *mesg;
3310:     int errnum;
3327:{
3329:  error(mesg, errnum);
3352:  exit(2);
3363:}
3365:
3366:/* Interface to handle errors and fix library lossage. */
3424:char *
3431:xmalloc(size)
3445:     size_t size;
3463:{
3465:  char *result;
3481:
3482:  result = malloc(size);
3507:  if (size && !result)
3530:    fatal("memory exhausted", 0);
3564:  return result;
3581:}
3583:
3584:/* Interface to handle errors and fix some library lossage. */
3647:char *
3654:xrealloc(ptr, size)
3674:     char *ptr;
3690:     size_t size;
3708:{
3710:  char *result;
3726:
3727:  if (ptr)
3738:    result = realloc(ptr, size);
3771:  else
3778:    result = malloc(size);
3805:  if (size && !result)
3828:    fatal("memory exhausted", 0);
3862:  return result;
3879:}
3881:
3882:#if !defined(HAVE_VALLOC)
3908:#define valloc malloc
3930:#else
3936:#ifdef __STDC__
3952:extern void *valloc(size_t);
3981:#else
3987:extern char *valloc();
4010:#endif
4017:#endif
4024:
4025:/* Hairy buffering mechanism for grep.  The intent is to keep
4087:   all reads aligned on a page boundary and multiples of the
4148:   page size. */
4165:
4166:static char *buffer;		/* Base of buffer. */
4210:static size_t bufsalloc;	/* Allocated size of buffer save region. */
4279:static size_t bufalloc;		/* Total buffer size. */
4329:static int bufdesc;		/* File descriptor. */
4373:static char *bufbeg;		/* Beginning of user-visible stuff. */
4434:static char *buflim;		/* Limit of user-visible stuff. */
4491:
4492:#if defined(HAVE_WORKING_MMAP)
4523:#if flag_systypes==0
4567:#define flag_systypes 1
4591:#endif
4642:
4643:static int bufmapped;		/* True for ordinary files. */
4697:static struct stat bufstat;	/* From fstat(). */
4745:static off_t bufoffset;		/* What read() normally remembers. */
4808:#endif
4815:
4816:/* Reset the buffer for a new file.  Initialize
4864:   on the first time through. */
4897:void
4902:reset(fd)
4912:     int fd;
4925:{
4927:  static int initialized;
4953:
4954:  if (!initialized)
4974:    {
4980:      initialized = 1;
5003:#ifndef BUFSALLOC
5021:      bufsalloc = MAX(8192, getpagesize());
5065:#else
5071:      bufsalloc = BUFSALLOC;
5100:#endif
5107:      bufalloc = 5 * bufsalloc;
5139:      /* The 1 byte of overflow is a kludge for dfaexec(), which
5204:	 inserts a sentinel newline at the end of the buffer
5258:	 being searched.  There's gotta be a better way... */
5313:      buffer = valloc(bufalloc + 1);
5350:      if (!buffer)
5369:	fatal("memory exhausted", 0);
5400:      bufbeg = buffer;
5423:      buflim = buffer;
5446:    }
5452:  bufdesc = fd;
5468:#if defined(HAVE_WORKING_MMAP)
5499:  if (fstat(fd, &bufstat) < 0 || !S_ISREG(bufstat.st_mode))
5559:    bufmapped = 0;
5578:  else
5585:    {
5591:      bufmapped = 1;
5612:      bufoffset = lseek(fd, 0, 1);
5647:    }
5653:#endif
5660:}
5662:
5663:/* Read new stuff into the buffer, saving the specified
5719:   amount of old stuff.  When we're done, 'bufbeg' points
5777:   to the beginning of the buffer contents, and 'buflim'
5834:   points just after the end.  Return count of new stuff. */
5895:static int
5906:fillbuf(save)
5920:     size_t save;
5938:{
5940:  char *nbuffer, *dp, *sp;
5967:  int cc;
5977:#if defined(HAVE_WORKING_MMAP)
6008:  caddr_t maddr;
6025:#endif
6032:  static int pagesize;
6055:
6056:  if (pagesize == 0 && (pagesize = getpagesize()) == 0)
6112:    abort();
6125:
6126:  if (save > bufsalloc)
6150:    {
6156:      while (save > bufsalloc)
6187:	bufsalloc *= 2;
6204:      bufalloc = 5 * bufsalloc;
6236:      nbuffer = valloc(bufalloc + 1);
6274:      if (!nbuffer)
6294:	fatal("memory exhausted", 0);
6325:    }
6331:  else
6338:    nbuffer = buffer;
6360:
6361:  sp = buflim - save;
6383:  dp = nbuffer + bufsalloc - save;
6418:  bufbeg = dp;
6433:  while (save--)
6450:    *dp++ = *sp++;
6469:
6470:  /* We may have allocated a new, larger buffer.  Since
6526:     there is no portable vfree(), we just have to forget
6584:     about the old one.  Sorry. */
6619:  buffer = nbuffer;
6639:
6640:#if defined(HAVE_WORKING_MMAP)
6671:  if (bufmapped && bufoffset % pagesize == 0
6716:      && bufstat.st_size - bufoffset >= bufalloc - bufsalloc)
6778:    {
6784:      maddr = buffer + bufsalloc;
6818:      maddr = mmap(maddr, bufalloc - bufsalloc, PROT_READ | PROT_WRITE,
6890:		   MAP_PRIVATE | MAP_FIXED, bufdesc, bufoffset);
6941:      if (maddr == (caddr_t) -1)
6974:	{
6977:	  fprintf(stderr, "%s: warning: %s: %s\n", filename,
7031:		  strerror(errno));
7053:	  goto tryread;
7070:	}
7073:#if 0
7079:      /* You might thing this (or MADV_WILLNEED) would help,
7140:	 but it doesn't, at least not on a Sun running 4.1.
7193:	 In fact, it actually slows us down about 30%! */
7244:      madvise(maddr, bufalloc - bufsalloc, MADV_SEQUENTIAL);
7305:#endif
7312:      cc = bufalloc - bufsalloc;
7345:      bufoffset += cc;
7368:    }
7374:  else
7381:    {
7387:    tryread:
7400:      /* We come here when we're not going to use mmap() any more.
7467:	 Note that we need to synchronize the file offset the
7522:	 first time through. */
7547:      if (bufmapped)
7568:	{
7571:	  bufmapped = 0;
7589:	  lseek(bufdesc, bufoffset, 0);
7622:	}
7625:      cc = read(bufdesc, buffer + bufsalloc, bufalloc - bufsalloc);
7693:    }
7699:#else
7705:  cc = read(bufdesc, buffer + bufsalloc, bufalloc - bufsalloc);
7769:#endif
7776:  if (cc > 0)
7790:    buflim = buffer + bufsalloc + cc;
7828:  else
7835:    buflim = buffer + bufsalloc;
7868:  return cc;
7881:}
7883:
7884:/* Flags controlling the style of output. */
7929:static int out_quiet;		/* Suppress all normal output. */
7986:static int out_invert;		/* Print nonmatching stuff. */
8041:static int out_file;		/* Print filenames. */
8086:static int out_line;		/* Print line numbers. */
8134:static int out_byte;		/* Print byte offsets. */
8182:static int out_before;		/* Lines of leading context. */
8238:static int out_after;		/* Lines of trailing context. */
8294:
8295:/* Internal variables to keep track of byte count, context, etc. */
8363:static size_t totalcc;		/* Total character count before bufbeg. */
8430:static char *lastnl;		/* Pointer after last newline counted. */
8494:static char *lastout;		/* Pointer after last character output;
8557:				   NULL if no character has been output
8601:				   or if it's conceptually before bufbeg. */
8650:static size_t totalnl;		/* Total newline count before lastnl. */
8715:static int pending;		/* Pending lines of output. */
8767:
8768:static void
8780:nlscan(lim)
8792:     char *lim;
8808:{
8810:  char *beg;
8823:
8824:  for (beg = lastnl; beg < lim; ++beg)
8863:    if (*beg == '\n')
8885:      ++totalnl;
8902:  lastnl = beg;
8918:}
8920:
8921:static void
8933:prline(beg, lim, sep)
8955:     char *beg;
8971:     char *lim;
8987:     char sep;
9002:{
9004:  if (out_file)
9020:    printf("%s%c", filename, sep);
9055:  if (out_line)
9071:    {
9077:      nlscan(beg);
9096:      printf("%d%c", ++totalnl, sep);
9134:      lastnl = lim;
9154:    }
9160:  if (out_byte)
9176:    printf("%lu%c", totalcc + (beg - bufbeg), sep);
9228:  fwrite(beg, 1, lim - beg, stdout);
9265:  if (ferror(stdout))
9287:    error("writing output", errno);
9323:  lastout = lim;
9340:}
9342:
9343:/* Print pending lines of trailing context prior to LIM. */
9403:static void
9415:prpending(lim)
9430:     char *lim;
9446:{
9448:  char *nl;
9460:
9461:  if (!lastout)
9477:    lastout = bufbeg;
9499:  while (pending > 0 && lastout < lim)
9538:    {
9544:      --pending;
9561:      if ((nl = memchr(lastout, '\n', lim - lastout)) != 0)
9621:	++nl;
9628:      else
9639:	nl = lim;
9650:      prline(lastout, nl, '-');
9682:    }
9688:}
9690:
9691:/* Print the lines between BEG and LIM.  Deal with context crap.
9756:   If NLINESP is non-null, store a count of lines between BEG and LIM. */
9830:static void
9842:prtext(beg, lim, nlinesp)
9868:     char *beg;
9884:     char *lim;
9900:     int *nlinesp;
9919:{
9921:  static int used;		/* avoid printing "--" before any output */
9985:  char *bp, *p, *nl;
10006:  int i, n;
10018:
10019:  if (!out_quiet && pending > 0)
10052:    prpending(beg);
10072:
10073:  p = beg;
10084:
10085:  if (!out_quiet)
10103:    {
10109:      /* Deal with leading context crap. */
10153:
10154:      bp = lastout ? lastout : bufbeg;
10193:      for (i = 0; i < out_before; ++i)
10232:	if (p > bp)
10245:	  do
10251:	    --p;
10261:	  while (p > bp && p[-1] != '\n');
10297:
10298:      /* We only print the "--" separator if our output is
10357:	 discontiguous from the last output in the file. */
10410:      if ((out_before || out_after) && used && p != lastout)
10471:	puts("--");
10484:
10485:      while (p < beg)
10507:	{
10510:	  nl = memchr(p, '\n', beg - p);
10544:	  prline(p, nl + 1, '-');
10571:	  p = nl + 1;
10586:	}
10589:    }
10595:
10596:  if (nlinesp)
10611:    {
10617:      /* Caller wants a line count. */
10656:      for (n = 0; p < lim; ++n)
10688:	{
10691:	  if ((nl = memchr(p, '\n', lim - p)) != 0)
10736:	    ++nl;
10747:	  else
10755:	    nl = lim;
10770:	  if (!out_quiet)
10789:	    prline(p, nl, ':');
10814:	  p = nl;
10825:	}
10828:      *nlinesp = n;
10848:    }
10854:  else
10861:    if (!out_quiet)
10881:      prline(beg, lim, ':');
10910:
10911:  pending = out_after;
10934:  used = 1;
10946:}
10948:
10949:/* Scan the specified portion of the buffer, matching lines (or
11013:   between matching lines if OUT_INVERT is true).  Return a count of
11082:   lines printed. */
11103:static int
11114:grepbuf(beg, lim)
11132:     char *beg;
11148:     char *lim;
11164:{
11166:  int nlines, n;
11183:  register char *p, *b;
11207:  char *endp;
11221:
11222:  nlines = 0;
11236:  p = beg;
11247:  while ((b = (*execute)(p, lim - p, &endp)) != 0)
11298:    {
11304:      /* Avoid matching the empty line at the end of the buffer. */
11372:      if (b == lim && ((b > beg && b[-1] == '\n') || b == beg))
11436:	break;
11444:      if (!out_invert)
11467:	{
11470:	  prtext(b, endp, (int *) 0);
11501:	  nlines += 1;
11517:	}
11520:      else if (p < b)
11542:	{
11545:	  prtext(p, b, &n);
11566:	  nlines += n;
11582:	}
11585:      p = endp;
11601:    }
11607:  if (out_invert && p < lim)
11636:    {
11642:      prtext(p, lim, &n);
11668:      nlines += n;
11687:    }
11693:  return nlines;
11710:}
11712:
11713:/* Search a given file.  Return a count of lines printed. */
11774:static int
11785:grep(fd)
11794:     int fd;
11807:{
11809:  int nlines, i;
11826:  size_t residue, save;
11850:  char *beg, *lim;
11869:
11870:  reset(fd);
11883:
11884:  totalcc = 0;
11899:  lastout = 0;
11914:  totalnl = 0;
11929:  pending = 0;
11944:
11945:  nlines = 0;
11959:  residue = 0;
11974:  save = 0;
11986:
11987:  for (;;)
11998:    {
12004:      if (fillbuf(save) < 0)
12033:	{
12036:	  error(filename, errno);
12063:	  return nlines;
12081:	}
12084:      lastnl = bufbeg;
12107:      if (lastout)
12126:	lastout = bufbeg;
12145:      if (buflim - bufbeg == save)
12180:	break;
12188:      beg = bufbeg + save - residue;
12225:      for (lim = buflim; lim > beg && lim[-1] != '\n'; --lim)
12287:	;
12290:      residue = buflim - lim;
12320:      if (beg < lim)
12341:	{
12344:	  nlines += grepbuf(beg, lim);
12376:	  if (pending)
12392:	    prpending(lim);
12413:	}
12416:      i = 0;
12429:      beg = lim;
12446:      while (i < out_before && beg > bufbeg && beg != lastout)
12509:	{
12512:	  ++i;
12520:	  do
12526:	    --beg;
12538:	  while (beg > bufbeg && beg[-1] != '\n');
12582:	}
12585:      if (beg != lastout)
12611:	lastout = 0;
12625:      save = residue + lim - beg;
12659:      totalcc += buflim - bufbeg - save;
12700:      if (out_line)
12720:	nlscan(beg);
12734:    }
12740:  if (residue)
12755:    {
12761:      nlines += grepbuf(bufbeg + save - residue, buflim);
12819:      if (pending)
12838:	prpending(buflim);
12858:    }
12864:  return nlines;
12881:}
12883:
12884:static char version[] = "GNU grep version 2.0";
12932:
12933:#define USAGE \
12949:  "usage: %s [-[[AB] ]<num>] [-[CEFGVchilnqsvwx]] [-[ef]] <expr> [<files...>]\n"
13030:
13031:static void
13043:usage()
13051:{
13053:  fprintf(stderr, USAGE, prog);
13085:  exit(2);
13096:}
13098:
13099:/* Go through the matchers vector and look for the specified matcher.
13169:   If we find it, install it in compile and execute, and return 1.  */
13240:int
13244:setmatcher(name)
13261:     char *name;
13278:{
13280:  int i;
13289:
13290:  for (i = 0; matchers[i].name; ++i)
13327:    if (strcmp(name, matchers[i].name) == 0)
13372:      {
13380:	compile = matchers[i].compile;
13412:	execute = matchers[i].execute;
13444:	return 1;
13455:      }
13463:  return 0;
13475:}  
13479:
13480:int
13484:main(argc, argv)
13501:     int argc;
13516:     char *argv[];
13535:{
13537:  char *keys;
13551:  size_t keycc, oldcc, keyalloc;
13584:  int keyfound, count_matches, no_filenames, list_files, suppress_errors;
13658:  int opt, cc, desc, count, status;
13694:  FILE *fp;
13706:  extern char *optarg;
13729:  extern int optind;
13750:
13751:  prog = argv[0];
13769:  if (prog && strrchr(prog, '/'))
13803:    prog = strrchr(prog, '/') + 1;
13838:
13839:  keys = NULL;
13854:  keycc = 0;
13867:  keyfound = 0;
13883:  count_matches = 0;
13904:  no_filenames = 0;
13924:  list_files = 0;
13942:  suppress_errors = 0;
13965:  matcher = NULL;
13983:
13984:  while ((opt = getopt(argc, argv, "0123456789A:B:CEFGVX:bce:f:hiLlnqsvwxy"))
14062:	 != EOF)
14072:    switch (opt)
14089:      {
14097:      case '0':
14113:      case '1':
14129:      case '2':
14145:      case '3':
14161:      case '4':
14177:      case '5':
14193:      case '6':
14209:      case '7':
14225:      case '8':
14241:      case '9':
14257:	out_before = 10 * out_before + opt - '0';
14300:	out_after = 10 * out_after + opt - '0';
14341:	break;
14349:      case 'A':
14365:	out_after = atoi(optarg);
14392:	if (out_after < 0)
14412:	  usage();
14424:	break;
14432:      case 'B':
14448:	out_before = atoi(optarg);
14476:	if (out_before < 0)
14497:	  usage();
14509:	break;
14517:      case 'C':
14533:	out_before = out_after = 2;
14562:	break;
14570:      case 'E':
14586:	if (matcher && strcmp(matcher, "egrep") != 0)
14633:	  fatal("you may specify only one of -E, -F, or -G", 0);
14691:	matcher = "posix-egrep";
14717:	break;
14725:      case 'F':
14741:	if (matcher && strcmp(matcher, "fgrep") != 0)
14788:	  fatal("you may specify only one of -E, -F, or -G", 0);;
14847:	matcher = "fgrep";
14867:	break;
14875:      case 'G':
14891:	if (matcher && strcmp(matcher, "grep") != 0)
14937:	  fatal("you may specify only one of -E, -F, or -G", 0);
14995:	matcher = "grep";
15014:	break;
15022:      case 'V':
15038:	fprintf(stderr, "%s\n", version);
15073:	break;
15081:      case 'X':
15097:	if (matcher)
15111:	  fatal("matcher already specified", 0);
15153:	matcher = optarg;
15172:	break;
15180:      case 'b':
15196:	out_byte = 1;
15211:	break;
15219:      case 'c':
15235:	out_quiet = 1;
15251:	count_matches = 1;
15271:	break;
15279:      case 'e':
15295:	cc = strlen(optarg);
15317:	keys = xrealloc(keys, keycc + cc + 1);
15357:	if (keyfound)
15372:	  keys[keycc++] = '\n';
15397:	strcpy(&keys[keycc], optarg);
15428:	keycc += cc;
15442:	keyfound = 1;
15457:	break;
15465:      case 'f':
15481:	fp = strcmp(optarg, "-") != 0 ? fopen(optarg, "r") : stdin;
15542:	if (!fp)
15552:	  fatal(optarg, errno);
15577:	for (keyalloc = 1; keyalloc <= keycc; keyalloc *= 2)
15631:	  ;
15636:	keys = xrealloc(keys, keyalloc);
15670:	oldcc = keycc;
15686:	if (keyfound)
15701:	  keys[keycc++] = '\n';
15726:	while (!feof(fp)
15744:	       && (cc = fread(keys + keycc, 1, keyalloc - keycc, fp)) > 0)
15812:	  {
15817:	    keycc += cc;
15835:	    if (keycc == keyalloc)
15863:	      keys = xrealloc(keys, keyalloc *= 2);
15908:	  }
15913:	if (fp != stdin)
15931:	  fclose(fp);
15946:	/* Nuke the final newline to avoid matching a null string. */
16009:	if (keycc - oldcc > 0 && keys[keycc - 1] == '\n')
16060:	  --keycc;
16072:	keyfound = 1;
16087:	break;
16095:      case 'h':
16111:	no_filenames = 1;
16130:	break;
16138:      case 'i':
16154:      case 'y':			/* For old-timers . . . */
16199:	match_icase = 1;
16217:	break;
16225:      case 'L':
16241:	/* Like -l, except list files that don't contain matches.
16300:	   Inspired by the same option in Hume's gre. */
16350:	out_quiet = 1;
16366:	list_files = -1;
16384:	break;
16392:      case 'l':
16408:	out_quiet = 1;
16424:	list_files = 1;
16441:	break;
16449:      case 'n':
16465:	out_line = 1;
16480:	break;
16488:      case 'q':
16504:	out_quiet = 1;
16520:	break;
16528:      case 's':
16544:	suppress_errors = 1;
16566:	break;
16574:      case 'v':
16590:	out_invert = 1;
16607:	break;
16615:      case 'w':
16631:	match_words = 1;
16649:	break;
16657:      case 'x':
16673:	match_lines = 1;
16691:	break;
16699:      default:
16714:	usage();
16724:	break;
16732:      }
16740:
16741:  if (!keyfound)
16758:    if (optind < argc)
16781:      {
16789:	keys = argv[optind++];
16813:	keycc = strlen(keys);
16836:      }
16844:    else
16853:      usage();
16868:
16869:  if (!matcher)
16885:    matcher = prog;
16905:
16906:  if (!setmatcher(matcher) && !setmatcher("default"))
16960:    abort();
16973:
16974:  (*compile)(keys, keycc);
17001:
17002:  if (argc - optind > 1 && !no_filenames)
17044:    out_file = 1;
17062:
17063:  status = 1;
17077:
17078:  if (optind < argc)
17099:    while (optind < argc)
17125:      {
17133:	desc = strcmp(argv[optind], "-") ? open(argv[optind], O_RDONLY) : 0;
17203:	if (desc < 0)
17218:	  {
17223:	    if (!suppress_errors)
17250:	      error(argv[optind], errno);
17285:	  }
17290:	else
17296:	  {
17301:	    filename = desc == 0 ? "(standard input)" : argv[optind];
17364:	    count = grep(desc);
17389:	    if (count_matches)
17413:	      {
17422:		if (out_file)
17438:		  printf("%s:", filename);
17467:		printf("%d\n", count);
17492:	      }
17501:	    if (count)
17517:	      {
17526:		status = 0;
17540:		if (list_files == 1)
17563:		  printf("%s\n", filename);
17593:	      }
17602:	    else if (list_files == -1)
17634:	      printf("%s\n", filename);
17667:	  }
17672:	if (desc != 0)
17688:	  close(desc);
17704:	++optind;
17715:      }
17723:  else
17730:    {
17736:      filename = "(standard input)";
17773:      count = grep(0);
17796:      if (count_matches)
17821:	printf("%d\n", count);
17845:      if (count)
17862:	{
17865:	  status = 0;
17880:	  if (list_files == 1)
17904:	    printf("(standard input)\n");
17939:	}
17942:      else if (list_files == -1)
17975:	printf("(standard input)\n");
18006:    }
18012:
18013:  exit(errseen ? 2 : status);
18043:}
18045:/* Getopt for GNU.
18064:   NOTE: getopt is now part of the C library, so if you don't know what
18136:   "Keep this file name-space clean" means, talk to roland@gnu.ai.mit.edu
18210:   before changing it!
18233:
18234:   Copyright (C) 1987, 88, 89, 90, 91, 92, 1993
18282:   	Free Software Foundation, Inc.
18317:
18318:   This program is free software; you can redistribute it and/or modify it
18393:   under the terms of the GNU General Public License as published by the
18466:   Free Software Foundation; either version 2, or (at your option) any
18537:   later version.
18555:
18556:   This program is distributed in the hope that it will be useful,
18623:   but WITHOUT ANY WARRANTY; without even the implied warranty of
18689:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
18754:   GNU General Public License for more details.
18802:
18803:   You should have received a copy of the GNU General Public License
18872:   along with this program; if not, write to the Free Software
18935:   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
18994:
18996:/* NOTE!!!  AIX requires this to be the first thing in the file.
19061:   Do not put ANYTHING before it!  */
19099:#if !defined (__GNUC__) && defined (_AIX)
19141: #pragma alloca
19157:#endif
19164:
19165:#ifdef HAVE_CONFIG_H
19206:#define flag_config 1
19228:#endif
19235:
19236:#ifdef __GNUC__
19252:#define alloca __builtin_alloca
19284:#else /* not __GNUC__ */
19309:#if defined (HAVE_ALLOCA_H) || (defined(sparc) && (defined(sun) || (!defined(USG) && !defined(SVR4) && !defined(__svr4__))))
19454:#define flag_alloca 1
19476:#else
19482:#ifndef _AIX
19495:char *alloca ();
19512:#endif
19519:#endif /* alloca.h */
19541:#endif /* not __GNUC__ */
19567:
19568:#if !__STDC__ && !defined(const) && IN_GCC
19611:#define const
19625:#endif
19632:
19633:/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.  */
19710:#ifndef _NO_PROTO
19728:#define _NO_PROTO
19746:#endif
19753:
19778:
19779:/* Comment out all this code if we are using the GNU C Library, and are not
19855:   actually compiling the library itself.  This code is part of the GNU C
20003:   and linking in this code is a waste when using the GNU C library
20071:   (especially if it is a shared library).  Rather than having every GNU
20144:   program understand `configure --with-gnu-libc' and omit the object files,
20221:   it is simpler to just do this in the source for each such file.  */
20292:
20293:#if defined (_LIBC) || !defined (__GNU_LIBRARY__)
20343:
20344:
20395:   to get __GNU_LIBRARY__ defined.  */
20434:#ifdef	__GNU_LIBRARY__
20457:#undef	alloca
20542:   contain conflicting prototypes for getopt.  */
20592:#if flag_stdlib==0   
20634:#define flag_stdlib 1
20656:#endif
20663:#else	/* Not GNU C library.  */
20695:#define	__alloca	alloca
20719:#endif	/* GNU C library.  */
20748:
20749:/* If GETOPT_COMPAT is defined, `+' as well as `--' can introduce a
20817:   long-named option.  Because this is not POSIX.2 compliant, it is
20885:   being phased out.  */
20910:/* #define GETOPT_COMPAT */
20938:
20939:/* This version of `getopt' appears to the caller like standard Unix `getopt'
21017:   but it behaves differently for the user, since it allows the user
21086:   to intersperse the options with the other arguments.
21142:
21143:   As `getopt' works, it permutes the elements of ARGV so that,
21207:   when it is done, all the options precede everything else.  Thus
21274:   all application programs are extended to handle flexible argument order.
21350:
21351:   Setting the environment variable POSIXLY_CORRECT disables permutation.
21425:   Then the behavior is completely standard.
21470:
21471:   GNU application programs can use a third alternative mode in which
21541:   they can distinguish the relative order of options and other arguments.  */
21620:
21641:
21642:/* For communication from `getopt' to the caller.
21692:   When `getopt' finds an option that takes an argument,
21749:   the argument value is returned here.
21789:   Also, when `ordering' is RETURN_IN_ORDER,
21834:   each non-option ARGV-element is returned here.  */
21888:
21889:char *optarg = 0;
21907:
21908:/* Index in ARGV of the next element to be scanned.
21960:   This is used for communication to and from the caller
22017:   and for communication between successive calls to `getopt'.
22080:
22081:   On entry to `getopt', zero means this is the first call; initialize.
22153:
22154:   When `getopt' returns EOF, this is the index of the first of the
22222:   non-option elements that the caller should itself scan.
22281:
22282:   Otherwise, `optind' communicates from one call to the next
22344:   how much of ARGV has been scanned so far.  */
22393:
22394:/* XXX 1003.2 says this must be 1 before any call.  */
22449:int optind = 0;
22465:
22466:/* The next char to be scanned in the option-element
22519:   in which the last option character we returned was found.
22580:   This allows us to pick up the scan where we left off.
22637:
22638:   If this is zero, or a null string, it means resume the scan
22701:   by advancing to the next ARGV-element.  */
22747:
22748:static char *nextchar;
22771:
22772:/* Callers store zero here to inhibit the error message
22828:   for unrecognized options.  */
22861:
22862:int opterr = 1;
22878:
22879:/* Set to an option character which was unrecognized.
22933:   This must be initialized on some systems to avoid linking in the
23001:   system's own getopt implementation.  */
23044:
23045:int optopt = '?';
23063:
23064:/* Describe how to deal with options that follow non-option ARGV-elements.
23139:
23140:   If the caller did not specify anything,
23183:   the default is REQUIRE_ORDER if the environment variable
23243:   POSIXLY_CORRECT is defined, PERMUTE otherwise.
23293:
23294:   REQUIRE_ORDER means don't recognize them as options;
23350:   stop option processing when the first non-option is seen.
23411:   This is what Unix does.
23438:   This mode of operation is selected by either setting the environment
23510:   variable POSIXLY_CORRECT, or using `+' as the first character
23575:   of the list of option characters.
23612:
23613:   PERMUTE is the default.  We permute the contents of ARGV as we scan,
23685:   so that eventually all the non-options are at the end.  This allows options
23764:   to be given in any order, even with programs that were not written to
23837:   expect this.
23853:
23854:   RETURN_IN_ORDER is an option available to programs that were written
23926:   to expect options and other ARGV-elements in any order and that care about
24004:   the ordering of the two.  We describe each non-option ARGV-element
24074:   as if it were the argument of an option with character code 1.
24140:   Using `-' as the first character of the list of option characters
24209:   selects this mode of operation.
24244:
24245:   The special argument `--' forces an end of option-scanning regardless
24318:   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
24387:   `--' can cause `getopt' to return EOF with `optind' != ARGC.  */
24455:
24456:static enum
24468:{
24470:  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
24512:} ordering;
24524:
24526:#ifdef	__GNU_LIBRARY__
24549:/* We want to avoid inclusion of string.h with non-GNU libraries
24614:   because there are many ways it can cause trouble.
24667:   On some systems, it contains special magic macros that don't work
24736:   in GCC.  */
24751:#if flag_string==0   
24793:#define flag_string 1
24815:#endif
24822:#define	my_index	strchr
24846:#define	my_bcopy(src, dst, n)	memcpy ((dst), (src), (n))
24903:#else
24909:
24910:/* Avoid depending on library functions or files
24959:   whose names are inconsistent.  */
24996:
24997:char *getenv ();
25014:
25015:static char *
25029:my_index (str, chr)
25049:     const char *str;
25071:     int chr;
25085:{
25087:  while (*str)
25102:    {
25108:      if (*str == chr)
25131:	return (char *) str;
25153:      str++;
25166:    }
25172:  return 0;
25184:}
25186:
25187:static void
25199:my_bcopy (from, to, size)
25225:     const char *from;
25248:     char *to;
25263:     int size;
25278:{
25280:  int i;
25289:  for (i = 0; i < size; i++)
25318:    to[i] = from[i];
25339:}
25341:#endif				/* GNU C library.  */
25373:
25375:/* Handle permutation of arguments.  */
25415:
25416:/* Describe the part of ARGV that contains non-options that have
25481:   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
25557:   `last_nonopt' is the index after the last of them.  */
25615:
25616:static int first_nonopt;
25641:static int last_nonopt;
25665:
25666:/* Exchange two adjacent subsequences of ARGV.
25713:   One subsequence is elements [first_nonopt,last_nonopt)
25771:   which contains all the non-options that have been skipped so far.
25840:   The other is elements [last_nonopt,optind), which contains all
25906:   the options processed since those non-options were skipped.
25969:
25970:   `first_nonopt' and `last_nonopt' are relocated so that they describe
26042:   the new indices of the non-options in ARGV after they are moved.  */
26114:
26115:static void
26127:exchange (argv)
26143:     char **argv;
26161:{
26163:  int nonopts_size = (last_nonopt - first_nonopt) * sizeof (char *);
26232:  char **temp = (char **) __alloca (nonopts_size);
26283:
26284:  /* Interchange the two blocks of data in ARGV.  */
26337:
26338:  my_bcopy ((char *) &argv[first_nonopt], (char *) temp, nonopts_size);
26410:  my_bcopy ((char *) &argv[last_nonopt], (char *) &argv[first_nonopt],
26481:	    (optind - last_nonopt) * sizeof (char *));
26529:  my_bcopy ((char *) temp,
26556:	    (char *) &argv[first_nonopt + optind - last_nonopt],
26614:	    nonopts_size);
26634:
26635:  /* Update records for the slots the non-options now occupy.  */
26701:
26702:  first_nonopt += (optind - last_nonopt);
26744:  last_nonopt = optind;
26768:}
26770:
26772:/* Scan elements of ARGV (whose length is ARGC) for option characters
26842:   given in OPTSTRING.
26865:
26866:   If an element of ARGV starts with '-', and is not exactly "-" or "--",
26940:   then it is an option element.  The characters of this element
27005:   (aside from the initial '-') are option characters.  If `getopt'
27073:   is called repeatedly, it returns successively each of the option characters
27152:   from each of the option elements.
27189:
27190:   If `getopt' finds another option character, it returns that character,
27264:   updating `optind' and `nextchar' so that the next call to `getopt' can
27338:   resume the scan with the following option character or ARGV-element.
27410:
27411:   If there are no more option characters, `getopt' returns `EOF'.
27478:   Then `optind' is the index in ARGV of the first ARGV-element
27542:   that is not an option.  (The ARGV-elements have been permuted
27607:   so that those that are not options now come last.)
27661:
27662:   OPTSTRING is a string containing the legitimate option characters.
27732:   If an option character is seen that is not listed in OPTSTRING,
27799:   return '?' after printing an error message.  If you set `opterr' to
27870:   zero, the error message is suppressed but we still return '?'.
27936:
27937:   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
28015:   so the following text in the same ARGV-element, or the text of the following
28095:   ARGV-element, is returned in `optarg'.  Two colons mean an option that
28169:   wants an optional arg; if there is text in the current ARGV-element,
28241:   it is returned in `optarg', otherwise `optarg' is set to zero.
28307:
28308:   If OPTSTRING starts with `-' or `+', it requests different methods of
28381:   handling the non-option ARGV-elements.
28423:   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
28491:
28492:   Long-named options begin with `--' instead of `-'.
28546:   Their names may be abbreviated as long as the abbreviation is unique
28618:   or is an exact match for some defined option.  If they have an
28684:   argument, it follows the option name in the same ARGV-element, separated
28760:   from the option name by a `=', or else the in next ARGV-element.
28828:   When `getopt' finds a long-named option, it returns 0 if that option's
28902:   `flag' field is nonzero, the value of the option's `val' field
28968:   if the `flag' field is zero.
29000:
29001:   The elements of ARGV aren't really const, because we permute them.
29071:   But we pretend they're const in the prototype to be compatible
29137:   with other systems.
29160:
29161:   LONGOPTS is a vector of `struct option' terminated by an
29221:   element containing a name which is zero.
29265:
29266:   LONGIND returns the index in LONGOPT of the long-named option found.
29338:   It is only valid when a long-named option has been found by the most
29410:   recent call.
29426:
29427:   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
29489:   long-named options.  */
29516:
29517:int
29521:_getopt_internal (argc, argv, optstring, longopts, longind, long_only)
29592:     int argc;
29607:     char *const *argv;
29631:     const char *optstring;
29659:     const struct option *longopts;
29695:     int *longind;
29714:     int long_only;
29734:{
29736:  int option_index;
29756:
29757:  optarg = 0;
29771:
29772:  /* Initialize the internal data when the first call is made.
29835:     Start processing options with ARGV-element 1 (since ARGV-element 0
29907:     is the program name); the sequence of previously skipped
29969:     non-option ARGV-elements is empty.  */
30013:
30014:  if (optind == 0)
30033:    {
30039:      first_nonopt = last_nonopt = optind = 1;
30086:
30087:      nextchar = NULL;
30110:
30111:      /* Determine how to handle the ordering of options and nonoptions.  */
30188:
30189:      if (optstring[0] == '-')
30220:	{
30223:	  ordering = RETURN_IN_ORDER;
30254:	  ++optstring;
30270:	}
30273:      else if (optstring[0] == '+')
30309:	{
30312:	  ordering = REQUIRE_ORDER;
30341:	  ++optstring;
30357:	}
30360:      else if (getenv ("POSIXLY_CORRECT") != NULL)
30411:	ordering = REQUIRE_ORDER;
30438:      else
30449:	ordering = PERMUTE;
30470:    }
30476:
30477:  if (nextchar == NULL || *nextchar == '\0')
30522:    {
30528:      if (ordering == PERMUTE)
30559:	{
30562:	  /* If we have just processed some options following some non-options,
30635:	     exchange them so that the options come first.  */
30691:
30692:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
30753:	    exchange ((char **) argv);
30785:	  else if (last_nonopt != optind)
30820:	    first_nonopt = optind;
30848:
30849:	  /* Now skip any additional non-options
30891:	     and extend the range of non-options previously skipped.  */
30957:
30958:	  while (optind < argc
30982:		 && (argv[optind][0] != '-' || argv[optind][1] == '\0')
31040:#ifdef GETOPT_COMPAT
31061:		 && (longopts == NULL
31085:		     || argv[optind][0] != '+' || argv[optind][1] == '\0')
31146:#endif				/* GETOPT_COMPAT */
31176:		 )
31181:	    optind++;
31196:	  last_nonopt = optind;
31221:	}
31224:
31225:      /* Special ARGV-element `--' means premature end of options.
31292:	 Skip it like a null option,
31322:	 then exchange with previous non-options as if it were an option,
31389:	 then skip everything else like a non-option.  */
31440:
31441:      if (optind != argc && !strcmp (argv[optind], "--"))
31499:	{
31502:	  optind++;
31515:
31516:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
31577:	    exchange ((char **) argv);
31609:	  else if (first_nonopt == last_nonopt)
31650:	    first_nonopt = optind;
31678:	  last_nonopt = argc;
31701:
31702:	  optind = argc;
31720:	}
31723:
31724:      /* If we have done all the ARGV-elements, stop the scan
31786:	 and back over any non-options that we skipped and permuted.  */
31852:
31853:      if (optind == argc)
31879:	{
31882:	  /* Set the next-arg-index to point at the non-options
31939:	     that we previously skipped, so the caller will digest them.  */
32009:	  if (first_nonopt != last_nonopt)
32045:	    optind = first_nonopt;
32073:	  return EOF;
32088:	}
32091:
32092:      /* If we have come to a non-option and did not permute it,
32157:	 either stop the scan or describe it to the caller and pass it by.  */
32229:
32230:      if ((argv[optind][0] != '-' || argv[optind][1] == '\0')
32292:#ifdef GETOPT_COMPAT
32313:	  && (longopts == NULL
32337:	      || argv[optind][0] != '+' || argv[optind][1] == '\0')
32398:#endif				/* GETOPT_COMPAT */
32428:	  )
32433:	{
32436:	  if (ordering == REQUIRE_ORDER)
32470:	    return EOF;
32487:	  optarg = argv[optind++];
32515:	  return 1;
32528:	}
32531:
32532:      /* We have found another option-ARGV-element.
32584:	 Start decoding its characters.  */
32621:
32622:      nextchar = (argv[optind] + 1
32657:		  + (longopts != NULL && argv[optind][1] == '-'));
32710:    }
32716:
32717:  if (longopts != NULL
32740:      && ((argv[optind][0] == '-'
32774:	   && (argv[optind][1] == '-' || long_only))
32820:#ifdef GETOPT_COMPAT
32841:	  || argv[optind][0] == '+'
32870:#endif				/* GETOPT_COMPAT */
32900:	  ))
32906:    {
32912:      const struct option *p;
32942:      char *s = nextchar;
32968:      int exact = 0;
32989:      int ambig = 0;
33010:      const struct option *pfound = NULL;
33052:      int indfound;
33072:
33073:      while (*s && *s != '=')
33103:	s++;
33109:
33110:      /* Test all options for either exact match or abbreviated matches.  */
33187:      for (p = longopts, option_index = 0; p->name;
33239:	   p++, option_index++)
33264:	if (!strncmp (p->name, nextchar, s - nextchar))
33313:	  {
33318:	    if (s - nextchar == strlen (p->name))
33361:	      {
33370:		/* Exact match found.  */
33398:		pfound = p;
33412:		indfound = option_index;
33439:		exact = 1;
33452:		break;
33461:	      }
33470:	    else if (pfound == NULL)
33500:	      {
33509:		/* First nonexact match found.  */
33546:		pfound = p;
33560:		indfound = option_index;
33587:	      }
33596:	    else
33606:	      /* Second nonexact match found.  */
33649:	      ambig = 1;
33667:	  }
33672:
33673:      if (ambig && !exact)
33700:	{
33703:	  if (opterr)
33718:	    fprintf (stderr, "%s: option `%s' is ambiguous\n",
33774:		     argv[0], argv[optind]);
33805:	  nextchar += strlen (nextchar);
33839:	  optind++;
33852:	  return '?';
33867:	}
33870:
33871:      if (pfound != NULL)
33897:	{
33900:	  option_index = indfound;
33928:	  optind++;
33941:	  if (*s)
33952:	    {
33959:	      /* Don't test has_arg with >, because some C compilers don't
34027:		 allow it to be used on enums.  */
34064:	      if (pfound->has_arg)
34092:		optarg = s + 1;
34110:	      else
34122:		{
34126:		  if (opterr)
34142:		    {
34150:		      if (argv[optind - 1][1] == '-')
34190:			/* --option */
34208:			fprintf (stderr,
34228:				 "%s: option `--%s' doesn't allow an argument\n",
34282:				 argv[0], pfound->name);
34311:		      else
34324:			/* +option or -option */
34352:			fprintf (stderr,
34372:			     "%s: option `%c%s' doesn't allow an argument\n",
34429:			     argv[0], argv[optind - 1][0], pfound->name);
34482:		    }
34490:		  nextchar += strlen (nextchar);
34525:		  return '?';
34541:		}
34545:	    }
34552:	  else if (pfound->has_arg == 1)
34586:	    {
34593:	      if (optind < argc)
34619:		optarg = argv[optind++];
34646:	      else
34658:		{
34662:		  if (opterr)
34678:		    fprintf (stderr, "%s: option `%s' requires an argument\n",
34743:			     argv[0], argv[optind - 1]);
34779:		  nextchar += strlen (nextchar);
34814:		  return optstring[0] == ':' ? ':' : '?';
34858:		}
34862:	    }
34869:	  nextchar += strlen (nextchar);
34903:	  if (longind != NULL)
34927:	    *longind = option_index;
34957:	  if (pfound->flag)
34978:	    {
34985:	      *(pfound->flag) = pfound->val;
35023:	      return 0;
35040:	    }
35047:	  return pfound->val;
35070:	}
35073:      /* Can't find it as a long option.  If this is not getopt_long_only,
35148:	 or the option starts with '--' or is not a valid short
35205:	 option, then it's an error.
35235:	 Otherwise interpret it as a short option.  */
35283:      if (!long_only || argv[optind][1] == '-'
35330:#ifdef GETOPT_COMPAT
35351:	  || argv[optind][0] == '+'
35380:#endif				/* GETOPT_COMPAT */
35410:	  || my_index (optstring, *nextchar) == NULL)
35457:	{
35460:	  if (opterr)
35475:	    {
35482:	      if (argv[optind][1] == '-')
35517:		/* --option */
35534:		fprintf (stderr, "%s: unrecognized option `--%s'\n",
35589:			 argv[0], nextchar);
35613:	      else
35625:		/* +option or -option */
35652:		fprintf (stderr, "%s: unrecognized option `%c%s'\n",
35707:			 argv[0], argv[optind][0], nextchar);
35748:	    }
35755:	  nextchar = (char *) "";
35782:	  optind++;
35795:	  return '?';
35810:	}
35813:    }
35819:
35820:  /* Look at and handle the next option-character.  */
35875:
35876:  {
35880:    char c = *nextchar++;
35906:    char *temp = my_index (optstring, c);
35948:
35949:    /* Increment `optind' when we start to process its last character.  */
36024:    if (*nextchar == '\0')
36051:      ++optind;
36067:
36068:    if (temp == NULL || c == ':')
36102:      {
36110:	if (opterr)
36123:	  {
36128:#if 0
36134:	    if (c < 040 || c >= 0177)
36165:	      fprintf (stderr, "%s: unrecognized option, character code 0%o\n",
36238:		       argv[0], c);
36260:	    else
36270:	      fprintf (stderr, "%s: unrecognized option `-%c'\n", argv[0], c);
36342:#else
36348:	    /* 1003.2 specifies the format of this message.  */
36405:	    fprintf (stderr, "%s: illegal option -- %c\n", argv[0], c);
36470:#endif
36477:	  }
36482:	optopt = c;
36495:	return '?';
36508:      }
36516:    if (temp[1] == ':')
36540:      {
36548:	if (temp[2] == ':')
36569:	  {
36574:	    /* This is an option that accepts an argument optionally.  */
36641:	    if (*nextchar != '\0')
36669:	      {
36678:		optarg = nextchar;
36699:		optind++;
36711:	      }
36720:	    else
36730:	      optarg = 0;
36749:	    nextchar = NULL;
36771:	  }
36776:	else
36782:	  {
36787:	    /* This is an option that requires an argument.  */
36844:	    if (*nextchar != '\0')
36872:	      {
36881:		optarg = nextchar;
36902:		/* If we end this ARGV-element by taking the rest as an arg,
36965:		   we must advance to the next element now.  */
37015:		optind++;
37027:	      }
37036:	    else if (optind == argc)
37066:	      {
37075:		if (opterr)
37089:		  {
37095:#if 0
37101:		    fprintf (stderr, "%s: option `-%c' requires an argument\n",
37167:			     argv[0], c);
37188:#else
37194:		    /* 1003.2 specifies the format of this message.  */
37252:		    fprintf (stderr, "%s: option requires an argument -- %c\n",
37318:			     argv[0], c);
37339:#endif
37346:		  }
37352:		optopt = c;
37366:		if (optstring[0] == ':')
37393:		  c = ':';
37406:		else
37413:		  c = '?';
37426:	      }
37435:	    else
37445:	      /* We already incremented `optind' once;
37493:		 increment it again when taking next ARGV-elt as argument.  */
37558:	      optarg = argv[optind++];
37590:	    nextchar = NULL;
37612:	  }
37617:      }
37625:    return c;
37639:  }
37643:}
37645:
37646:int
37650:getopt (argc, argv, optstring)
37681:     int argc;
37696:     char *const *argv;
37720:     const char *optstring;
37748:{
37750:  return _getopt_internal (argc, argv, optstring,
37800:			   (const struct option *) 0,
37833:			   (int *) 0,
37850:			   0);
37860:}
37862:
37863:#endif	/* _LIBC or not __GNU_LIBRARY__.  */
37907:
37909:#ifdef TEST
37921:
37922:/* Compile with -DTEST to make an executable for use in testing
37986:   the above definition of `getopt'.  */
38027:
38028:int
38032:main (argc, argv)
38050:     int argc;
38065:     char **argv;
38083:{
38085:  int c;
38094:  int digit_optind = 0;
38118:
38119:  while (1)
38131:    {
38137:      int this_option_optind = optind ? optind : 1;
38189:
38190:      c = getopt (argc, argv, "abc:d:0123456789");
38241:      if (c == EOF)
38261:	break;
38269:
38270:      switch (c)
38287:	{
38290:	case '0':
38301:	case '1':
38312:	case '2':
38323:	case '3':
38334:	case '4':
38345:	case '5':
38356:	case '6':
38367:	case '7':
38378:	case '8':
38389:	case '9':
38400:	  if (digit_optind != 0 && digit_optind != this_option_optind)
38464:	    printf ("digits occur in two different argv-elements.\n");
38528:	  digit_optind = this_option_optind;
38566:	  printf ("option %c\n", c);
38596:	  break;
38606:
38607:	case 'a':
38618:	  printf ("option a\n");
38644:	  break;
38654:
38655:	case 'b':
38666:	  printf ("option b\n");
38692:	  break;
38702:
38703:	case 'c':
38714:	  printf ("option c with value `%s'\n", optarg);
38764:	  break;
38774:
38775:	case '?':
38786:	  break;
38796:
38797:	default:
38807:	  printf ("?? getopt returned character code 0%o ??\n", c);
38868:	}
38871:    }
38877:
38878:  if (optind < argc)
38899:    {
38905:      printf ("non-option ARGV-elements: ");
38950:      while (optind < argc)
38978:	printf ("%s ", argv[optind++]);
39011:      printf ("\n");
39032:    }
39038:
39039:  exit (0);
39051:}
39053:
39054:#endif /* TEST */
39072:/* Extended regular expression matching and search library,
39132:   version 0.12.
39149:   (Implements POSIX draft P10003.2/D11.2, except for
39203:   internationalization features.)
39238:
39239:   Copyright (C) 1993 Free Software Foundation, Inc.
39292:
39293:   This program is free software; you can redistribute it and/or modify
39365:   it under the terms of the GNU General Public License as published by
39437:   the Free Software Foundation; either version 2, or (at your option)
39508:   any later version.
39530:
39531:   This program is distributed in the hope that it will be useful,
39598:   but WITHOUT ANY WARRANTY; without even the implied warranty of
39664:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
39729:   GNU General Public License for more details.
39777:
39778:   You should have received a copy of the GNU General Public License
39847:   along with this program; if not, write to the Free Software
39910:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
39975:
39976:/* AIX requires this to be the first thing in the file. */
40035:#if defined (_AIX) && !defined (REGEX_MALLOC)
40081:  #pragma alloca
40098:#endif
40105:
40106:#define _GNU_SOURCE
40126:
40203:#if flag_systypes==0
40247:#define flag_systypes 1
40271:#endif
40278:
40279:#ifdef HAVE_CONFIG_H
40300:#if flag_config==0
40339:#define flag_config 1
40361:#endif
40368:#endif
40375:
40376:/* The `emacs' switch turns on certain matching commands
40433:   that make sense only in Emacs. */
40470:#ifdef emacs
40483:
40542:
40543:/* Emacs uses `NULL' as a predicate.  */
40584:#undef NULL
40596:
40597:#else  /* not emacs */
40620:
40621:/* We used to test for `BSTRING' here, but only GCC and Emacs define
40690:   `BSTRING', as far as I know, and neither of them use this code.  */
40761:#if HAVE_STRING_H || STDC_HEADERS
40795:#if flag_string==0
40834:#define flag_string 1
40856:#endif
40863:#ifndef bcmp
40876:#define bcmp(s1, s2, n)	memcmp ((s1), (s2), (n))
40925:#endif
40932:#ifndef bcopy
40946:#define bcopy(s, d, n)	memcpy ((d), (s), (n))
40992:#endif
40999:#ifndef bzero
41013:#define bzero(s, n)	memset ((s), 0, (n))
41054:#endif
41061:#else
41067:#if flag_strings==0
41108:#define flag_strings 1
41131:#endif
41138:#endif
41145:
41146:#ifdef STDC_HEADERS
41166:#if flag_stdlib==0 
41206:#define flag_stdlib 1
41228:#endif
41235:#else
41241:char *malloc ();
41258:char *realloc ();
41276:#endif
41283:
41284:
41285:/* Define the syntax stuff for \<, \>, etc.  */
41333:
41334:/* This must be nonzero for the wordchar and notwordchar pattern
41399:   commands in re_match_2.  */
41430:#ifndef Sword 
41445:#define Sword 1
41461:#endif
41468:
41469:#ifdef SYNTAX_TABLE
41489:
41490:extern char *re_syntax_table;
41520:
41521:#else /* not SYNTAX_TABLE */
41550:
41551:/* How many characters in the character set.  */
41600:#define CHAR_SET_SIZE 256
41626:
41627:static char re_syntax_table[CHAR_SET_SIZE];
41671:
41672:static void
41684:init_syntax_once ()
41704:{
41706:   register int c;
41725:   static int done = 0;
41749:
41750:   if (done)
41763:     return;
41776:
41777:   bzero (re_syntax_table, sizeof re_syntax_table);
41829:
41830:   for (c = 'a'; c <= 'z'; c++)
41862:     re_syntax_table[c] = Sword;
41895:
41896:   for (c = 'A'; c <= 'Z'; c++)
41928:     re_syntax_table[c] = Sword;
41961:
41962:   for (c = '0'; c <= '9'; c++)
41994:     re_syntax_table[c] = Sword;
42027:
42028:   re_syntax_table['_'] = Sword;
42061:
42062:   done = 1;
42075:}
42077:
42078:#endif /* not SYNTAX_TABLE */
42108:
42109:#define SYNTAX(c) re_syntax_table[c]
42146:
42147:#endif /* not emacs */
42170:
42172:/* Get the interface, including the syntax bits.  */
42244:
42245:/* isalpha etc. are used for the character classes.  */
42320:
42321:/* Jim Meyering writes:
42345:
42346:   "... Some ctype macros are valid only for character codes that
42412:   isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
42482:   using /bin/cc or gcc but without giving an ansi option).  So, all
42551:   ctype uses should be through macros like ISPRINT...  If
42610:   STDC_HEADERS is defined, then autoconf has verified that the ctype
42680:   macros don't need to be guarded with references to isascii. ...
42747:   Defining isascii to 1 should let any compiler worth its salt
42811:   eliminate the && through constant folding."  */
42862:#if ! defined (isascii) || defined (STDC_HEADERS)
42912:#undef isascii
42927:#define isascii(c) 1
42948:#endif
42955:
42956:#ifdef isblank
42971:#define ISBLANK(c) (isascii (c) && isblank (c))
43019:#else
43025:#define ISBLANK(c) ((c) == ' ' || (c) == '\t')
43072:#endif
43079:#ifdef isgraph
43094:#define ISGRAPH(c) (isascii (c) && isgraph (c))
43142:#else
43148:#define ISGRAPH(c) (isascii (c) && isprint (c) && !isspace (c))
43212:#endif
43219:
43220:#define ISPRINT(c) (isascii (c) && isprint (c))
43268:#define ISDIGIT(c) (isascii (c) && isdigit (c))
43316:#define ISALNUM(c) (isascii (c) && isalnum (c))
43364:#define ISALPHA(c) (isascii (c) && isalpha (c))
43412:#define ISCNTRL(c) (isascii (c) && iscntrl (c))
43460:#define ISLOWER(c) (isascii (c) && islower (c))
43508:#define ISPUNCT(c) (isascii (c) && ispunct (c))
43556:#define ISSPACE(c) (isascii (c) && isspace (c))
43604:#define ISUPPER(c) (isascii (c) && isupper (c))
43652:#define ISXDIGIT(c) (isascii (c) && isxdigit (c))
43702:
43703:#ifndef NULL
43716:#define NULL 0
43731:#endif
43738:
43739:/* We remove any previous definition of `SIGN_EXTEND_CHAR',
43799:   since ours (we hope) works properly with all combinations of
43863:   machines, compilers, `char' and `unsigned char' argument types.
43930:   (Per Bothner suggested the basic approach.)  */
43981:#undef SIGN_EXTEND_CHAR
44005:#if __STDC__
44018:#define SIGN_EXTEND_CHAR(c) ((signed char) (c))
44066:#else  /* not __STDC__ */
44092:/* As in Harbison and Steele.  */
44126:#define SIGN_EXTEND_CHAR(c) ((((unsigned char) (c)) ^ 128) - 128)
44192:#endif
44199:
44201:/* Should we use malloc or alloca?  If REGEX_MALLOC is not defined, we
44272:   use `alloca' instead of `malloc'.  This is because using malloc in
44342:   re_search* or re_match* could cause memory leaks when C-g is used in
44414:   Emacs; also, malloc is slower and causes storage fragmentation.  On
44485:   the other hand, malloc is more portable, and easier to debug.  
44552:   
44556:   Because we sometimes use alloca, some routines have to be macros,
44625:   not functions -- `alloca'-allocated space disappears at the end of the
44699:   function it is called in.  */
44732:
44733:#ifdef REGEX_MALLOC
44753:
44754:#define REGEX_ALLOCATE malloc
44784:#define REGEX_REALLOCATE(source, osize, nsize) realloc (source, nsize)
44855:
44856:#else /* not REGEX_MALLOC  */
44886:
44887:/* Emacs already defines alloca, sometimes.  */
44935:#ifndef alloca
44950:
44951:/* Make alloca work the best possible way.  */
44998:#ifdef __GNUC__
45014:#define alloca __builtin_alloca
45046:#else /* not __GNUC__ */
45071:#if HAVE_ALLOCA_H
45089:#if flag_alloca==0
45128:#define flag_alloca 1
45150:#endif 
45158:#else /* not __GNUC__ or HAVE_ALLOCA_H */
45200:#ifndef _AIX /* Already did AIX, up at the top.  */
45252:char *alloca ();
45269:#endif /* not _AIX */
45291:#endif /* not HAVE_ALLOCA_H */ 
45323:#endif /* not __GNUC__ */
45349:
45350:#endif /* not alloca */
45374:
45375:#define REGEX_ALLOCATE alloca
45405:
45406:/* Assumes a `char *destination' variable.  */
45453:#define REGEX_REALLOCATE(source, osize, nsize)				\
45505:  (destination = (char *) alloca (nsize),				\
45552:   bcopy (source, destination, osize),					\
45597:   destination)
45613:
45614:#endif /* not REGEX_MALLOC */
45644:
45645:
45646:/* True if `size1' is non-NULL and PTR is pointing anywhere inside
45713:   `string1' or just past its end.  This works if PTR is NULL, which is
45785:   a good thing.  */
45806:#define FIRST_STRING_P(ptr) 					\
45841:  (size1 && string1 <= (ptr) && (ptr) <= string1 + size1)
45899:
45900:/* (Re)Allocate N items of type T using malloc, or fail.  */
45961:#define TALLOC(n, t) ((t *) malloc ((n) * sizeof (t)))
46016:#define RETALLOC(addr, n, t) ((addr) = (t *) realloc (addr, (n) * sizeof (t)))
46095:#define REGEX_TALLOC(n, t) ((t *) REGEX_ALLOCATE ((n) * sizeof (t)))
46164:
46165:#define BYTEWIDTH 8 /* In bits.  */
46201:
46202:#define STREQ(s1, s2) ((strcmp (s1, s2) == 0))
46249:
46250:#undef MAX               /****** added later *******/
46304:#define MAX(a, b) ((a) > (b) ? (a) : (b))
46346:#define MIN(a, b) ((a) < (b) ? (a) : (b))
46388:
46389:typedef char boolean;
46411:#define false 0
46427:#define true 1
46442:
46444:/* These are the command codes that appear in compiled regular
46507:   expressions.  Some opcodes are followed by argument bytes.  A
46572:   command code can specify any interpretation whatsoever for its
46638:   arguments.  Zero bytes may appear in the compiled regular expression.
46711:
46712:   The value of `exactn' is needed in search.c (search_buffer) in Emacs.
46785:   So regex.h defines a symbol `RE_EXACTN_VALUE' to be 1; the value of
46856:   `exactn' we use here must also be 1.  */
46900:
46901:typedef enum
46914:{
46916:  no_op = 0,
46929:
46930:        /* Followed by one byte giving n, then by n literal bytes.  */
47001:  exactn = 1,
47015:
47016:        /* Matches any (more or less) character.  */
47069:  anychar,
47080:
47081:        /* Matches any one char belonging to specified set.  First
47148:           following byte is number of bitmap bytes.  Then come bytes
47218:           for a bitmap saying which chars are in.  Bits in each byte
47288:           are ordered low-bit-first.  A character is in the set if its
47360:           bit is 1.  A character too large to have a bit in the map is
47432:           automatically not in the set.  */
47477:  charset,
47488:
47489:        /* Same parameters as charset, but match any character that is
47560:           not one of those specified.  */
47603:  charset_not,
47618:
47619:        /* Start remembering the text that is matched, for storing in a
47691:           register.  Followed by one byte with the register number, in
47763:           the range 0 to one less than the pattern buffer's re_nsub
47832:           field.  Then followed by one byte with the number of groups
47903:           inner to this one.  (This last has to be part of the
47967:           start_memory only because we need it in the on_failure_jump
48038:           of re_match_2.)  */
48069:  start_memory,
48085:
48086:        /* Stop remembering the text that is matched and store it in a
48157:           memory register.  Followed by one byte with the register
48225:           number, in the range 0 to one less than `re_nsub' in the
48293:           pattern buffer, and one byte with the number of inner groups,
48366:           just like `start_memory'.  (We need the number of inner
48433:           groups here because we don't have any easy way of finding the
48506:           corresponding start_memory when we're at a stop_memory.)  */
48578:  stop_memory,
48593:
48594:        /* Match a duplicate of something remembered. Followed by one
48664:           byte containing the register number.  */
48716:  duplicate,
48729:
48730:        /* Fail unless at beginning of line.  */
48779:  begline,
48790:
48791:        /* Fail unless at end of line.  */
48834:  endline,
48845:
48846:        /* Succeeds if at beginning of buffer (if emacs) or at beginning
48919:           of string to be matched (if not).  */
48968:  begbuf,
48978:
48979:        /* Analogously, for end of buffer/string.  */
49033:  endbuf,
49043: 
49045:        /* Followed by two byte relative address to which to jump.  */
49116:  jump, 
49125:
49126:	/* Same as jump, but marks the end of an alternative.  */
49185:  jump_past_alt,
49202:
49203:        /* Followed by two-byte relative address of place to resume at
49274:           in case of failure.  */
49309:  on_failure_jump,
49328:	
49330:        /* Like on_failure_jump, but pushes a placeholder instead of the
49403:           current string position when executed.  */
49457:  on_failure_keep_string_jump,
49488:  
49491:        /* Throw away latest failure point and then jump to following
49561:           two-byte relative address.  */
49603:  pop_failure_jump,
49623:
49624:        /* Change to pop_failure_jump if know won't have to backtrack to
49697:           match; otherwise change to jump.  This is used to jump
49763:           back to the beginning of a repeat.  If what follows this jump
49836:           clearly won't match what the repeat does, such that we can be
49909:           sure that there is no use backtracking out of repetitions
49978:           already matched, then we change it to a pop_failure_jump.
50047:           Followed by two-byte address.  */
50092:  maybe_pop_jump,
50110:
50111:        /* Jump to following two-byte address, and push a dummy failure
50183:           point. This failure point will be thrown away if an attempt
50254:           is made to use it for a failure.  A `+' construct makes this
50326:           before the first repeat.  Also used as an intermediary kind
50397:           of jump when compiling an alternative.  */
50451:  dummy_failure_jump,
50473:
50474:	/* Push a dummy failure point and continue.  Used at the end of
50539:	   alternatives.  */
50561:  push_dummy_failure,
50583:
50584:        /* Followed by two-byte relative address and two-byte number n.
50656:           After matching N times, jump to the address upon failure.  */
50729:  succeed_n,
50742:
50743:        /* Followed by two-byte relative address, and two-byte number n.
50816:           Jump to the address N times, then fail.  */
50871:  jump_n,
50881:
50882:        /* Set the following two-byte relative address to the
51015:           bytes of number.  */
51047:  set_number_at,
51064:
51065:  wordchar,	/* Matches any word-constituent character.  */
51124:  notwordchar,	/* Matches any char that is not a word-constituent.  */
51195:
51196:  wordbeg,	/* Succeeds if at word beginning.  */
51245:  wordend,	/* Succeeds if at word end.  */
51288:
51289:  wordbound,	/* Succeeds if at a word boundary.  */
51341:  notwordbound	/* Succeeds if not at a word boundary.  */
51399:
51400:#ifdef emacs
51413:  ,before_dot,	/* Succeeds if before point.  */
51461:  at_dot,	/* Succeeds if at point.  */
51500:  after_dot,	/* Succeeds if after point.  */
51545:
51546:	/* Matches any character whose syntax is specified.  Followed by
51612:           a byte which contains a syntax code, e.g., Sword.  */
51677:  syntaxspec,
51691:
51692:	/* Matches any character whose syntax is not that specified.  */
51758:  notsyntaxspec
51774:#endif /* emacs */
51793:} re_opcode_t;
51808:
51810:/* Common operations on the compiled pattern.  */
51860:
51861:/* Store NUMBER in two contiguous bytes starting at DESTINATION.  */
51930:
51931:#define STORE_NUMBER(destination, number)				\
51978:  do {									\
51995:    (destination)[0] = (number) & 0377;					\
52041:    (destination)[1] = (number) >> 8;					\
52085:  } while (0)
52099:
52100:/* Same as STORE_NUMBER, except increment DESTINATION to
52157:   the byte after where the number is stored.  Therefore, DESTINATION
52227:   must be an lvalue.  */
52253:
52254:#define STORE_NUMBER_AND_INCR(destination, number)			\
52309:  do {									\
52326:    STORE_NUMBER (destination, number);					\
52372:    (destination) += 2;							\
52404:  } while (0)
52418:
52419:/* Put into DESTINATION a number stored in two contiguous bytes starting
52492:   at SOURCE.  */
52510:
52511:#define EXTRACT_NUMBER(destination, source)				\
52560:  do {									\
52577:    (destination) = *(source) & 0377;					\
52621:    (destination) += SIGN_EXTEND_CHAR (*((source) + 1)) << 8;		\
52686:  } while (0)
52700:
52701:#ifdef DEBUG
52714:static void
52726:extract_number (dest, source)
52756:    int *dest;
52771:    unsigned char *source;
52798:{
52800:  int temp = SIGN_EXTEND_CHAR (*(source + 1)); 
52848:  *dest = *source & 0377;
52874:  *dest += temp << 8;
52896:}
52898:
52899:#ifndef EXTRACT_MACROS /* To debug the macros.  */
52950:#undef EXTRACT_NUMBER
52972:#define EXTRACT_NUMBER(dest, src) extract_number (&dest, src)
53034:#endif /* not EXTRACT_MACROS */
53066:
53067:#endif /* DEBUG */
53086:
53087:/* Same as EXTRACT_NUMBER, except increment SOURCE to after the number.
53159:   SOURCE must be an lvalue.  */
53192:
53193:#define EXTRACT_NUMBER_AND_INCR(destination, source)			\
53250:  do {									\
53267:    EXTRACT_NUMBER (destination, source);				\
53314:    (source) += 2; 							\
53342:  } while (0)
53356:
53357:#ifdef DEBUG
53370:static void
53382:extract_number_and_incr (destination, source)
53428:    int *destination;
53450:    unsigned char **source;
53478:{ 
53481:  extract_number (destination, *source);
53522:  *source += 2;
53538:}
53540:
53541:#ifndef EXTRACT_MACROS
53564:#undef EXTRACT_NUMBER_AND_INCR
53595:#define EXTRACT_NUMBER_AND_INCR(dest, src) \
53640:  extract_number_and_incr (&dest, &src)
53680:#endif /* not EXTRACT_MACROS */
53712:
53713:#endif /* DEBUG */
53732:
53734:/* If DEBUG is defined, Regex prints many voluminous messages about what
53807:   it is doing (if the variable `debug' is nonzero).  If linked with the
53880:   main program in `iregex.c', you can enter patterns and strings
53946:   interactively.  And if linked with the main program in `main.c' and
54017:   the other test files, you can run the already-written tests.  */
54085:
54086:#ifdef DEBUG
54099:
54100:/* We use standard I/O for debugging.  */
54165:
54166:/* It is useful to test things that ``must'' be true when debugging.  */
54259:
54260:static int debug = 0;
54282:
54283:#define DEBUG_STATEMENT(e) e
54312:#define DEBUG_PRINT1(x) if (debug) printf (x)
54358:#define DEBUG_PRINT2(x1, x2) if (debug) printf (x1, x2)
54414:#define DEBUG_PRINT3(x1, x2, x3) if (debug) printf (x1, x2, x3)
54478:#define DEBUG_PRINT4(x1, x2, x3, x4) if (debug) printf (x1, x2, x3, x4)
54550:#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e) 				\
54602:  if (debug) print_partial_compiled_pattern (s, e)
54653:#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)			\
54712:  if (debug) print_double_string (w, s1, sz1, s2, sz2)
54767:
54768:
54769:extern void printchar ();
54795:
54796:/* Print the fastmap in human-readable form.  */
54845:
54846:void
54851:print_fastmap (fastmap)
54875:    char *fastmap;
54894:{
54896:  unsigned was_a_range = 0;
54924:  unsigned i = 0;  
54944:  
54947:  while (i < (1 << BYTEWIDTH))
54978:    {
54984:      if (fastmap[i++])
55008:	{
55011:	  was_a_range = 0;
55031:          printchar (i - 1);
55060:          while (i < (1 << BYTEWIDTH)  &&  fastmap[i])
55115:            {
55129:              was_a_range = 1;
55160:              i++;
55179:            }
55193:	  if (was_a_range)
55213:            {
55227:              printf ("-");
55255:              printchar (i - 1);
55288:            }
55302:        }
55312:    }
55318:  putchar ('\n'); 
55337:}
55339:
55340:
55341:/* Print a compiled pattern string in human-readable form, starting at
55412:   the START pointer into it and ending just before the pointer END.  */
55485:
55486:void
55491:print_partial_compiled_pattern (start, end)
55535:    unsigned char *start;
55561:    unsigned char *end;
55585:{
55587:  int mcnt, mcnt2;
55606:  unsigned char *p = start;
55634:  unsigned char *pend = end;
55663:
55664:  if (start == NULL)
55685:    {
55691:      printf ("(null)\n");
55718:      return;
55732:    }
55738:    
55743:  /* Loop over pattern commands.  */
55780:  while (p < pend)
55799:    {
55805:      printf ("%d:\t", p - start);
55840:
55841:      switch ((re_opcode_t) *p++)
55875:	{
55878:        case no_op:
55898:          printf ("/no_op");
55927:          break;
55944:
55945:	case exactn:
55959:	  mcnt = *p++;
55975:          printf ("/exactn/%d", mcnt);
56014:          do
56027:	    {
56034:              putchar ('/');
56063:	      printchar (*p++);
56088:            }
56102:          while (--mcnt);
56128:          break;
56145:
56146:	case start_memory:
56166:          mcnt = *p++;
56189:          printf ("/start_memory/%d/%d", mcnt, *p++);
56243:          break;
56260:
56261:	case stop_memory:
56280:          mcnt = *p++;
56303:	  printf ("/stop_memory/%d/%d", mcnt, *p++);
56349:          break;
56366:
56367:	case duplicate:
56384:	  printf ("/duplicate/%d", *p++);
56419:	  break;
56429:
56430:	case anychar:
56445:	  printf ("/anychar");
56469:	  break;
56479:
56480:	case charset:
56495:        case charset_not:
56521:          {
56533:            register int c, last = -100;
56574:	    register int in_range = 0;
56606:
56607:	    printf ("/charset [%s",
56636:	            (re_opcode_t) *(p - 1) == charset_not ? "^" : "");
56700:            
56713:            assert (p + *p < pend);
56749:
56750:            for (c = 0; c < 256; c++)
56788:	      if (c / 8 < *p
56810:		  && (p[1 + (c/8)] & (1 << (c % 8))))
56850:		{
56854:		  /* Are we starting a range?  */
56890:		  if (last + 1 == c && ! in_range)
56927:		    {
56935:		      putchar ('-');
56958:		      in_range = 1;
56980:		    }
56988:		  /* Have we broken a range?  */
57023:		  else if (last + 1 != c && in_range)
57063:              {
57079:		      printchar (last);
57105:		      in_range = 0;
57127:		    }
57135:                
57152:		  if (! in_range)
57172:		    printchar (c);
57193:
57194:		  last = c;
57208:              }
57224:
57225:	    if (in_range)
57244:	      printchar (last);
57269:
57270:	    putchar (']');
57290:
57291:	    p += 1 + *p;
57309:	  }
57314:	  break;
57324:
57325:	case begline:
57340:	  printf ("/begline");
57364:          break;
57381:
57382:	case endline:
57397:          printf ("/endline");
57428:          break;
57445:
57446:	case on_failure_jump:
57469:          extract_number_and_incr (&mcnt, &p);
57516:  	  printf ("/on_failure_jump to %d", p + mcnt - start);
57574:          break;
57591:
57592:	case on_failure_keep_string_jump:
57627:          extract_number_and_incr (&mcnt, &p);
57674:  	  printf ("/on_failure_keep_string_jump to %d", p + mcnt - start);
57744:          break;
57761:
57762:	case dummy_failure_jump:
57788:          extract_number_and_incr (&mcnt, &p);
57835:  	  printf ("/dummy_failure_jump to %d", p + mcnt - start);
57896:          break;
57913:
57914:	case push_dummy_failure:
57940:          printf ("/push_dummy_failure");
57982:          break;
57999:          
58010:        case maybe_pop_jump:
58039:          extract_number_and_incr (&mcnt, &p);
58086:  	  printf ("/maybe_pop_jump to %d", p + mcnt - start);
58143:	  break;
58153:
58154:        case pop_failure_jump:
58185:	  extract_number_and_incr (&mcnt, &p);
58225:  	  printf ("/pop_failure_jump to %d", p + mcnt - start);
58284:	  break;          
58304:          
58315:        case jump_past_alt:
58343:	  extract_number_and_incr (&mcnt, &p);
58383:  	  printf ("/jump_past_alt to %d", p + mcnt - start);
58439:	  break;          
58459:          
58470:        case jump:
58489:	  extract_number_and_incr (&mcnt, &p);
58529:  	  printf ("/jump to %d", p + mcnt - start);
58576:	  break;
58586:
58587:        case succeed_n: 
58612:          extract_number_and_incr (&mcnt, &p);
58659:          extract_number_and_incr (&mcnt2, &p);
58707:	  printf ("/succeed_n to %d, %d times", p + mcnt - start, mcnt2);
58774:          break;
58791:        
58800:        case jump_n: 
58822:          extract_number_and_incr (&mcnt, &p);
58869:          extract_number_and_incr (&mcnt2, &p);
58917:	  printf ("/jump_n to %d, %d times", p + mcnt - start, mcnt2);
58981:          break;
58998:        
59007:        case set_number_at: 
59036:          extract_number_and_incr (&mcnt, &p);
59083:          extract_number_and_incr (&mcnt2, &p);
59131:	  printf ("/set_number_at location %d to %d", p + mcnt - start, mcnt2);
59204:          break;
59221:        
59230:        case wordbound:
59254:	  printf ("/wordbound");
59280:	  break;
59290:
59291:	case notwordbound:
59311:	  printf ("/notwordbound");
59340:          break;
59357:
59358:	case wordbeg:
59373:	  printf ("/wordbeg");
59397:	  break;
59407:          
59418:	case wordend:
59433:	  printf ("/wordend");
59457:          
59468:#ifdef emacs
59481:	case before_dot:
59499:	  printf ("/before_dot");
59526:          break;
59543:
59544:	case at_dot:
59558:	  printf ("/at_dot");
59581:          break;
59598:
59599:	case after_dot:
59616:	  printf ("/after_dot");
59642:          break;
59659:
59660:	case syntaxspec:
59678:          printf ("/syntaxspec");
59712:	  mcnt = *p++;
59728:	  printf ("/%d", mcnt);
59753:          break;
59770:	  
59774:	case notsyntaxspec:
59795:          printf ("/notsyntaxspec");
59832:	  mcnt = *p++;
59848:	  printf ("/%d", mcnt);
59873:	  break;
59883:#endif /* emacs */
59902:
59903:	case wordchar:
59919:	  printf ("/wordchar");
59944:          break;
59961:	  
59965:	case notwordchar:
59984:	  printf ("/notwordchar");
60012:          break;
60029:
60030:	case begbuf:
60044:	  printf ("/begbuf");
60067:          break;
60084:
60085:	case endbuf:
60099:	  printf ("/endbuf");
60122:          break;
60139:
60140:        default:
60157:          printf ("?%d", *(p-1));
60191:	}
60194:
60195:      putchar ('\n');
60217:    }
60223:
60224:  printf ("%d:\tend of pattern.\n", p - start);
60272:}
60274:
60275:
60276:void
60281:print_compiled_pattern (bufp)
60311:    struct re_pattern_buffer *bufp;
60347:{
60349:  unsigned char *buffer = bufp->buffer;
60389:
60390:  print_partial_compiled_pattern (buffer, buffer + bufp->used);
60454:  printf ("%d bytes used/%d bytes allocated.\n", bufp->used, bufp->allocated);
60533:
60534:  if (bufp->fastmap_accurate && bufp->fastmap)
60581:    {
60587:      printf ("fastmap: ");
60615:      print_fastmap (bufp->fastmap);
60652:    }
60658:
60659:  printf ("re_nsub: %d\t", bufp->re_nsub);
60702:  printf ("regs_alloc: %d\t", bufp->regs_allocated);
60755:  printf ("can_be_null: %d\t", bufp->can_be_null);
60806:  printf ("newline_anchor: %d\n", bufp->newline_anchor);
60863:  printf ("no_sub: %d\t", bufp->no_sub);
60904:  printf ("not_bol: %d\t", bufp->not_bol);
60947:  printf ("not_eol: %d\t", bufp->not_eol);
60990:  printf ("syntax: %d\n", bufp->syntax);
61031:  /* Perhaps we should print the translate table?  */
61085:}
61087:
61088:
61089:void
61094:print_double_string (where, string1, size1, string2, size2)
61154:    const char *where;
61177:    const char *string1;
61202:    const char *string2;
61227:    int size1;
61242:    int size2;
61257:{
61259:  unsigned this_char;
61281:  
61284:  if (where == NULL)
61305:    printf ("(null)");
61328:  else
61335:    {
61341:      if (FIRST_STRING_P (where))
61375:        {
61385:          for (this_char = where - string1; this_char < size1; this_char++)
61461:            printchar (string1[this_char]);
61505:
61506:          where = string2;    
61537:        }
61547:
61548:      for (this_char = where - string2; this_char < size2; this_char++)
61620:        printchar (string2[this_char]);
61660:    }
61666:}
61668:
61669:#else /* not DEBUG */
61691:
61692:#undef assert
61706:#define assert(e)
61724:
61725:#define DEBUG_STATEMENT(e)
61752:#define DEBUG_PRINT1(x)
61776:#define DEBUG_PRINT2(x1, x2)
61805:#define DEBUG_PRINT3(x1, x2, x3)
61838:#define DEBUG_PRINT4(x1, x2, x3, x4)
61875:#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e)
61921:#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)
61976:
61977:#endif /* not DEBUG */
62000:
62002:/* Set by `re_set_syntax' to the current regexp syntax to recognize.  Can
62076:   also be assigned to arbitrarily: each pattern buffer stores its own
62147:   syntax, so it can be changed between regex compilations.  */
62211:reg_syntax_t re_syntax_options = RE_SYNTAX_EMACS;
62261:
62262:
62263:/* Specify the precise syntax of regexps for compilation.  This provides
62336:   for compatibility for various utilities which historically have
62403:   different, incompatible syntaxes.
62440:
62441:   The argument SYNTAX is a bit mask comprised of the various bits
62508:   defined in regex.h.  We return the old syntax.  */
62562:
62563:reg_syntax_t
62576:re_set_syntax (syntax)
62599:    reg_syntax_t syntax;
62624:{
62626:  reg_syntax_t ret = re_syntax_options;
62666:  
62669:  re_syntax_options = syntax;
62699:  return ret;
62713:}
62715:
62717:/* This table gives an error message for each of the error codes listed
62789:   in regex.h.  Obviously the order here has to be same as there.  */
62859:
62860:static const char *re_error_msg[] =
62896:  { NULL,					/* REG_NOERROR */
62928:    "No match",					/* REG_NOMATCH */
62966:    "Invalid regular expression",		/* REG_BADPAT */
63018:    "Invalid collation character",		/* REG_ECOLLATE */
63073:    "Invalid character class name",		/* REG_ECTYPE */
63127:    "Trailing backslash",			/* REG_EESCAPE */
63173:    "Invalid back reference",			/* REG_ESUBREG */
63223:    "Unmatched [ or [^",			/* REG_EBRACK */
63267:    "Unmatched ( or \\(",			/* REG_EPAREN */
63312:    "Unmatched \\{",				/* REG_EBRACE */
63353:    "Invalid content of \\{\\}",		/* REG_BADBR */
63403:    "Invalid range end",			/* REG_ERANGE */
63447:    "Memory exhausted",				/* REG_ESPACE */
63491:    "Invalid preceding regular expression",	/* REG_BADRPT */
63552:    "Premature end of regular expression",	/* REG_EEND */
63610:    "Regular expression too big",		/* REG_ESIZE */
63661:    "Unmatched ) or \\)",			/* REG_ERPAREN */
63707:  };
63712:
63714:/* Subroutine declarations and macros for regex_compile.  */
63775:
63776:static void store_op1 (), store_op2 ();
63816:static void insert_op1 (), insert_op2 ();
63858:static boolean at_begline_loc_p (), at_endline_loc_p ();
63915:static boolean group_in_compile_stack ();
63957:static reg_errcode_t compile_range ();
63996:
63997:/* Fetch the next character in the uncompiled pattern---translating it 
64069:   if necessary.  Also cast from a signed character in the constant
64137:   string passed to us by the user to an unsigned char that we can use
64208:   as an array index (in, e.g., `translate').  */
64258:#define PATFETCH(c)							\
64286:  do {if (p == pend) return REG_EEND;					\
64330:    c = (unsigned char) *p++;						\
64367:    if (translate) c = translate[c]; 					\
64411:  } while (0)
64425:
64426:/* Fetch the next character in the uncompiled pattern, with no
64489:   translation.  */
64509:#define PATFETCH_RAW(c)							\
64541:  do {if (p == pend) return REG_EEND;					\
64585:    c = (unsigned char) *p++; 						\
64623:  } while (0)
64637:
64638:/* Go backwards one character in the pattern.  */
64688:#define PATUNFETCH p--
64711:
64712:
64713:/* If `translate' is non-null, return translate[D], else just D.  We
64782:   cast the subscript to translate because some data is declared as
64850:   `char *', to avoid warnings when a string constant is passed.  But
64920:   when we use a character as a subscript we must make it unsigned.  */
64992:#define TRANSLATE(d) (translate ? translate[(unsigned char) (d)] : (d))
65064:
65065:
65066:/* Macros for outputting the compiled pattern into `buffer'.  */
65131:
65132:/* If the buffer isn't allocated when it comes in, use this.  */
65197:#define INIT_BUF_SIZE  32
65223:
65224:/* Make sure we have at least N more bytes of space in buffer.  */
65291:#define GET_BUFFER_SPACE(n)						\
65326:    while (b - bufp->buffer + (n) > bufp->allocated)			\
65383:      EXTEND_BUFFER ()
65406:
65407:/* Make sure we have one more byte of buffer space and then add C to it.  */
65484:#define BUF_PUSH(c)							\
65512:  do {									\
65529:    GET_BUFFER_SPACE (1);						\
65562:    *b++ = (unsigned char) (c);						\
65601:  } while (0)
65615:
65616:
65617:/* Ensure we have two more bytes of buffer space and then append C1 and C2.  */
65697:#define BUF_PUSH_2(c1, c2)						\
65731:  do {									\
65748:    GET_BUFFER_SPACE (2);						\
65781:    *b++ = (unsigned char) (c1);					\
65820:    *b++ = (unsigned char) (c2);					\
65859:  } while (0)
65873:
65874:
65875:/* As with BUF_PUSH_2, except for three bytes.  */
65926:#define BUF_PUSH_3(c1, c2, c3)						\
65964:  do {									\
65981:    GET_BUFFER_SPACE (3);						\
66014:    *b++ = (unsigned char) (c1);					\
66053:    *b++ = (unsigned char) (c2);					\
66092:    *b++ = (unsigned char) (c3);					\
66131:  } while (0)
66145:
66146:
66147:/* Store a jump with opcode OP at LOC to location TO.  We store a
66213:   relative address offset by the three bytes the jump itself occupies.  */
66289:#define STORE_JUMP(op, loc, to) \
66323:  store_op1 (op, loc, (to) - (loc) - 3)
66363:
66364:/* Likewise, for a two-argument jump.  */
66406:#define STORE_JUMP2(op, loc, to, arg) \
66446:  store_op2 (op, loc, (to) - (loc) - 3, arg)
66491:
66492:/* Like `STORE_JUMP', but for inserting.  Assume `b' is the buffer end.  */
66568:#define INSERT_JUMP(op, loc, to) \
66603:  insert_op1 (op, loc, (to) - (loc) - 3, b)
66647:
66648:/* Like `STORE_JUMP2', but for inserting.  Assume `b' is the buffer end.  */
66725:#define INSERT_JUMP2(op, loc, to, arg) \
66766:  insert_op2 (op, loc, (to) - (loc) - 3, arg, b)
66815:
66816:
66817:/* This is not an arbitrary limit: the arguments which represent offsets
66890:   into the pattern are two bytes long.  So if 2^16 bytes turns out to
66961:   be too small, many things would have to change.  */
67016:#define MAX_BUF_SIZE (1L << 16)
67048:
67049:
67050:/* Extend the buffer by twice its current size via realloc and
67113:   reset the pointers that pointed into the old block to point to the
67183:   correct places in the new one.  If extending the buffer results in it
67256:   being larger than MAX_BUF_SIZE, then flag memory exhausted.  */
67323:#define EXTEND_BUFFER()							\
67355:  do { 									\
67373:    unsigned char *old_buffer = bufp->buffer;				\
67424:    if (bufp->allocated == MAX_BUF_SIZE) 				\
67471:      return REG_ESIZE;							\
67503:    bufp->allocated <<= 1;						\
67537:    if (bufp->allocated > MAX_BUF_SIZE)					\
67583:      bufp->allocated = MAX_BUF_SIZE; 					\
67628:    bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated);\
67707:    if (bufp->buffer == NULL)						\
67744:      return REG_ESPACE;						\
67776:    /* If the buffer moved, move all the pointers into it.  */		\
67842:    if (old_buffer != bufp->buffer)					\
67884:      {									\
67902:        b = (b - old_buffer) + bufp->buffer;				\
67952:        begalt = (begalt - old_buffer) + bufp->buffer;			\
68011:        if (fixup_alt_jump)						\
68046:          fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;\
68120:        if (laststart)							\
68151:          laststart = (laststart - old_buffer) + bufp->buffer;		\
68217:        if (pending_exact)						\
68251:          pending_exact = (pending_exact - old_buffer) + bufp->buffer;	\
68324:      }									\
68342:  } while (0)
68356:
68357:
68358:/* Since we have one byte reserved for the register number argument to
68429:   {start,stop}_memory, the maximum number of groups we can report
68496:   things about is what fits in that byte.  */
68543:#define MAX_REGNUM 255
68566:
68567:/* But patterns can have more than `MAX_REGNUM' registers.  We just
68635:   ignore the excess.  */
68661:typedef unsigned regnum_t;
68688:
68689:
68690:/* Macros for the compile stack.  */
68727:
68728:/* Since offsets can go either forwards or backwards, this type needs to
68801:   be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
68877:typedef int pattern_offset_t;
68907:
68908:typedef struct
68923:{
68925:  pattern_offset_t begalt_offset;
68959:  pattern_offset_t fixup_alt_jump;
68994:  pattern_offset_t inner_group_offset;
69033:  pattern_offset_t laststart_offset;  
69072:  regnum_t regnum;
69091:} compile_stack_elt_t;
69114:
69115:
69116:typedef struct
69131:{
69133:  compile_stack_elt_t *stack;
69163:  unsigned size;
69180:  unsigned avail;			/* Offset of next open position.  */
69237:} compile_stack_type;
69259:
69260:
69261:#define INIT_COMPILE_STACK_SIZE 32
69296:
69297:#define COMPILE_STACK_EMPTY  (compile_stack.avail == 0)
69353:#define COMPILE_STACK_FULL  (compile_stack.avail == compile_stack.size)
69425:
69426:/* The next available element.  */
69461:#define COMPILE_STACK_TOP (compile_stack.stack[compile_stack.avail])
69530:
69531:
69532:/* Set the bit for character C in a list.  */
69578:#define SET_LIST_BIT(c)                               \
69634:  (b[((unsigned char) (c)) / BYTEWIDTH]               \
69690:   |= 1 << (((unsigned char) c) % BYTEWIDTH))
69736:
69737:
69738:/* Get the next unsigned number in the uncompiled pattern.  */
69801:#define GET_UNSIGNED_NUMBER(num) 					\
69841:  { if (p != pend)							\
69868:     {									\
69885:       PATFETCH (c); 							\
69915:       while (ISDIGIT (c)) 						\
69950:         { 								\
69971:           if (num < 0)							\
70003:              num = 0;							\
70034:           num = num * 10 + c - '0'; 					\
70078:           if (p == pend) 						\
70112:              break; 							\
70142:           PATFETCH (c);						\
70174:         } 								\
70195:       } 								\
70214:    }		
70222:
70223:#define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */
70281:
70282:#define IS_CHAR_CLASS(string)						\
70319:   (STREQ (string, "alpha") || STREQ (string, "upper")			\
70378:    || STREQ (string, "lower") || STREQ (string, "digit")		\
70439:    || STREQ (string, "alnum") || STREQ (string, "xdigit")		\
70501:    || STREQ (string, "space") || STREQ (string, "print")		\
70562:    || STREQ (string, "punct") || STREQ (string, "graph")		\
70623:    || STREQ (string, "cntrl") || STREQ (string, "blank"))
70682:
70684:/* `regex_compile' compiles PATTERN (of length SIZE) according to SYNTAX.
70758:   Returns one of error codes defined in `regex.h', or zero for success.
70831:
70832:   Assumes the `allocated' (and perhaps `buffer') and `translate'
70898:   fields are set in BUFP on entry.
70934:
70935:   If it succeeds, results are put in BUFP (if it returns an error, the
71007:   contents of BUFP are undefined):
71043:     `buffer' is the compiled pattern;
71082:     `syntax' is set to SYNTAX;
71114:     `used' is set to the length of the compiled pattern;
71172:     `fastmap_accurate' is zero;
71205:     `re_nsub' is the number of subexpressions in PATTERN;
71264:     `not_bol' and `not_eol' are zero;
71303:   
71307:   The `fastmap' and `newline_anchor' fields are neither
71364:   examined nor set.  */
71389:
71390:static reg_errcode_t
71411:regex_compile (pattern, size, syntax, bufp)
71455:     const char *pattern;
71481:     int size;
71496:     reg_syntax_t syntax;
71522:     struct re_pattern_buffer *bufp;
71559:{
71561:  /* We fetch characters from PATTERN here.  Even though PATTERN is
71629:     `char *' (i.e., signed), we declare these variables as unsigned, so
71702:     they can be reliably used as array indices.  */
71755:  register unsigned char c, c1;
71787:  
71790:  /* A random tempory spot in PATTERN.  */
71833:  const char *p1;
71851:
71852:  /* Points to the end of the buffer, where we should append.  */
71918:  register unsigned char *b;
71947:  
71950:  /* Keeps track of unclosed groups.  */
71991:  compile_stack_type compile_stack;
72027:
72028:  /* Points to the current (ending) position in the pattern.  */
72093:  const char *p = pattern;
72120:  const char *pend = pattern + size;
72157:  
72160:  /* How to translate the characters in the pattern.  */
72217:  char *translate = bufp->translate;
72254:
72255:  /* Address of the count-byte of the most recently inserted `exactn'
72325:     command.  This makes it possible to tell if a new exact-match
72392:     character can be added to that command or if the character requires
72465:     a new `exactn' command.  */
72498:  unsigned char *pending_exact = 0;
72534:
72535:  /* Address of start of the most recently finished expression.
72599:     This tells, e.g., postfix * where to find the start of its
72663:     operand.  Reset at the beginning of groups and alternatives.  */
72733:  unsigned char *laststart = 0;
72765:
72766:  /* Address of beginning of regexp, or inside of last group.  */
72832:  unsigned char *begalt;
72857:
72858:  /* Place in the uncompiled pattern (i.e., the {) to
72912:     which to go back if the interval is invalid.  */
72966:  const char *beg_interval;
72994:                
73011:  /* Address of the place where a forward jump should go to the end of
73082:     the containing expression.  Each alternative of an `or' -- except the
73157:     last -- ends with a forward jump of this sort.  */
73213:  unsigned char *fixup_alt_jump = 0;
73250:
73251:  /* Counts open-groups as they are encountered.  Remembered for the
73320:     matching close-group on the compile stack, so the same register
73389:     number is put in the stop_memory as the start_memory.  */
73452:  regnum_t regnum = 0;
73475:
73476:#ifdef DEBUG
73489:  DEBUG_PRINT1 ("\nCompiling pattern: ");
73531:  if (debug)
73544:    {
73550:      unsigned debug_count;
73578:      
73585:      for (debug_count = 0; debug_count < size; debug_count++)
73648:        printchar (pattern[debug_count]);
73690:      putchar ('\n');
73712:    }
73718:#endif /* DEBUG */
73737:
73738:  /* Initialize the compile stack.  */
73777:  compile_stack.stack = TALLOC (INIT_COMPILE_STACK_SIZE, compile_stack_elt_t);
73856:  if (compile_stack.stack == NULL)
73891:    return REG_ESPACE;
73914:
73915:  compile_stack.size = INIT_COMPILE_STACK_SIZE;
73963:  compile_stack.avail = 0;
73990:
73991:  /* Initialize the pattern buffer.  */
74031:  bufp->syntax = syntax;
74056:  bufp->fastmap_accurate = 0;
74086:  bufp->not_bol = bufp->not_eol = 0;
74123:
74124:  /* Set `used' to zero, so that if we return an error, the pattern
74192:     printer (for debugging) will think there's no pattern.  We reset it
74265:     at the end.  */
74286:  bufp->used = 0;
74304:  
74307:  /* Always count groups, whether or not bufp->no_sub is set.  */
74373:  bufp->re_nsub = 0;				
74398:
74399:#if !defined (emacs) && !defined (SYNTAX_TABLE)
74447:  /* Initialize the syntax table.  */
74485:   init_syntax_once ();
74509:#endif
74516:
74517:  if (bufp->allocated == 0)
74545:    {
74551:      if (bufp->buffer)
74575:	{ /* If zero allocated, but buffer is non-null, try to realloc
74639:             enough space.  This loses if buffer's address is bogus, but
74712:             that is the user's responsibility.  */
74764:          RETALLOC (bufp->buffer, INIT_BUF_SIZE, unsigned char);
74829:        }
74839:      else
74850:        { /* Caller did not allocate a buffer.  Do it for them.  */
74918:          bufp->buffer = TALLOC (INIT_BUF_SIZE, unsigned char);
74982:        }
74992:      if (!bufp->buffer) return REG_ESPACE;
75036:
75037:      bufp->allocated = INIT_BUF_SIZE;
75076:    }
75082:
75083:  begalt = b = bufp->buffer;
75112:
75113:  /* Loop through the uncompiled pattern until we're at the end.  */
75182:  while (p != pend)
75202:    {
75208:      PATFETCH (c);
75228:
75229:      switch (c)
75246:        {
75256:        case '^':
75274:          {
75286:            if (   /* If at start of pattern, it's an operator.  */
75354:                   p == pattern + 1
75390:                   /* If context independent, it's an operator.  */
75458:                || syntax & RE_CONTEXT_INDEP_ANCHORS
75511:                   /* Otherwise, depends on what's come before.  */
75579:                || at_begline_loc_p (pattern, p, syntax))
75637:              BUF_PUSH (begline);
75671:            else
75688:              goto normal_char;
75720:          }
75732:          break;
75749:
75750:
75751:        case '$':
75769:          {
75781:            if (   /* If at end of pattern, it's an operator.  */
75847:                   p == pend 
75877:                   /* If context independent, it's an operator.  */
75945:                || syntax & RE_CONTEXT_INDEP_ANCHORS
75998:                   /* Otherwise, depends on what's next.  */
76059:                || at_endline_loc_p (p, pend, syntax))
76114:               BUF_PUSH (endline);
76149:             else
76167:               goto normal_char;
76200:           }
76213:           break;
76231:
76232:
76233:	case '+':
76244:        case '?':
76262:          if ((syntax & RE_BK_PLUS_QM)
76301:              || (syntax & RE_LIMITED_OPS))
76345:            goto normal_char;
76375:        handle_plus:
76396:        case '*':
76414:          /* If there is no previous pattern... */
76465:          if (!laststart)
76491:            {
76505:              if (syntax & RE_CONTEXT_INVALID_OPS)
76556:                return REG_BADRPT;
76591:              else if (!(syntax & RE_CONTEXT_INDEP_OPS))
76648:                goto normal_char;
76682:            }
76696:
76697:          {
76709:            /* Are we optimizing this jump?  */
76757:            boolean keep_string_p = false;
76800:            
76813:            /* 1 means zero (many) matches is allowed.  */
76872:            char zero_times_ok = 0, many_times_ok = 0;
76927:
76928:            /* If there is a sequence of repetition chars, collapse it
76999:               down to just one (the right one).  We can't combine
77066:               interval operators with these because of, e.g., `a{2}*',
77138:               which should only match an even number of `a's.  */
77205:
77206:            for (;;)
77227:              {
77243:                zero_times_ok |= c != '+';
77286:                many_times_ok |= c != '?';
77329:
77330:                if (p == pend)
77361:                  break;
77386:
77387:                PATFETCH (c);
77417:
77418:                if (c == '*'
77447:                    || (!(syntax & RE_BK_PLUS_QM) && (c == '+' || c == '?')))
77525:                  ;
77545:
77546:                else if (syntax & RE_BK_PLUS_QM  &&  c == '\\')
77610:                  {
77630:                    if (p == pend) return REG_EESCAPE;
77685:
77686:                    PATFETCH (c1);
77721:                    if (!(c1 == '+' || c1 == '?'))
77772:                      {
77796:                        PATUNFETCH;
77832:                        PATUNFETCH;
77868:                        break;
77899:                      }
77923:
77924:                    c = c1;
77952:                  }
77972:                else
77993:                  {
78013:                    PATUNFETCH;
78045:                    break;
78072:                  }
78092:
78093:                /* If we get here, we found another repeat character.  */
78167:               }
78184:
78185:            /* Star, etc. applied to an empty pattern is equivalent
78253:               to an empty pattern.  */
78293:            if (!laststart)  
78323:              break;
78344:
78345:            /* Now we know whether or not zero matches is allowed
78411:               and also whether or not two or more matches is allowed.  */
78486:            if (many_times_ok)
78517:              { /* More than one repetition is allowed, so put in at the
78590:                   end a backward relative jump from `b' to before the next
78666:                   jump we're going to put in below (which jumps from
78736:                   laststart to after this jump).  
78788:
78789:                   But if we are at the `*' in the exact sequence `.*\n',
78863:                   insert an unconditional jump backwards to the .,
78931:                   instead of the beginning of the loop.  This way we only
79006:                   push a failure point once, instead of every time
79074:                   through the loop.  */
79115:                assert (p - 1 > pattern);
79157:
79158:                /* Allocate the space for the jump.  */
79214:                GET_BUFFER_SPACE (3);
79252:
79253:                /* We know we are not at the first character of the pattern,
79330:                   because laststart was nonzero.  And we've already
79399:                   incremented `p', by the way, to be the character after
79473:                   the `*'.  Do we have to do something analogous here
79544:                   for null bytes, because of RE_DOT_NOT_NULL?  */
79611:                if (TRANSLATE (*(p - 2)) == TRANSLATE ('.')
79671:		    && zero_times_ok
79694:                    && p < pend && TRANSLATE (*p) == TRANSLATE ('\n')
79764:                    && !(syntax & RE_DOT_NEWLINE))
79815:                  { /* We have .*\n.  */
79856:                    STORE_JUMP (jump, b, laststart);
79909:                    keep_string_p = true;
79951:                  }
79971:                else
79992:                  /* Anything else.  */
80032:                  STORE_JUMP (maybe_pop_jump, b, laststart - 3);
80097:
80098:                /* We've added more stuff to the buffer.  */
80159:                b += 3;
80183:              }
80199:
80200:            /* On failure, jump from laststart to b + 3, which will be the
80275:               end of the buffer after this jump is inserted.  */
80341:            GET_BUFFER_SPACE (3);
80375:            INSERT_JUMP (keep_string_p ? on_failure_keep_string_jump
80444:                                       : on_failure_jump,
80502:                         laststart, b + 3);
80546:            pending_exact = 0;
80577:            b += 3;
80597:
80598:            if (!zero_times_ok)
80630:              {
80646:                /* At least one repetition is required, so insert a
80714:                   `dummy_failure_jump' before the initial
80773:                   `on_failure_jump' instruction of the loop. This
80840:                   effects a skip over that instruction the first time
80911:                   we hit that loop.  */
80952:                GET_BUFFER_SPACE (3);
80990:                INSERT_JUMP (dummy_failure_jump, laststart, laststart + 6);
81066:                b += 3;
81090:              }
81106:            }
81120:	  break;
81130:
81131:
81132:	case '.':
81143:          laststart = b;
81168:          BUF_PUSH (anychar);
81198:          break;
81215:
81216:
81217:        case '[':
81235:          {
81247:            boolean had_char_class = false;
81291:
81292:            if (p == pend) return REG_EBRACK;
81338:
81339:            /* Ensure that we have enough space to push a charset: the
81410:               opcode, the length count, and the bitset; 34 bytes in all.  */
81488:	    GET_BUFFER_SPACE (34);
81516:
81517:            laststart = b;
81544:
81545:            /* We test `*p == '^' twice, instead of using an if
81609:               statement, so we only need one BUF_PUSH.  */
81669:            BUF_PUSH (*p == '^' ? charset_not : charset); 
81728:            if (*p == '^')
81755:              p++;
81774:
81775:            /* Remember the first position in the bracket expression.  */
81849:            p1 = p;
81869:
81870:            /* Push the number of bytes in the bitmap.  */
81929:            BUF_PUSH ((1 << BYTEWIDTH) / BYTEWIDTH);
81982:
81983:            /* Clear the whole map.  */
82023:            bzero (b, (1 << BYTEWIDTH) / BYTEWIDTH);
82076:
82077:            /* charset_not matches newline according to a syntax bit.  */
82151:            if ((re_opcode_t) b[-2] == charset_not
82202:                && (syntax & RE_HAT_LISTS_NOT_NEWLINE))
82258:              SET_LIST_BIT ('\n');
82293:
82294:            /* Read in characters and ranges, setting map bits.  */
82362:            for (;;)
82383:              {
82399:                if (p == pend) return REG_EBRACK;
82449:
82450:                PATFETCH (c);
82480:
82481:                /* \ might escape characters inside [...] and [^...].  */
82555:                if ((syntax & RE_BACKSLASH_ESCAPE_IN_LISTS) && c == '\\')
82629:                  {
82649:                    if (p == pend) return REG_EESCAPE;
82704:
82705:                    PATFETCH (c1);
82740:                    SET_LIST_BIT (c1);
82779:                    continue;
82809:                  }
82829:
82830:                /* Could be the end of the bracket expression.  If it's
82902:                   not (i.e., when the bracket expression is `[]' so
82971:                   far), the ']' character bit gets set way below.  */
83042:                if (c == ']' && p != p1 + 1)
83087:                  break;
83112:
83113:                /* Look ahead to see if it's a range when the last thing
83186:                   was a character class.  */
83232:                if (had_char_class && c == '-' && *p != ']')
83293:                  return REG_ERANGE;
83330:
83331:                /* Look ahead to see if it's a range when the last thing
83404:                   was a character: if this is a hyphen not at the
83471:                   beginning or the end of a list, then it's the range
83542:                   operator.  */
83575:                if (c == '-' 
83605:                    && !(p - 2 >= pattern && p[-2] == '[') 
83665:                    && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^')
83740:                    && *p != ']')
83774:                  {
83794:                    reg_errcode_t ret
83832:                      = compile_range (&p, pend, translate, syntax, b);
83904:                    if (ret != REG_NOERROR) return ret;
83960:                  }
83980:
83981:                else if (p[0] == '-' && p[1] != ']')
84034:                  { /* This handles ranges made up of characters only.  */
84109:                    reg_errcode_t ret;
84148:
84149:		    /* Move past the `-'.  */
84181:                    PATFETCH (c1);
84216:                    
84237:                    ret = compile_range (&p, pend, translate, syntax, b);
84311:                    if (ret != REG_NOERROR) return ret;
84367:                  }
84387:
84388:                /* See if we're at the beginning of a possible character
84461:                   class.  */
84491:
84492:                else if (syntax & RE_CHAR_CLASSES && c == '[' && *p == ':')
84568:                  { /* Leave room for the null.  */
84620:                    char str[CHAR_CLASS_MAX_LENGTH + 1];
84677:
84678:                    PATFETCH (c);
84712:                    c1 = 0;
84740:
84741:                    /* If pattern is `[[:'.  */
84789:                    if (p == pend) return REG_EBRACK;
84843:
84844:                    for (;;)
84873:                      {
84897:                        PATFETCH (c);
84935:                        if (c == ':' || c == ']' || p == pend
84997:                            || c1 == CHAR_CLASS_MAX_LENGTH)
85057:                          break;
85090:                        str[c1++] = c;
85129:                      }
85153:                    str[c1] = '\0';
85189:
85190:                    /* If isn't a word bracketed by `[:' and:`]':
85256:                       undo the ending character, the letters, and leave 
85330:                       the leading `:' and `[' (but set bits for them).  */
85406:                    if (c == ':' && *p == ']')
85453:                      {
85477:                        int ch;
85509:                        boolean is_alnum = STREQ (str, "alnum");
85574:                        boolean is_alpha = STREQ (str, "alpha");
85639:                        boolean is_blank = STREQ (str, "blank");
85704:                        boolean is_cntrl = STREQ (str, "cntrl");
85769:                        boolean is_digit = STREQ (str, "digit");
85834:                        boolean is_graph = STREQ (str, "graph");
85899:                        boolean is_lower = STREQ (str, "lower");
85964:                        boolean is_print = STREQ (str, "print");
86029:                        boolean is_punct = STREQ (str, "punct");
86094:                        boolean is_space = STREQ (str, "space");
86159:                        boolean is_upper = STREQ (str, "upper");
86224:                        boolean is_xdigit = STREQ (str, "xdigit");
86291:                        
86316:                        if (!IS_CHAR_CLASS (str)) return REG_ECTYPE;
86385:
86386:                        /* Throw away the ] at the end of the character
86458:                           class.  */
86496:                        PATFETCH (c);					
86539:
86540:                        if (p == pend) return REG_EBRACK;
86598:
86599:                        for (ch = 0; ch < 1 << BYTEWIDTH; ch++)
86663:                          {
86691:                            if (   (is_alnum  && ISALNUM (ch))
86754:                                || (is_alpha  && ISALPHA (ch))
86817:                                || (is_blank  && ISBLANK (ch))
86880:                                || (is_cntrl  && ISCNTRL (ch))
86943:                                || (is_digit  && ISDIGIT (ch))
87006:                                || (is_graph  && ISGRAPH (ch))
87069:                                || (is_lower  && ISLOWER (ch))
87132:                                || (is_print  && ISPRINT (ch))
87195:                                || (is_punct  && ISPUNCT (ch))
87258:                                || (is_space  && ISSPACE (ch))
87321:                                || (is_upper  && ISUPPER (ch))
87384:                                || (is_xdigit && ISXDIGIT (ch)))
87449:                            SET_LIST_BIT (ch);
87496:                          }
87524:                        had_char_class = true;
87571:                      }
87595:                    else
87620:                      {
87644:                        c1++;
87674:                        while (c1--)    
87715:                          PATUNFETCH;
87753:                        SET_LIST_BIT ('[');
87797:                        SET_LIST_BIT (':');
87841:                        had_char_class = false;
87889:                      }
87913:                  }
87933:                else
87954:                  {
87974:                    had_char_class = false;
88018:                    SET_LIST_BIT (c);
88056:                  }
88076:              }
88092:
88093:            /* Discard any (non)matching list bytes that are all 0 at the
88167:               end of the map.  Decrease the map-length byte too.  */
88237:            while ((int) b[-1] > 0 && b[b[-1] - 1] == 0) 
88295:              b[-1]--; 
88319:            b += b[-1];
88343:          }
88355:          break;
88372:
88373:
88374:	case '(':
88385:          if (syntax & RE_NO_BK_PARENS)
88425:            goto handle_open;
88455:          else
88470:            goto normal_char;
88500:
88501:
88502:        case ')':
88520:          if (syntax & RE_NO_BK_PARENS)
88560:            goto handle_close;
88591:          else
88606:            goto normal_char;
88636:
88637:
88638:        case '\n':
88657:          if (syntax & RE_NEWLINE_ALT)
88696:            goto handle_alt;
88725:          else
88740:            goto normal_char;
88770:
88771:
88772:	case '|':
88783:          if (syntax & RE_NO_BK_VBAR)
88821:            goto handle_alt;
88850:          else
88865:            goto normal_char;
88895:
88896:
88897:        case '{':
88915:           if (syntax & RE_INTERVALS && syntax & RE_NO_BK_BRACES)
88981:             goto handle_interval;
89016:           else
89032:             goto normal_char;
89063:
89064:
89065:        case '\\':
89084:          if (p == pend) return REG_EESCAPE;
89129:
89130:          /* Do not translate the character after the \, so that we can
89202:             distinguish, e.g., \B from \b, even if we normally would
89272:             translate, e.g., B to b.  */
89314:          PATFETCH_RAW (c);
89342:
89343:          switch (c)
89364:            {
89378:            case '(':
89400:              if (syntax & RE_NO_BK_PARENS)
89444:                goto normal_backslash;
89483:
89484:            handle_open:
89509:              bufp->re_nsub++;
89540:              regnum++;
89564:
89565:              if (COMPILE_STACK_FULL)
89603:                { 
89622:                  RETALLOC (compile_stack.stack, compile_stack.size << 1,
89696:                            compile_stack_elt_t);
89746:                  if (compile_stack.stack == NULL) return REG_ESPACE;
89816:
89817:                  compile_stack.size <<= 1;
89861:                }
89879:
89880:              /* These are the values to restore when we hit end of this
89953:                 group.  They are all relative offsets, so that if the
90024:                 whole pattern moves because of realloc, they will still
90097:                 be valid.  */
90128:              COMPILE_STACK_TOP.begalt_offset = begalt - bufp->buffer;
90199:              COMPILE_STACK_TOP.fixup_alt_jump 
90247:                = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
90321:              COMPILE_STACK_TOP.laststart_offset = b - bufp->buffer;
90390:              COMPILE_STACK_TOP.regnum = regnum;
90439:
90440:              /* We will eventually replace the 0 with the number of
90509:                 groups inner to this one.  But do not push a
90571:                 start_memory for groups beyond the last one we can
90639:                 represent in the compiled pattern.  */
90695:              if (regnum <= MAX_REGNUM)
90735:                {
90753:                  COMPILE_STACK_TOP.inner_group_offset = b - bufp->buffer + 2;
90832:                  BUF_PUSH_3 (start_memory, regnum, 0);
90888:                }
90906:                
90923:              compile_stack.avail++;
90960:
90961:              fixup_alt_jump = 0;
90995:              laststart = 0;
91024:              begalt = b;
91050:	      /* If we've reached MAX_REGNUM groups, then this open
91111:		 won't actually generate any code, so we'll have to
91165:		 clear pending_exact explicitly.  */
91204:	      pending_exact = 0;
91230:              break;
91251:
91252:
91253:            case ')':
91275:              if (syntax & RE_NO_BK_PARENS) goto normal_backslash;
91342:
91343:              if (COMPILE_STACK_EMPTY)
91382:                if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
91441:                  goto normal_backslash;
91482:                else
91503:                  return REG_ERPAREN;
91541:
91542:            handle_close:
91568:              if (fixup_alt_jump)
91602:                { /* Push a dummy failure point at the end of the
91668:                     alternative for a possible future
91723:                     `pop_failure_jump' to pop.  See comments at
91788:                     `push_dummy_failure' in `re_match_2'.  */
91851:                  BUF_PUSH (push_dummy_failure);
91900:                  
91919:                  /* We allocated space for this jump when we assigned
91990:                     to `fixup_alt_jump', in the `handle_alt' case below.  */
92068:                  STORE_JUMP (jump_past_alt, fixup_alt_jump, b - 1);
92137:                }
92155:
92156:              /* See similar code for backslashed left paren above.  */
92228:              if (COMPILE_STACK_EMPTY)
92267:                if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
92326:                  goto normal_char;
92362:                else
92383:                  return REG_ERPAREN;
92421:
92422:              /* Since we just checked for an empty stack above, this
92492:                 ``can't happen''.  */
92531:              assert (compile_stack.avail != 0);
92580:              {
92596:                /* We don't just want to restore into `regnum', because
92668:                   later groups should continue to be numbered higher,
92739:                   as in `(ab)c(de)' -- the second group is #2.  */
92807:                regnum_t this_group_regnum;
92851:
92852:                compile_stack.avail--;		
92893:                begalt = bufp->buffer + COMPILE_STACK_TOP.begalt_offset;
92966:                fixup_alt_jump
92997:                  = COMPILE_STACK_TOP.fixup_alt_jump
93050:                    ? bufp->buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1 
93125:                    : 0;
93150:                laststart = bufp->buffer + COMPILE_STACK_TOP.laststart_offset;
93229:                this_group_regnum = COMPILE_STACK_TOP.regnum;
93291:		/* If we've reached MAX_REGNUM groups, then this open
93347:		   won't actually generate any code, so we'll have to
93403:		   clear pending_exact explicitly.  */
93444:		pending_exact = 0;
93465:
93466:                /* We're at the end of the group, so now we know how many
93540:                   groups were inside this one.  */
93592:                if (this_group_regnum <= MAX_REGNUM)
93645:                  {
93665:                    unsigned char *inner_group_loc
93716:                      = bufp->buffer + COMPILE_STACK_TOP.inner_group_offset;
93793:                    
93814:                    *inner_group_loc = regnum - this_group_regnum;
93881:                    BUF_PUSH_3 (stop_memory, this_group_regnum,
93945:                                regnum - this_group_regnum);
94006:                  }
94026:              }
94042:              break;
94063:
94064:
94065:            case '|':					/* `\|'.  */
94104:              if (syntax & RE_LIMITED_OPS || syntax & RE_NO_BK_VBAR)
94173:                goto normal_backslash;
94212:            handle_alt:
94236:              if (syntax & RE_LIMITED_OPS)
94279:                goto normal_char;
94313:
94314:              /* Insert before the previous alternative a jump which
94383:                 jumps to this alternative if the former fails.  */
94451:              GET_BUFFER_SPACE (3);
94487:              INSERT_JUMP (on_failure_jump, begalt, b + 6);
94547:              pending_exact = 0;
94580:              b += 3;
94602:
94603:              /* The alternative before this one has a jump after it
94672:                 which gets executed if it gets matched.  Adjust that
94742:                 jump so it will jump to this alternative's analogous
94812:                 jump (put in below, which in turn will jump to the next
94885:                 (if any) alternative's such jump, etc.).  The last such
94958:                 jump jumps to the correct final destination.  A picture:
95032:                          _____ _____ 
95071:                          |   | |   |   
95112:                          |   v |   v 
95151:                         a | b   | c   
95191:
95192:                 If we are at `b', then fixup_alt_jump right now points to a
95269:                 three-byte space after `a'.  We'll put in the jump, set
95342:                 fixup_alt_jump to right after `b', and leave behind three
95417:                 bytes which we'll fill in when we get to after `c'.  */
95490:
95491:              if (fixup_alt_jump)
95525:                STORE_JUMP (jump_past_alt, fixup_alt_jump, b);
95588:
95589:              /* Mark and leave space for a jump after this alternative,
95662:                 to be filled in later either by next alternative or
95731:                 when know we're at the end of a series of alternatives.  */
95808:              fixup_alt_jump = b;
95842:              GET_BUFFER_SPACE (3);
95878:              b += 3;
95900:
95901:              laststart = 0;
95930:              begalt = b;
95956:              break;
95977:
95978:
95979:            case '{': 
96002:              /* If \{ is a literal.  */
96043:              if (!(syntax & RE_INTERVALS)
96086:                     /* If we're at `\{' and it's not the open-interval 
96159:                        operator.  */
96197:                  || ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))
96274:                  || (p - 2 == pattern  &&  p == pend))
96330:                goto normal_backslash;
96369:
96370:            handle_interval:
96399:              {
96415:                /* If got here, then the syntax allows intervals.  */
96485:
96486:                /* At least (most) this many matches must be made.  */
96557:                int lower_bound = -1, upper_bound = -1;
96613:
96614:                beg_interval = p - 1;
96652:
96653:                if (p == pend)
96684:                  {
96704:                    if (syntax & RE_NO_BK_BRACES)
96754:                      goto unfetch_interval;
96799:                    else
96824:                      return REG_EBRACE;
96865:                  }
96885:
96886:                GET_UNSIGNED_NUMBER (lower_bound);
96937:
96938:                if (c == ',')
96968:                  {
96988:                    GET_UNSIGNED_NUMBER (upper_bound);
97043:                    if (upper_bound < 0) upper_bound = RE_DUP_MAX;
97110:                  }
97130:                else
97151:                  /* Interval such as `{1}' => match exactly once. */
97221:                  upper_bound = lower_bound;
97266:
97267:                if (lower_bound < 0 || upper_bound > RE_DUP_MAX
97331:                    || lower_bound > upper_bound)
97381:                  {
97401:                    if (syntax & RE_NO_BK_BRACES)
97451:                      goto unfetch_interval;
97496:                    else 
97522:                      return REG_BADBR;
97562:                  }
97582:
97583:                if (!(syntax & RE_NO_BK_BRACES)) 
97633:                  {
97653:                    if (c != '\\') return REG_EBRACE;
97707:
97708:                    PATFETCH (c);
97742:                  }
97762:
97763:                if (c != '}')
97793:                  {
97813:                    if (syntax & RE_NO_BK_BRACES)
97863:                      goto unfetch_interval;
97908:                    else 
97934:                      return REG_BADBR;
97974:                  }
97994:
97995:                /* We just parsed a valid interval.  */
98051:
98052:                /* If it's invalid to have no preceding re.  */
98116:                if (!laststart)
98148:                  {
98168:                    if (syntax & RE_CONTEXT_INVALID_OPS)
98225:                      return REG_BADRPT;
98266:                    else if (syntax & RE_CONTEXT_INDEP_OPS)
98326:                      laststart = b;
98363:                    else
98388:                      goto unfetch_interval;
98433:                  }
98453:
98454:                /* If the upper bound is zero, don't want to succeed at
98526:                   all; jump from `laststart' to `b + 3', which will be
98598:                   the end of the buffer after we insert the jump.  */
98669:                 if (upper_bound == 0)
98708:                   {
98729:                     GET_BUFFER_SPACE (3);
98772:                     INSERT_JUMP (jump, laststart, b + 3);
98831:                     b += 3;
98860:                   }
98881:
98882:                 /* Otherwise, we have a nontrivial interval.  When
98950:                    we're all done, the pattern will look like:
99014:                      set_number_at <jump count> <upper bound>
99077:                      set_number_at <succeed_n count> <lower bound>
99145:                      succeed_n <after jump addr> <succed_n count>
99212:                      <body of loop>
99249:                      jump_n <succeed_n addr> <jump count>
99308:                    (The upper bound and `jump_n' are omitted if
99373:                    `upper_bound' is 1, though.)  */
99426:                 else 
99449:                   { /* If the upper bound is > 1, we need to insert
99518:                        more at the end of the loop.  */
99575:                     unsigned nbytes = 10 + (upper_bound > 1) * 10;
99643:
99644:                     GET_BUFFER_SPACE (nbytes);
99692:
99693:                     /* Initialize lower bound of the `succeed_n', even
99765:                        though it will be set during matching by its
99834:                        attendant `set_number_at' (inserted next),
99901:                        because `re_compile_fastmap' needs to know.
99969:                        Jump to the `jump_n' we might insert below.  */
100041:                     INSERT_JUMP2 (succeed_n, laststart,
100098:                                   b + 5 + (upper_bound > 1) * 5,
100164:                                   lower_bound);
100213:                     b += 5;
100242:
100243:                     /* Code to initialize the lower bound.  Insert 
100312:                        before the `succeed_n'.  The `5' is the last two
100385:                        bytes of this `set_number_at', plus 3 bytes of
100456:                        the following `succeed_n'.  */
100511:                     insert_op2 (set_number_at, laststart, 5, lower_bound, b);
100590:                     b += 5;
100619:
100620:                     if (upper_bound > 1)
100662:                       { /* More than one repetition is allowed, so
100730:                            append a backward jump to the `succeed_n'
100800:                            that starts this interval.
100855:                            
100884:                            When we've reached this during matching,
100953:                            we'll have matched the interval once, so
101022:                            jump back only `upper_bound - 1' times.  */
101094:                         STORE_JUMP2 (jump_n, b, laststart + 5,
101158:                                      upper_bound - 1);
101214:                         b += 5;
101247:
101248:                         /* The location we want to set is the second
101318:                            parameter of the `jump_n'; that is `b-2' as
101390:                            an absolute address.  `laststart' will be
101460:                            the `set_number_at' we're about to insert;
101531:                            `laststart+3' the number to set, the source
101603:                            for the relative address.  But we are
101669:                            inserting into the middle of the pattern --
101741:                            so everything is getting moved up by 5.
101809:                            Conclusion: (b - 2) - (laststart + 3) + 5,
101880:                            i.e., b - laststart.
101929:                            
101958:                            We insert this at the beginning of the loop
102030:                            so that if we fail during matching, we'll
102100:                            reinitialize the bounds.  */
102157:                         insert_op2 (set_number_at, laststart, b - laststart,
102235:                                     upper_bound - 1, b);
102293:                         b += 5;
102326:                       }
102351:                   }
102372:                pending_exact = 0;
102407:                beg_interval = NULL;
102444:              }
102460:              break;
102481:
102482:            unfetch_interval:
102512:              /* If an invalid interval, match the characters as literals.  */
102591:               assert (beg_interval);
102629:               p = beg_interval;
102662:               beg_interval = NULL;
102698:
102699:               /* normal_char and normal_backslash need `c'.  */
102764:               PATFETCH (c);	
102794:
102795:               if (!(syntax & RE_NO_BK_BRACES))
102843:                 {
102862:                   if (p > pattern  &&  p[-1] == '\\')
102917:                     goto normal_backslash;
102961:                 }
102980:               goto normal_char;
103013:
103014:#ifdef emacs
103027:            /* There is no way to specify the before_dot and after_dot
103098:               operators.  rms says this is ok.  --karl  */
103158:            case '=':
103180:              BUF_PUSH (at_dot);
103213:              break;
103234:
103235:            case 's':	
103258:              laststart = b;
103287:              PATFETCH (c);
103315:              BUF_PUSH_2 (syntaxspec, syntax_spec_code[c]);
103375:              break;
103396:
103397:            case 'S':
103419:              laststart = b;
103448:              PATFETCH (c);
103476:              BUF_PUSH_2 (notsyntaxspec, syntax_spec_code[c]);
103539:              break;
103560:#endif /* emacs */
103579:
103580:
103581:            case 'w':
103603:              laststart = b;
103632:              BUF_PUSH (wordchar);
103667:              break;
103688:
103689:
103690:            case 'W':
103712:              laststart = b;
103741:              BUF_PUSH (notwordchar);
103779:              break;
103800:
103801:
103802:            case '<':
103824:              BUF_PUSH (wordbeg);
103858:              break;
103879:
103880:            case '>':
103902:              BUF_PUSH (wordend);
103936:              break;
103957:
103958:            case 'b':
103980:              BUF_PUSH (wordbound);
104016:              break;
104037:
104038:            case 'B':
104060:              BUF_PUSH (notwordbound);
104099:              break;
104120:
104121:            case '`':
104143:              BUF_PUSH (begbuf);
104176:              break;
104197:
104198:            case '\'':
104221:              BUF_PUSH (endbuf);
104254:              break;
104275:
104276:            case '1': case '2': case '3': case '4': case '5':
104338:            case '6': case '7': case '8': case '9':
104390:              if (syntax & RE_NO_BK_REFS)
104432:                goto normal_char;
104466:
104467:              c1 = c - '0';
104495:
104496:              if (c1 > regnum)
104527:                return REG_ESUBREG;
104563:
104564:              /* Can't back reference to a subexpression if inside of it.  */
104642:              if (group_in_compile_stack (compile_stack, c1))
104704:                goto normal_char;
104738:
104739:              laststart = b;
104768:              BUF_PUSH_2 (duplicate, c1);
104810:              break;
104831:
104832:
104833:            case '+':
104855:            case '?':
104877:              if (syntax & RE_BK_PLUS_QM)
104919:                goto handle_plus;
104953:              else
104972:                goto normal_backslash;
105011:
105012:            default:
105033:            normal_backslash:
105063:              /* You might think it would be useful for \ to mean
105129:                 not to translate; but if we don't translate it
105193:                 it will never match anything.  */
105244:              c = TRANSLATE (c);
105277:              goto normal_char;
105309:            }
105323:          break;
105340:
105341:
105342:	default:
105352:        /* Expects the character in `c'.  */
105397:	normal_char:
105411:	      /* If no exactn currently being built.  */
105461:          if (!pending_exact 
105491:
105492:              /* If last exactn not at current position.  */
105553:              || pending_exact + *pending_exact + 1 != b
105610:              
105625:              /* We have only one byte following the exactn for the count.  */
105704:	      || *pending_exact == (1 << BYTEWIDTH) - 1
105753:
105754:              /* If followed by a repetition operator.  */
105813:              || *p == '*' || *p == '^'
105853:	      || ((syntax & RE_BK_PLUS_QM)
105889:		  ? *p == '\\' && (p[1] == '+' || p[1] == '?')
105938:		  : (*p == '+' || *p == '?'))
105970:	      || ((syntax & RE_INTERVALS)
106005:                  && ((syntax & RE_NO_BK_BRACES)
106054:		      ? *p == '{'
106074:                      : (p[0] == '\\' && p[1] == '{'))))
106131:	    {
106138:	      /* Start building a new exactn.  */
106181:              
106196:              laststart = b;
106225:
106226:	      BUF_PUSH_2 (exactn, 0);
106257:	      pending_exact = b - 1;
106287:            }
106301:            
106314:	  BUF_PUSH (c);
106331:          (*pending_exact)++;
106361:	  break;
106371:        } /* switch (c) */
106398:    } /* while p != pend */
106426:
106427:  
106430:  /* Through the pattern now.  */
106464:  
106467:  if (fixup_alt_jump)
106489:    STORE_JUMP (jump_past_alt, fixup_alt_jump, b);
106540:
106541:  if (!COMPILE_STACK_EMPTY) 
106570:    return REG_EPAREN;
106593:
106594:  free (compile_stack.stack);
106624:
106625:  /* We have succeeded; set the length of the buffer.  */
106683:  bufp->used = b - bufp->buffer;
106716:
106717:#ifdef DEBUG
106730:  if (debug)
106743:    {
106749:      DEBUG_PRINT1 ("\nCompiled pattern: \n");
106796:      print_compiled_pattern (bufp);
106833:    }
106839:#endif /* DEBUG */
106858:
106859:  return REG_NOERROR;
106881:} /* regex_compile */
106903:
106905:/* Subroutines for `regex_compile'.  */
106945:
106946:/* Store OP at LOC followed by two-byte integer parameter ARG.  */
107013:
107014:static void
107026:store_op1 (op, loc, arg)
107051:    re_opcode_t op;
107071:    unsigned char *loc;
107095:    int arg;
107108:{
107110:  *loc = (unsigned char) op;
107139:  STORE_NUMBER (loc + 1, arg);
107170:}
107172:
107173:
107174:/* Like `store_op1', but" for 'two two-byte parameters ARG1 and ARG2.  */
107248:
107249:static void
107261:store_op2 (op, loc, arg1, arg2)
107293:    re_opcode_t op;
107313:    unsigned char *loc;
107337:    int arg1, arg2;
107357:{
107359:  *loc = (unsigned char) op;
107388:  STORE_NUMBER (loc + 1, arg1);
107420:  STORE_NUMBER (loc + 3, arg2);
107452:}
107454:
107455:
107456:/* Copy the bytes from LOC to END to open up three bytes of space at LOC
107529:   for OP followed by two-byte integer parameter ARG.  */
107587:
107588:static void
107600:insert_op1 (op, loc, arg, end)
107631:    re_opcode_t op;
107651:    unsigned char *loc;
107675:    int arg;
107688:    unsigned char *end;    
107716:{
107718:  register unsigned char *pfrom = end;
107757:  register unsigned char *pto = end + 3;
107798:
107799:  while (pfrom != loc)
107822:    *--pto = *--pfrom;
107845:    
107850:  store_op1 (op, loc, arg);
107878:}
107880:
107881:
107882:/* Like `insert_op1', but for two two-byte parameters ARG1 and ARG2.  */
107955:
107956:static void
107968:insert_op2 (op, loc, arg1, arg2, end)
108006:    re_opcode_t op;
108026:    unsigned char *loc;
108050:    int arg1, arg2;
108070:    unsigned char *end;    
108098:{
108100:  register unsigned char *pfrom = end;
108139:  register unsigned char *pto = end + 5;
108180:
108181:  while (pfrom != loc)
108204:    *--pto = *--pfrom;
108227:    
108232:  store_op2 (op, loc, arg1, arg2);
108267:}
108269:
108270:
108271:/* P points to just after a ^ in PATTERN.  Return true if that ^ comes
108342:   after an alternative or a begin-subexpression.  We assume there is at
108415:   least one character before the ^.  */
108456:
108457:static boolean
108472:at_begline_loc_p (pattern, p, syntax)
108510:    const char *pattern, *p;
108539:    reg_syntax_t syntax;
108564:{
108566:  const char *prev = p - 2;
108594:  boolean prev_prev_backslash = prev > pattern && prev[-1] == '\\';
108662:  
108665:  return
108674:       /* After a subexpression?  */
108711:       (*prev == '(' && (syntax & RE_NO_BK_PARENS || prev_prev_backslash))
108786:       /* After an alternative?  */
108822:    || (*prev == '|' && (syntax & RE_NO_BK_VBAR || prev_prev_backslash));
108896:}
108898:
108899:
108900:/* The dual of at_begline_loc_p.  This one is for $.  We assume there is
108973:   at least one character after the $, i.e., `P < PEND'.  */
109034:
109035:static boolean
109050:at_endline_loc_p (p, pend, syntax)
109085:    const char *p, *pend;
109111:    int syntax;
109127:{
109129:  const char *next = p;
109153:  boolean next_backslash = *next == '\\';
109195:  const char *next_next = p + 1 < pend ? p + 1 : NULL;
109250:  
109253:  return
109262:       /* Before a subexpression?  */
109300:       (syntax & RE_NO_BK_PARENS ? *next == ')'
109348:        : next_backslash && next_next && *next_next == ')')
109408:       /* Before an alternative?  */
109445:    || (syntax & RE_NO_BK_VBAR ? *next == '|'
109491:        : next_backslash && next_next && *next_next == '|');
109552:}
109554:
109555:
109556:/* Returns true if REGNUM is in one of COMPILE_STACK's elements and 
109625:   false if it's not.  */
109651:
109652:static boolean
109667:group_in_compile_stack (compile_stack, regnum)
109714:    compile_stack_type compile_stack;
109752:    regnum_t regnum;
109773:{
109775:  int this_element;
109795:
109796:  for (this_element = compile_stack.avail - 1;  
109845:       this_element >= 0; 
109872:       this_element--)
109895:    if (compile_stack.stack[this_element].regnum == regnum)
109955:      return true;
109974:
109975:  return false;
109991:}
109993:
109994:
109995:/* Read the ending character of a range (in a bracket expression) from the
110070:   uncompiled pattern *P_PTR (which ends at PEND).  We assume the
110136:   starting character is in `P[-2]'.  (`P[-1]' is the character `-'.)
110206:   Then we set the translation of all bits between the starting and
110274:   ending characters (inclusive) in the compiled pattern B.
110334:   
110338:   Return an error code.
110363:   
110367:   We use these short variable names so we can use the same macros as
110437:   `regex_compile' itself.  */
110468:
110469:static reg_errcode_t
110490:compile_range (p_ptr, pend, translate, syntax, b)
110540:    const char **p_ptr, *pend;
110571:    char *translate;
110592:    reg_syntax_t syntax;
110617:    unsigned char *b;
110639:{
110641:  unsigned this_char;
110663:
110664:  const char *p = *p_ptr;
110690:  int range_start, range_end;
110720:  
110723:  if (p == pend)
110740:    return REG_ERANGE;
110763:
110764:  /* Even though the pattern is a signed `char *', we need to fetch
110832:     with unsigned char *'s; if the high bit of the pattern character
110902:     is set, the range endpoints will be negative if we fetch using a
110972:     signed char *.
110992:
110993:     We also want to fetch the endpoints without translating them; the 
111065:     appropriate translation is done in the bit-setting loop below.  */
111137:  range_start = ((unsigned char *) p)[-2];
111180:  range_end   = ((unsigned char *) p)[0];
111222:
111223:  /* Have to increment the pointer into the pattern string, so the
111290:     caller isn't still at the ending character.  */
111343:  (*p_ptr)++;
111357:
111358:  /* If the start is after the end, the range is empty.  */
111418:  if (range_start > range_end)
111449:    return syntax & RE_NO_EMPTY_RANGES ? REG_ERANGE : REG_NOERROR;
111516:
111517:  /* Here we see why `this_char' has to be larger than an `unsigned
111585:     char' -- the range is inclusive, so if `range_end' == 0xff
111649:     (assuming 8-bit characters), we would otherwise go into an infinite
111722:     loop, since all characters <= 0xff.  */
111767:  for (this_char = range_start; this_char <= range_end; this_char++)
111836:    {
111842:      SET_LIST_BIT (TRANSLATE (this_char));
111886:    }
111892:  
111895:  return REG_NOERROR;
111917:}
111919:
111921:/* Failure stack declarations and macros; both re_compile_fastmap and
111991:   re_match_2 use a failure stack.  These have to be macros because of
112062:   REGEX_ALLOCATE.  */
112085:   
112089:
112090:/* Number of failure points for which to initially allocate space
112156:   when matching.  If this number is exceeded, we allocate more
112220:   space, so it is not a hard limit.  */
112261:#ifndef INIT_FAILURE_ALLOC
112288:#define INIT_FAILURE_ALLOC 5
112317:#endif
112324:
112325:/* Roughly the maximum number of failure points on the stack.  Would be
112397:   exactly that if always used MAX_FAILURE_SPACE each time we failed.
112467:   This is a variable only so users of regex can assign to it; we never
112539:   change it ourselves.  */
112567:int re_max_failures = 2000;
112595:
112596:typedef const unsigned char *fail_stack_elt_t;
112643:
112644:typedef struct
112659:{
112661:  fail_stack_elt_t *stack;
112688:  unsigned size;
112705:  unsigned avail;			/* Offset of next open position.  */
112762:} fail_stack_type;
112781:
112782:#define FAIL_STACK_EMPTY()     (fail_stack.avail == 0)
112837:#define FAIL_STACK_PTR_EMPTY() (fail_stack_ptr->avail == 0)
112897:#define FAIL_STACK_FULL()      (fail_stack.avail == fail_stack.size)
112966:#define FAIL_STACK_TOP()       (fail_stack.stack[fail_stack.avail])
113034:
113035:
113036:/* Initialize `fail_stack'.  Do `return -2' if the alloc fails.  */
113104:
113105:#define INIT_FAIL_STACK()						\
113138:  do {									\
113155:    fail_stack.stack = (fail_stack_elt_t *)				\
113204:      REGEX_ALLOCATE (INIT_FAILURE_ALLOC * sizeof (fail_stack_elt_t));	\
113277:									\
113288:    if (fail_stack.stack == NULL)					\
113328:      return -2;							\
113353:									\
113364:    fail_stack.size = INIT_FAILURE_ALLOC;				\
113411:    fail_stack.avail = 0;						\
113444:  } while (0)
113458:
113459:
113460:/* Double the size of FAIL_STACK, up to approximately `re_max_failures' items.
113539:
113540:   Return 1 if succeeds, and 0 if either ran out of memory
113599:   allocating space for it or it was already too large.  
113657:   
113661:   REGEX_REALLOCATE requires `destination' be declared.   */
113722:
113723:#define DOUBLE_FAIL_STACK(fail_stack)					\
113767:  ((fail_stack).size > re_max_failures * MAX_FAILURE_ITEMS		\
113829:   ? 0									\
113846:   : ((fail_stack).stack = (fail_stack_elt_t *)				\
113899:        REGEX_REALLOCATE ((fail_stack).stack, 				\
113951:          (fail_stack).size * sizeof (fail_stack_elt_t),		\
114011:          ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),	\
114078:									\
114089:      (fail_stack).stack == NULL					\
114128:      ? 0								\
114147:      : ((fail_stack).size <<= 1, 					\
114188:         1)))
114202:
114203:
114204:/* Push PATTERN_OP on FAIL_STACK. 
114239:
114240:   Return 1 if was able to do so and 0 if ran out of memory allocating
114311:   space to do so.  */
114334:#define PUSH_PATTERN_OP(pattern_op, fail_stack)				\
114387:  ((FAIL_STACK_FULL ()							\
114418:    && !DOUBLE_FAIL_STACK (fail_stack))					\
114464:    ? 0									\
114482:    : ((fail_stack).stack[(fail_stack).avail++] = pattern_op,		\
114547:       1))
114558:
114559:/* This pushes an item onto the failure stack.  Must be a four-byte
114627:   value.  Assumes the variable `fail_stack'.  Probably should only
114695:   be called from within `PUSH_FAILURE_POINT'.  */
114746:#define PUSH_FAILURE_ITEM(item)						\
114785:  fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) item
114850:
114851:/* The complement operation.  Assumes `fail_stack' is nonempty.  */
114919:#define POP_FAILURE_ITEM() fail_stack.stack[--fail_stack.avail]
114983:
114984:/* Used to omit pushing failure point id's when we're not debugging.  */
115057:#ifdef DEBUG
115070:#define DEBUG_PUSH PUSH_FAILURE_ITEM
115107:#define DEBUG_POP(item_addr) *(item_addr) = POP_FAILURE_ITEM ()
115171:#else
115177:#define DEBUG_PUSH(item)
115202:#define DEBUG_POP(item_addr)
115231:#endif
115238:
115239:
115240:/* Push the information about the state we will need
115293:   if we ever fail back to it.  
115326:   
115330:   Requires variables fail_stack, regstart, regend, reg_info, and
115396:   num_regs be declared.  DOUBLE_FAIL_STACK requires `destination' be
115466:   declared.
115479:   
115483:   Does `return FAILURE_CODE' if runs out of memory.  */
115540:
115541:#define PUSH_FAILURE_POINT(pattern_place, string_place, failure_code)	\
115613:  do {									\
115630:    char *destination;							\
115661:    /* Must be int, so when we don't save any registers, the arithmetic	\
115735:       of 0 + -1 isn't done as unsigned.  */				\
115785:    int this_reg;							\
115811:    									\
115826:    DEBUG_STATEMENT (failure_id++);					\
115868:    DEBUG_STATEMENT (nfailure_points_pushed++);				\
115921:    DEBUG_PRINT2 ("\nPUSH_FAILURE_POINT #%u:\n", failure_id);		\
115986:    DEBUG_PRINT2 ("  Before push, next avail: %d\n", (fail_stack).avail);\
116061:    DEBUG_PRINT2 ("                     size: %d\n", (fail_stack).size);\
116135:									\
116146:    DEBUG_PRINT2 ("  slots needed: %d\n", NUM_FAILURE_ITEMS);		\
116211:    DEBUG_PRINT2 ("     available: %d\n", REMAINING_AVAIL_SLOTS);	\
116279:									\
116290:    /* Ensure we have enough space allocated for what we will push.  */	\
116364:    while (REMAINING_AVAIL_SLOTS < NUM_FAILURE_ITEMS)			\
116422:      {									\
116440:        if (!DOUBLE_FAIL_STACK (fail_stack))			\
116489:          return failure_code;						\
116527:									\
116538:        DEBUG_PRINT2 ("\n  Doubled stack; size now: %d\n",		\
116600:		       (fail_stack).size);				\
116634:        DEBUG_PRINT2 ("  slots available: %d\n", REMAINING_AVAIL_SLOTS);\
116708:      }									\
116726:									\
116737:    /* Push the info, starting with the registers.  */			\
116796:    DEBUG_PRINT1 ("\n");						\
116828:									\
116839:    for (this_reg = lowest_active_reg; this_reg <= highest_active_reg;	\
116912:         this_reg++)							\
116941:      {									\
116959:	DEBUG_PRINT2 ("  Pushing reg: %d\n", this_reg);			\
117012:        DEBUG_STATEMENT (num_regs_pushed++);				\
117062:									\
117073:	DEBUG_PRINT2 ("    start: 0x%x\n", regstart[this_reg]);		\
117133:        PUSH_FAILURE_ITEM (regstart[this_reg]);				\
117186:                                                                        \
117260:	DEBUG_PRINT2 ("    end: 0x%x\n", regend[this_reg]);		\
117316:        PUSH_FAILURE_ITEM (regend[this_reg]);				\
117367:									\
117378:	DEBUG_PRINT2 ("    info: 0x%x\n      ", reg_info[this_reg]);	\
117442:        DEBUG_PRINT2 (" match_null=%d",					\
117488:                      REG_MATCH_NULL_STRING_P (reg_info[this_reg]));	\
117559:        DEBUG_PRINT2 (" active=%d", IS_ACTIVE (reg_info[this_reg]));	\
117630:        DEBUG_PRINT2 (" matched_something=%d",				\
117682:                      MATCHED_SOMETHING (reg_info[this_reg]));		\
117748:        DEBUG_PRINT2 (" ever_matched=%d",				\
117795:                      EVER_MATCHED_SOMETHING (reg_info[this_reg]));	\
117865:	DEBUG_PRINT1 ("\n");						\
117894:        PUSH_FAILURE_ITEM (reg_info[this_reg].word);			\
117951:      }									\
117969:									\
117980:    DEBUG_PRINT2 ("  Pushing  low active reg: %d\n", lowest_active_reg);\
118054:    PUSH_FAILURE_ITEM (lowest_active_reg);				\
118102:									\
118113:    DEBUG_PRINT2 ("  Pushing high active reg: %d\n", highest_active_reg);\
118188:    PUSH_FAILURE_ITEM (highest_active_reg);				\
118237:									\
118248:    DEBUG_PRINT2 ("  Pushing pattern 0x%x: ", pattern_place);		\
118313:    DEBUG_PRINT_COMPILED_PATTERN (bufp, pattern_place, pend);		\
118378:    PUSH_FAILURE_ITEM (pattern_place);					\
118423:									\
118434:    DEBUG_PRINT2 ("  Pushing string 0x%x: `", string_place);		\
118498:    DEBUG_PRINT_DOUBLE_STRING (string_place, string1, size1, string2,   \
118572:				 size2);				\
118590:    DEBUG_PRINT1 ("'\n");						\
118623:    PUSH_FAILURE_ITEM (string_place);					\
118667:									\
118678:    DEBUG_PRINT2 ("  Pushing failure id: %u\n", failure_id);		\
118742:    DEBUG_PUSH (failure_id);						\
118778:  } while (0)
118792:
118793:/* This is the number of items that are pushed and popped on the stack
118864:   for each register.  */
118890:#define NUM_REG_ITEMS  3
118915:
118916:/* Individual items aside from the registers.  */
118966:#ifdef DEBUG
119040:#else
119046:#define NUM_NONREG_ITEMS 4
119073:#endif
119080:
119081:/* We push at most this many items on the stack.  */
119134:#define MAX_FAILURE_ITEMS ((num_regs - 1) * NUM_REG_ITEMS + NUM_NONREG_ITEMS)
119212:
119213:/* We actually push this many items.  */
119254:#define NUM_FAILURE_ITEMS						\
119287:  ((highest_active_reg - lowest_active_reg + 1) * NUM_REG_ITEMS 	\
119354:    + NUM_NONREG_ITEMS)
119378:
119379:/* How many items can still be added to the stack without overflowing it.  */
119457:#define REMAINING_AVAIL_SLOTS ((fail_stack).size - (fail_stack).avail)
119528:
119529:
119530:/* Pops what PUSH_FAIL_STACK pushes.
119567:
119568:   We restore into the parameters, all of which should be lvalues:
119635:     STR -- the saved data position.
119672:     PAT -- the saved pattern position.
119712:     LOW_REG, HIGH_REG -- the highest and lowest active registers.
119779:     REGSTART, REGEND -- arrays of string positions.
119832:     REG_INFO -- array of information about each subexpression.
119896:   
119900:   Also assumes the variables `fail_stack' and (if debugging), `bufp',
119971:   `pend', `string1', `size1', `string2', and `size2'.  */
120030:
120031:#define POP_FAILURE_POINT(str, pat, low_reg, high_reg, regstart, regend, reg_info)\
120115:{									\
120127:  DEBUG_STATEMENT (fail_stack_elt_t failure_id;)			\
120180:  int this_reg;								\
120205:  const unsigned char *string_temp;					\
120247:									\
120258:  assert (!FAIL_STACK_EMPTY ());					\
120297:									\
120308:  /* Remove failure points and point to how many regs pushed.  */	\
120376:  DEBUG_PRINT1 ("POP_FAILURE_POINT:\n");				\
120422:  DEBUG_PRINT2 ("  Before pop, next avail: %d\n", fail_stack.avail);	\
120493:  DEBUG_PRINT2 ("                    size: %d\n", fail_stack.size);	\
120563:									\
120574:  assert (fail_stack.avail >= NUM_NONREG_ITEMS);			\
120627:									\
120638:  DEBUG_POP (&failure_id);						\
120672:  DEBUG_PRINT2 ("  Popping failure id: %u\n", failure_id);		\
120734:									\
120745:  /* If the saved string location is NULL, it came from an		\
120807:     on_failure_keep_string_jump opcode, and we want to throw away the	\
120880:     saved NULL, thus retaining our current position in the string.  */	\
120954:  string_temp = POP_FAILURE_ITEM ();					\
120997:  if (string_temp != NULL)						\
121031:    str = (const char *) string_temp;					\
121075:									\
121086:  DEBUG_PRINT2 ("  Popping string 0x%x: `", str);			\
121140:  DEBUG_PRINT_DOUBLE_STRING (str, string1, size1, string2, size2);	\
121209:  DEBUG_PRINT1 ("'\n");							\
121241:									\
121252:  pat = (unsigned char *) POP_FAILURE_ITEM ();				\
121304:  DEBUG_PRINT2 ("  Popping pattern 0x%x: ", pat);			\
121358:  DEBUG_PRINT_COMPILED_PATTERN (bufp, pat, pend);			\
121412:									\
121423:  /* Restore register info.  */						\
121462:  high_reg = (unsigned) POP_FAILURE_ITEM ();				\
121512:  DEBUG_PRINT2 ("  Popping high active reg: %d\n", high_reg);		\
121577:									\
121588:  low_reg = (unsigned) POP_FAILURE_ITEM ();				\
121637:  DEBUG_PRINT2 ("  Popping  low active reg: %d\n", low_reg);		\
121701:									\
121712:  for (this_reg = high_reg; this_reg >= low_reg; this_reg--)		\
121776:    {									\
121792:      DEBUG_PRINT2 ("    Popping reg: %d\n", this_reg);			\
121852:									\
121863:      reg_info[this_reg].word = POP_FAILURE_ITEM ();			\
121920:      DEBUG_PRINT2 ("      info: 0x%x\n", reg_info[this_reg]);		\
121986:									\
121997:      regend[this_reg] = (const char *) POP_FAILURE_ITEM ();		\
122061:      DEBUG_PRINT2 ("      end: 0x%x\n", regend[this_reg]);		\
122124:									\
122135:      regstart[this_reg] = (const char *) POP_FAILURE_ITEM ();		\
122201:      DEBUG_PRINT2 ("      start: 0x%x\n", regstart[this_reg]);		\
122268:    }									\
122284:									\
122295:  DEBUG_STATEMENT (nfailure_points_popped++);				\
122346:} /* POP_FAILURE_POINT */
122372:
122374:/* re_compile_fastmap computes a ``fastmap'' for the compiled pattern in
122447:   BUFP.  A fastmap records which of the (1 << BYTEWIDTH) possible
122514:   characters can start a string that matches the pattern.  This fastmap
122587:   is used by re_search to skip quickly over impossible starting points.
122660:
122661:   The caller must supply the address of a (1 << BYTEWIDTH)-byte data
122731:   area as BUFP->fastmap.
122757:   
122761:   We set the `fastmap', `fastmap_accurate', and `can_be_null' fields in
122834:   the pattern buffer.
122857:
122858:   Returns 0 if we succeed, -2 if an internal error.   */
122916:
122917:int
122921:re_compile_fastmap (bufp)
122947:     struct re_pattern_buffer *bufp;
122984:{
122986:  int j, k;
122998:  fail_stack_type fail_stack;
123028:#ifndef REGEX_MALLOC
123049:  char *destination;
123070:#endif
123077:  /* We don't push any register information onto the failure stack.  */
123149:  unsigned num_regs = 0;
123174:  
123177:  register char *fastmap = bufp->fastmap;
123219:  unsigned char *pattern = bufp->buffer;
123260:  unsigned long size = bufp->used;
123295:  const unsigned char *p = pattern;
123331:  register unsigned char *pend = pattern + size;
123380:
123381:  /* Assume that each path through the pattern can be null until
123446:     proven otherwise.  We set this false at the bottom of switch
123512:     statement, to which we get only if a particular path doesn't
123578:     match the empty string.  */
123611:  boolean path_can_be_null = true;
123646:
123647:  /* We aren't doing a `succeed_n' to begin with.  */
123701:  boolean succeed_n_p = false;
123732:
123733:  assert (fastmap != NULL && p != NULL);
123774:  
123777:  INIT_FAIL_STACK ();
123799:  bzero (fastmap, 1 << BYTEWIDTH);  /* Assume nothing's valid.  */
123866:  bufp->fastmap_accurate = 1;	    /* It will be when we're done.  */
123935:  bufp->can_be_null = 0;
123960:      
123967:  while (p != pend || !FAIL_STACK_EMPTY ())
124011:    {
124017:      if (p == pend)
124038:        {
124048:          bufp->can_be_null |= path_can_be_null;
124097:          
124108:          /* Reset for next path.  */
124146:          path_can_be_null = true;
124181:          
124192:          p = fail_stack.stack[--fail_stack.avail];
124244:	}
124247:
124248:      /* We should never be about to go beyond the end of the pattern.  */
124323:      assert (p < pend);
124348:      
124355:#ifdef SWITCH_ENUM_BUG
124378:      switch ((int) ((re_opcode_t) *p++))
124420:#else
124426:      switch ((re_opcode_t) *p++)
124460:#endif
124467:	{
124470:
124471:        /* I guess the idea here is to simply not bother with a fastmap
124543:           if a backreference is used, since it's too hard to figure out
124616:           the fastmap for the corresponding group.  Setting
124677:           `can_be_null' stops `re_search_2' from using the fastmap, so
124749:           that is all we do.  */
124783:	case duplicate:
124800:	  bufp->can_be_null = 1;
124826:          return 0;
124846:
124847:
124848:      /* Following are the cases which match a character.  These end
124917:         with `break'.  */
124944:
124945:	case exactn:
124959:          fastmap[p[1]] = 1;
124988:	  break;
124998:
124999:
125000:        case charset:
125022:          for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
125076:	    if (p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH)))
125128:              fastmap[j] = 1;
125158:	  break;
125168:
125169:
125170:	case charset_not:
125189:	  /* Chars beyond end of map must be allowed.  */
125240:	  for (j = *p * BYTEWIDTH; j < (1 << BYTEWIDTH); j++)
125295:            fastmap[j] = 1;
125323:
125324:	  for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
125371:	    if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))))
125426:              fastmap[j] = 1;
125456:          break;
125473:
125474:
125475:	case wordchar:
125491:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
125533:	    if (SYNTAX (j) == Sword)
125563:	      fastmap[j] = 1;
125586:	  break;
125596:
125597:
125598:	case notwordchar:
125617:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
125659:	    if (SYNTAX (j) != Sword)
125689:	      fastmap[j] = 1;
125712:	  break;
125722:
125723:
125724:        case anychar:
125746:          /* `.' matches anything ...  */
125788:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
125830:            fastmap[j] = 1;
125858:
125859:          /* ... except perhaps newline.  */
125904:          if (!(bufp->syntax & RE_DOT_NEWLINE))
125952:            fastmap['\n'] = 0;
125983:
125984:          /* Return if we have already set `can_be_null'; if we have,
126054:             then the fastmap is irrelevant.  Something's wrong here.  */
126128:	  else if (bufp->can_be_null)
126159:	    return 0;
126174:
126175:          /* Otherwise, have to check alternative paths.  */
126236:	  break;
126246:
126247:
126248:#ifdef emacs
126261:        case syntaxspec:
126286:	  k = *p++;
126299:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
126341:	    if (SYNTAX (j) == (enum syntaxcode) k)
126385:	      fastmap[j] = 1;
126408:	  break;
126418:
126419:
126420:	case notsyntaxspec:
126441:	  k = *p++;
126454:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
126496:	    if (SYNTAX (j) != (enum syntaxcode) k)
126540:	      fastmap[j] = 1;
126563:	  break;
126573:
126574:
126575:      /* All cases after this match the empty string.  These end with
126645:         `continue'.  */
126670:
126671:
126672:	case before_dot:
126690:	case at_dot:
126704:	case after_dot:
126721:          continue;
126741:#endif /* not emacs */
126764:
126765:
126766:        case no_op:
126786:        case begline:
126808:        case endline:
126830:	case begbuf:
126844:	case endbuf:
126858:	case wordbound:
126875:	case notwordbound:
126895:	case wordbeg:
126910:	case wordend:
126925:        case push_dummy_failure:
126958:          continue;
126978:
126979:
126980:	case jump_n:
126994:        case pop_failure_jump:
127025:	case maybe_pop_jump:
127047:	case jump:
127059:        case jump_past_alt:
127087:	case dummy_failure_jump:
127113:          EXTRACT_NUMBER_AND_INCR (j, p);
127155:	  p += j;	
127167:	  if (j > 0)
127181:	    continue;
127196:            
127209:          /* Jump backward implies we just went through the body of a
127279:             loop and matched nothing.  Opcode jumped to should be
127346:             `on_failure_jump' or `succeed_n'.  Just treat it like an
127416:             ordinary jump.  For a * loop, it has pushed its failure
127485:             point already; if so, discard that as redundant.  */
127551:          if ((re_opcode_t) *p != on_failure_jump
127601:	      && (re_opcode_t) *p != succeed_n)
127642:	    continue;
127657:
127658:          p++;
127673:          EXTRACT_NUMBER_AND_INCR (j, p);
127715:          p += j;		
127735:	  
127739:          /* If what's on the stack is where we are now, pop it.  */
127808:          if (!FAIL_STACK_EMPTY () 
127844:	      && fail_stack.stack[fail_stack.avail - 1] == p)
127899:            fail_stack.avail--;
127931:
127932:          continue;
127952:
127953:
127954:        case on_failure_jump:
127984:        case on_failure_keep_string_jump:
128026:	handle_on_failure_jump:
128051:          EXTRACT_NUMBER_AND_INCR (j, p);
128093:
128094:          /* For some patterns, e.g., `(a?)?', `p+j' here points to the
128166:             end of the pattern.  We don't want to push such a point,
128236:             since when we restore it above, entering the switch will
128306:             increment `p' past the end of the pattern.  We don't need
128377:             to push such a point since we obviously won't find any more
128450:             fastmap entries beyond `pend'.  Such a pattern can match
128520:             the null string, though.  */
128562:          if (p + j < pend)
128590:            {
128604:              if (!PUSH_PATTERN_OP (p + j, fail_stack))
128660:                return -2;
128687:            }
128701:          else
128716:            bufp->can_be_null = 1;
128751:
128752:          if (succeed_n_p)
128779:            {
128793:              EXTRACT_NUMBER_AND_INCR (k, p);	/* Skip the n.  */
128858:              succeed_n_p = false;
128893:	    }
128900:
128901:          continue;
128921:
128922:
128923:	case succeed_n:
128940:          /* Get to the number of times to succeed.  */
128996:          p += 2;		
129016:
129017:          /* Increment p past the n for when k != 0.  */
129074:          EXTRACT_NUMBER_AND_INCR (k, p);
129116:          if (k == 0)
129138:	    {
129145:              p -= 4;
129167:  	      succeed_n_p = true;  /* Spaghetti code alert.  */
129226:              goto handle_on_failure_jump;
129269:            }
129283:          continue;
129303:
129304:
129305:	case set_number_at:
129326:          p += 4;
129344:          continue;
129364:
129365:
129366:	case start_memory:
129386:        case stop_memory:
129412:	  p += 2;
129423:	  continue;
129436:
129437:
129438:	default:
129448:          abort (); /* We have listed all the cases.  */
129505:        } /* switch *p++ */
129533:
129534:      /* Getting here means we have found the possible starting
129598:         characters for one path of the pattern -- and that the empty
129668:         string does not match.  We need not follow this path further.
129739:         Instead, look at the next alternative (remembered on the
129805:         stack), or quit if no more.  The test at the top of the loop
129875:         does these things.  */
129907:      path_can_be_null = false;
129939:      p = pend;
129955:    } /* while p */
129975:
129976:  /* Set `can_be_null' for the last path (also the first path, if the
130046:     pattern is empty).  */
130074:  bufp->can_be_null |= path_can_be_null;
130115:  return 0;
130127:} /* re_compile_fastmap */
130154:
130156:/* Set REGS to hold NUM_REGS registers, storing them in STARTS and
130223:   ENDS.  Subsequent matches using PATTERN_BUFFER and REGS will use
130291:   this memory for recording register information.  STARTS and ENDS
130359:   must be allocated using the malloc library routine, and must each
130428:   be at least NUM_REGS * sizeof (regoff_t) bytes long.
130484:
130485:   If NUM_REGS == 0, then subsequent matches should allocate their own
130556:   register data.
130574:
130575:   Unless this function is called, the first search or match using
130642:   PATTERN_BUFFER will allocate its own register data, without
130705:   freeing the old data.  */
130734:
130735:void
130740:re_set_registers (bufp, regs, num_regs, starts, ends)
130794:    struct re_pattern_buffer *bufp;
130830:    struct re_registers *regs;
130861:    unsigned num_regs;
130884:    regoff_t *starts, *ends;
130913:{
130915:  if (num_regs)
130931:    {
130937:      bufp->regs_allocated = REGS_REALLOCATE;
130983:      regs->num_regs = num_regs;
131016:      regs->start = starts;
131044:      regs->end = ends;
131068:    }
131074:  else
131081:    {
131087:      bufp->regs_allocated = REGS_UNALLOCATED;
131134:      regs->num_regs = 0;
131160:      regs->start = regs->end = (regoff_t) 0;
131206:    }
131212:}
131214:
131216:/* Searching routines.  */
131243:
131244:/* Like re_search_2, below, but only one string is specified, and
131310:   doesn't let you say where to stop matching. */
131360:
131361:int
131365:re_search (bufp, string, size, startpos, range, regs)
131419:     struct re_pattern_buffer *bufp;
131456:     const char *string;
131481:     int size, startpos, range;
131513:     struct re_registers *regs;
131545:{
131547:  return re_search_2 (bufp, NULL, 0, string, size, startpos, range, 
131616:		      regs, size);
131637:}
131639:
131640:
131641:/* Using the compiled pattern in BUFP->buffer, first tries to match the
131713:   virtual concatenation of STRING1 and STRING2, starting first at index
131786:   STARTPOS, then at STARTPOS + 1, and so on.
131832:   
131836:   STRING1 and STRING2 have length SIZE1 and SIZE2, respectively.
131902:   
131906:   RANGE is how far to scan while trying to match.  RANGE = 0 means try
131978:   only at STARTPOS; in general, the last start tried is STARTPOS +
132046:   RANGE.
132056:   
132060:   In REGS, return the indices of the virtual concatenation of STRING1
132131:   and STRING2 that matched the entire BUFP->buffer and its contained
132201:   subexpressions.
132220:   
132224:   Do not consider matching one past the index STOP in the virtual
132291:   concatenation of STRING1 and STRING2.
132332:
132333:   We return either the position in the strings at which the match was
132404:   found, -1 if no match, or -2 if error (such as failure
132462:   stack overflow).  */
132486:
132487:int
132491:re_search_2 (bufp, string1, size1, string2, size2, startpos, range, regs, stop)
132571:     struct re_pattern_buffer *bufp;
132608:     const char *string1, *string2;
132644:     int size1, size2;
132667:     int startpos;
132686:     int range;
132702:     struct re_registers *regs;
132734:     int stop;
132749:{
132751:  int val;
132762:  register char *fastmap = bufp->fastmap;
132804:  register char *translate = bufp->translate;
132850:  int total_size = size1 + size2;
132884:  int endpos = startpos + range;
132917:
132918:  /* Check for out-of-range STARTPOS.  */
132960:  if (startpos < 0 || startpos > total_size)
133005:    return -1;
133020:    
133025:  /* Fix up RANGE if it might eventually take us outside
133082:     the virtual concatenation of STRING1 and STRING2.  */
133141:  if (endpos < -1)
133160:    range = -1 - startpos;
133187:  else if (endpos > total_size)
133219:    range = total_size - startpos;
133254:
133255:  /* If the search isn't to be a backwards one, don't waste time in a
133325:     search for a pattern that must be anchored.  */
133378:  if (bufp->used > 0 && (re_opcode_t) bufp->buffer[0] == begbuf && range > 0)
133456:    {
133462:      if (startpos > 0)
133486:	return -1;
133498:      else
133509:	range = 1;
133521:    }
133527:
133528:  /* Update the fastmap now if not correct already.  */
133584:  if (fastmap && !bufp->fastmap_accurate)
133626:    if (re_compile_fastmap (bufp) == -2)
133667:      return -2;
133684:  
133687:  /* Loop through the string, looking for a place to start matching.  */
133760:  for (;;)
133771:    { 
133778:      /* If a fastmap is supplied, skip quickly over characters that
133847:         cannot be the start of a match.  If the pattern can match the
133918:         null string, however, we don't need to skip characters; we want
133991:         the first null string.  */
134027:      if (fastmap && startpos < total_size && !bufp->can_be_null)
134093:	{
134096:	  if (range > 0)	/* Searching forwards.  */
134141:	    {
134148:	      register const char *d;
134179:	      register int lim = 0;
134208:	      int irange = range;
134235:
134236:              if (startpos < size1 && startpos + range >= size1)
134301:                lim = range - (size1 - startpos);
134351:
134352:	      d = (startpos >= size1 ? string2 - size1 : string1) + startpos;
134423:   
134427:              /* Written out as an if-else to avoid testing `translate'
134499:                 inside the loop.  */
134537:	      if (translate)
134559:                while (range > lim
134594:                       && !fastmap[(unsigned char)
134645:				   translate[(unsigned char) *d++]])
134686:                  range--;
134713:	      else
134725:                while (range > lim && !fastmap[(unsigned char) *d++])
134795:                  range--;
134822:
134823:	      startpos += irange - range;
134858:	    }
134865:	  else				/* Searching backwards.  */
134904:	    {
134911:	      register char c = (size1 == 0 || startpos >= size1
134969:                                 ? string2[startpos - size1] 
135031:                                 : string1[startpos]);
135086:
135087:	      if (!fastmap[(unsigned char) TRANSLATE (c)])
135139:		goto advance;
135155:	    }
135162:	}
135165:
135166:      /* If can't match the null string, and that's all we have left, fail.  */
135246:      if (range >= 0 && startpos == total_size && fastmap
135304:          && !bufp->can_be_null)
135337:	return -1;
135349:
135350:      val = re_match_2 (bufp, string1, size1, string2, size2,
135412:	                startpos, regs, stop);
135452:      if (val >= 0)
135472:	return startpos;
135490:        
135499:      if (val == -2)
135520:	return -2;
135532:
135533:    advance:
135546:      if (!range) 
135565:        break;
135580:      else if (range > 0) 
135607:        {
135617:          range--; 
135637:          startpos++;
135659:        }
135669:      else
135680:        {
135690:          range++; 
135710:          startpos--;
135732:        }
135742:    }
135748:  return -1;
135761:} /* re_search_2 */
135781:
135783:/* Declarations and macros for re_match_2.  */
135830:
135831:static int bcmp_translate ();
135861:static boolean alt_match_null_string_p (),
135904:               common_op_match_null_string_p (),
135953:               group_match_null_string_p ();
135998:
135999:/* Structure for per-register (a.k.a. per-group) information.
136061:   This must not be longer than one word, because we push this value
136130:   onto the failure stack.  Other register information, such as the
136198:   starting and ending positions (which are addresses), and the list of
136270:   inner groups (which is a bits list) are maintained in separate
136336:   variables.  
136352:   
136356:   We are making a (strictly speaking) nonportable assumption here: that
136429:   the compiler will pack our bit fields into something that fits into
136500:   the type of `word', i.e., is something that fits into one item on the
136573:   failure stack.  */
136595:typedef union
136609:{
136611:  fail_stack_elt_t word;
136636:  struct
136645:  {
136649:      /* This field is one if this group can match the empty string,
136718:         zero if not.  If not yet determined,  `MATCH_NULL_UNSET_VALUE'.  */
136795:#define MATCH_NULL_UNSET_VALUE 3
136828:    unsigned match_null_string_p : 2;
136866:    unsigned is_active : 1;
136894:    unsigned matched_something : 1;
136930:    unsigned ever_matched_something : 1;
136971:  } bits;
136981:} register_info_type;
137003:
137004:#define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)
137071:#define IS_ACTIVE(R)  ((R).bits.is_active)
137114:#define MATCHED_SOMETHING(R)  ((R).bits.matched_something)
137173:#define EVER_MATCHED_SOMETHING(R)  ((R).bits.ever_matched_something)
137242:
137243:
137244:/* Call this when have matched a real character; it sets `matched' flags
137317:   for the subexpressions which we are currently inside.  Also records
137388:   that those subexprs have matched.  */
137429:#define SET_REGS_MATCHED()						\
137463:  do									\
137478:    {									\
137494:      unsigned r;							\
137520:      for (r = lowest_active_reg; r <= highest_active_reg; r++)		\
137587:        {								\
137606:          MATCHED_SOMETHING (reg_info[r])				\
137653:            = EVER_MATCHED_SOMETHING (reg_info[r])			\
137708:            = 1;							\
137733:        }								\
137752:    }									\
137768:  while (0)
137780:
137781:
137782:/* This converts PTR, a pointer into one of the search strings `string1'
137855:   and `string2' into an offset from the beginning of that string.  */
137926:#define POINTER_TO_OFFSET(ptr)						\
137964:  (FIRST_STRING_P (ptr) ? (ptr) - string1 : (ptr) - string2 + size1)
138033:
138034:/* Registers are set to a sentinel when they haven't yet matched.  */
138104:#define REG_UNSET_VALUE ((char *) -1)
138142:#define REG_UNSET(e) ((e) == REG_UNSET_VALUE)
138188:
138189:
138190:/* Macros for dealing with the split strings in re_match_2.  */
138254:
138255:#define MATCHING_IN_FIRST_STRING  (dend == end_match_1)
138311:
138312:/* Call before fetching a character with *d.  This switches over to
138380:   string2 if necessary.  */
138409:#define PREFETCH()							\
138436:  while (d == dend)						    	\
138468:    {									\
138484:      /* End of string2 => fail.  */					\
138527:      if (dend == end_match_2) 						\
138566:        goto fail;							\
138593:      /* End of string1 => advance to string2.  */ 			\
138649:      d = string2;						        \
138683:      dend = end_match_2;						\
138716:    }
138722:
138723:
138724:/* Test if at very beginning or at very end of the virtual concatenation
138797:   of `string1' and `string2'.  If only one string, it's `string2'.  */
138869:#define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)
138942:#define AT_STRINGS_END(d) ((d) == end2)	
138983:
138984:
138985:/* Test if D points to a character which is word-constituent.  We have
139056:   two special cases to check for: if past the end of string1, look at
139127:   the first character in string2; and if before the beginning of
139193:   string2, look at the last character in string1.  */
139248:#define WORDCHAR_P(d)							\
139278:  (SYNTAX ((d) == end1 ? *string2					\
139318:           : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\
139376:   == Sword)
139389:
139390:/* Test if the character before D and the one at D differ with respect
139461:   to being word-constituent.  */
139495:#define AT_WORD_BOUNDARY(d)						\
139530:  (AT_STRINGS_BEG (d) || AT_STRINGS_END (d)				\
139579:   || WORDCHAR_P (d - 1) != WORDCHAR_P (d))
139623:
139624:
139625:/* Free everything we malloc.  */
139659:#ifdef REGEX_MALLOC
139679:#define FREE_VAR(var) if (var) free (var); var = NULL
139733:#define FREE_VARIABLES()						\
139765:  do {									\
139782:    FREE_VAR (fail_stack.stack);					\
139821:    FREE_VAR (regstart);						\
139853:    FREE_VAR (regend);							\
139884:    FREE_VAR (old_regstart);						\
139920:    FREE_VAR (old_regend);						\
139954:    FREE_VAR (best_regstart);						\
139991:    FREE_VAR (best_regend);						\
140026:    FREE_VAR (reg_info);						\
140058:    FREE_VAR (reg_dummy);						\
140091:    FREE_VAR (reg_info_dummy);						\
140129:  } while (0)
140143:#else /* not REGEX_MALLOC */
140172:/* Some MIPS systems (at least) want this to free alloca'd storage.  */
140244:#define FREE_VARIABLES() alloca (0)
140280:#endif /* not REGEX_MALLOC */
140310:
140311:
140312:/* These values must meet several constraints.  They must not be valid
140383:   register values; since we have a limit of 255 registers (because
140451:   we use only one byte in the pattern for the register number), we can
140523:   use numbers larger than 255.  They must differ by 1, because of
140590:   NUM_FAILURE_ITEMS above.  And the value for the lowest register must
140662:   be larger than the value for the highest register, so we do not try
140733:   to actually save any registers when none are active.  */
140793:#define NO_HIGHEST_ACTIVE_REG (1 << BYTEWIDTH)
140840:#define NO_LOWEST_ACTIVE_REG (NO_HIGHEST_ACTIVE_REG + 1)
140897:
140899:/* Matching routines.  */
140925:
140926:#ifndef emacs   /* Emacs never uses this.  */
140972:/* re_match is like re_match_2 except it takes only a single string.  */
141045:
141046:int
141050:re_match (bufp, string, size, pos, regs)
141091:     struct re_pattern_buffer *bufp;
141128:     const char *string;
141153:     int size, pos;
141173:     struct re_registers *regs;
141205: {
141208:  return re_match_2 (bufp, NULL, 0, string, size, pos, regs, size); 
141277:}
141279:#endif /* not emacs */
141302:
141303:
141304:/* re_match_2 matches the compiled pattern in BUFP against the
141367:   the (virtual) concatenation of STRING1 and STRING2 (of length SIZE1
141438:   and SIZE2, respectively).  We start matching at POS, and stop
141503:   matching at STOP.
141524:   
141528:   If REGS is non-null and the `no_sub' field of BUFP is nonzero, we
141597:   store offsets for the substring each group matched in REGS.  See the
141669:   documentation for exactly how many groups we fill.
141723:
141724:   We return -1 if no match, -2 if an internal error (such as the
141790:   failure stack overflowing).  Otherwise, we return the length of the
141861:   matched substring.  */
141887:
141888:int
141892:re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
141959:     struct re_pattern_buffer *bufp;
141996:     const char *string1, *string2;
142032:     int size1, size2;
142055:     int pos;
142069:     struct re_registers *regs;
142101:     int stop;
142116:{
142118:  /* General temporaries.  */
142148:  int mcnt;
142160:  unsigned char *p1;
142181:
142182:  /* Just past the end of the corresponding string.  */
142238:  const char *end1, *end2;
142265:
142266:  /* Pointers into string1 and string2, just past the last characters in
142339:     each to consider matching.  */
142375:  const char *end_match_1, *end_match_2;
142416:
142417:  /* Where we are in the data, and the end of the current string.  */
142487:  const char *d, *dend;
142511:  
142514:  /* Where we are in the pattern, and the end of the pattern.  */
142580:  unsigned char *p = bufp->buffer;
142615:  register unsigned char *pend = p + bufp->used;
142664:
142665:  /* We use this to map every character in the string.  */
142724:  char *translate = bufp->translate;
142761:
142762:  /* Failure point stack.  Each place that can handle a failure further
142834:     down the line pushes a failure point on this stack.  It consists of
142907:     restart, regend, and reg_info for all registers corresponding to
142977:     the subexpressions we're currently inside, plus the number of such
143049:     registers, and, finally, two char *'s.  The first char * is where
143120:     to resume scanning the pattern; the second one is where to resume
143191:     scanning the strings.  If the latter is zero, the failure point is
143263:     a ``dummy''; if a failure happens and the failure point is a dummy,
143336:     it gets discarded and the next next one is tried.  */
143395:  fail_stack_type fail_stack;
143425:#ifdef DEBUG
143438:  static unsigned failure_id = 0;
143472:  unsigned nfailure_points_pushed = 0, nfailure_points_popped = 0;
143539:#endif
143546:
143547:  /* We fill all the registers internally, independent of what we
143679:     an element for register zero.  */
143718:  unsigned num_regs = bufp->re_nsub + 1;
143759:  
143762:  /* The currently active registers.  */
143803:  unsigned lowest_active_reg = NO_LOWEST_ACTIVE_REG;
143856:  unsigned highest_active_reg = NO_HIGHEST_ACTIVE_REG;
143911:
143912:  /* Information on the contents of registers. These are pointers into
143983:     the input strings; they record just what was matched (on this
144050:     attempt) by a subexpression part of the pattern, that is, the
144117:     regnum-th regstart pointer points to where in the pattern we began
144189:     matching and the regnum-th regend points to right after where we
144259:     stopped matching the regnum-th subexpression.  (The zeroth register
144332:     keeps track of what the whole pattern matches.)  */
144389:  const char **regstart, **regend;
144424:
144425:  /* If a group that's operated upon by a repetition operator fails to
144496:     match anything, then the register for its start will need to be
144565:     restored because it will have been set to wherever in the string we
144638:     are when we last see its open-group operator.  Similarly for a
144706:     register's end.  */
144731:  const char **old_regstart, **old_regend;
144774:
144775:  /* The is_active field of reg_info helps us keep track of which (possibly
144851:     nested) subexpressions we are currently in. The matched_something
144922:     field of reg_info[reg_num] helps us tell whether or not we have
144991:     matched any of the pattern so far this time through the reg_num-th
145063:     subexpression.  These two fields get reset each time through any
145133:     loop their register is in.  */
145169:  register_info_type *reg_info; 
145202:
145203:  /* The following record the register info as found in the above
145269:     variables when we find a match better than any we've seen before. 
145341:     This happens as we backtrack through the failure points, which in
145412:     turn happens only if we have not yet matched the entire string. */
145484:  unsigned best_regs_set = false;
145518:  const char **best_regstart, **best_regend;
145563:  
145566:  /* Logically, this is `best_regend[0]'.  But we don't want to have to
145638:     allocate space for that if we're not allocating space for anything
145710:     else (see below).  Also, we never need info about register 0 for
145780:     any of the other register vectors, and it seems rather a kludge to
145852:     treat `best_regend' differently than the rest.  So we keep track of
145925:     the end of the best match so far in a separate variable.  We
145991:     initialize this to NULL so that when we backtrack the first time
146061:     and need to test it, it's not garbage.  */
146109:  const char *match_end = NULL;
146141:
146142:  /* Used when we pop values we don't care about.  */
146196:  const char **reg_dummy;
146222:  register_info_type *reg_info_dummy;
146260:
146261:#ifdef DEBUG
146274:  /* Counts the total number of registers pushed.  */
146328:  unsigned num_regs_pushed = 0; 	
146362:#endif
146369:
146370:  DEBUG_PRINT1 ("\n\nEntering re_match_2.\n");
146417:  
146420:  INIT_FAIL_STACK ();
146442:  
146445:  /* Do not bother to initialize all the register variables if there are
146518:     no groups in the pattern, as it takes a fair amount of time.  If
146654:     pattern), even though we never use it, since it simplifies the
146722:     array indexing.  We should fix this.  */
146768:  if (bufp->re_nsub)
146789:    {
146795:      regstart = REGEX_TALLOC (num_regs, const char *);
146851:      regend = REGEX_TALLOC (num_regs, const char *);
146905:      old_regstart = REGEX_TALLOC (num_regs, const char *);
146965:      old_regend = REGEX_TALLOC (num_regs, const char *);
147023:      best_regstart = REGEX_TALLOC (num_regs, const char *);
147084:      best_regend = REGEX_TALLOC (num_regs, const char *);
147143:      reg_info = REGEX_TALLOC (num_regs, register_info_type);
147205:      reg_dummy = REGEX_TALLOC (num_regs, const char *);
147262:      reg_info_dummy = REGEX_TALLOC (num_regs, register_info_type);
147330:
147331:      if (!(regstart && regend && old_regstart && old_regend && reg_info 
147405:            && best_regstart && best_regend && reg_dummy && reg_info_dummy)) 
147483:        {
147493:          FREE_VARIABLES ();
147522:          return -2;
147543:        }
147553:    }
147559:#ifdef REGEX_MALLOC
147579:  else
147586:    {
147592:      /* We must initialize all our variables to NULL, so that
147655:         `FREE_VARIABLES' doesn't try to free them.  */
147711:      regstart = regend = old_regstart = old_regend = best_regstart
147779:        = best_regend = reg_dummy = NULL;
147821:      reg_info = reg_info_dummy = (register_info_type *) NULL;
147884:    }
147890:#endif /* REGEX_MALLOC */
147916:
147917:  /* The starting position is bogus.  */
147958:  if (pos < 0 || pos > size1 + size2)
147996:    {
148002:      FREE_VARIABLES ();
148027:      return -1;
148044:    }
148050:    
148055:  /* Initialize subexpression text positions to -1 to mark ones that no
148127:     start_memory/stop_memory has been seen for. Also initialize the
148196:     register information struct.  */
148234:  for (mcnt = 1; mcnt < num_regs; mcnt++)
148276:    {
148282:      regstart[mcnt] = regend[mcnt] 
148319:        = old_regstart[mcnt] = old_regend[mcnt] = REG_UNSET_VALUE;
148386:        
148395:      REG_MATCH_NULL_STRING_P (reg_info[mcnt]) = MATCH_NULL_UNSET_VALUE;
148468:      IS_ACTIVE (reg_info[mcnt]) = 0;
148506:      MATCHED_SOMETHING (reg_info[mcnt]) = 0;
148552:      EVER_MATCHED_SOMETHING (reg_info[mcnt]) = 0;
148603:    }
148609:  
148612:  /* We move `string1' into `string2' if the latter's empty -- but not if
148686:     `string1' is null.  */
148714:  if (size2 == 0 && string1 != NULL)
148751:    {
148757:      string2 = string1;
148782:      size2 = size1;
148803:      string1 = 0;
148822:      size1 = 0;
148839:    }
148845:  end1 = string1 + size1;
148871:  end2 = string2 + size2;
148897:
148898:  /* Compute where to stop matching, within the two strings.  */
148963:  if (stop <= size1)
148984:    {
148990:      end_match_1 = string1 + stop;
149026:      end_match_2 = string2;
149055:    }
149061:  else
149068:    {
149074:      end_match_1 = end1;
149100:      end_match_2 = string2 + stop - size1;
149144:    }
149150:
149151:  /* `p' scans through the pattern as `d' scans through the data. 
149218:     `dend' is the end of the input string that `d' points within.  `d'
149290:     is advanced into the following input string whenever necessary, but
149363:     this happens before fetching; therefore, at the beginning of the
149433:     loop, `d' can be pointing at the end of a string, but it cannot
149502:     equal `string2'.  */
149528:  if (size1 > 0 && pos <= size1)
149561:    {
149567:      d = string1 + pos;
149592:      dend = end_match_1;
149618:    }
149624:  else
149631:    {
149637:      d = string2 + pos - size1;
149670:      dend = end_match_2;
149696:    }
149702:
149703:  DEBUG_PRINT1 ("The compiled pattern is: ");
149749:  DEBUG_PRINT_COMPILED_PATTERN (bufp, p, pend);
149797:  DEBUG_PRINT1 ("The string to match is: `");
149843:  DEBUG_PRINT_DOUBLE_STRING (d, string1, size1, string2, size2);
149908:  DEBUG_PRINT1 ("'\n");
149932:  
149935:  /* This loops over pattern commands.  It exits by returning from the
150006:     function if the match is complete, or it drops through if the match
150079:     fails at this starting point in the input data.  */
150136:  for (;;)
150147:    {
150153:      DEBUG_PRINT2 ("\n0x%x: ", p);
150189:
150190:      if (p == pend)
150211:	{ /* End of pattern means we might have succeeded.  */
150267:          DEBUG_PRINT1 ("end of pattern ... ");
150315:          
150326:	  /* If we haven't matched the entire string, and we want the
150389:             longest match, try backtracking.  */
150439:          if (d != end_match_2)
150471:	    {
150478:              DEBUG_PRINT1 ("backtracking.\n");
150526:              
150541:              if (!FAIL_STACK_EMPTY ())
150581:                { /* More failure points to try.  */
150634:                  boolean same_str_p = (FIRST_STRING_P (match_end) 
150702:	        	                == MATCHING_IN_FIRST_STRING);
150758:
150759:                  /* If exceeds best match so far, save it.  */
150823:                  if (!best_regs_set
150860:                      || (same_str_p && d > match_end)
150915:                      || (!same_str_p && !MATCHING_IN_FIRST_STRING))
150984:                    {
151006:                      best_regs_set = true;
151050:                      match_end = d;
151087:                      
151110:                      DEBUG_PRINT1 ("\nSAVING match as best so far.\n");
151183:                      
151206:                      for (mcnt = 1; mcnt < num_regs; mcnt++)
151268:                        {
151294:                          best_regstart[mcnt] = regstart[mcnt];
151358:                          best_regend[mcnt] = regend[mcnt];
151418:                        }
151444:                    }
151466:                  goto fail;	       
151503:                }
151521:
151522:              /* If no failure points, don't restore garbage.  */
151588:              else if (best_regs_set)   
151629:                {
151647:  	        restore_best_regs:
151677:                  /* Restore best match.  It may happen that `dend ==
151747:                     end_match_1' while the restored d is in string2.
151817:                     For example, the pattern `x.*y.*z' against the
151885:                     strings `x-' and `y-z-', if the two strings are
151954:                     not consecutive in memory.  */
152006:                  DEBUG_PRINT1 ("Restoring best registers.\n");
152070:                  
152089:                  d = match_end;
152122:                  dend = ((d >= string1 && d <= end1)
152176:		           ? end_match_1 : end_match_2);
152219:
152220:		  for (mcnt = 1; mcnt < num_regs; mcnt++)
152264:		    {
152272:		      regstart[mcnt] = best_regstart[mcnt];
152318:		      regend[mcnt] = best_regend[mcnt];
152360:		    }
152368:                }
152386:            } /* d != end_match_2 */
152423:
152424:          DEBUG_PRINT1 ("Accepting match.\n");
152471:
152472:          /* If caller wants register contents data back, do it.  */
152541:          if (regs && !bufp->no_sub)
152578:	    {
152585:              /* Have the register data arrays been allocated?  */
152652:              if (bufp->regs_allocated == REGS_UNALLOCATED)
152712:                { /* No.  So allocate them with malloc.  We need one
152781:                     extra element beyond `num_regs' for the `-1' marker
152854:                     GNU code uses.  */
152894:                  regs->num_regs = MAX (RE_NREGS, num_regs + 1);
152959:                  regs->start = TALLOC (regs->num_regs, regoff_t);
153026:                  regs->end = TALLOC (regs->num_regs, regoff_t);
153091:                  if (regs->start == NULL || regs->end == NULL)
153155:                    return -2;
153186:                  bufp->regs_allocated = REGS_REALLOCATE;
153244:                }
153262:              else if (bufp->regs_allocated == REGS_REALLOCATE)
153326:                { /* Yes.  If we need more elements than were already
153396:                     allocated, reallocate them.  If we need fewer, just
153469:                     leave it alone.  */
153510:                  if (regs->num_regs < num_regs + 1)
153563:                    {
153585:                      regs->num_regs = num_regs + 1;
153638:                      RETALLOC (regs->start, regs->num_regs, regoff_t);
153710:                      RETALLOC (regs->end, regs->num_regs, regoff_t);
153780:                      if (regs->start == NULL || regs->end == NULL)
153848:                        return -2;
153883:                    }
153905:                }
153923:              else
153942:		{
153946:		  /* These braces fend off a "empty body in an else-statement"
154011:		     warning under GCC when assert expands to nothing.  */
154072:		  assert (bufp->regs_allocated == REGS_FIXED);
154121:		}
154125:
154126:              /* Convert the pointer data in `regstart' and `regend' to
154198:                 indices.  Register zero has to be set differently,
154266:                 since we haven't kept track of any info for it.  */
154335:              if (regs->num_regs > 0)
154373:                {
154391:                  regs->start[0] = pos;
154431:                  regs->end[0] = (MATCHING_IN_FIRST_STRING ? d - string1
154504:			          : d - string2 + size1);
154541:                }
154559:              
154574:              /* Go through the first `min (num_regs, regs->num_regs)'
154645:                 registers, since that is all we initialized.  */
154711:	      for (mcnt = 1; mcnt < MIN (num_regs, regs->num_regs); mcnt++)
154780:		{
154784:                  if (REG_UNSET (regstart[mcnt]) || REG_UNSET (regend[mcnt]))
154862:                    regs->start[mcnt] = regs->end[mcnt] = -1;
154924:                  else
154947:                    {
154969:		      regs->start[mcnt] = POINTER_TO_OFFSET (regstart[mcnt]);
155033:                      regs->end[mcnt] = POINTER_TO_OFFSET (regend[mcnt]);
155107:                    }
155129:		}
155133:              
155148:              /* If the regs structure we return has more elements than
155220:                 were in the pattern, set the extra elements to -1.  If
155292:                 we (re)allocated the registers, this is the case,
155359:                 because we always allocate enough to have at least one
155431:                 -1 at the end.  */
155467:              for (mcnt = num_regs; mcnt < regs->num_regs; mcnt++)
155534:                regs->start[mcnt] = regs->end[mcnt] = -1;
155592:	    } /* regs && !bufp->no_sub */
155627:
155628:          FREE_VARIABLES ();
155657:          DEBUG_PRINT4 ("%u failure points pushed, %u popped (%u remain).\n",
155735:                        nfailure_points_pushed, nfailure_points_popped,
155807:                        nfailure_points_pushed - nfailure_points_popped);
155881:          DEBUG_PRINT2 ("%u registers pushed.\n", num_regs_pushed);
155949:
155950:          mcnt = d - pos - (MATCHING_IN_FIRST_STRING 
156004:			    ? string1 
156022:			    : string2 - size1);
156049:
156050:          DEBUG_PRINT2 ("Returning %d from re_match_2.\n", mcnt);
156116:
156117:          return mcnt;
156140:        }
156150:
156151:      /* Otherwise match next pattern command.  */
156202:#ifdef SWITCH_ENUM_BUG
156225:      switch ((int) ((re_opcode_t) *p++))
156267:#else
156273:      switch ((re_opcode_t) *p++)
156307:#endif
156314:	{
156317:        /* Ignore these.  Used to ignore the n of succeed_n's which
156385:           currently have n == 0.  */
156423:        case no_op:
156443:          DEBUG_PRINT1 ("EXECUTING no_op.\n");
156490:          break;
156507:
156508:
156509:        /* Match the next n pattern characters exactly.  The following
156580:           byte in the pattern defines n, and the n bytes after that
156649:           are the characters to match.  */
156693:	case exactn:
156707:	  mcnt = *p++;
156723:          DEBUG_PRINT2 ("EXECUTING exactn %d.\n", mcnt);
156780:
156781:          /* This is written out as an if-else so we don't waste time
156851:             testing `translate' inside the loop.  */
156905:          if (translate)
156930:	    {
156937:	      do
156947:		{
156951:		  PREFETCH ();
156968:		  if (translate[(unsigned char) *d++] != (char) *p++)
157024:                    goto fail;
157055:		}
157059:	      while (--mcnt);
157082:	    }
157089:	  else
157097:	    {
157104:	      do
157114:		{
157118:		  PREFETCH ();
157135:		  if (*d++ != (char) *p++) goto fail;
157175:		}
157179:	      while (--mcnt);
157202:	    }
157209:	  SET_REGS_MATCHED ();
157233:          break;
157250:
157251:
157252:        /* Match any character except possibly a newline or a null.  */
157324:	case anychar:
157339:          DEBUG_PRINT1 ("EXECUTING anychar.\n");
157388:
157389:          PREFETCH ();
157412:
157413:          if ((!(bufp->syntax & RE_DOT_NEWLINE) && TRANSLATE (*d) == '\n')
157488:              || (bufp->syntax & RE_DOT_NOT_NULL && TRANSLATE (*d) == '\000'))
157567:	    goto fail;
157583:
157584:          SET_REGS_MATCHED ();
157615:          DEBUG_PRINT2 ("  Matched `%d'.\n", *d);
157665:          d++;
157680:	  break;
157690:
157691:
157692:	case charset:
157707:	case charset_not:
157726:	  {
157731:	    register unsigned char c;
157762:	    boolean not = (re_opcode_t) *(p - 1) == charset_not;
157820:
157821:            DEBUG_PRINT2 ("EXECUTING charset%s.\n", not ? "_not" : "");
157893:
157894:	    PREFETCH ();
157912:	    c = TRANSLATE (*d); /* The character to match.  */
157968:
157969:            /* Cast to `unsigned' instead of `unsigned char' in case the
158042:               bit list is a full 32 bytes long.  */
158095:	    if (c < (unsigned) (*p * BYTEWIDTH)
158136:		&& p[1 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
158188:	      not = !not;
158207:
158208:	    p += 1 + *p;
158226:
158227:	    if (!not) goto fail;
158253:            
158266:	    SET_REGS_MATCHED ();
158292:            d++;
158309:	    break;
158321:	  }
158326:
158327:
158328:        /* The beginning of a group is represented by start_memory.
158396:           The arguments are the register number in the next byte, and the
158471:           number of groups inner to this one in the next.  The text
158540:           matched within the group is recorded (in the internal
158605:           registers data structure) under the register number.  */
158673:        case start_memory:
158700:	  DEBUG_PRINT3 ("EXECUTING start_memory %d (%d):\n", *p, p[1]);
158765:
158766:          /* Find out if this group can match the empty string.  */
158834:	  p1 = p;		/* To send to group_match_null_string_p.  */
158891:          
158902:          if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)
158982:            REG_MATCH_NULL_STRING_P (reg_info[*p]) 
159034:              = group_match_null_string_p (&p1, pend, reg_info);
159099:
159100:          /* Save the position in the string where we were the last time
159173:             we were at this open-group operator in case the group is
159243:             operated upon by a repetition operator, e.g., with `(a*)*b'
159316:             against `ab'; then we want to ignore where we are now in
159386:             the string in case this attempt to match fails.  */
159451:          old_regstart[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
159519:                             ? REG_UNSET (regstart[*p]) ? d : regstart[*p]
159594:                             : regstart[*p];
159639:	  DEBUG_PRINT2 ("  old_regstart: %d\n", 
159681:			 POINTER_TO_OFFSET (old_regstart[*p]));
159724:
159725:          regstart[*p] = d;
159753:	  DEBUG_PRINT2 ("  regstart: %d\n", POINTER_TO_OFFSET (regstart[*p]));
159825:
159826:          IS_ACTIVE (reg_info[*p]) = 1;
159866:          MATCHED_SOMETHING (reg_info[*p]) = 0;
159914:          
159925:          /* This is the new highest active register.  */
159983:          highest_active_reg = *p;
160018:          
160029:          /* If nothing was active before, this is the new lowest active
160102:             register.  */
160129:          if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
160186:            lowest_active_reg = *p;
160222:
160223:          /* Move past the register number and inner group count.  */
160293:          p += 2;
160311:          break;
160328:
160329:
160330:        /* The stop_memory opcode represents the end of a group.  Its
160400:           arguments are the same as start_memory's: the register
160466:           number, and the number of inner groups.  */
160521:	case stop_memory:
160540:	  DEBUG_PRINT3 ("EXECUTING stop_memory %d (%d):\n", *p, p[1]);
160604:             
160618:          /* We need to save the string position the last time we were at
160692:             this close-group operator in case the group is operated
160761:             upon by a repetition operator, e.g., with `((a*)*(b*)*)*'
160832:             against `aba'; then we want to ignore where we are now in
160903:             the string in case this attempt to match fails.  */
160968:          old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
161034:                           ? REG_UNSET (regend[*p]) ? d : regend[*p]
161103:			   : regend[*p];
161123:	  DEBUG_PRINT2 ("      old_regend: %d\n", 
161167:			 POINTER_TO_OFFSET (old_regend[*p]));
161208:
161209:          regend[*p] = d;
161235:	  DEBUG_PRINT2 ("      regend: %d\n", POINTER_TO_OFFSET (regend[*p]));
161307:
161308:          /* This register isn't active anymore.  */
161361:          IS_ACTIVE (reg_info[*p]) = 0;
161401:          
161412:          /* If this was the only register active, nothing is active
161481:             anymore.  */
161507:          if (lowest_active_reg == highest_active_reg)
161562:            {
161576:              lowest_active_reg = NO_LOWEST_ACTIVE_REG;
161632:              highest_active_reg = NO_HIGHEST_ACTIVE_REG;
161690:            }
161704:          else
161719:            { /* We must scan for the new highest active register, since
161792:                 it isn't necessarily one less than now: consider
161858:                 (a(b)c(d(e)f)g).  When group 3 ends, after the f), the
161930:                 new highest active register is 1.  */
161985:              unsigned char r = *p - 1;
162025:              while (r > 0 && !IS_ACTIVE (reg_info[r]))
162081:                r--;
162102:              
162117:              /* If we end up at register zero, that means that we saved
162190:                 the registers as the result of an `on_failure_jump', not
162264:                 a `start_memory', and we jumped to past the innermost
162335:                 `stop_memory'.  For example, in ((.)*) we save
162399:                 registers 1 and 2 as a result of the *, but when we pop
162472:                 back to the second ), we are at the stop_memory 1.
162540:                 Thus, nothing is active.  */
162586:	      if (r == 0)
162605:                {
162623:                  lowest_active_reg = NO_LOWEST_ACTIVE_REG;
162683:                  highest_active_reg = NO_HIGHEST_ACTIVE_REG;
162745:                }
162763:              else
162782:                highest_active_reg = r;
162822:            }
162836:          
162847:          /* If just failed to match something this time around with a
162918:             group that's operated on by a repetition operator, try to
162989:             force exit from the ``loop'', and restore the register
163057:             information for this group that we had before trying this
163128:             last match.  */
163157:          if ((!MATCHED_SOMETHING (reg_info[*p])
163206:               || (re_opcode_t) p[-3] == start_memory)
163261:	      && (p + 2) < pend)              
163301:            {
163315:              boolean is_a_jump_n = false;
163358:              
163373:              p1 = p + 2;
163399:              mcnt = 0;
163423:              switch ((re_opcode_t) *p1++)
163466:                {
163484:                  case jump_n:
163515:		    is_a_jump_n = true;
163541:                  case pop_failure_jump:
163582:		  case maybe_pop_jump:
163607:		  case jump:
163622:		  case dummy_failure_jump:
163651:                    EXTRACT_NUMBER_AND_INCR (mcnt, p1);
163707:		    if (is_a_jump_n)
163730:		      p1 += 2;
163747:                    break;
163774:                  
163793:                  default:
163820:                    /* do nothing */ ;
163859:                }
163877:	      p1 += mcnt;
163896:        
163905:              /* If the next operation is a jump backwards in the pattern
163979:	         to an on_failure_jump right before the start_memory
164041:                 corresponding to this stop_memory, exit from the loop
164112:                 by forcing a failure after pushing on the stack the
164181:                 on_failure_jump's jump in the pattern, and d.  */
164248:              if (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump
164315:                  && (re_opcode_t) p1[3] == start_memory && p1[4] == *p)
164388:		{
164392:                  /* If this group ever matched anything, then restore
164463:                     what its registers were before trying this last
164532:                     failed match, e.g., with `(a*)*b' against `ab' for
164604:                     regstart[1], and, e.g., with `((a*)*(b*)*)*'
164670:                     against `aba' for regend[3].
164720:                     
164742:                     Also restore the registers for inner groups for,
164812:                     e.g., `((a*)(b*))*' against `aba' (register 3 would
164885:                     otherwise get trashed).  */
164934:                     
164956:                  if (EVER_MATCHED_SOMETHING (reg_info[*p]))
165017:		    {
165025:		      unsigned r; 
165046:        
165055:                      EVER_MATCHED_SOMETHING (reg_info[*p]) = 0;
165120:                      
165143:		      /* Restore this and inner groups' (if any) registers.  */
165209:                      for (r = *p; r < *p + *(p + 1); r++)
165268:                        {
165294:                          regstart[r] = old_regstart[r];
165351:
165352:                          /* xx why this test?  */
165403:                          if ((int) old_regend[r] >= (int) regstart[r])
165475:                            regend[r] = old_regend[r];
165530:                        }     
165561:                    }
165583:		  p1++;
165593:                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
165647:                  PUSH_FAILURE_POINT (p1 + mcnt, d, -2);
165704:
165705:                  goto fail;
165734:                }
165752:            }
165766:          
165777:          /* Move past the register number and the inner group count.  */
165851:          p += 2;
165869:          break;
165886:
165887:
165888:	/* \<digit> has been turned into a `duplicate' command which is
165953:           followed by the numeric value of <digit> as the register number.  */
166033:        case duplicate:
166057:	  {
166062:	    register const char *d2, *dend2;
166100:	    int regno = *p++;   /* Get which register to match against.  */
166169:	    DEBUG_PRINT2 ("EXECUTING duplicate %d.\n", regno);
166225:
166226:	    /* Can't back reference a group which we've never matched.  */
166294:            if (REG_UNSET (regstart[regno]) || REG_UNSET (regend[regno]))
166368:              goto fail;
166393:              
166408:            /* Where in input to try to start matching.  */
166468:            d2 = regstart[regno];
166502:            
166515:            /* Where to stop matching; if both the place to start and
166585:               the place to stop matching are in the same string, then
166656:               set to the place to stop, otherwise, for now have to use
166728:               the end of the first string.  */
166776:
166777:            dend2 = ((FIRST_STRING_P (regstart[regno]) 
166833:		      == FIRST_STRING_P (regend[regno]))
166876:		     ? regend[regno] : end_match_1);
166915:	    for (;;)
166929:	      {
166938:		/* If necessary, advance to next segment in register
166993:                   contents.  */
167026:		while (d2 == dend2)
167048:		  {
167054:		    if (dend2 == end_match_2) break;
167093:		    if (dend2 == regend[regno]) break;
167134:
167135:                    /* End of string1 => advance to string2. */
167199:                    d2 = string2;
167233:                    dend2 = regend[regno];
167276:		  }
167282:		/* At end of register contents => success */
167329:		if (d2 == dend2) break;
167355:
167356:		/* If necessary, advance to next segment in data.  */
167412:		PREFETCH ();
167427:
167428:		/* How many characters left in this segment to match.  */
167488:		mcnt = dend - d;
167507:                
167524:		/* Want how many consecutive characters we can match in
167582:                   one shot, so, if necessary, adjust the count.  */
167651:                if (mcnt > dend2 - d2)
167690:		  mcnt = dend2 - d2;
167713:                  
167732:		/* Compare that many; failure if mismatch, else move
167787:                   past them.  */
167821:		if (translate 
167838:                    ? bcmp_translate (d, d2, mcnt, translate) 
167901:                    : bcmp (d, d2, mcnt))
167943:		  goto fail;
167958:		d += mcnt, d2 += mcnt;
167983:	      }
167992:	  }
167997:	  break;
168007:
168008:
168009:        /* begline matches the empty string at the beginning of the string
168084:           (unless `not_bol' is set in `bufp'), and, if
168140:           `newline_anchor' is set, after newlines.  */
168196:	case begline:
168211:          DEBUG_PRINT1 ("EXECUTING begline.\n");
168260:          
168271:          if (AT_STRINGS_BEG (d))
168305:            {
168319:              if (!bufp->not_bol) break;
168360:            }
168374:          else if (d[-1] == '\n' && bufp->newline_anchor)
168432:            {
168446:              break;
168467:            }
168481:          /* In all other cases, we fail.  */
168527:          goto fail;
168548:
168549:
168550:        /* endline is the dual of begline.  */
168597:	case endline:
168612:          DEBUG_PRINT1 ("EXECUTING endline.\n");
168661:
168662:          if (AT_STRINGS_END (d))
168696:            {
168710:              if (!bufp->not_eol) break;
168751:            }
168765:          
168776:          /* We have to ``prefetch'' the next character.  */
168837:          else if ((d == end1 ? *string2 : *d) == '\n'
168892:                   && bufp->newline_anchor)
168936:            {
168950:              break;
168971:            }
168985:          goto fail;
169006:
169007:
169008:	/* Match at the very beginning of the data.  */
169057:        case begbuf:
169078:          DEBUG_PRINT1 ("EXECUTING begbuf.\n");
169126:          if (AT_STRINGS_BEG (d))
169160:            break;
169179:          goto fail;
169200:
169201:
169202:	/* Match at the very end of the data.  */
169245:        case endbuf:
169266:          DEBUG_PRINT1 ("EXECUTING endbuf.\n");
169314:	  if (AT_STRINGS_END (d))
169341:	    break;
169353:          goto fail;
169374:
169375:
169376:        /* on_failure_keep_string_jump is used to optimize `.*\n'.  It
169447:           pushes NULL as the value for the string on the stack.  Then
169518:           `pop_failure_point' will keep the current value for the
169585:           string, instead of restoring it.  To see why, consider
169651:           matching `foo\nbar' against `.*\n'.  The .* matches the foo;
169723:           then the . fails against the \n.  But the next thing we want
169795:           to do is match the \n against the \n; if we restored the
169863:           string value, we would be back at the foo.
169917:           
169929:           Because this is used only in specific cases, we don't need to
170002:           check all the things that `on_failure_jump' does, to make
170071:           sure the right things get saved on the stack.  Hence we don't
170144:           share its code.  The only reason to push anything on the
170212:           stack at all is that otherwise we would have to change
170278:           `anychar's code to do something besides goto fail in this
170347:           case; that seems worse than this.  */
170396:        case on_failure_keep_string_jump:
170438:          DEBUG_PRINT1 ("EXECUTING on_failure_keep_string_jump");
170504:          
170515:          EXTRACT_NUMBER_AND_INCR (mcnt, p);
170560:          DEBUG_PRINT3 (" %d (to 0x%x):\n", mcnt, p + mcnt);
170621:
170622:          PUSH_FAILURE_POINT (p + mcnt, NULL, -2);
170673:          break;
170690:
170691:
170692:	/* Uses of on_failure_jump:
170721:        
170730:           Each alternative starts with an on_failure_jump that points
170801:           to the beginning of the next alternative.  Each alternative
170872:           except the last ends with a jump that in effect jumps past
170942:           the rest of the alternatives.  (They really jump to the
171009:           ending jump of the following alternative, because tensioning
171081:           these jumps is a hassle.)
171118:
171119:           Repeats start with an on_failure_jump that points past both
171190:           the repetition text and either the following jump or
171254:           pop_failure_jump back to this on_failure_jump.  */
171316:	case on_failure_jump:
171339:        on_failure:
171359:          DEBUG_PRINT1 ("EXECUTING on_failure_jump");
171413:
171414:          EXTRACT_NUMBER_AND_INCR (mcnt, p);
171459:          DEBUG_PRINT3 (" %d (to 0x%x)", mcnt, p + mcnt);
171517:
171518:          /* If this on_failure_jump comes right before a group (i.e.,
171589:             the original * applied to a group), save the information
171659:             for that group and all inner ones, so that if we fail back
171731:             to this point, the group's information will be correct.
171800:             For example, in \(a*\)*\1, we need the preceding group,
171869:             and in \(\(a*\)b*\)\2, we need the inner group.  */
171934:
171935:          /* We can't use `p' to check ahead because we push
171996:             a failure point to `p + mcnt' after we do this.  */
172061:          p1 = p;
172079:
172080:          /* We need to skip no_op's before we look for the
172140:             start_memory in case this on_failure_jump is happening as
172211:             the result of a completed succeed_n, as in \(a\)\{1,3\}b\1
172283:             against aba.  */
172313:          while (p1 < pend && (re_opcode_t) *p1 == no_op)
172371:            p1++;
172389:
172390:          if (p1 < pend && (re_opcode_t) *p1 == start_memory)
172452:            {
172466:              /* We have a new highest active register now.  This will
172537:                 get reset at the start_memory we are about to get to,
172608:                 but we will have saved all the registers relevant to
172678:                 this repetition op, as described above.  */
172739:              highest_active_reg = *(p1 + 1) + *(p1 + 2);
172797:              if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
172858:                lowest_active_reg = *(p1 + 1);
172905:            }
172919:
172920:          DEBUG_PRINT1 (":\n");
172952:          PUSH_FAILURE_POINT (p + mcnt, d, -2);
173000:          break;
173017:
173018:
173019:        /* A smart repeat ends with `maybe_pop_jump'.
173073:	   We change it to either `pop_failure_jump' or `jump'.  */
173134:        case maybe_pop_jump:
173163:          EXTRACT_NUMBER_AND_INCR (mcnt, p);
173208:          DEBUG_PRINT2 ("EXECUTING maybe_pop_jump %d.\n", mcnt);
173273:          {
173285:	    register unsigned char *p2 = p;
173322:
173323:            /* Compare the beginning of the repeat with what in the
173391:               pattern follows its end. If we can establish that there
173462:               is nothing that they would both match, i.e., that we
173530:               would have to backtrack because of (as in, e.g., `a*a')
173601:               then we can change to pop_failure_jump, because we'll
173670:               never have to backtrack.
173710:               
173726:               This is not true in the case of alternatives: in
173790:               `(a|ab)*' we do need to backtrack to the `ab' alternative
173863:               (e.g., if the string was `ab').  But instead of trying to
173936:               detect that here, the alternative has put on a dummy
174004:               failure point which is what we will end up popping.  */
174075:
174076:	    /* Skip over open/close-group commands.  */
174125:	    while (p2 + 2 < pend
174151:		   && ((re_opcode_t) *p2 == stop_memory
174193:		       || (re_opcode_t) *p2 == start_memory))
174241:	      p2 += 3;			/* Skip over args, too.  */
174287:
174288:            /* If we're at the end of the pattern, we can change.  */
174358:            if (p2 == pend)
174386:	      {
174395:		/* Consider what happens when matching ":\(.*\)"
174446:		   against ":/".  I don't really understand this code
174502:		   yet.  */
174516:  	        p[-3] = (unsigned char) pop_failure_jump;
174569:                DEBUG_PRINT1
174598:                  ("  End of pattern: change to `pop_failure_jump'.\n");
174671:              }
174687:
174688:            else if ((re_opcode_t) *p2 == exactn
174737:		     || (bufp->newline_anchor && (re_opcode_t) *p2 == endline))
174803:	      {
174812:		register unsigned char c
174839:                  = *p2 == (unsigned char) endline ? '\n' : p2[2];
174906:		p1 = p + mcnt;
174923:
174924:                /* p1[0] ... p1[2] are the `on_failure_jump' corresponding
174999:                   to the `maybe_finalize_jump' of this case.  Examine what 
175076:                   follows.  */
175108:                if ((re_opcode_t) p1[3] == exactn && p1[5] != c)
175173:                  {
175193:  		    p[-3] = (unsigned char) pop_failure_jump;
175243:                    DEBUG_PRINT3 ("  %c != %c => pop_failure_jump.\n",
175314:                                  c, p1[5]);
175359:                  }
175379:                  
175398:		else if ((re_opcode_t) p1[3] == charset
175440:			 || (re_opcode_t) p1[3] == charset_not)
175483:		  {
175489:		    int not = (re_opcode_t) p1[3] == charset_not;
175541:                    
175562:		    if (c < (unsigned char) (p1[4] * BYTEWIDTH)
175612:			&& p1[5 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
175666:		      not = !not;
175686:
175687:                    /* `not' is equal to 1 if c would match, which means
175760:                        that we can't change to pop_failure_jump.  */
175830:		    if (!not)
175846:                      {
175870:  		        p[-3] = (unsigned char) pop_failure_jump;
175924:                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
176000:                      }
176024:		  }
176030:	      }
176039:	  }
176044:	  p -= 2;		/* Point at relative address again.  */
176096:	  if ((re_opcode_t) p[-1] != pop_failure_jump)
176144:	    {
176151:	      p[-1] = (unsigned char) jump;
176188:              DEBUG_PRINT1 ("  Match => jump.\n");
176239:	      goto unconditional_jump;
176271:	    }
176278:        /* Note fall through.  */
176312:
176313:
176314:	/* The end of a simple repeat has a pop_failure_jump back to
176376:           its matching on_failure_jump, where the latter will push a
176446:           failure point.  The pop_failure_jump takes off failure
176512:           points put on by this pop_failure_jump's matching
176573:           on_failure_jump; we got through the pattern to here from the
176645:           matching on_failure_jump, so didn't fail.  */
176702:        case pop_failure_jump:
176733:          {
176745:            /* We need to pass separate storage for the lowest and
176812:               highest registers, even though we don't care about the
176882:               actual values.  Otherwise, we will restore only one
176949:               register from the stack, since lowest will == highest in
177021:               `pop_failure_point'.  */
177061:            unsigned dummy_low_reg, dummy_high_reg;
177113:            unsigned char *pdummy;
177148:            const char *sdummy;
177180:
177181:            DEBUG_PRINT1 ("EXECUTING pop_failure_jump.\n");
177241:            POP_FAILURE_POINT (sdummy, pdummy,
177288:                               dummy_low_reg, dummy_high_reg,
177350:                               reg_dummy, reg_dummy, reg_info_dummy);
177420:          }
177432:          /* Note fall through.  */
177468:
177469:          
177480:        /* Unconditionally jump (without popping any failure points).  */
177554:        case jump:
177573:	unconditional_jump:
177594:	  EXTRACT_NUMBER_AND_INCR (mcnt, p);	/* Get the amount to jump.  */
177663:          DEBUG_PRINT2 ("EXECUTING jump %d ", mcnt);
177716:	  p += mcnt;				/* Do the jump.  */
177753:          DEBUG_PRINT2 ("(to 0x%x).\n", p);
177797:	  break;
177807:
177808:	
177810:        /* We need this opcode so we can detect where alternatives end
177881:           in `group_match_null_string_p' et al.  */
177934:        case jump_past_alt:
177962:          DEBUG_PRINT1 ("EXECUTING jump_past_alt.\n");
178017:          goto unconditional_jump;
178052:
178053:
178054:        /* Normally, the on_failure_jump pushes a failure point, which
178125:           then gets popped at pop_failure_jump.  We will end up at
178193:           pop_failure_jump, also, and with a pattern of, say, `a+', we
178265:           are skipping over the on_failure_jump, so we have to push
178334:           something meaningless for pop_failure_jump to pop.  */
178400:        case dummy_failure_jump:
178433:          DEBUG_PRINT1 ("EXECUTING dummy_failure_jump.\n");
178493:          /* It doesn't matter what we push for the string here.  What
178564:             the code at `fail' tests is the value for the pattern.  */
178636:          PUSH_FAILURE_POINT (0, 0, -2);
178677:          goto unconditional_jump;
178712:
178713:
178714:        /* At the end of an alternative, we need to push a dummy failure
178787:           point in case we are followed by a `pop_failure_jump', because
178861:           we don't want the failure point for the alternative to be
178930:           popped.  For example, matching `(a|ab)*' against `aab'
178996:           requires that we match the `ab' alternative.  */
179056:        case push_dummy_failure:
179089:          DEBUG_PRINT1 ("EXECUTING push_dummy_failure.\n");
179149:          /* See comments just above at `dummy_failure_jump' about the
179220:             two zeroes.  */
179249:          PUSH_FAILURE_POINT (0, 0, -2);
179290:          break;
179307:
179308:        /* Have to succeed matching what follows at least n times.
179375:           After that, handle like `on_failure_jump'.  */
179433:        case succeed_n: 
179458:          EXTRACT_NUMBER (mcnt, p + 2);
179498:          DEBUG_PRINT2 ("EXECUTING succeed_n %d.\n", mcnt);
179558:
179559:          assert (mcnt >= 0);
179589:          /* Originally, this is how many times we HAVE to succeed.  */
179661:          if (mcnt > 0)
179685:            {
179699:               mcnt--;
179722:	       p += 2;
179738:               STORE_NUMBER_AND_INCR (p, mcnt);
179786:               DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p, mcnt);
179852:            }
179866:	  else if (mcnt == 0)
179889:            {
179903:              DEBUG_PRINT2 ("  Setting two bytes from 0x%x to no_op.\n", p+2);
179982:	      p[2] = (unsigned char) no_op;
180019:              p[3] = (unsigned char) no_op;
180063:              goto on_failure;
180094:            }
180108:          break;
180125:        
180134:        case jump_n: 
180156:          EXTRACT_NUMBER (mcnt, p + 2);
180196:          DEBUG_PRINT2 ("EXECUTING jump_n %d.\n", mcnt);
180253:
180254:          /* Originally, this is how many times we CAN jump.  */
180319:          if (mcnt)
180339:            {
180353:               mcnt--;
180376:               STORE_NUMBER (p + 2, mcnt);
180419:	       goto unconditional_jump;	     
180458:            }
180472:          /* If don't have to jump any more, skip over the rest of command.  */
180552:	  else      
180566:	    p += 4;		     
180586:          break;
180603:        
180612:	case set_number_at:
180633:	  {
180638:            DEBUG_PRINT1 ("EXECUTING set_number_at.\n");
180695:
180696:            EXTRACT_NUMBER_AND_INCR (mcnt, p);
180743:            p1 = p + mcnt;
180770:            EXTRACT_NUMBER_AND_INCR (mcnt, p);
180817:            DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p1, mcnt);
180881:	    STORE_NUMBER (p1, mcnt);
180911:            break;
180930:          }
180942:
180943:        case wordbound:
180967:          DEBUG_PRINT1 ("EXECUTING wordbound.\n");
181018:          if (AT_WORD_BOUNDARY (d))
181054:	    break;
181066:          goto fail;
181087:
181088:	case notwordbound:
181108:          DEBUG_PRINT1 ("EXECUTING notwordbound.\n");
181162:	  if (AT_WORD_BOUNDARY (d))
181191:	    goto fail;
181207:          break;
181224:
181225:	case wordbeg:
181240:          DEBUG_PRINT1 ("EXECUTING wordbeg.\n");
181289:	  if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))
181359:	    break;
181371:          goto fail;
181392:
181393:	case wordend:
181408:          DEBUG_PRINT1 ("EXECUTING wordend.\n");
181457:	  if (!AT_STRINGS_BEG (d) && WORDCHAR_P (d - 1)
181506:              && (!WORDCHAR_P (d) || AT_STRINGS_END (d)))
181564:	    break;
181576:          goto fail;
181597:
181598:#ifdef emacs
181611:#ifdef emacs19
181626:  	case before_dot:
181646:          DEBUG_PRINT1 ("EXECUTING before_dot.\n");
181698: 	  if (PTR_CHAR_POS ((unsigned char *) d) >= point)
181751:  	    goto fail;
181769:  	  break;
181781:  
181784:  	case at_dot:
181800:          DEBUG_PRINT1 ("EXECUTING at_dot.\n");
181848: 	  if (PTR_CHAR_POS ((unsigned char *) d) != point)
181901:  	    goto fail;
181919:  	  break;
181931:  
181934:  	case after_dot:
181953:          DEBUG_PRINT1 ("EXECUTING after_dot.\n");
182004:          if (PTR_CHAR_POS ((unsigned char *) d) <= point)
182063:  	    goto fail;
182081:  	  break;
182093:#else /* not emacs19 */
182117:	case at_dot:
182131:          DEBUG_PRINT1 ("EXECUTING at_dot.\n");
182179:	  if (PTR_CHAR_POS ((unsigned char *) d) + 1 != point)
182235:	    goto fail;
182251:	  break;
182261:#endif /* not emacs19 */
182286:
182287:	case syntaxspec:
182305:          DEBUG_PRINT2 ("EXECUTING syntaxspec %d.\n", mcnt);
182366:	  mcnt = *p++;
182382:	  goto matchsyntax;
182403:
182404:        case wordchar:
182427:          DEBUG_PRINT1 ("EXECUTING Emacs wordchar.\n");
182483:	  mcnt = (int) Sword;
182506:        matchsyntax:
182527:	  PREFETCH ();
182543:	  if (SYNTAX (*d++) != (enum syntaxcode) mcnt)
182591:            goto fail;
182614:          SET_REGS_MATCHED ();
182645:	  break;
182655:
182656:	case notsyntaxspec:
182677:          DEBUG_PRINT2 ("EXECUTING notsyntaxspec %d.\n", mcnt);
182741:	  mcnt = *p++;
182757:	  goto matchnotsyntax;
182781:
182782:        case notwordchar:
182808:          DEBUG_PRINT1 ("EXECUTING Emacs notwordchar.\n");
182867:	  mcnt = (int) Sword;
182890:        matchnotsyntax:
182914:	  PREFETCH ();
182930:	  if (SYNTAX (*d++) == (enum syntaxcode) mcnt)
182978:            goto fail;
183001:	  SET_REGS_MATCHED ();
183025:          break;
183042:
183043:#else /* not emacs */
183065:	case wordchar:
183081:          DEBUG_PRINT1 ("EXECUTING non-Emacs wordchar.\n");
183141:	  PREFETCH ();
183157:          if (!WORDCHAR_P (d))
183188:            goto fail;
183211:	  SET_REGS_MATCHED ();
183235:          d++;
183250:	  break;
183260:	  
183264:	case notwordchar:
183283:          DEBUG_PRINT1 ("EXECUTING non-Emacs notwordchar.\n");
183346:	  PREFETCH ();
183362:	  if (WORDCHAR_P (d))
183385:            goto fail;
183408:          SET_REGS_MATCHED ();
183439:          d++;
183454:	  break;
183464:#endif /* not emacs */
183487:          
183498:        default:
183515:          abort ();
183535:	}
183538:      continue;  /* Successfully executed one pattern command; keep going.  */
183617:
183618:
183619:    /* We goto here if a matching operation fails. */
183673:    fail:
183683:      if (!FAIL_STACK_EMPTY ())
183715:	{ /* A restart point is known.  Restore to that state.  */
183775:          DEBUG_PRINT1 ("\nFAIL:\n");
183813:          POP_FAILURE_POINT (d, p,
183848:                             lowest_active_reg, highest_active_reg,
183916:                             regstart, regend, reg_info);
183974:
183975:          /* If this failure point is a dummy, try the next one.  */
184044:          if (!p)
184062:	    goto fail;
184078:
184079:          /* If we failed to the end of the pattern, don't examine *p.  */
184154:	  assert (p <= pend);
184177:          if (p < pend)
184201:            {
184215:              boolean is_a_jump_n = false;
184258:              
184273:              /* If failed to a backwards jump that's part of a repetition
184348:                 loop, need to pop this failure point and use the next one.  */
184428:              switch ((re_opcode_t) *p)
184468:                {
184486:                case jump_n:
184515:                  is_a_jump_n = true;
184553:                case maybe_pop_jump:
184590:                case pop_failure_jump:
184629:                case jump:
184656:                  p1 = p + 1;
184686:                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
184740:                  p1 += mcnt;	
184771:
184772:                  if ((is_a_jump_n && (re_opcode_t) *p1 == succeed_n)
184842:                      || (!is_a_jump_n
184881:                          && (re_opcode_t) *p1 == on_failure_jump))
184949:                    goto fail;
184980:                  break;
185005:                default:
185030:                  /* do nothing */ ;
185067:                }
185085:            }
185099:
185100:          if (d >= string1 && d <= end1)
185141:	    dend = end_match_1;
185166:        }
185176:      else
185187:        break;   /* Matching at this starting point really fails.  */
185257:    } /* for (;;) */
185278:
185279:  if (best_regs_set)
185300:    goto restore_best_regs;
185328:
185329:  FREE_VARIABLES ();
185350:
185351:  return -1;         			/* Failure to match.  */
185400:} /* re_match_2 */
185419:
185421:/* Subroutine definitions for re_match_2.  */
185467:
185468:
185469:/* We are passed P pointing to a register number after a start_memory.
185540:   
185544:   Return true if the pattern up to the corresponding stop_memory can
185614:   match the empty string, and false otherwise.
185662:   
185666:   If we find the matching stop_memory, sets P to point to one past its number.
185746:   Otherwise, sets P to an undefined byte less than or equal to END.
185815:
185816:   We don't handle duplicates properly (yet).  */
185866:
185867:static boolean
185882:group_match_null_string_p (p, end, reg_info)
185927:    unsigned char **p, *end;
185956:    register_info_type *reg_info;
185990:{
185992:  int mcnt;
186004:  /* Point to after the args to the start_memory.  */
186058:  unsigned char *p1 = *p + 2;
186088:  
186091:  while (p1 < end)
186110:    {
186116:      /* Skip over opcodes that can match nothing, and return true or
186186:	 false, as appropriate, when we get to one that can't, or to the
186252:         matching stop_memory.  */
186287:      
186294:      switch ((re_opcode_t) *p1)
186327:        {
186337:        /* Could be either a loop or a series of alternatives.  */
186404:        case on_failure_jump:
186434:          p1++;
186450:          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
186496:          
186507:          /* If the next operation is not a jump backwards in the
186573:	     pattern.  */
186592:
186593:	  if (mcnt >= 0)
186611:	    {
186618:              /* Go through the on_failure_jumps of the alternatives,
186688:                 seeing if any of the alternatives cannot match nothing.
186761:                 The last alternative starts with only a jump,
186824:                 whereas the rest start with on_failure_jump and end
186893:                 with a jump, e.g., here is the pattern for `a|b|c':
186962:
186963:                 /on_failure_jump/0/6/exactn/1/a/jump_past_alt/0/6
187030:                 /on_failure_jump/0/6/exactn/1/b/jump_past_alt/0/3
187097:                 /exactn/1/c						
187132:
187133:                 So, we have to first go through the first (n-1)
187198:                 alternatives and then deal with the last one separately.  */
187276:
187277:
187278:              /* Deal with the first (n-1) alternatives, which start
187347:                 with an on_failure_jump (see above) that jumps to right
187420:                 past a jump_past_alt.  */
187463:
187464:              while ((re_opcode_t) p1[mcnt-3] == jump_past_alt)
187528:                {
187546:                  /* `mcnt' holds how many bytes long the alternative
187616:                     is, including the ending `jump_past_alt' and
187682:                     its number.  */
187719:
187720:                  if (!alt_match_null_string_p (p1, p1 + mcnt - 3, 
187788:				                      reg_info))
187825:                    return false;
187859:
187860:                  /* Move to right after this alternative, including the
187933:		     jump_past_alt.  */
187959:                  p1 += mcnt;	
187990:
187991:                  /* Break if it's the beginning of an n-th alternative
188063:                     that doesn't begin with an on_failure_jump.  */
188132:                  if ((re_opcode_t) *p1 != on_failure_jump)
188192:                    break;
188219:		
188222:		  /* Still have to check that it's not an n-th
188271:		     alternative that starts with an on_failure_jump.  */
188331:		  p1++;
188341:                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
188395:                  if ((re_opcode_t) p1[mcnt-3] != jump_past_alt)
188460:                    {
188482:		      /* Get to the beginning of the n-th alternative.  */
188543:                      p1 -= 3;
188574:                      break;
188603:                    }
188625:                }
188643:
188644:              /* Deal with the last alternative: go back and get number
188716:                 of the `jump_past_alt' just before it.  `mcnt' contains
188789:                 the length of the alternative.  */
188841:              EXTRACT_NUMBER (mcnt, p1 - 2);
188886:
188887:              if (!alt_match_null_string_p (p1, p1 + mcnt, reg_info))
188957:                return false;
188987:
188988:              p1 += mcnt;	/* Get past the n-th alternative.  */
189052:            } /* if mcnt > 0 */
189084:          break;
189101:
189102:          
189113:        case stop_memory:
189139:	  assert (p1[1] == **p);
189165:          *p = p1 + 2;
189188:          return true;
189211:
189212:        
189221:        default: 
189239:          if (!common_op_match_null_string_p (&p1, end, reg_info))
189306:            return false;
189332:        }
189342:    } /* while p1 < end */
189369:
189370:  return false;
189386:} /* group_match_null_string_p */
189420:
189421:
189422:/* Similar to group_match_null_string_p, but doesn't deal with alternatives:
189499:   It expects P to be the first byte of a single alternative and END one
189572:   byte past the last. The alternative can contain groups.  */
189635:   
189639:static boolean
189654:alt_match_null_string_p (p, end, reg_info)
189697:    unsigned char *p, *end;
189725:    register_info_type *reg_info;
189759:{
189761:  int mcnt;
189773:  unsigned char *p1 = p;
189798:  
189801:  while (p1 < end)
189820:    {
189826:      /* Skip over opcodes that can match nothing, and break when we get 
189900:         to one that can't.  */
189932:      
189939:      switch ((re_opcode_t) *p1)
189972:        {
189982:	/* It's a loop.  */
190003:        case on_failure_jump:
190033:          p1++;
190049:          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
190095:          p1 += mcnt;
190117:          break;
190134:          
190145:	default: 
190156:          if (!common_op_match_null_string_p (&p1, end, reg_info))
190223:            return false;
190249:        }
190259:    }  /* while p1 < end */
190287:
190288:  return true;
190303:} /* alt_match_null_string_p */
190335:
190336:
190337:/* Deals with the ops common to group_match_null_string_p and
190399:   alt_match_null_string_p.  
190429:   
190433:   Sets P to one after the op and its arguments, if any.  */
190494:
190495:static boolean
190510:common_op_match_null_string_p (p, end, reg_info)
190559:    unsigned char **p, *end;
190588:    register_info_type *reg_info;
190622:{
190624:  int mcnt;
190636:  boolean ret;
190651:  int reg_no;
190665:  unsigned char *p1 = *p;
190691:
190692:  switch ((re_opcode_t) *p1++)
190723:    {
190729:    case no_op:
190745:    case begline:
190763:    case endline:
190781:    case begbuf:
190798:    case endbuf:
190815:    case wordbeg:
190833:    case wordend:
190851:    case wordbound:
190871:    case notwordbound:
190894:#ifdef emacs
190907:    case before_dot:
190928:    case at_dot:
190945:    case after_dot:
190965:#endif
190972:      break;
190985:
190986:    case start_memory:
191009:      reg_no = *p1;
191029:      assert (reg_no > 0 && reg_no <= MAX_REGNUM);
191080:      ret = group_match_null_string_p (&p1, end, reg_info);
191140:      
191147:      /* Have to set this here in case we're checking a group which
191215:         contains a group and a back reference to it.  */
191273:
191274:      if (REG_MATCH_NULL_STRING_P (reg_info[reg_no]) == MATCH_NULL_UNSET_VALUE)
191354:        REG_MATCH_NULL_STRING_P (reg_info[reg_no]) = ret;
191412:
191413:      if (!ret)
191429:        return false;
191451:      break;
191464:          
191475:    /* If this is an optimized succeed_n for zero times, make the jump.  */
191551:    case jump:
191566:      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
191608:      if (mcnt >= 0)
191629:        p1 += mcnt;
191649:      else
191660:        return false;
191682:      break;
191695:
191696:    case succeed_n:
191716:      /* Get to the number of times to succeed.  */
191768:      p1 += 2;		
191785:      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
191827:
191828:      if (mcnt == 0)
191849:        {
191859:          p1 -= 4;
191878:          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
191924:          p1 += mcnt;
191946:        }
191956:      else
191967:        return false;
191989:      break;
192002:
192003:    case duplicate: 
192024:      if (!REG_MATCH_NULL_STRING_P (reg_info[*p1]))
192076:        return false;
192098:      break;
192111:
192112:    case set_number_at:
192136:      p1 += 4;
192151:
192152:    default:
192165:      /* All other opcodes mean we cannot match the empty string.  */
192235:      return false;
192255:  }
192259:
192260:  *p = p1;
192271:  return true;
192286:} /* common_op_match_null_string_p */
192324:
192325:
192326:/* Return zero if TRANSLATE[S1] and TRANSLATE[S2] are identical for LEN
192398:   bytes; nonzero otherwise.  */
192431:   
192435:static int
192446:bcmp_translate (s1, s2, len, translate)
192486:     unsigned char *s1, *s2;
192515:     register int len;
192538:     char *translate;
192560:{
192562:  register unsigned char *p1 = s1, *p2 = s2;
192607:  while (len)
192621:    {
192627:      if (translate[*p1++] != translate[*p2++]) return 1;
192685:      len--;
192698:    }
192704:  return 0;
192716:}
192718:
192720:/* Entry points for GNU code.  */
192754:
192755:/* re_compile_pattern is the GNU regular expression compiler: it
192820:   compiles PATTERN (of length SIZE) and puts the result in BUFP.
192886:   Returns 0 if the pattern was valid, otherwise an error string.
192952:   
192956:   Assumes the `allocated' (and perhaps `buffer') and `translate' fields
193029:   are set in BUFP on entry.
193058:   
193062:   We call regex_compile to do the actual compilation.  */
193121:
193122:const char *
193135:re_compile_pattern (pattern, length, bufp)
193178:     const char *pattern;
193204:     int length;
193221:     struct re_pattern_buffer *bufp;
193258:{
193260:  reg_errcode_t ret;
193281:  
193284:  /* GNU code is written to assume at least RE_NREGS registers will be set
193359:     (and at least one extra will be -1).  */
193405:  bufp->regs_allocated = REGS_UNALLOCATED;
193448:  
193451:  /* And GNU code determines whether or not to get register information
193523:     by passing null for the REGS argument to re_match, etc., not by
193592:     setting no_sub.  */
193617:  bufp->no_sub = 0;
193637:  
193640:  /* Match anchors at newline.  */
193675:  bufp->newline_anchor = 1;
193703:  
193706:  ret = regex_compile (pattern, length, re_syntax_options, bufp);
193772:
193773:  return re_error_msg[(int) ret];
193807:}     
193814:
193816:/* Entry points compatible with 4.2 BSD regex library.  We don't define
193888:   them if this is an Emacs or POSIX compilation.  */
193942:
193943:#if !defined (emacs) && !defined (_POSIX_SOURCE)
193992:
193993:/* BSD has one and only one pattern buffer.  */
194041:static struct re_pattern_buffer re_comp_buf;
194086:
194087:char *
194094:re_comp (s)
194106:    const char *s;
194125:{
194127:  reg_errcode_t ret;
194148:  
194151:  if (!s)
194161:    {
194167:      if (!re_comp_buf.buffer)
194198:	return "No previous regular expression";
194240:      return 0;
194256:    }
194262:
194263:  if (!re_comp_buf.buffer)
194290:    {
194296:      re_comp_buf.buffer = (unsigned char *) malloc (200);
194355:      if (re_comp_buf.buffer == NULL)
194393:        return "Memory exhausted";
194428:      re_comp_buf.allocated = 200;
194463:
194464:      re_comp_buf.fastmap = (char *) malloc (1 << BYTEWIDTH);
194526:      if (re_comp_buf.fastmap == NULL)
194565:	return "Memory exhausted";
194593:    }
194599:
194600:  /* Since `re_exec' always passes NULL for the `regs' argument, we
194668:     don't need to initialize the pattern buffer fields which affect it.  */
194745:
194746:  /* Match anchors at newlines.  */
194782:  re_comp_buf.newline_anchor = 1;
194816:
194817:  ret = regex_compile (s, strlen (s), re_syntax_options, &re_comp_buf);
194889:  
194892:  /* Yes, we're discarding `const' here.  */
194937:  return (char *) re_error_msg[(int) ret];
194980:}
194982:
194983:
194984:int
194988:re_exec (s)
195000:    const char *s;
195019:{
195021:  const int len = strlen (s);
195051:  return
195060:    0 <= re_search (&re_comp_buf, s, len, 0, len, (struct re_registers *) 0);
195138:}
195140:#endif /* not emacs and not _POSIX_SOURCE */
195185:
195187:/* POSIX.2 functions.  Don't define these for Emacs.  */
195244:
195245:#ifndef emacs
195259:
195260:/* regcomp takes a regular expression as a string and compiles it.
195327:
195328:   PREG is a regex_t *.  We do not expect any fields to be initialized,
195400:   since POSIX says we shouldn't.  Thus, we set
195448:
195449:     `buffer' to the compiled pattern;
195488:     `used' to the length of the compiled pattern;
195539:     `syntax' to RE_SYNTAX_POSIX_EXTENDED if the
195588:       REG_EXTENDED bit in CFLAGS is set; otherwise, to
195644:       RE_SYNTAX_POSIX_BASIC;
195674:     `newline_anchor' to REG_NEWLINE being set in CFLAGS;
195732:     `fastmap' and `fastmap_accurate' to zero;
195779:     `re_nsub' to the number of subexpressions in PATTERN.
195838:
195839:   PATTERN is the address of the pattern string.
195888:
195889:   CFLAGS is a series of bits which affect compilation.
195945:
195946:     If REG_EXTENDED is set, we use POSIX extended syntax; otherwise, we
196019:     use POSIX basic syntax.
196048:
196049:     If REG_NEWLINE is set, then . and [^...] don't match newline.
196116:     Also, regexec will try a match beginning after every newline.
196183:
196184:     If REG_ICASE is set, then we considers upper- and lowercase
196249:     versions of letters to be equivalent when matching.
196306:
196307:     If REG_NOSUB is set, then when PREG is passed to regexec, that
196375:     routine will report only success or failure, and nothing about the
196447:     registers.
196463:
196464:   It returns 0 if it succeeds, nonzero if it doesn't.  (See regex.h for
196537:   the return codes and their meanings.)  */
196582:
196583:int
196587:regcomp (preg, pattern, cflags)
196619:    regex_t *preg;
196638:    const char *pattern; 
196664:    int cflags;
196680:{
196682:  reg_errcode_t ret;
196703:  unsigned syntax
196721:    = (cflags & REG_EXTENDED) ?
196753:      RE_SYNTAX_POSIX_EXTENDED : RE_SYNTAX_POSIX_BASIC;
196809:
196810:  /* regex_compile will allocate the space for the compiled pattern.  */
196883:  preg->buffer = 0;
196903:  preg->allocated = 0;
196926:  preg->used = 0;
196944:  
196947:  /* Don't bother to use a fastmap when searching.  This simplifies the
197019:     REG_NEWLINE case: if we used a fastmap, we'd have to put all the
197089:     characters after newlines into the fastmap.  This way, we just try
197161:     every character.  */
197187:  preg->fastmap = 0;
197208:  
197211:  if (cflags & REG_ICASE)
197237:    {
197243:      unsigned i;
197261:      
197268:      preg->translate = (char *) malloc (CHAR_SET_SIZE);
197325:      if (preg->translate == NULL)
197360:        return (int) REG_ESPACE;
197393:
197394:      /* Map uppercase characters to corresponding lowercase ones.  */
197465:      for (i = 0; i < CHAR_SET_SIZE; i++)
197507:        preg->translate[i] = ISUPPER (i) ? tolower (i) : i;
197567:    }
197573:  else
197580:    preg->translate = NULL;
197608:
197609:  /* If REG_NEWLINE is set, newlines are treated differently.  */
197675:  if (cflags & REG_NEWLINE)
197703:    { /* REG_NEWLINE implies neither . nor [^...] match newline.  */
197772:      syntax &= ~RE_DOT_NEWLINE;
197805:      syntax |= RE_HAT_LISTS_NOT_NEWLINE;
197847:      /* It also changes the matching behavior.  */
197899:      preg->newline_anchor = 1;
197931:    }
197937:  else
197944:    preg->newline_anchor = 0;
197974:
197975:  preg->no_sub = !!(cflags & REG_NOSUB);
198016:
198017:  /* POSIX says a null character in the pattern terminates it, so we 
198087:     can use strlen here in compiling the pattern.  */
198142:  ret = regex_compile (pattern, strlen (pattern), syntax, preg);
198207:  
198210:  /* POSIX doesn't distinguish between an unmatched open-group and an
198280:     unmatched close-group: both are REG_EPAREN.  */
198333:  if (ret == REG_ERPAREN) ret = REG_EPAREN;
198377:  
198380:  return (int) ret;
198400:}
198402:
198403:
198404:/* regexec searches for a given pattern, specified by PREG, in the
198471:   string STRING.
198489:   
198493:   If NMATCH is zero or REG_NOSUB was set in the cflags argument to
198561:   `regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at
198629:   least NMATCH elements, and we set them to the offsets of the
198693:   corresponding matched substrings.
198730:   
198734:   EFLAGS specifies `execution flags' which affect matching: if
198798:   REG_NOTBOL is set, then ^ does not match at the beginning of the
198866:   string; if REG_NOTEOL is set, then $ does not match at the end.
198933:   
198937:   We return 0 if we find a match and REG_NOMATCH if not.  */
198999:
199000:int
199004:regexec (preg, string, nmatch, pmatch, eflags)
199051:    const regex_t *preg;
199076:    const char *string; 
199101:    size_t nmatch; 
199121:    regmatch_t pmatch[]; 
199147:    int eflags;
199163:{
199165:  int ret;
199176:  struct re_registers regs;
199204:  regex_t private_preg;
199228:  int len = strlen (string);
199257:  boolean want_reg_info = !preg->no_sub && nmatch > 0;
199312:
199313:  private_preg = *preg;
199337:  
199340:  private_preg.not_bol = !!(eflags & REG_NOTBOL);
199390:  private_preg.not_eol = !!(eflags & REG_NOTEOL);
199440:  
199443:  /* The user has told us exactly how many registers to return
199506:     information about, via `nmatch'.  We have to pass that on to the
199576:     matching routines.  */
199604:  private_preg.regs_allocated = REGS_FIXED;
199648:  
199651:  if (want_reg_info)
199672:    {
199678:      regs.num_regs = nmatch;
199708:      regs.start = TALLOC (nmatch, regoff_t);
199754:      regs.end = TALLOC (nmatch, regoff_t);
199798:      if (regs.start == NULL || regs.end == NULL)
199848:        return (int) REG_NOMATCH;
199882:    }
199888:
199889:  /* Perform the searching operation.  */
199931:  ret = re_search (&private_preg, string, len,
199978:                   /* start: */ 0, /* range: */ len,
200031:                   want_reg_info ? &regs : (struct re_registers *) 0);
200102:  
200105:  /* Copy the register information to the POSIX structure.  */
200168:  if (want_reg_info)
200189:    {
200195:      if (ret >= 0)
200215:        {
200225:          unsigned r;
200247:
200248:          for (r = 0; r < nmatch; r++)
200287:            {
200301:              pmatch[r].rm_so = regs.start[r];
200348:              pmatch[r].rm_eo = regs.end[r];
200393:            }
200407:        }
200417:
200418:      /* If we needed the temporary register info, free the space now.  */
200493:      free (regs.start);
200518:      free (regs.end);
200541:    }
200547:
200548:  /* We want zero return to mean success, unlike `re_search'.  */
200614:  return ret >= 0 ? (int) REG_NOERROR : (int) REG_NOMATCH;
200673:}
200675:
200676:
200677:/* Returns a message corresponding to an error code, ERRCODE, returned
200748:   from either regcomp or regexec.   We don't use PREG here.  */
200813:
200814:size_t
200821:regerror (errcode, preg, errbuf, errbuf_size)
200867:    int errcode;
200884:    const regex_t *preg;
200909:    char *errbuf;
200927:    size_t errbuf_size;
200951:{
200953:  const char *msg;
200972:  size_t msg_size;
200991:
200992:  if (errcode < 0
201010:      || errcode >= (sizeof (re_error_msg) / sizeof (re_error_msg[0])))
201082:    /* Only error codes returned by the rest of the code should be passed 
201157:       to this routine.  If we are given anything else, or if other regex
201231:       code generates an invalid error code, then the program has a bug.
201304:       Dump core so we can fix it.  */
201343:    abort ();
201357:
201358:  msg = re_error_msg[errcode];
201389:
201390:  /* POSIX doesn't require that we do anything in this case, but why
201459:     not be nice.  */
201481:  if (! msg)
201494:    msg = "Success";
201515:
201573:  
201576:  if (errbuf_size != 0)
201600:    {
201606:      if (msg_size > errbuf_size)
201640:        {
201650:          strncpy (errbuf, msg, errbuf_size - 1);
201700:          errbuf[errbuf_size - 1] = 0;
201739:        }
201749:      else
201760:        strcpy (errbuf, msg);
201790:    }
201796:
201797:  return msg_size;
201816:}
201818:
201819:
201820:/* Free dynamically allocated space used by PREG.  */
201874:
201875:void
201880:regfree (preg)
201895:    regex_t *preg;
201914:{
201916:  if (preg->buffer != NULL)
201944:    free (preg->buffer);
201969:  preg->buffer = NULL;
201992:  
201995:  preg->allocated = 0;
202018:  preg->used = 0;
202036:
202037:  if (preg->fastmap != NULL)
202066:    free (preg->fastmap);
202092:  preg->fastmap = NULL;
202116:  preg->fastmap_accurate = 0;
202146:
202147:  if (preg->translate != NULL)
202178:    free (preg->translate);
202206:  preg->translate = NULL;
202232:}
202234:
202235:#endif /* not emacs  */
202259:
202261:/*
202264:Local variables:
202281:make-backup-files: t
202302:version-control: t
202321:trim-versions-without-asking: nil
202355:End:
202360:*/
202363:/* dfa.c - deterministic extended regexp routines for GNU
202421:   Copyright (C) 1988 Free Software Foundation, Inc.
202474:
202475:   This program is free software; you can redistribute it and/or modify
202547:   it under the terms of the GNU General Public License as published by
202619:   the Free Software Foundation; either version 2, or (at your option)
202690:   any later version.
202712:
202713:   This program is distributed in the hope that it will be useful,
202780:   but WITHOUT ANY WARRANTY; without even the implied warranty of
202846:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
202911:   GNU General Public License for more details.
202959:
202960:   You should have received a copy of the GNU General Public License
203029:   along with this program; if not, write to the Free Software
203092:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
203157:
203158:/* Written June, 1988 by Mike Haertel
203196:   Modified July, 1988 by Arthur David Olson to assist BMG speedups  */
203268:
203342:
203343:#ifdef STDC_HEADERS
203363:#if flag_stdlib==0
203402:#define flag_stdlib 1
203424:#endif
203431:#else
203437:#if flag_systypes==0 
203482:#define flag_systypes 1
203506:#endif
203513:extern char *calloc(), *malloc(), *realloc();
203559:extern void free();
203579:#endif
203586:
203587:#if defined(HAVE_STRING_H) || defined(STDC_HEADERS)
203639:#if flag_string==0
203678:#define flag_string 1
203700:#endif
203707:#undef index
203720:#define index strchr
203741:#else
203747:#if flag_strings==0
203788:#define flag_strings 1
203811:#endif
203818:#endif
203825:
203826:#ifndef isgraph
203842:#define isgraph(C) (isprint(C) && !isspace(C))
203889:#endif
203896:
203897:#undef ISALPHA
203912:#undef ISUPPER
203927:#undef ISLOWER
203942:#undef ISDIGIT
203957:#undef ISXDIGIT
203973:#undef ISSPACE
203988:#undef ISPUNCT
204003:#undef ISALNUM
204018:#undef ISPRINT
204033:#undef ISGRAPH
204048:#undef ISCNTRL
204063:
204064:
204065:#ifdef isascii
204080:#define ISALPHA(C) (isascii(C) && isalpha(C))
204126:#define ISUPPER(C) (isascii(C) && isupper(C))
204172:#define ISLOWER(C) (isascii(C) && islower(C))
204218:#define ISDIGIT(C) (isascii(C) && isdigit(C))
204264:#define ISXDIGIT(C) (isascii(C) && isxdigit(C))
204312:#define ISSPACE(C) (isascii(C) && isspace(C))
204358:#define ISPUNCT(C) (isascii(C) && ispunct(C))
204404:#define ISALNUM(C) (isascii(C) && isalnum(C))
204450:#define ISPRINT(C) (isascii(C) && isprint(C))
204496:#define ISGRAPH(C) (isascii(C) && isgraph(C))
204542:#define ISCNTRL(C) (isascii(C) && iscntrl(C))
204588:#else
204594:#define ISALPHA(C) isalpha(C)
204624:#define ISUPPER(C) isupper(C)
204654:#define ISLOWER(C) islower(C)
204684:#define ISDIGIT(C) isdigit(C)
204714:#define ISXDIGIT(C) isxdigit(C)
204746:#define ISSPACE(C) isspace(C)
204776:#define ISPUNCT(C) ispunct(C)
204806:#define ISALNUM(C) isalnum(C)
204836:#define ISPRINT(C) isprint(C)
204866:#define ISGRAPH(C) isgraph(C)
204896:#define ISCNTRL(C) iscntrl(C)
204926:#endif
204933:
204974:
204975:#if __STDC__
204988:typedef void *ptr_t;
205009:#else
205015:typedef char *ptr_t;
205036:#endif
205043:
205044:static void	dfamust();
205067:
205068:static ptr_t
205081:xcalloc(n, s)
205095:     int n;
205107:     size_t s;
205122:{
205124:  ptr_t r = calloc(n, s);
205150:
205151:  if (!r)
205161:    dfaerror("Memory exhausted");
205195:  return r;
205207:}
205209:
205210:static ptr_t
205223:xmalloc_1(n)
205236:     size_t n;
205251:{
205253:  ptr_t r = malloc(n);
205276:
205277:  assert(n != 0);
205295:  if (!r)
205305:    dfaerror("Memory exhausted");
205339:  return r;
205351:}
205353:
205354:static ptr_t
205367:xrealloc_1(p, n)
205384:     ptr_t p;
205398:     size_t n;
205413:{
205415:  ptr_t r = realloc(p, n);
205442:
205443:  assert(n != 0);
205461:  if (!r)
205471:    dfaerror("Memory exhausted");
205505:  return r;
205517:}
205519:
205520:#define CALLOC(p, t, n) ((p) = (t *) xcalloc((n), sizeof (t)))
205583:#define MALLOC(p, t, n) ((p) = (t *) xmalloc_1((n) * sizeof (t)))
205649:#define REALLOC(p, t, n) ((p) = (t *) xrealloc_1((ptr_t) (p), (n) * sizeof (t)))
205730:
205731:/* Reallocate an array of type t if nalloc is too small for index. */
205801:#define REALLOC_IF_NECESSARY(p, t, nalloc, index) \
205853:  if ((index) >= (nalloc))			  \
205886:    {						  \
205901:      while ((index) >= (nalloc))		  \
205940:	(nalloc) *= 2;				  \
205963:      REALLOC(p, t, nalloc);			  \
205998:    }
206004:
206005:#ifdef DEBUG
206018:
206019:static void
206031:prtok(t)
206040:     token t;
206054:{
206056:  char *s;
206067:
206068:  if (t < 0)
206081:    fprintf(stderr, "END");
206109:  else if (t < NOTCHAR)
206133:    fprintf(stderr, "%c", t);
206163:  else
206170:    {
206176:      switch (t)
206193:	{
206196:	case EMPTY: s = "EMPTY"; break;
206229:	case BACKREF: s = "BACKREF"; break;
206266:	case BEGLINE: s = "BEGLINE"; break;
206303:	case ENDLINE: s = "ENDLINE"; break;
206340:	case BEGWORD: s = "BEGWORD"; break;
206377:	case ENDWORD: s = "ENDWORD"; break;
206414:	case LIMWORD: s = "LIMWORD"; break;
206451:	case NOTLIMWORD: s = "NOTLIMWORD"; break;
206494:	case QMARK: s = "QMARK"; break;
206527:	case STAR: s = "STAR"; break;
206558:	case PLUS: s = "PLUS"; break;
206589:	case CAT: s = "CAT"; break;
206618:	case OR: s = "OR"; break;
206645:	case ORTOP: s = "ORTOP"; break;
206678:	case LPAREN: s = "LPAREN"; break;
206713:	case RPAREN: s = "RPAREN"; break;
206748:	default: s = "CSET"; break;
206777:	}
206780:      fprintf(stderr, "%s", s);
206812:    }
206818:}
206820:#endif /* DEBUG */
206839:
206840:/* Stuff pertaining to charclasses. */
206879:
206880:static int
206891:tstbit(b, c)
206904:     int b;
206916:     charclass c;
206934:{
206936:  return c[b / INTBITS] & 1 << b % INTBITS;
206980:}
206982:
206983:static void
206995:setbit(b, c)
207008:     int b;
207020:     charclass c;
207038:{
207040:  c[b / INTBITS] |= 1 << b % INTBITS;
207078:}
207080:
207081:static void
207093:clrbit(b, c)
207106:     int b;
207118:     charclass c;
207136:{
207138:  c[b / INTBITS] &= ~(1 << b % INTBITS);
207179:}
207181:
207182:static void
207194:copyset(src, dst)
207212:     charclass src;
207232:     charclass dst;
207252:{
207254:  int i;
207263:
207264:  for (i = 0; i < CHARCLASS_INTS; ++i)
207303:    dst[i] = src[i];
207324:}
207326:
207327:static void
207339:zeroset(s)
207350:     charclass s;
207368:{
207370:  int i;
207379:
207380:  for (i = 0; i < CHARCLASS_INTS; ++i)
207419:    s[i] = 0;
207433:}
207435:
207436:static void
207448:notset(s)
207458:     charclass s;
207476:{
207478:  int i;
207487:
207488:  for (i = 0; i < CHARCLASS_INTS; ++i)
207527:    s[i] = ~s[i];
207545:}
207547:
207548:static int
207559:equal(s1, s2)
207573:     charclass s1;
207592:     charclass s2;
207611:{
207613:  int i;
207622:
207623:  for (i = 0; i < CHARCLASS_INTS; ++i)
207662:    if (s1[i] != s2[i])
207686:      return 0;
207702:  return 1;
207714:}
207716:
207717:/* A pointer to the current dfa is kept here during parsing. */
207781:static struct dfa *dfa;
207805:
207806:/* Find the index of charclass s in dfa->charclasses, or allocate a new charclass. */
207892:static int
207903:charclass_index(s)
207922:     charclass s;
207940:{
207942:  int i;
207951:
207952:  for (i = 0; i < dfa->cindex; ++i)
207988:    if (equal(s, dfa->charclasses[i]))
208027:      return i;
208043:  REALLOC_IF_NECESSARY(dfa->charclasses, charclass, dfa->calloc, dfa->cindex);
208122:  ++dfa->cindex;
208139:  copyset(s, dfa->charclasses[i]);
208174:  return i;
208186:}
208188:
208189:/* Syntax bits controlling the behavior of the lexical analyzer. */
208257:static int syntax_bits, syntax_bits_set;
208298:
208299:/* Flag for case-folding letters into sets. */
208346:static int case_fold;
208368:
208369:/* Entry point to set syntax options. */
208410:void
208415:dfasyntax(bits, fold)
208437:     int bits;
208452:     int fold;
208467:{
208469:  syntax_bits_set = 1;
208492:  syntax_bits = bits;
208514:  case_fold = fold;
208534:}
208536:
208537:/* Lexical analyzer.  All the dross that deals with the obnoxious
208603:   GNU Regex syntax bits is located here.  The poor, suffering
208666:   reader is referred to the GNU Regex documentation for the
208727:   meaning of the @#%!@#%^!@ syntax bits. */
208772:
208773:static char *lexstart;		/* Pointer to beginning of input string. */
208841:static char *lexptr;		/* Pointer to next input character. */
208902:static lexleft;			/* Number of characters remaining. */
208958:static token lasttok;		/* Previous token returned; initially END. */
209027:static int laststart;		/* True if we're separated from beginning or (, |
209100:				   only by zero-width characters. */
209141:static int parens;		/* Count of outstanding left parens. */
209201:static int minrep, maxrep;	/* Repeat counts for {m,n}. */
209259:
209260:/* Note that characters become unsigned here. */
209309:#define FETCH(c, eoferr)   	      \
209345:  {			   	      \
209363:    if (! lexleft)	   	      \
209394:      if (eoferr != 0)	   	      \
209429:	dfaerror(eoferr);  	      \
209458:      else		   	      \
209482:	return END;	   	      \
209507:    (c) = (unsigned char) *lexptr++;  \
209547:    --lexleft;		   	      \
209575:  }
209579:
209580:#define FUNC(F, P) static int F(c) int c; { return P(c); }
209639:
209640:FUNC(is_alpha, ISALPHA)
209664:FUNC(is_upper, ISUPPER)
209688:FUNC(is_lower, ISLOWER)
209712:FUNC(is_digit, ISDIGIT)
209736:FUNC(is_xdigit, ISXDIGIT)
209762:FUNC(is_space, ISSPACE)
209786:FUNC(is_punct, ISPUNCT)
209810:FUNC(is_alnum, ISALNUM)
209834:FUNC(is_print, ISPRINT)
209858:FUNC(is_graph, ISGRAPH)
209882:FUNC(is_cntrl, ISCNTRL)
209906:
209907:/* The following list maps the names of the Posix named character classes
209981:   to predicate functions that determine whether a given character is in
210054:   the class.  The leading [ has already been eaten by the lexical analyzer. */
210134:static struct {
210150:  char *name;
210164:  int (*pred)();
210181:} prednames[] = {
210199:  ":alpha:]", is_alpha,
210223:  ":upper:]", is_upper,
210247:  ":lower:]", is_lower,
210271:  ":digit:]", is_digit,
210295:  ":xdigit:]", is_xdigit,
210321:  ":space:]", is_space,
210345:  ":punct:]", is_punct,
210369:  ":alnum:]", is_alnum,
210393:  ":print:]", is_print,
210417:  ":graph:]", is_graph,
210441:  ":cntrl:]", is_cntrl,
210465:  0
210469:};
210472:
210473:static int
210484:looking_at(s)
210498:     char *s;
210512:{
210514:  int len;
210525:
210526:  len = strlen(s);
210545:  if (lexleft < len)
210566:    return 0;
210580:  return strncmp(s, lexptr, len) == 0;
210619:}
210621:
210622:static token
210635:lex()
210641:{
210643:  token c, c1, c2;
210662:  int backslash = 0, invert;
210691:  charclass ccl;
210708:  int i;
210717:
210718:  /* Basic plan: We fetch a character.  If it's a backslash,
210779:     we set the backslash flag and go through the loop again.
210841:     On the plus side, this avoids having a duplicate of the
210902:     main switch inside the backslash case.  On the minus side,
210966:     it means that just about every case begins with
211019:     "if (backslash) ...".  */
211050:  for (i = 0; i < 2; ++i)
211076:    {
211082:      FETCH(c, 0);
211101:      switch (c)
211118:	{
211121:	case '\\':
211133:	  if (backslash)
211151:	    goto normal_char;
211174:	  if (lexleft == 0)
211195:	    dfaerror("Unfinished \\ escape");
211234:	  backslash = 1;
211252:	  break;
211262:
211263:	case '^':
211274:	  if (backslash)
211292:	    goto normal_char;
211315:	  if (syntax_bits & RE_CONTEXT_INDEP_ANCHORS
211361:	      || lasttok == END
211386:	      || lasttok == LPAREN
211414:	      || lasttok == OR)
211439:	    return lasttok = BEGLINE;
211470:	  goto normal_char;
211491:
211492:	case '$':
211503:	  if (backslash)
211521:	    goto normal_char;
211544:	  if (syntax_bits & RE_CONTEXT_INDEP_ANCHORS
211590:	      || lexleft == 0
211613:	      || (syntax_bits & RE_NO_BK_PARENS
211654:		  ? lexleft > 0 && *lexptr == ')'
211690:		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == ')')
211750:	      || (syntax_bits & RE_NO_BK_VBAR
211789:		  ? lexleft > 0 && *lexptr == '|'
211825:		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == '|')
211885:	      || ((syntax_bits & RE_NEWLINE_ALT)
211927:	          && lexleft > 0 && *lexptr == '\n'))
211974:	    return lasttok = ENDLINE;
212005:	  goto normal_char;
212026:
212027:	case '1':
212038:	case '2':
212049:	case '3':
212060:	case '4':
212071:	case '5':
212082:	case '6':
212093:	case '7':
212104:	case '8':
212115:	case '9':
212126:	  if (backslash && !(syntax_bits & RE_NO_BK_REFS))
212178:	    {
212185:	      laststart = 0;
212207:	      return lasttok = BACKREF;
212240:	    }
212247:	  goto normal_char;
212268:
212269:	case '<':
212280:	  if (backslash)
212298:	    return lasttok = BEGWORD;
212329:	  goto normal_char;
212350:
212351:	case '>':
212362:	  if (backslash)
212380:	    return lasttok = ENDWORD;
212411:	  goto normal_char;
212432:
212433:	case 'b':
212444:	  if (backslash)
212462:	    return lasttok = LIMWORD;
212493:	  goto normal_char;
212514:
212515:	case 'B':
212526:	  if (backslash)
212544:	    return lasttok = NOTLIMWORD;
212578:	  goto normal_char;
212599:
212600:	case '?':
212611:	  if (syntax_bits & RE_LIMITED_OPS)
212648:	    goto normal_char;
212671:	  if (backslash != ((syntax_bits & RE_BK_PLUS_QM) != 0))
212729:	    goto normal_char;
212752:	  if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)
212811:	    goto normal_char;
212834:	  return lasttok = QMARK;
212861:
212862:	case '*':
212873:	  if (backslash)
212891:	    goto normal_char;
212914:	  if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)
212973:	    goto normal_char;
212996:	  return lasttok = STAR;
213022:
213023:	case '+':
213034:	  if (syntax_bits & RE_LIMITED_OPS)
213071:	    goto normal_char;
213094:	  if (backslash != ((syntax_bits & RE_BK_PLUS_QM) != 0))
213152:	    goto normal_char;
213175:	  if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)
213234:	    goto normal_char;
213257:	  return lasttok = PLUS;
213283:
213284:	case '{':
213295:	  if (!(syntax_bits & RE_INTERVALS))
213333:	    goto normal_char;
213356:	  if (backslash != ((syntax_bits & RE_NO_BK_BRACES) == 0))
213416:	    goto normal_char;
213439:	  minrep = maxrep = 0;
213463:	  /* Cases:
213476:	     {M} - exact count
213500:	     {M,} - minimum count, maximum is infinity
213548:	     {,M} - 0 through M
213573:	     {M,N} - M through N */
213602:	  FETCH(c, "unfinished repeat count");
213642:	  if (ISDIGIT(c))
213661:	    {
213668:	      minrep = c - '0';
213693:	      for (;;)
213709:		{
213713:		  FETCH(c, "unfinished repeat count");
213754:		  if (!ISDIGIT(c))
213775:		    break;
213788:		  minrep = 10 * minrep + c - '0';
213824:		}
213828:	    }
213835:	  else if (c != ',')
213857:	    dfaerror("malformed repeat count");
213898:	  if (c == ',')
213915:	    for (;;)
213929:	      {
213938:		FETCH(c, "unfinished repeat count");
213977:		if (!ISDIGIT(c))
213996:		  break;
214007:		maxrep = 10 * maxrep + c - '0';
214041:	      }
214050:	  else
214058:	    maxrep = minrep;
214080:	  if (!(syntax_bits & RE_NO_BK_BRACES))
214121:	    {
214128:	      if (c != '\\')
214150:		dfaerror("malformed repeat count");
214188:	      FETCH(c, "unfinished repeat count");
214232:	    }
214239:	  if (c != '}')
214256:	    dfaerror("malformed repeat count");
214297:	  laststart = 0;
214315:	  return lasttok = REPMN;
214342:
214343:	case '|':
214354:	  if (syntax_bits & RE_LIMITED_OPS)
214391:	    goto normal_char;
214414:	  if (backslash != ((syntax_bits & RE_NO_BK_VBAR) == 0))
214472:	    goto normal_char;
214495:	  laststart = 1;
214513:	  return lasttok = OR;
214537:
214538:	case '\n':
214550:	  if (syntax_bits & RE_LIMITED_OPS
214586:	      || backslash
214606:	      || !(syntax_bits & RE_NEWLINE_ALT))
214649:	    goto normal_char;
214672:	  laststart = 1;
214690:	  return lasttok = OR;
214714:
214715:	case '(':
214726:	  if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))
214786:	    goto normal_char;
214809:	  ++parens;
214822:	  laststart = 1;
214840:	  return lasttok = LPAREN;
214868:
214869:	case ')':
214880:	  if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))
214940:	    goto normal_char;
214963:	  if (parens == 0 && syntax_bits & RE_UNMATCHED_RIGHT_PAREN_ORD)
215029:	    goto normal_char;
215052:	  --parens;
215065:	  laststart = 0;
215083:	  return lasttok = RPAREN;
215111:
215112:	case '.':
215123:	  if (backslash)
215141:	    goto normal_char;
215164:	  zeroset(ccl);
215181:	  notset(ccl);
215197:	  if (!(syntax_bits & RE_DOT_NEWLINE))
215237:	    clrbit('\n', ccl);
215261:	  if (syntax_bits & RE_DOT_NOT_NULL)
215299:	    clrbit('\0', ccl);
215323:	  laststart = 0;
215341:	  return lasttok = CSET + charclass_index(ccl);
215390:
215391:	case 'w':
215402:	case 'W':
215413:	  if (!backslash)
215432:	    goto normal_char;
215455:	  zeroset(ccl);
215472:	  for (c2 = 0; c2 < NOTCHAR; ++c2)
215508:	    if (ISALNUM(c2))
215530:	      setbit(c2, ccl);
215554:	  if (c == 'W')
215571:	    notset(ccl);
215589:	  laststart = 0;
215607:	  return lasttok = CSET + charclass_index(ccl);
215656:	
215658:	case '[':
215669:	  if (backslash)
215687:	    goto normal_char;
215710:	  zeroset(ccl);
215727:	  FETCH(c, "Unbalanced [");
215756:	  if (c == '^')
215773:	    {
215780:	      FETCH(c, "Unbalanced [");
215813:	      invert = 1;
215832:	    }
215839:	  else
215847:	    invert = 0;
215864:	  do
215870:	    {
215877:	      /* Nobody ever said this had to be fast. :-)
215929:		 Note that if we're looking at some other [:...:]
215981:		 construct, we just treat it as a bunch of ordinary
216035:		 characters.  We can do this because we assume
216084:		 regex has checked for syntax errors before
216130:		 dfa is ever called. */
216156:	      if (c == '[' && (syntax_bits & RE_CHAR_CLASSES))
216212:		for (c1 = 0; prednames[c1].name; ++c1)
216253:		  if (looking_at(prednames[c1].name))
216293:		    {
216301:		      for (c2 = 0; c2 < NOTCHAR; ++c2)
216342:			if ((*prednames[c1].pred)(c2))
216376:			  setbit(c2, ccl);
216398:		      lexptr += strlen(prednames[c1].name);
216444:		      lexleft -= strlen(prednames[c1].name);
216491:		      FETCH(c1, "Unbalanced [");
216526:		      goto skip;
216545:		    }
216553:	      if (c == '\\' && (syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))
216623:		FETCH(c, "Unbalanced [");
216651:	      FETCH(c1, "Unbalanced [");
216685:	      if (c1 == '-')
216707:		{
216711:		  FETCH(c2, "Unbalanced [");
216742:		  if (c2 == ']')
216761:		    {
216769:		      /* In the case [x-], the - is an ordinary hyphen,
216827:			 which is left in c1, the lookahead character. */
216880:		      --lexptr;
216898:		      ++lexleft;
216917:		      c2 = c;
216933:		    }
216941:		  else
216950:		    {
216958:		      if (c2 == '\\'
216981:			  && (syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))
217035:			FETCH(c2, "Unbalanced [");
217065:		      FETCH(c1, "Unbalanced [");
217100:		    }
217108:		}
217112:	      else
217124:		c2 = c;
217134:	      while (c <= c2)
217157:		{
217161:		  setbit(c, ccl);
217181:		  if (case_fold)
217200:		    if (ISUPPER(c))
217222:		      setbit(tolower(c), ccl);
217255:		    else if (ISLOWER(c))
217282:		      setbit(toupper(c), ccl);
217315:		  ++c;
217324:		}
217328:	    skip:
217339:	      ;
217348:	    }
217355:	  while ((c = c1) != ']');
217383:	  if (invert)
217398:	    {
217405:	      notset(ccl);
217425:	      if (syntax_bits & RE_HAT_LISTS_NOT_NEWLINE)
217476:		clrbit('\n', ccl);
217497:	    }
217504:	  laststart = 0;
217522:	  return lasttok = CSET + charclass_index(ccl);
217571:
217572:	default:
217582:	normal_char:
217596:	  laststart = 0;
217614:	  if (case_fold && ISALPHA(c))
217646:	    {
217653:	      zeroset(ccl);
217674:	      setbit(c, ccl);
217697:	      if (isupper(c))
217720:		setbit(tolower(c), ccl);
217747:	      else
217759:		setbit(toupper(c), ccl);
217786:	      return lasttok = CSET + charclass_index(ccl);
217839:	    }
217846:	  return c;
217859:	}
217862:    }
217868:
217869:  /* The above loop should consume at most a backslash
217924:     and some other character. */
217958:  abort();
217969:}
217971:
217972:/* Recursive descent parser for regular expressions. */
218028:
218029:static token tok;		/* Lookahead token. */
218071:static depth;			/* Current depth of a hypothetical stack
218128:				   holding deferred productions.  This is
218174:				   used to determine the depth that will be
218222:				   required of the real stack later on in
218268:				   dfaanalyze(). */
218292:
218293:/* Add the given token to the parse tree, maintaining the depth count and
218367:   updating the maximum depth if necessary. */
218414:static void
218426:addtok(t)
218436:     token t;
218450:{
218452:  REALLOC_IF_NECESSARY(dfa->tokens, token, dfa->talloc, dfa->tindex);
218522:  dfa->tokens[dfa->tindex++] = t;
218556:
218557:  switch (t)
218570:    {
218576:    case QMARK:
218592:    case STAR:
218607:    case PLUS:
218622:      break;
218635:
218636:    case CAT:
218650:    case OR:
218663:    case ORTOP:
218679:      --depth;
218694:      break;
218707:
218708:    default:
218721:      ++dfa->nleaves;
218743:    case EMPTY:
218759:      ++depth;
218774:      break;
218787:    }
218793:  if (depth > dfa->depth)
218819:    dfa->depth = depth;
218843:}
218845:
218846:/* The grammar understood by the parser is as follows.
218901:
218902:   regexp:
218913:     regexp OR branch
218935:     branch
218947:
218948:   branch:
218959:     branch closure
218979:     closure
218992:
218993:   closure:
219005:     closure QMARK
219024:     closure STAR
219042:     closure PLUS
219060:     atom
219070:
219071:   atom:
219080:     <normal character>
219104:     CSET
219114:     BACKREF
219127:     BEGLINE
219140:     ENDLINE
219153:     BEGWORD
219166:     ENDWORD
219179:     LIMWORD
219192:     NOTLIMWORD
219208:     <empty>
219221:
219222:   The parser builds a parse tree in postfix form in an array of tokens. */
219298:
219299:#if __STDC__
219312:static void regexp(int);
219337:#else
219343:static void regexp();
219365:#endif
219372:
219373:static void
219385:atom()
219392:{
219394:  if ((tok >= 0 && tok < NOTCHAR) || tok >= CSET || tok == BACKREF
219461:      || tok == BEGLINE || tok == ENDLINE || tok == BEGWORD
219521:      || tok == ENDWORD || tok == LIMWORD || tok == NOTLIMWORD)
219585:    {
219591:      addtok(tok);
219610:      tok = lex();
219629:    }
219635:  else if (tok == LPAREN)
219661:    {
219667:      tok = lex();
219686:      regexp(0);
219703:      if (tok != RPAREN)
219728:	dfaerror("Unbalanced (");
219755:      tok = lex();
219774:    }
219780:  else
219787:    addtok(EMPTY);
219806:}
219808:
219809:/* Return the number of tokens in the given subexpression. */
219871:static int
219882:nsubtoks(tindex)
219899:{
219901:  int ntoks1;
219915:
219916:  switch (dfa->tokens[tindex - 1])
219951:    {
219957:    default:
219970:      return 1;
219986:    case QMARK:
220002:    case STAR:
220017:    case PLUS:
220032:      return 1 + nsubtoks(tindex - 1);
220071:    case CAT:
220085:    case OR:
220098:    case ORTOP:
220114:      ntoks1 = nsubtoks(tindex - 1);
220151:      return 1 + ntoks1 + nsubtoks(tindex - 1 - ntoks1);
220208:    }
220214:}
220216:
220217:/* Copy the given subexpression to the top of the tree. */
220276:static void
220288:copytoks(tindex, ntokens)
220314:     int tindex, ntokens;
220340:{
220342:  int i;
220351:
220352:  for (i = 0; i < ntokens; ++i)
220384:    addtok(dfa->tokens[tindex + i]);
220421:}
220423:
220424:static void
220436:closure()
220446:{
220448:  int tindex, ntokens, i;
220474:
220475:  atom();
220485:  while (tok == QMARK || tok == STAR || tok == PLUS || tok == REPMN)
220554:    if (tok == REPMN)
220576:      {
220584:	ntokens = nsubtoks(dfa->tindex);
220618:	tindex = dfa->tindex - ntokens;
220651:	if (maxrep == 0)
220669:	  addtok(PLUS);
220686:	if (minrep == 0)
220704:	  addtok(QMARK);
220722:	for (i = 1; i < minrep; ++i)
220752:	  {
220757:	    copytoks(tindex, ntokens);
220789:	    addtok(CAT);
220807:	  }
220812:	for (; i < maxrep; ++i)
220837:	  {
220842:	    copytoks(tindex, ntokens);
220874:	    addtok(QMARK);
220894:	    addtok(CAT);
220912:	  }
220917:	tok = lex();
220931:      }
220939:    else
220948:      {
220956:	addtok(tok);
220970:	tok = lex();
220984:      }
220992:}
220994:
220995:static void
221007:branch()
221016:{
221018:  closure();
221031:  while (tok != RPAREN && tok != OR && tok >= 0)
221080:    {
221086:      closure();
221103:      addtok(CAT);
221122:    }
221128:}
221130:
221131:static void
221143:regexp(toplevel)
221160:     int toplevel;
221179:{
221181:  branch();
221193:  while (tok == OR)
221213:    {
221219:      tok = lex();
221238:      branch();
221254:      if (toplevel)
221274:	addtok(ORTOP);
221290:      else
221301:	addtok(OR);
221314:    }
221320:}
221322:
221323:/* Main entry point for the parser.  S is a string to be parsed, len is the
221476:   the struct dfa to parse into. */
221512:void
221517:dfaparse(s, len, d)
221537:     char *s;
221551:     size_t len;
221568:     struct dfa *d;
221588:
221589:{
221591:  dfa = d;
221602:  lexstart = lexptr = s;
221627:  lexleft = len;
221644:  lasttok = END;
221661:  laststart = 1;
221678:  parens = 0;
221692:
221693:  if (! syntax_bits_set)
221718:    dfaerror("No syntax specified");
221755:
221756:  tok = lex();
221771:  depth = d->depth;
221791:
221792:  regexp(1);
221805:
221806:  if (tok != END)
221824:    dfaerror("Unbalanced )");
221854:
221855:  addtok(END - d->nregexps);
221884:  addtok(CAT);
221899:
221900:  if (d->nregexps)
221919:    addtok(ORTOP);
221938:
221939:  ++d->nregexps;
221956:}
221958:
221959:/* Some primitives for operating on sets of positions. */
222017:
222018:/* Copy one set to another; the destination must be large enough. */
222087:static void
222099:copy(src, dst)
222114:     position_set *src;
222138:     position_set *dst;
222162:{
222164:  int i;
222173:
222174:  for (i = 0; i < src->nelem; ++i)
222209:    dst->elems[i] = src->elems[i];
222244:  dst->nelem = src->nelem;
222271:}
222273:
222274:/* Insert a position in a set.  Position sets are maintained in sorted
222345:   order according to index.  If position already exists in the set with
222418:   the same index then their constraints are logically or'd together.
222488:   S->elems must point to an array large enough to hold the resulting set. */
222566:static void
222578:insert(p, s)
222591:     position p;
222608:     position_set *s;
222630:{
222632:  int i;
222641:  position t1, t2;
222660:
222661:  for (i = 0; i < s->nelem && p.index < s->elems[i].index; ++i)
222725:    ;
222731:  if (i < s->nelem && p.index == s->elems[i].index)
222783:    s->elems[i].constraint |= p.constraint;
222827:  else
222834:    {
222840:      t1 = p;
222854:      ++s->nelem;
222872:      while (i < s->nelem)
222899:	{
222902:	  t2 = s->elems[i];
222923:	  s->elems[i++] = t1;
222946:	  t1 = t2;
222958:	}
222961:    }
222967:}
222969:
222970:/* Merge two sets of positions into a third.  The result is exactly as if
223044:   the positions of both sets were inserted into an initially empty set. */
223120:static void
223132:merge(s1, s2, m)
223149:     position_set *s1;
223172:     position_set *s2;
223195:     position_set *m;
223217:{
223219:  int i = 0, j = 0;
223239:
223240:  m->nelem = 0;
223256:  while (i < s1->nelem && j < s2->nelem)
223297:    if (s1->elems[i].index > s2->elems[j].index)
223346:      m->elems[m->nelem++] = s1->elems[i++];
223391:    else if (s1->elems[i].index < s2->elems[j].index)
223445:      m->elems[m->nelem++] = s2->elems[j++];
223490:    else
223499:      {
223507:	m->elems[m->nelem] = s1->elems[i++];
223545:	m->elems[m->nelem++].constraint |= s2->elems[j++].constraint;
223608:      }
223616:  while (i < s1->nelem)
223640:    m->elems[m->nelem++] = s1->elems[i++];
223683:  while (j < s2->nelem)
223707:    m->elems[m->nelem++] = s2->elems[j++];
223750:}
223752:
223753:/* Delete a position from a set. */
223789:static void
223801:delete(p, s)
223814:     position p;
223831:     position_set *s;
223853:{
223855:  int i;
223864:
223865:  for (i = 0; i < s->nelem; ++i)
223898:    if (p.index == s->elems[i].index)
223936:      break;
223949:  if (i < s->nelem)
223969:    for (--s->nelem; i < s->nelem; ++i)
224009:      s->elems[i] = s->elems[i + 1];
224046:}
224048:
224049:/* Find the index of the state corresponding to the given position set with
224125:   the given preceding context, or create a new state if there is no such
224199:   state.  Newline and letter tell whether we got here on a newline or
224270:   letter, respectively. */
224298:static int
224309:state_index(d, s, newline, letter)
224344:     struct dfa *d;
224364:     position_set *s;
224386:     int newline;
224404:     int letter;
224421:{
224423:  int hash = 0;
224439:  int constraint;
224457:  int i, j;
224469:
224470:  newline = newline ? 1 : 0;
224499:  letter = letter ? 1 : 0;
224526:
224527:  for (i = 0; i < s->nelem; ++i)
224560:    hash ^= s->elems[i].index + s->elems[i].constraint;
224616:
224617:  /* Try to find a state that exactly matches the proposed one. */
224684:  for (i = 0; i < d->sindex; ++i)
224718:    {
224724:      if (hash != d->states[i].hash || s->nelem != d->states[i].elems.nelem
224800:	  || newline != d->states[i].newline || letter != d->states[i].letter)
224872:	continue;
224883:      for (j = 0; j < s->nelem; ++j)
224920:	if (s->elems[j].constraint
224948:	    != d->states[i].elems.elems[j].constraint
224995:	    || s->elems[j].index != d->states[i].elems.elems[j].index)
225059:	  break;
225069:      if (j == s->nelem)
225094:	return i;
225105:    }
225111:
225112:  /* We'll have to create a new state. */
225154:  REALLOC_IF_NECESSARY(d->states, dfa_state, d->salloc, d->sindex);
225222:  d->states[i].hash = hash;
225250:  MALLOC(d->states[i].elems.elems, position, s->nelem);
225306:  copy(s, &d->states[i].elems);
225338:  d->states[i].newline = newline;
225372:  d->states[i].letter = letter;
225404:  d->states[i].backref = 0;
225432:  d->states[i].constraint = 0;
225463:  d->states[i].first_end = 0;
225493:  for (j = 0; j < s->nelem; ++j)
225526:    if (d->tokens[s->elems[j].index] < 0)
225568:      {
225576:	constraint = s->elems[j].constraint;
225614:	if (SUCCEEDS_IN_CONTEXT(constraint, newline, 0, letter, 0)
225674:	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 0, letter, 1)
225737:	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 1, letter, 0)
225800:	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 1, letter, 1))
225864:	  d->states[i].constraint |= constraint;
225906:	if (! d->states[i].first_end)
225937:	  d->states[i].first_end = d->tokens[s->elems[j].index];
225995:      }
226003:    else if (d->tokens[s->elems[j].index] == BACKREF)
226057:      {
226065:	d->states[i].constraint = NO_CONSTRAINT;
226107:	d->states[i].backref = 1;
226134:      }
226142:
226143:  ++d->sindex;
226158:
226159:  return i;
226171:}
226173:
226174:/* Find the epsilon closure of a set of positions.  If any position of the set
226253:   contains a symbol that matches the empty string in some context, replace
226329:   that position with the elements of its follow labeled with an appropriate
226406:   constraint.  Repeat exhaustively until no funny positions are left.
226477:   S->elems must be large enough to hold the result. */
226533:void
226538:epsclosure(s, d)
226555:     position_set *s;
226577:     struct dfa *d;
226597:{
226599:  int i, j;
226611:  int *visited;
226627:  position p, old;
226646:
226647:  MALLOC(visited, int, d->tindex);
226682:  for (i = 0; i < d->tindex; ++i)
226716:    visited[i] = 0;
226736:
226737:  for (i = 0; i < s->nelem; ++i)
226770:    if (d->tokens[s->elems[i].index] >= NOTCHAR
226818:	&& d->tokens[s->elems[i].index] != BACKREF
226862:	&& d->tokens[s->elems[i].index] < CSET)
226903:      {
226911:	old = s->elems[i];
226931:	p.constraint = old.constraint;
226963:	delete(s->elems[i], s);
226988:	if (visited[old.index])
227013:	  {
227018:	    --i;
227028:	    continue;
227043:	  }
227048:	visited[old.index] = 1;
227073:	switch (d->tokens[old.index])
227104:	  {
227109:	  case BEGLINE:
227126:	    p.constraint &= BEGLINE_CONSTRAINT;
227167:	    break;
227179:	  case ENDLINE:
227196:	    p.constraint &= ENDLINE_CONSTRAINT;
227237:	    break;
227249:	  case BEGWORD:
227266:	    p.constraint &= BEGWORD_CONSTRAINT;
227307:	    break;
227319:	  case ENDWORD:
227336:	    p.constraint &= ENDWORD_CONSTRAINT;
227377:	    break;
227389:	  case LIMWORD:
227406:	    p.constraint &= LIMWORD_CONSTRAINT;
227447:	    break;
227459:	  case NOTLIMWORD:
227479:	    p.constraint &= NOTLIMWORD_CONSTRAINT;
227523:	    break;
227535:	  default:
227547:	    break;
227559:	  }
227564:	for (j = 0; j < d->follows[old.index].nelem; ++j)
227615:	  {
227620:	    p.index = d->follows[old.index].elems[j].index;
227673:	    insert(p, s);
227692:	  }
227697:	/* Force rescan to start at the beginning. */
227744:	i = -1;
227753:      }
227761:
227762:  free(visited);
227779:}
227781:
227782:/* Perform bottom-up analysis on the parse tree, computing various functions.
227860:   Note that at this point, we're pretending constructs like \< are real
227933:   characters rather than constraints on what can follow them.
227996:
227997:   Nullable:  A node is nullable if it is at the root of a regexp that can
228072:   match the empty string.
228099:   *  EMPTY leaves are nullable.
228132:   * No other leaf is nullable.
228164:   * A QMARK or STAR node is nullable.
228203:   * A PLUS node is nullable if its argument is nullable.
228261:   * A CAT node is nullable if both its arguments are nullable.
228325:   * An OR node is nullable if either argument is nullable.
228385:
228386:   Firstpos:  The firstpos of a node is the set of positions (nonempty leaves)
228465:   that could correspond to the first character of a string matching the
228538:   regexp rooted at the given node.
228574:   * EMPTY leaves have empty firstpos.
228613:   * The firstpos of a nonempty leaf is that leaf itself.
228671:   * The firstpos of a QMARK, STAR, or PLUS node is the firstpos of its
228743:     argument.
228758:   * The firstpos of a CAT node is the firstpos of the left argument, union
228834:     the firstpos of the right if the left argument is nullable.
228899:   * The firstpos of an OR node is the union of firstpos of each argument.
228974:
228975:   Lastpos:  The lastpos of a node is the set of positions that could
229045:   correspond to the last character of a string matching the regexp at
229116:   the given node.
229135:   * EMPTY leaves have empty lastpos.
229173:   * The lastpos of a nonempty leaf is that leaf itself.
229230:   * The lastpos of a QMARK, STAR, or PLUS node is the lastpos of its
229300:     argument.
229315:   * The lastpos of a CAT node is the lastpos of its right argument, union
229390:     the lastpos of the left if the right argument is nullable.
229454:   * The lastpos of an OR node is the union of the lastpos of each argument.
229531:
229532:   Follow:  The follow of a position is the set of positions that could
229604:   correspond to the character following a character matching the node in
229678:   a string matching the regexp.  At this point we consider special symbols
229754:   that match the empty string in some context to be just normal characters.
229831:   Later, if we find that a special symbol is in a follow set, we will
229902:   replace it with the elements of its follow, labeled with an appropriate
229977:   constraint.
229992:   * Every node in the firstpos of the argument of a STAR or PLUS node is in
230069:     the follow of every node in the lastpos.
230115:   * Every node in the firstpos of the second argument of a CAT node is in
230190:     the follow of every node in the lastpos of the first argument.
230258:
230259:   Because of the postfix representation of the parse tree, the depth-first
230335:   analysis is conveniently done by a linear scan with the aid of a stack.
230410:   Sets are stored as arrays of the elements, obeying a stack-like allocation
230488:   scheme; the number of elements in each set deeper in the stack can be
230561:   used to determine the address of a particular set's array. */
230626:void
230631:dfaanalyze(d, searchflag)
230657:     struct dfa *d;
230677:     int searchflag;
230698:{
230700:  int *nullable;		/* Nullable stack. */
230740:  int *nfirstpos;		/* Element count stack for firstpos sets. */
230804:  position *firstpos;		/* Array where firstpos elements are stored. */
230875:  int *nlastpos;		/* Element count stack for lastpos sets. */
230937:  position *lastpos;		/* Array where lastpos elements are stored. */
231006:  int *nalloc;			/* Sizes of arrays allocated to follow sets. */
231071:  position_set tmp;		/* Temporary set for merging sets. */
231130:  position_set merged;		/* Result of merging sets. */
231184:  int wants_newline;		/* True if some position wants newline info. */
231254:  int *o_nullable;
231273:  int *o_nfirst, *o_nlast;
231300:  position *o_firstpos, *o_lastpos;
231336:  int i, j;
231348:  position *pos;
231365:
231366:#ifdef DEBUG
231379:  fprintf(stderr, "dfaanalyze:\n");
231415:  for (i = 0; i < d->tindex; ++i)
231449:    {
231455:      fprintf(stderr, " %d:", i);
231489:      prtok(d->tokens[i]);
231516:    }
231522:  putc('\n', stderr);
231544:#endif
231551:
231552:  d->searchflag = searchflag;
231582:
231583:  MALLOC(nullable, int, d->depth);
231618:  o_nullable = nullable;
231643:  MALLOC(nfirstpos, int, d->depth);
231679:  o_nfirst = nfirstpos;
231703:  MALLOC(firstpos, position, d->nleaves);
231745:  o_firstpos = firstpos, firstpos += d->nleaves;
231794:  MALLOC(nlastpos, int, d->depth);
231829:  o_nlast = nlastpos;
231851:  MALLOC(lastpos, position, d->nleaves);
231892:  o_lastpos = lastpos, lastpos += d->nleaves;
231938:  MALLOC(nalloc, int, d->tindex);
231972:  for (i = 0; i < d->tindex; ++i)
232006:    nalloc[i] = 0;
232025:  MALLOC(merged.elems, position, d->nleaves);
232071:
232072:  CALLOC(d->follows, position_set, d->tindex);
232119:
232120:  for (i = 0; i < d->tindex; ++i)
232154:#ifdef DEBUG
232167:    {				/* Nonsyntactic #ifdef goo... */
232209:#endif
232216:    switch (d->tokens[i])
232242:      {
232250:      case EMPTY:
232268:	/* The empty set is nullable. */
232302:	*nullable++ = 1;
232320:
232321:	/* The firstpos and lastpos of the empty leaf are both empty. */
232387:	*nfirstpos++ = *nlastpos++ = 0;
232420:	break;
232428:
232429:      case STAR:
232446:      case PLUS:
232463:	/* Every element in the firstpos of the argument is in the follow
232530:	   of every element in the lastpos. */
232570:	tmp.nelem = nfirstpos[-1];
232598:	tmp.elems = firstpos;
232621:	pos = lastpos;
232637:	for (j = 0; j < nlastpos[-1]; ++j)
232673:	  {
232678:	    merge(&tmp, &d->follows[pos[j].index], &merged);
232732:	    REALLOC_IF_NECESSARY(d->follows[pos[j].index].elems, position,
232800:				 nalloc[pos[j].index], merged.nelem - 1);
232846:	    copy(&merged, &d->follows[pos[j].index]);
232893:	  }
232898:
232899:      case QMARK:
232917:	/* A QMARK or STAR node is automatically nullable. */
232972:	if (d->tokens[i] != PLUS)
232999:	  nullable[-1] = 1;
233020:	break;
233028:
233029:      case CAT:
233045:	/* Every element in the firstpos of the second argument is in the
233112:	   follow of every element in the lastpos of the first argument. */
233181:	tmp.nelem = nfirstpos[-1];
233209:	tmp.elems = firstpos;
233232:	pos = lastpos + nlastpos[-1];
233263:	for (j = 0; j < nlastpos[-2]; ++j)
233299:	  {
233304:	    merge(&tmp, &d->follows[pos[j].index], &merged);
233358:	    REALLOC_IF_NECESSARY(d->follows[pos[j].index].elems, position,
233426:				 nalloc[pos[j].index], merged.nelem - 1);
233472:	    copy(&merged, &d->follows[pos[j].index]);
233519:	  }
233524:
233525:	/* The firstpos of a CAT node is the firstpos of the first argument,
233595:	   union that of the second argument if the first is nullable. */
233662:	if (nullable[-2])
233681:	  nfirstpos[-2] += nfirstpos[-1];
233716:	else
233722:	  firstpos += nfirstpos[-1];
233752:	--nfirstpos;
233766:
233767:	/* The lastpos of a CAT node is the lastpos of the second argument,
233836:	   union that of the first argument if the second is nullable. */
233903:	if (nullable[-1])
233922:	  nlastpos[-2] += nlastpos[-1];
233955:	else
233961:	  {
233966:	    pos = lastpos + nlastpos[-2];
234001:	    for (j = nlastpos[-1] - 1; j >= 0; --j)
234046:	      pos[j] = lastpos[j];
234074:	    lastpos += nlastpos[-2];
234104:	    nlastpos[-2] = nlastpos[-1];
234138:	  }
234143:	--nlastpos;
234156:
234157:	/* A CAT node is nullable if both arguments are nullable. */
234219:	nullable[-2] = nullable[-1] && nullable[-2];
234265:	--nullable;
234278:	break;
234286:
234287:      case OR:
234302:      case ORTOP:
234320:	/* The firstpos is the union of the firstpos of each argument. */
234387:	nfirstpos[-2] += nfirstpos[-1];
234420:	--nfirstpos;
234434:
234435:	/* The lastpos is the union of the lastpos of each argument. */
234500:	nlastpos[-2] += nlastpos[-1];
234531:	--nlastpos;
234544:
234545:	/* An OR node is nullable if either argument is nullable. */
234607:	nullable[-2] = nullable[-1] || nullable[-2];
234653:	--nullable;
234666:	break;
234674:
234675:      default:
234690:	/* Anything else is a nonempty position.  (Note that special
234752:	   constructs like \< are treated as nonempty strings here;
234813:	   an "epsilon closure" effectively makes them nullable later.
234877:	   Backreferences have to get a real position so we can detect
234941:	   transitions on them later.  But they are nullable. */
234999:	*nullable++ = d->tokens[i] == BACKREF;
235039:
235040:	/* This position is in its own firstpos and lastpos. */
235097:	*nfirstpos++ = *nlastpos++ = 1;
235130:	--firstpos, --lastpos;
235154:	firstpos->index = lastpos->index = i;
235193:	firstpos->constraint = lastpos->constraint = NO_CONSTRAINT;
235254:
235255:	/* Allocate the follow set for this position. */
235305:	nalloc[i] = 1;
235321:	MALLOC(d->follows[i].elems, position, nalloc[i]);
235372:	break;
235380:      }
235388:#ifdef DEBUG
235401:    /* ... balance the above nonsyntactic #ifdef goo... */
235460:      fprintf(stderr, "node %d:", i);
235498:      prtok(d->tokens[i]);
235525:      putc('\n', stderr);
235551:      fprintf(stderr, nullable[-1] ? " nullable: yes\n" : " nullable: no\n");
235629:      fprintf(stderr, " firstpos:");
235666:      for (j = nfirstpos[-1] - 1; j >= 0; --j)
235713:	{
235716:	  fprintf(stderr, " %d:", firstpos[j].index);
235763:	  prtok(d->tokens[firstpos[j].index]);
235803:	}
235806:      fprintf(stderr, "\n lastpos:");
235844:      for (j = nlastpos[-1] - 1; j >= 0; --j)
235890:	{
235893:	  fprintf(stderr, " %d:", lastpos[j].index);
235939:	  prtok(d->tokens[lastpos[j].index]);
235978:	}
235981:      putc('\n', stderr);
236007:    }
236013:#endif
236020:
236021:  /* For each follow set that is the follow set of a real position, replace
236097:     it with its epsilon closure. */
236134:  for (i = 0; i < d->tindex; ++i)
236168:    if (d->tokens[i] < NOTCHAR || d->tokens[i] == BACKREF
236226:	|| d->tokens[i] >= CSET)
236252:      {
236260:#ifdef DEBUG
236273:	fprintf(stderr, "follows(%d:", i);
236309:	prtok(d->tokens[i]);
236331:	fprintf(stderr, "):");
236355:	for (j = d->follows[i].nelem - 1; j >= 0; --j)
236403:	  {
236408:	    fprintf(stderr, " %d:", d->follows[i].elems[j].index);
236468:	    prtok(d->tokens[d->follows[i].elems[j].index]);
236521:	  }
236526:	putc('\n', stderr);
236547:#endif
236554:	copy(&d->follows[i], &merged);
236586:	epsclosure(&merged, d);
236611:	if (d->follows[i].nelem < merged.nelem)
236652:	  REALLOC(d->follows[i].elems, position, merged.nelem);
236709:	copy(&merged, &d->follows[i]);
236741:      }
236749:
236750:  /* Get the epsilon closure of the firstpos of the regexp.  The result will
236827:     be the set of positions of state 0. */
236871:  merged.nelem = 0;
236891:  for (i = 0; i < nfirstpos[-1]; ++i)
236929:    insert(firstpos[i], &merged);
236963:  epsclosure(&merged, d);
236989:
236990:  /* Check if any of the positions of state 0 will want newline context. */
237066:  wants_newline = 0;
237087:  for (i = 0; i < merged.nelem; ++i)
237124:    if (PREV_NEWLINE_DEPENDENT(merged.elems[i].constraint))
237184:      wants_newline = 1;
237209:
237210:  /* Build the initial state. */
237243:  d->salloc = 1;
237260:  d->sindex = 0;
237277:  MALLOC(d->states, dfa_state, d->salloc);
237320:  state_index(d, &merged, wants_newline, 0);
237365:
237366:  free(o_nullable);
237386:  free(o_nfirst);
237404:  free(o_firstpos);
237424:  free(o_nlast);
237441:  free(o_lastpos);
237460:  free(nalloc);
237476:  free(merged.elems);
237498:}
237500:
237501:/* Find, for each character, the transition out of state s of d, and store
237576:   it in the appropriate slot of trans.
237616:
237617:   We divide the positions of s into groups (positions can appear in more
237691:   than one group).  Each group is labeled with a set of characters that
237764:   every position in the group matches (taking into account, if necessary,
237839:   preceding context information of s).  For each group, find the union
237911:   of the its elements' follows.  This set is the set of positions of the
237985:   new state.  For each character in the group's label, set the transition
238060:   on this character to be to a state corresponding to the set's positions,
238136:   and its associated backward context information, if necessary.
238202:
238280:   0 in every state.
238301:
238302:   The collection of groups is constructed by building an equivalence-class
238378:   partition of the positions of s.
238414:
238415:   For each position, find the set of characters C that it matches.  Eliminate
238494:   any characters from C that fail on grounds of backward context.
238561:
238562:   Search through the groups, looking for a group whose label L has nonempty
238639:   intersection with C.  If L - C is nonempty, create a new group labeled
238713:   L - C and having the same positions as the current group, and set L to
238787:   the intersection of L and C.  Insert the position in this group, set
238859:   C = C - L, and resume scanning.
238894:
238895:   If after comparing with every group there are characters remaining in C,
238971:   create a new group labeled with the characters of C and insert this
239042:   position in that group. */
239072:void
239077:dfastate(s, d, trans)
239099:     int s;
239111:     struct dfa *d;
239131:     int trans[];
239149:{
239151:  position_set grps[NOTCHAR];	/* As many as will ever be needed. */
239219:  charclass labels[NOTCHAR];	/* Labels corresponding to the groups. */
239290:  int ngrps = 0;		/* Number of groups actually used. */
239346:  position pos;			/* Current position being considered. */
239405:  charclass matches;		/* Set of matching characters. */
239461:  int matchesf;			/* True if matches is nonempty. */
239514:  charclass intersect;		/* Intersection with some label set. */
239578:  int intersectf;		/* True if intersect is nonempty. */
239634:  charclass leftovers;		/* Stuff in the label that didn't match. */
239702:  int leftoversf;		/* True if leftovers is nonempty. */
239758:  static charclass letters;	/* Set of characters considered letters. */
239830:  static charclass newline;	/* Set of characters that aren't newline. */
239903:  position_set follows;		/* Union of the follows of some group. */
239970:  position_set tmp;		/* Temporary space for merging sets. */
240031:  int state;			/* New state. */
240063:  int wants_newline;		/* New state wants to know newline context. */
240132:  int state_newline;		/* New state on a newline transition. */
240195:  int wants_letter;		/* New state wants to know letter context. */
240262:  int state_letter;		/* New state on a letter transition. */
240323:  static initialized;		/* Flag for static initialization. */
240384:  int i, j, k;
240399:
240400:  /* Initialize the set of letters, if necessary. */
240453:  if (! initialized)
240474:    {
240480:      initialized = 1;
240503:      for (i = 0; i < NOTCHAR; ++i)
240539:	if (ISALNUM(i))
240556:	  setbit(i, letters);
240579:      setbit('\n', newline);
240608:    }
240614:
240615:  zeroset(matches);
240635:
240636:  for (i = 0; i < d->states[s].elems.nelem; ++i)
240685:    {
240691:      pos = d->states[s].elems.elems[i];
240732:      if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR)
240803:	setbit(d->tokens[pos.index], matches);
240843:      else if (d->tokens[pos.index] >= CSET)
240888:	copyset(d->charclasses[d->tokens[pos.index] - CSET], matches);
240952:      else
240963:	continue;
240974:
240975:      /* Some characters may need to be eliminated from matches because
241047:	 they fail in the current context. */
241086:      if (pos.constraint != 0xFF)
241120:	{
241123:	  if (! MATCHES_NEWLINE_CONTEXT(pos.constraint,
241172:					 d->states[s].newline, 1))
241204:	    clrbit('\n', matches);
241232:	  if (! MATCHES_NEWLINE_CONTEXT(pos.constraint,
241281:					 d->states[s].newline, 0))
241313:	    for (j = 0; j < CHARCLASS_INTS; ++j)
241355:	      matches[j] &= newline[j];
241388:	  if (! MATCHES_LETTER_CONTEXT(pos.constraint,
241436:					d->states[s].letter, 1))
241466:	    for (j = 0; j < CHARCLASS_INTS; ++j)
241508:	      matches[j] &= ~letters[j];
241542:	  if (! MATCHES_LETTER_CONTEXT(pos.constraint,
241590:					d->states[s].letter, 0))
241620:	    for (j = 0; j < CHARCLASS_INTS; ++j)
241662:	      matches[j] &= letters[j];
241695:
241696:	  /* If there are no characters left, there's no point in going on. */
241768:	  for (j = 0; j < CHARCLASS_INTS && !matches[j]; ++j)
241823:	    ;
241830:	  if (j == CHARCLASS_INTS)
241858:	    continue;
241873:	}
241876:
241877:      for (j = 0; j < ngrps; ++j)
241911:	{
241914:	  /* If matches contains a single character only, and the current
241981:	     group's label doesn't contain that character, go on to the
242046:	     next group. */
242067:	  if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR
242134:	      && !tstbit(d->tokens[pos.index], labels[j]))
242186:	    continue;
242201:
242202:	  /* Check if this group's label has a nonempty intersection with
242269:	     matches. */
242287:	  intersectf = 0;
242306:	  for (k = 0; k < CHARCLASS_INTS; ++k)
242346:	    (intersect[k] = matches[k] & labels[j][k]) ? intersectf = 1 : 0;
242416:	  if (! intersectf)
242437:	    continue;
242452:
242453:	  /* It does; now find the set differences both ways. */
242511:	  leftoversf = matchesf = 0;
242541:	  for (k = 0; k < CHARCLASS_INTS; ++k)
242581:	    {
242588:	      /* Even an optimizing compiler can't know this for sure. */
242655:	      int match = matches[k], label = labels[j][k];
242708:
242709:	      (leftovers[k] = ~match & label) ? leftoversf = 1 : 0;
242770:	      (matches[k] = match & ~label) ? matchesf = 1 : 0;
242827:	    }
242834:
242835:	  /* If there were leftovers, create a new group labeled with them. */
242907:	  if (leftoversf)
242926:	    {
242933:	      copyset(leftovers, labels[ngrps]);
242975:	      copyset(intersect, labels[j]);
243013:	      MALLOC(grps[ngrps].elems, position, d->nleaves);
243069:	      copy(&grps[j], &grps[ngrps]);
243106:	      ++ngrps;
243122:	    }
243129:
243130:	  /* Put the position in the current group.  Note that there is no
243198:	     reason to call insert() here. */
243237:	  grps[j].elems[grps[j].nelem++] = pos;
243278:
243279:	  /* If every character matching the current position has been
243343:	     accounted for, we're done. */
243379:	  if (! matchesf)
243398:	    break;
243410:	}
243413:
243414:      /* If we've passed the last group, and there are still characters
243486:	 unaccounted for, then we'll have to create a new group. */
243547:      if (j == ngrps)
243569:	{
243572:	  copyset(matches, labels[ngrps]);
243608:	  zeroset(matches);
243629:	  MALLOC(grps[ngrps].elems, position, d->nleaves);
243681:	  grps[ngrps].nelem = 1;
243707:	  grps[ngrps].elems[0] = pos;
243738:	  ++ngrps;
243750:	}
243753:    }
243759:
243760:  MALLOC(follows.elems, position, d->nleaves);
243807:  MALLOC(tmp.elems, position, d->nleaves);
243850:
243851:  /* If we are a searching matcher, the default transition is to a state
243924:     containing the positions of state 0, otherwise the default transition
243999:     is to fail miserably. */
244029:  if (d->searchflag)
244050:    {
244056:      wants_newline = 0;
244081:      wants_letter = 0;
244105:      for (i = 0; i < d->states[0].elems.nelem; ++i)
244158:	{
244161:	  if (PREV_NEWLINE_DEPENDENT(d->states[0].elems.elems[i].constraint))
244232:	    wants_newline = 1;
244256:	  if (PREV_LETTER_DEPENDENT(d->states[0].elems.elems[i].constraint))
244326:	    wants_letter = 1;
244349:	}
244352:      copy(&d->states[0].elems, &follows);
244395:      state = state_index(d, &follows, 0, 0);
244441:      if (wants_newline)
244466:	state_newline = state_index(d, &follows, 1, 0);
244515:      else
244526:	state_newline = state;
244550:      if (wants_letter)
244574:	state_letter = state_index(d, &follows, 0, 1);
244622:      else
244633:	state_letter = state;
244656:      for (i = 0; i < NOTCHAR; ++i)
244692:	if (i == '\n')
244708:	  trans[i] = state_newline;
244737:	else if (ISALNUM(i))
244759:	  trans[i] = state_letter;
244787:	else
244793:	  trans[i] = state;
244814:    }
244820:  else
244827:    for (i = 0; i < NOTCHAR; ++i)
244861:      trans[i] = -1;
244882:
244883:  for (i = 0; i < ngrps; ++i)
244913:    {
244919:      follows.nelem = 0;
244944:
244945:      /* Find the union of the follows of the positions of the group.
245015:	 This is a hideously inefficient loop.  Fix it someday. */
245075:      for (j = 0; j < grps[i].nelem; ++j)
245117:	for (k = 0; k < d->follows[grps[i].elems[j].index].nelem; ++k)
245181:	  insert(d->follows[grps[i].elems[j].index].elems[k], &follows);
245247:
245248:      /* If we are building a searching matcher, throw in the positions
245320:	 of state 0 as well. */
245345:      if (d->searchflag)
245370:	for (j = 0; j < d->states[0].elems.nelem; ++j)
245418:	  insert(d->states[0].elems.elems[j], &follows);
245468:
245469:      /* Find out if the new state will want any context information. */
245542:      wants_newline = 0;
245567:      if (tstbit('\n', labels[i]))
245602:	for (j = 0; j < follows.nelem; ++j)
245639:	  if (PREV_NEWLINE_DEPENDENT(follows.elems[j].constraint))
245699:	    wants_newline = 1;
245723:
245724:      wants_letter = 0;
245748:      for (j = 0; j < CHARCLASS_INTS; ++j)
245791:	if (labels[i][j] & letters[j])
245823:	  break;
245833:      if (j < CHARCLASS_INTS)
245863:	for (j = 0; j < follows.nelem; ++j)
245900:	  if (PREV_LETTER_DEPENDENT(follows.elems[j].constraint))
245959:	    wants_letter = 1;
245982:
245983:      /* Find the state(s) corresponding to the union of the follows. */
246056:      state = state_index(d, &follows, 0, 0);
246102:      if (wants_newline)
246127:	state_newline = state_index(d, &follows, 1, 0);
246176:      else
246187:	state_newline = state;
246211:      if (wants_letter)
246235:	state_letter = state_index(d, &follows, 0, 1);
246283:      else
246294:	state_letter = state;
246317:
246318:      /* Set the transitions for each character in the current label. */
246391:      for (j = 0; j < CHARCLASS_INTS; ++j)
246434:	for (k = 0; k < INTBITS; ++k)
246465:	  if (labels[i][j] & 1 << k)
246495:	    {
246502:	      int c = j * INTBITS + k;
246534:
246535:	      if (c == '\n')
246557:		trans[c] = state_newline;
246585:	      else if (ISALNUM(c))
246613:		trans[c] = state_letter;
246640:	      else if (c < NOTCHAR)
246669:		trans[c] = state;
246689:	    }
246696:    }
246702:
246703:  for (i = 0; i < ngrps; ++i)
246733:    free(grps[i].elems);
246758:  free(follows.elems);
246781:  free(tmp.elems);
246800:}
246802:
246803:/* Some routines for manipulating a compiled dfa's transition tables.
246873:   Each state may or may not have a transition table; if it does, and it
246946:   is a non-accepting state, then d->trans[state] points to its table.
247017:   If it is an accepting state then d->fails[state] points to its table.
247090:   If it has no table at all, then d->trans[state] is NULL.
247150:   TODO: Improve this comment, get rid of the unnecessary redundancy. */
247223:
247224:static void
247236:build_state(s, d)
247254:     int s;
247266:     struct dfa *d;
247286:{
247288:  int *trans;			/* The new transition table. */
247336:  int i;
247345:
247346:  /* Set an upper limit on the number of transition tables that will ever
247420:     exist at once.  1024 is arbitrary.  The idea is that the frequently
247493:     used transition tables will be quickly rebuilt, whereas the ones that
247568:     were only needed once or twice will be cleared away. */
247629:  if (d->trcount >= 1024)
247655:    {
247661:      for (i = 0; i < d->tralloc; ++i)
247700:	if (d->trans[i])
247718:	  {
247723:	    free((ptr_t) d->trans[i]);
247755:	    d->trans[i] = NULL;
247780:	  }
247785:	else if (d->fails[i])
247808:	  {
247813:	    free((ptr_t) d->fails[i]);
247845:	    d->fails[i] = NULL;
247870:	  }
247875:      d->trcount = 0;
247897:    }
247903:
247904:  ++d->trcount;
247920:
247921:  /* Set up the success bits for this state. */
247969:  d->success[s] = 0;
247990:  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 1, d->states[s].letter, 0,
248064:      s, *d))
248078:    d->success[s] |= 4;
248102:  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 0, d->states[s].letter, 1,
248176:      s, *d))
248190:    d->success[s] |= 2;
248214:  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 0, d->states[s].letter, 0,
248288:      s, *d))
248302:    d->success[s] |= 1;
248326:
248327:  MALLOC(trans, int, NOTCHAR);
248358:  dfastate(s, d, trans);
248383:
248384:  /* Now go through the new transition table, and make sure that the trans
248459:     and fail arrays are allocated large enough to hold a pointer for the
248533:     largest state mentioned in the table. */
248579:  for (i = 0; i < NOTCHAR; ++i)
248611:    if (trans[i] >= d->tralloc)
248643:      {
248651:	int oldalloc = d->tralloc;
248679:
248680:	while (trans[i] >= d->tralloc)
248712:	  d->tralloc *= 2;
248732:	REALLOC(d->realtrans, int *, d->tralloc + 1);
248779:	d->trans = d->realtrans + 1;
248809:	REALLOC(d->fails, int *, d->tralloc);
248848:	REALLOC(d->success, int, d->tralloc);
248887:	REALLOC(d->newlines, int, d->tralloc);
248927:	while (oldalloc < d->tralloc)
248958:	  {
248963:	    d->trans[oldalloc] = NULL;
248995:	    d->fails[oldalloc++] = NULL;
249029:	  }
249034:      }
249042:
249043:  /* Keep the newline transition in a special place so we can use it as
249115:     a sentinel. */
249135:  d->newlines[s] = trans['\n'];
249167:  trans['\n'] = -1;
249187:
249188:  if (ACCEPTING(s, *d))
249212:    d->fails[s] = trans;
249237:  else
249244:    d->trans[s] = trans;
249269:}
249271:
249272:static void
249284:build_state_zero(d)
249304:     struct dfa *d;
249324:{
249326:  d->tralloc = 1;
249344:  d->trcount = 0;
249362:  CALLOC(d->realtrans, int *, d->tralloc + 1);
249409:  d->trans = d->realtrans + 1;
249440:  CALLOC(d->fails, int *, d->tralloc);
249479:  MALLOC(d->success, int, d->tralloc);
249518:  MALLOC(d->newlines, int, d->tralloc);
249558:  build_state(0, d);
249579:}
249581:
249582:/* Search through a buffer looking for a match to the given struct dfa.
249654:   Find the first occurrence of a string matching the regexp in the buffer,
249730:   and the shortest possible version thereof.  Return a pointer to the first
249807:   character after the match, or NULL if none is found.  Begin points to
249880:   the beginning of the buffer, and end points to the first character after
249956:   its end.  We store a newline in *end to act as a sentinel, so end had
250029:   better point somewhere valid.  Newline is a flag indicating whether to
250103:   allow newlines to be in the matching string.  If count is non-
250169:   NULL it points to a place we're supposed to increment every time we
250240:   see a newline.  Finally, if backref is non-NULL it points to a place
250312:   where we're supposed to store a 1 if backreferencing happened and the
250385:   match needs to be verified by a backtracking matcher.  Otherwise
250453:   we store a 0 in *backref. */
250485:char *
250492:dfaexec(d, begin, end, newline, count, backref)
250540:     struct dfa *d;
250560:     char *begin;
250578:     char *end;
250594:     int newline;
250612:     int *count;
250629:     int *backref;
250648:{
250650:  register s, s1, tmp;		/* Current state. */
250695:  register unsigned char *p;	/* Current input character. */
250755:  register **trans, *t;		/* Copy of d->trans so it can be optimized
250823:				   into a register. */
250850:  static sbit[NOTCHAR];	/* Table for anding with d->success. */
250914:  static sbit_init;
250934:
250935:  if (! sbit_init)
250954:    {
250960:      int i;
250973:
250974:      sbit_init = 1;
250995:      for (i = 0; i < NOTCHAR; ++i)
251031:	if (i == '\n')
251047:	  sbit[i] = 4;
251063:	else if (ISALNUM(i))
251085:	  sbit[i] = 2;
251101:	else
251107:	  sbit[i] = 1;
251123:    }
251129:
251130:  if (! d->tralloc)
251150:    build_state_zero(d);
251175:
251176:  s = s1 = 0;
251190:  p = (unsigned char *) begin;
251221:  trans = d->trans;
251241:  *end = '\n';
251256:
251257:  for (;;)
251268:    {
251274:      /* The dreaded inner loop. */
251310:      if ((t = trans[s]) != 0)
251341:	do
251345:	  {
251350:	    s1 = t[*p++];
251369:	    if (! (t = trans[s1]))
251397:	      goto last_was_s;
251421:	    s = t[*p++];
251439:	  }
251444:        while ((t = trans[s]) != 0);
251481:      goto last_was_s1;
251505:    last_was_s:
251521:      tmp = s, s = s1, s1 = tmp;
251554:    last_was_s1:
251571:
251572:      if (s >= 0 && p <= (unsigned char *) end && d->fails[s])
251635:	{
251638:	  if (d->success[s] & sbit[*p])
251671:	    {
251678:	      if (backref)
251698:		if (d->states[s].backref)
251726:		  *backref = 1;
251744:		else
251751:		  *backref = 0;
251769:	      return (char *) p;
251795:	    }
251802:
251803:	  s1 = s;
251814:	  s = d->fails[s][*p++];
251840:	  continue;
251853:	}
251856:
251857:      /* If the previous character was a newline, count it. */
251920:      if (count && (char *) p <= end && p[-1] == '\n')
251975:	++*count;
251986:
251987:      /* Check if we've run off the end of the buffer. */
252045:      if ((char *) p > end)
252073:	return NULL;
252087:
252088:      if (s >= 0)
252106:	{
252109:	  build_state(s, d);
252131:	  trans = d->trans;
252152:	  continue;
252165:	}
252168:
252169:      if (p[-1] == '\n' && newline)
252205:	{
252208:	  s = d->newlines[s1];
252232:	  continue;
252245:	}
252248:
252249:      s = 0;
252262:    }
252268:}
252270:
252271:/* Initialize the components of a dfa that the other routines don't
252339:   initialize for themselves. */
252372:void
252377:dfainit(d)
252388:     struct dfa *d;
252408:{
252410:  d->calloc = 1;
252427:  MALLOC(d->charclasses, charclass, d->calloc);
252475:  d->cindex = 0;
252492:
252493:  d->talloc = 1;
252510:  MALLOC(d->tokens, token, d->talloc);
252549:  d->tindex = d->depth = d->nleaves = d->nregexps = 0;
252604:
252605:  d->searchflag = 0;
252626:  d->tralloc = 0;
252644:
252645:  d->musts = 0;
252661:}
252663:
252664:/* Parse and analyze a single string of the given length. */
252725:void
252730:dfacomp(s, len, d, searchflag)
252761:     char *s;
252775:     size_t len;
252792:     struct dfa *d;
252812:     int searchflag;
252833:{
252835:  if (case_fold)	/* dummy folding in service of dfamust() */
252896:    {
252902:      char *copy;
252920:      int i;
252933:
252934:      copy = malloc(len);
252960:      if (!copy)
252977:	dfaerror("out of memory");
253005:      
253012:      /* This is a kludge. */
253042:      case_fold = 0;
253063:      for (i = 0; i < len; ++i)
253095:	if (ISUPPER(s[i]))
253115:	  copy[i] = tolower(s[i]);
253143:	else
253149:	  copy[i] = s[i];
253168:
253169:      dfainit(d);
253187:      dfaparse(copy, len, d);
253217:      free(copy);
253235:      dfamust(d);
253253:      d->cindex = d->tindex = d->depth = d->nleaves = d->nregexps = 0;
253324:      case_fold = 1;
253345:      dfaparse(s, len, d);
253372:      dfaanalyze(d, searchflag);
253405:    }
253411:  else
253418:    {
253424:        dfainit(d);
253444:        dfaparse(s, len, d);
253473:	dfamust(d);
253486:        dfaanalyze(d, searchflag);
253521:    }
253527:}
253529:
253530:/* Free the storage held by the components of a dfa. */
253586:void
253591:dfafree(d)
253602:     struct dfa *d;
253622:{
253624:  int i;
253633:  struct dfamust *dm, *ndm;
253661:
253662:  free((ptr_t) d->charclasses);
253694:  free((ptr_t) d->tokens);
253721:  for (i = 0; i < d->sindex; ++i)
253755:    free((ptr_t) d->states[i].elems.elems);
253799:  free((ptr_t) d->states);
253826:  for (i = 0; i < d->tindex; ++i)
253860:    if (d->follows[i].elems)
253889:      free((ptr_t) d->follows[i].elems);
253930:  free((ptr_t) d->follows);
253958:  for (i = 0; i < d->tralloc; ++i)
253993:    if (d->trans[i])
254014:      free((ptr_t) d->trans[i]);
254047:    else if (d->fails[i])
254073:      free((ptr_t) d->fails[i]);
254106:  free((ptr_t) d->realtrans);
254136:  free((ptr_t) d->fails);
254162:  free((ptr_t) d->newlines);
254191:  for (dm = d->musts; dm; dm = ndm)
254227:    {
254233:      ndm = dm->next;
254255:      free(dm->must);
254277:      free((ptr_t) dm);
254301:    }
254307:}
254309:
254310:/* Having found the postfix representation of the regular expression,
254380:   try to find a long sequence of characters that must appear in any line
254454:   containing the r.e.
254477:   Finding a "longest" sequence is beyond the scope here;
254535:   we take an easy way out and hope for the best.
254585:   (Take "(ab|a)b"--please.)
254614:
254615:   We do a bottom-up calculation of sequences of characters that must appear
254692:   in matches of r.e.'s represented by trees rooted at the nodes of the postfix
254772:   representation:
254791:	sequences that must appear at the left of the match ("left")
254853:	sequences that must appear at the right of the match ("right")
254917:	lists of sequences that must appear somewhere in the match ("in")
254984:	sequences that must constitute the match ("is")
255033:
255034:   When we get to the root of the tree, we use one of the longest of its
255107:   calculated "in" sequences as our answer.  The sequence we find is returned in
255188:   d->must (where "d" is the single argument passed to "dfamust");
255255:   the length of the sequence is returned in d->mustn.
255310:
255311:   The sequences calculated for the various types of node (in pseudo ANSI c)
255388:   are shown below.  "p" is the operand of unary operators (and the left-hand
255466:   operand of binary operators); "q" is the right-hand operand of binary
255539:   operators.
255553:
255554:   "ZERO" means "a zero-length sequence" below.
255602:
255603:	Type	left		right		is		in
255629:	----	----		-----		--		--
255655:	char c	# c		# c		# c		# c
255682:	
255684:	CSET	ZERO		ZERO		ZERO		ZERO
255713:	
255715:	STAR	ZERO		ZERO		ZERO		ZERO
255744:
255745:	QMARK	ZERO		ZERO		ZERO		ZERO
255775:
255776:	PLUS	p->left		p->right	ZERO		p->in
255812:
255813:	CAT	(p->is==ZERO)?	(q->is==ZERO)?	(p->is!=ZERO &&	p->in plus
255875:		p->left :	q->right :	q->is!=ZERO) ?	q->in plus
255924:		p->is##q->left	p->right##q->is	p->is##q->is :	p->right##q->left
255990:						ZERO
256001:					
256007:	OR	longest common	longest common	(do p->is and	substrings common to
256076:		leading		trailing	q->is have same	p->in and q->in
256128:		(sub)sequence	(sub)sequence	length and	
256170:		of p->left	of p->right	content) ?	
256207:		and q->left	and q->right	p->is : NULL	
256248:
256249:   If there's anything else we recognize in the tree, all four sequences get set
256330:   to zero-length sequences.  If there's something we don't recognize in the tree,
256413:   we just return a zero-length sequence.
256455:
256456:   Break ties in favor of infrequent letters (choosing 'zzz' in preference to
256534:   'aaa')?
256545:
256546:   And. . .is it here or someplace that we might ponder "optimizations" such as
256626:	egrep 'psi|epsilon'	->	egrep 'psi'
256662:	egrep 'pepsi|epsilon'	->	egrep 'epsi'
256701:					(Yes, we now find "epsi" as a "string
256744:					that must occur", but we might also
256785:					simplify the *entire* r.e. being sought)
256831:	grep '[c]'		->	grep 'c'
256856:	grep '(ab|a)b'		->	grep 'ab'
256886:	grep 'ab*'		->	grep 'a'
256911:	grep 'a*b'		->	grep 'b'
256936:
256937:   There are several issues:
256966:
256967:   Is optimization easy (enough)?
257001:
257002:   Does optimization actually accomplish anything,
257053:   or is the automaton you get from "psi|epsilon" (for example)
257117:   the same as the one you get from "psi" (for example)?
257174:  
257177:   Are optimizable r.e.'s likely to be used in real-life situations
257245:   (something like 'ab*' is probably unlikely; something like is
257310:   'psi|epsilon' is likelier)? */
257344:
257345:static char *
257359:icatalloc(old, new)
257379:     char *old;
257395:     char *new;
257411:{
257413:  char *result;
257429:  int oldsize, newsize;
257453:
257454:  newsize = (new == NULL) ? 0 : strlen(new);
257499:  if (old == NULL)
257518:    oldsize = 0;
257535:  else if (newsize == 0)
257560:    return old;
257576:  else	oldsize = strlen(old);
257606:  if (old == NULL)
257625:    result = (char *) malloc(newsize + 1);
257668:  else
257675:    result = (char *) realloc((void *) old, oldsize + newsize + 1);
257743:  if (result != NULL && new != NULL)
257780:    (void) strcpy(result + oldsize, new);
257822:  return result;
257839:}
257841:
257842:static char *
257856:icpyalloc(string)
257874:     char *string;
257893:{
257895:  return icatalloc((char *) NULL, string);
257938:}
257940:
257941:static char *
257955:istrstr(lookin, lookfor)
257980:     char *lookin;
257999:     char *lookfor;
258019:{
258021:  char *cp;
258033:  int len;
258044:
258045:  len = strlen(lookfor);
258070:  for (cp = lookin; *cp != '\0'; ++cp)
258109:    if (strncmp(cp, lookfor, len) == 0)
258149:      return cp;
258166:  return NULL;
258181:}
258183:
258184:static void
258196:ifree(cp)
258206:     char *cp;
258221:{
258223:  if (cp != NULL)
258241:    free(cp);
258255:}
258257:
258258:static void
258270:freelist(cpp)
258284:     char **cpp;
258301:{
258303:  int i;
258312:
258313:  if (cpp == NULL)
258332:    return;
258344:  for (i = 0; cpp[i] != NULL; ++i)
258379:    {
258385:      free(cpp[i]);
258405:      cpp[i] = NULL;
258426:    }
258432:}
258434:
258435:static char **
258450:enlist(cpp, new, len)
258472:     char **cpp;
258489:     char *new;
258505:     int len;
258519:{
258521:  int i, j;
258533:
258534:  if (cpp == NULL)
258553:    return NULL;
258570:  if ((new = icpyalloc(new)) == NULL)
258608:    {
258614:      freelist(cpp);
258635:      return NULL;
258654:    }
258660:  new[len] = '\0';
258679:  /* Is there already something in the list that's new (or longer)? */
258750:  for (i = 0; cpp[i] != NULL; ++i)
258785:    if (istrstr(cpp[i], new) != NULL)
258823:      {
258831:	free(new);
258843:	return cpp;
258856:      }
258864:  /* Eliminate any obsoleted strings. */
258905:  j = 0;
258914:  while (cpp[j] != NULL)
258939:    if (istrstr(new, cpp[j]) == NULL)
258977:      ++j;
258988:    else
258997:      {
259005:	free(cpp[j]);
259020:	if (--i == j)
259035:	  break;
259045:	cpp[j] = cpp[i];
259063:	cpp[i] = NULL;
259079:      }
259087:  /* Add the new string. */
259115:  cpp = (char **) realloc((char *) cpp, (i + 2) * sizeof *cpp);
259179:  if (cpp == NULL)
259198:    return NULL;
259215:  cpp[i] = new;
259231:  cpp[i + 1] = NULL;
259252:  return cpp;
259266:}
259268:
259269:/* Given pointers to two strings, return a pointer to an allocated
259336:   list of their distinct common substrings. Return NULL if something
259406:   seems wild. */
259424:static char **
259439:comsubs(left, right)
259460:     char *left;
259477:     char *right;
259495:{
259497:  char **cpp;
259511:  char *lcp;
259524:  char *rcp;
259537:  int i, len;
259551:
259552:  if (left == NULL || right == NULL)
259589:    return NULL;
259606:  cpp = (char **) malloc(sizeof *cpp);
259645:  if (cpp == NULL)
259664:    return NULL;
259681:  cpp[0] = NULL;
259698:  for (lcp = left; *lcp != '\0'; ++lcp)
259738:    {
259744:      len = 0;
259759:      rcp = index(right, *lcp);
259791:      while (rcp != NULL)
259817:	{
259820:	  for (i = 1; lcp[i] != '\0' && lcp[i] == rcp[i]; ++i)
259876:	    ;
259883:	  if (i > len)
259899:	    len = i;
259913:	  rcp = index(rcp + 1, *lcp);
259944:	}
259947:      if (len == 0)
259967:	continue;
259978:      if ((cpp = enlist(cpp, lcp, len)) == NULL)
260027:	break;
260035:    }
260041:  return cpp;
260055:}
260057:
260058:static char **
260073:addlists(old, new)
260092:char **old;
260104:char **new;
260116:{
260118:  int i;
260127:
260128:  if (old == NULL || new == NULL)
260162:    return NULL;
260179:  for (i = 0; new[i] != NULL; ++i)
260214:    {
260220:      old = enlist(old, new[i], strlen(new[i]));
260269:      if (old == NULL)
260292:	break;
260300:    }
260306:  return old;
260320:}
260322:
260323:/* Given two lists of substrings, return a new list giving substrings
260393:   common to both. */
260415:static char **
260430:inboth(left, right)
260450:     char **left;
260468:     char **right;
260487:{
260489:  char **both;
260504:  char **temp;
260519:  int lnum, rnum;
260537:
260538:  if (left == NULL || right == NULL)
260575:    return NULL;
260592:  both = (char **) malloc(sizeof *both);
260633:  if (both == NULL)
260653:    return NULL;
260670:  both[0] = NULL;
260688:  for (lnum = 0; left[lnum] != NULL; ++lnum)
260733:    {
260739:      for (rnum = 0; right[rnum] != NULL; ++rnum)
260789:	{
260792:	  temp = comsubs(left[lnum], right[rnum]);
260836:	  if (temp == NULL)
260857:	    {
260864:	      freelist(both);
260887:	      return NULL;
260907:	    }
260914:	  both = addlists(both, temp);
260946:	  freelist(temp);
260965:	  if (both == NULL)
260986:	    return NULL;
261004:	}
261007:    }
261013:  return both;
261028:}
261030:
261031:typedef struct
261046:{
261048:  char **in;
261061:  char *left;
261075:  char *right;
261090:  char *is;
261102:} must;
261110:
261111:static void
261123:resetmust(mp)
261137:must *mp;
261147:{
261149:  mp->left[0] = mp->right[0] = mp->is[0] = '\0';
261198:  freelist(mp->in);
261218:}
261220:
261221:static void
261233:dfamust(dfa)
261246:struct dfa *dfa;
261263:{
261265:  must *musts;
261280:  must *mp;
261292:  char *result;
261308:  int ri;
261318:  int i;
261327:  int exact;
261340:  token t;
261351:  static must must0;
261372:  struct dfamust *dm;
261394:
261395:  result = "";
261410:  exact = 0;
261423:  musts = (must *) malloc((dfa->tindex + 1) * sizeof *musts);
261485:  if (musts == NULL)
261506:    return;
261518:  mp = musts;
261532:  for (i = 0; i <= dfa->tindex; ++i)
261569:    mp[i] = must0;
261588:  for (i = 0; i <= dfa->tindex; ++i)
261625:    {
261631:      mp[i].in = (char **) malloc(sizeof *mp[i].in);
261684:      mp[i].left = malloc(2);
261714:      mp[i].right = malloc(2);
261745:      mp[i].is = malloc(2);
261773:      if (mp[i].in == NULL || mp[i].left == NULL ||
261825:	  mp[i].right == NULL || mp[i].is == NULL)
261869:	goto done;
261881:      mp[i].left[0] = mp[i].right[0] = mp[i].is[0] = '\0';
261940:      mp[i].in[0] = NULL;
261966:    }
261972:#ifdef DEBUG
261985:  fprintf(stderr, "dfamust:\n");
262018:  for (i = 0; i < dfa->tindex; ++i)
262054:    {
262060:      fprintf(stderr, " %d:", i);
262094:      prtok(dfa->tokens[i]);
262123:    }
262129:  putc('\n', stderr);
262151:#endif
262158:  for (ri = 0; ri < dfa->tindex; ++ri)
262197:    {
262203:      switch (t = dfa->tokens[ri])
262238:	{
262241:	case LPAREN:
262255:	case RPAREN:
262269:	  goto done;		/* "cannot happen" */
262306:	case EMPTY:
262319:	case BEGLINE:
262334:	case ENDLINE:
262349:	case BEGWORD:
262364:	case ENDWORD:
262379:	case LIMWORD:
262394:	case NOTLIMWORD:
262412:	case BACKREF:
262427:	  resetmust(mp);
262445:	  break;
262455:	case STAR:
262467:	case QMARK:
262480:	  if (mp <= musts)
262500:	    goto done;		/* "cannot happen" */
262539:	  --mp;
262548:	  resetmust(mp);
262566:	  break;
262576:	case OR:
262586:	case ORTOP:
262599:	  if (mp < &musts[2])
262622:	    goto done;		/* "cannot happen" */
262661:	  {
262666:	    char **new;
262683:	    must *lmp;
262699:	    must *rmp;
262715:	    int j, ln, rn, n;
262738:
262739:	    rmp = --mp;
262756:	    lmp = --mp;
262773:	    /* Guaranteed to be.  Unlikely, but. . . */
262822:	    if (strcmp(lmp->is, rmp->is) != 0)
262862:	      lmp->is[0] = '\0';
262888:	    /* Left side--easy */
262915:	    i = 0;
262927:	    while (lmp->left[i] != '\0' && lmp->left[i] == rmp->left[i])
262993:	      ++i;
263005:	    lmp->left[i] = '\0';
263031:	    /* Right side */
263053:	    ln = strlen(lmp->right);
263083:	    rn = strlen(rmp->right);
263113:	    n = ln;
263126:	    if (n > rn)
263143:	      n = rn;
263158:	    for (i = 0; i < n; ++i)
263187:	      if (lmp->right[ln - i - 1] != rmp->right[rn - i - 1])
263248:		break;
263257:	    for (j = 0; j < i; ++j)
263286:	      lmp->right[j] = lmp->right[(ln - i) + j];
263335:	    lmp->right[j] = '\0';
263362:	    new = inboth(lmp->in, rmp->in);
263399:	    if (new == NULL)
263421:	      goto done;
263439:	    freelist(lmp->in);
263463:	    free((char *) lmp->in);
263492:	    lmp->in = new;
263512:	  }
263517:	  break;
263527:	case PLUS:
263539:	  if (mp <= musts)
263559:	    goto done;		/* "cannot happen" */
263598:	  --mp;
263607:	  mp->is[0] = '\0';
263628:	  break;
263638:	case END:
263649:	  if (mp != &musts[1])
263673:	    goto done;		/* "cannot happen" */
263712:	  for (i = 0; musts[0].in[i] != NULL; ++i)
263756:	    if (strlen(musts[0].in[i]) > strlen(result))
263806:	      result = musts[0].in[i];
263838:	  if (strcmp(result, musts[0].is) == 0)
263879:	    exact = 1;
263895:	  goto done;
263909:	case CAT:
263920:	  if (mp < &musts[2])
263943:	    goto done;		/* "cannot happen" */
263982:	  {
263987:	    must *lmp;
264003:	    must *rmp;
264019:
264020:	    rmp = --mp;
264037:	    lmp = --mp;
264054:	    /* In.  Everything in left, plus everything in
264106:	       right, plus catenation of
264140:	       left's right and right's left. */
264182:	    lmp->in = addlists(lmp->in, rmp->in);
264225:	    if (lmp->in == NULL)
264251:	      goto done;
264269:	    if (lmp->right[0] != '\0' &&
264303:		rmp->left[0] != '\0')
264327:	      {
264336:		char *tp;
264348:
264349:		tp = icpyalloc(lmp->right);
264379:		if (tp == NULL)
264397:		  goto done;
264412:		tp = icatalloc(tp, rmp->left);
264445:		if (tp == NULL)
264463:		  goto done;
264478:		lmp->in = enlist(lmp->in, tp,
264510:				 strlen(tp));
264528:		free(tp);
264540:		if (lmp->in == NULL)
264563:		  goto done;
264578:	      }
264587:	    /* Left-hand */
264608:	    if (lmp->is[0] != '\0')
264637:	      {
264646:		lmp->left = icatalloc(lmp->left,
264681:				      rmp->left);
264703:		if (lmp->left == NULL)
264728:		  goto done;
264743:	      }
264752:	    /* Right-hand */
264774:	    if (rmp->is[0] == '\0')
264803:	      lmp->right[0] = '\0';
264832:	    lmp->right = icatalloc(lmp->right, rmp->right);
264885:	    if (lmp->right == NULL)
264914:	      goto done;
264932:	    /* Guaranteed to be */
264960:	    if (lmp->is[0] != '\0' && rmp->is[0] != '\0')
265011:	      {
265020:		lmp->is = icatalloc(lmp->is, rmp->is);
265061:		if (lmp->is == NULL)
265084:		  goto done;
265099:	      }
265108:	    else
265118:	      lmp->is[0] = '\0';
265144:	  }
265149:	  break;
265159:	default:
265169:	  if (t < END)
265185:	    {
265192:	      /* "cannot happen" */
265221:	      goto done;
265239:	    }
265246:	  else if (t == '\0')
265269:	    {
265276:	      /* not on *my* shift */
265307:	      goto done;
265325:	    }
265332:	  else if (t >= CSET)
265355:	    {
265362:	      /* easy enough */
265387:	      resetmust(mp);
265409:	    }
265416:	  else
265424:	    {
265431:	      /* plain character */
265460:	      resetmust(mp);
265482:	      mp->is[0] = mp->left[0] = mp->right[0] = t;
265533:	      mp->is[1] = mp->left[1] = mp->right[1] = '\0';
265587:	      mp->in = enlist(mp->in, mp->is, 1);
265630:	      if (mp->in == NULL)
265657:		goto done;
265670:	    }
265677:	  break;
265687:	}
265690:#ifdef DEBUG
265703:      fprintf(stderr, " node: %d:", ri);
265744:      prtok(dfa->tokens[ri]);
265774:      fprintf(stderr, "\n  in:");
265808:      for (i = 0; mp->in[i]; ++i)
265842:	fprintf(stderr, " \"%s\"", mp->in[i]);
265882:      fprintf(stderr, "\n  is: \"%s\"\n", mp->is);
265933:      fprintf(stderr, "  left: \"%s\"\n", mp->left);
265986:      fprintf(stderr, "  right: \"%s\"\n", mp->right);
266041:#endif
266048:      ++mp;
266060:    }
266066: done:
266073:  if (strlen(result))
266095:    {
266101:      dm = (struct dfamust *) malloc(sizeof (struct dfamust));
266164:      dm->exact = exact;
266189:      dm->must = malloc(strlen(result) + 1);
266234:      strcpy(dm->must, result);
266266:      dm->next = dfa->musts;
266295:      dfa->musts = dm;
266318:    }
266324:  mp = musts;
266338:  for (i = 0; i <= dfa->tindex; ++i)
266375:    {
266381:      freelist(mp[i].in);
266407:      ifree((char *) mp[i].in);
266439:      ifree(mp[i].left);
266464:      ifree(mp[i].right);
266490:      ifree(mp[i].is);
266513:    }
266519:  free((char *) mp);
266540:}
266542:/* kwset.c - search for any of a set of keywords.
266592:   Copyright 1989 Free Software Foundation
266635:		  Written August 1989 by Mike Haertel.
266676:
266677:   This program is free software; you can redistribute it and/or modify
266749:   it under the terms of the GNU General Public License as published by
266821:   the Free Software Foundation; either version 1, or (at your option)
266892:   any later version.
266914:
266915:   This program is distributed in the hope that it will be useful,
266982:   but WITHOUT ANY WARRANTY; without even the implied warranty of
267048:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
267113:   GNU General Public License for more details.
267161:
267162:   You should have received a copy of the GNU General Public License
267231:   along with this program; if not, write to the Free Software
267294:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
267355:
267356:   The author may be reached (Email) at the address mike@ai.mit.edu,
267425:   or (US mail) as Mike Haertel c/o Free Software Foundation. */
267490:
267491:/* The algorithm implemented by these routines bears a startling resemblence
267568:   to one discovered by Beate Commentz-Walter, although it is not identical.
267645:   See "A String Matching Algorithm Fast on the Average," Technical Report,
267721:   IBM-Germany, Scientific Center Heidelberg, Tiergartenstrasse 15, D-6900
267796:   Heidelberg, Germany.  See also Aho, A.V., and M. Corasick, "Efficient
267869:   String Matching:  An Aid to Bibliographic Search," CACM June 1975,
267939:   Vol. 18, No. 6, which describes the failure function used below. */
268010:
268011:
268012:#ifdef STDC_HEADERS
268032:#undef RE_DUP_MAX
268070:#define flag_limits 1
268092:#if flag_stdlib==0 
268132:#define flag_stdlib 1
268154:#endif
268161:#else
268167:#define INT_MAX 2147483647
268194:#define UCHAR_MAX 255
268216:#ifdef __STDC__
268252:#else
268258:#if flag_systypes==0
268302:#define flag_systypes 1
268326:#endif
268333:#endif
268340:extern char *malloc();
268363:extern void free();
268383:#endif
268390:
268391:#ifdef HAVE_MEMCHR
268410:#if flag_string==0
268449:#define flag_string 1
268471:#endif
268478:#ifdef NEED_MEMORY_H
268499:#if flag_memory==0
268538:#define flag_memory 1
268560:#endif
268567:#endif
268574:#else
268580:#ifdef __STDC__
268596:extern void *memchr();
268619:#else
268625:extern char *memchr();
268648:#endif
268655:#endif
268662:
268663:#ifdef GREP
268675:extern char *xmalloc();
268699:#define malloc xmalloc
268722:#endif
268729:
268770:
268771:#define NCHAR (UCHAR_MAX + 1)
268801:#define obstack_chunk_alloc malloc
268836:#define obstack_chunk_free free
268868:
268869:/* Balanced tree of edges and labels leaving a given trie node. */
268936:struct tree
268948:{
268950:  struct tree *llink;		/* Left link; MUST be first field. */
269011:  struct tree *rlink;		/* Right link (to larger labels). */
269071:  struct trie *trie;		/* Trie node pointed to by this edge. */
269134:  unsigned char label;		/* Label on this edge. */
269184:  char balance;			/* Difference in depths of subtrees. */
269242:};
269245:
269246:/* Node of a trie representing a set of reversed keywords. */
269308:struct trie
269320:{
269322:  unsigned int accepting;	/* Word index of accepted word, or zero. */
269392:  struct tree *links;		/* Tree of edges leaving this node. */
269454:  struct trie *parent;		/* Parent of this node. */
269505:  struct trie *next;		/* List of all trie nodes in level order. */
269572:  struct trie *fail;		/* Aho-Corasick failure function. */
269631:  int depth;			/* Depth of this node from the root. */
269686:  int shift;			/* Shift function for search failures. */
269743:  int maxshift;			/* Max shift of self and descendents. */
269802:};
269805:
269806:/* Structure returned opaquely to the caller, containing everything. */
269878:struct kwset
269891:{
269893:  struct obstack obstack;	/* Obstack for node allocation. */
269954:  int words;			/* Number of words in the trie. */
270004:  struct trie *trie;		/* The trie itself. */
270049:  int mind;			/* Minimum depth of an accepting node. */
270105:  int maxd;			/* Maximum depth of any node. */
270152:  unsigned char delta[NCHAR];	/* Delta table for rapid search. */
270218:  struct trie *next[NCHAR];	/* Table of children of the root. */
270283:  char *target;			/* Target string if there's only one. */
270342:  int mind2;			/* Used in Boyer-Moore search for one string. */
270406:  char *trans;			/* Character translation table. */
270458:};
270461:
270462:/* Allocate and initialize a keyword set object, returning an opaque
270531:   pointer to it.  Return NULL if memory is not available. */
270593:kwset_t
270601:kwsalloc(trans)
270617:     char *trans;
270635:{
270637:  struct kwset *kwset;
270660:
270661:  kwset = (struct kwset *) malloc(sizeof (struct kwset));
270719:  if (!kwset)
270733:    return 0;
270747:
270748:  obstack_init(&kwset->obstack);
270781:  kwset->words = 0;
270801:  kwset->trie
270815:    = (struct trie *) obstack_alloc(&kwset->obstack, sizeof (struct trie));
270891:  if (!kwset->trie)
270911:    {
270917:      kwsfree((kwset_t) kwset);
270949:      return 0;
270965:    }
270971:  kwset->trie->accepting = 0;
271001:  kwset->trie->links = 0;
271027:  kwset->trie->parent = 0;
271054:  kwset->trie->next = 0;
271079:  kwset->trie->fail = 0;
271104:  kwset->trie->depth = 0;
271130:  kwset->trie->shift = 0;
271156:  kwset->mind = INT_MAX;
271181:  kwset->maxd = -1;
271201:  kwset->target = 0;
271222:  kwset->trans = trans;
271246:
271247:  return (kwset_t) kwset;
271273:}
271275:
271276:/* Add the given string to the contents of the keyword set.  Return NULL
271349:   for success, an error message otherwise. */
271396:char *
271403:kwsincr(kws, text, len)
271427:     kwset_t kws;
271445:     char *text;
271462:     size_t len;
271479:{
271481:  struct kwset *kwset;
271504:  register struct trie *trie;
271534:  register unsigned char label;
271566:  register struct tree *link;
271596:  register int depth;
271618:  struct tree *links[12];
271644:  enum { L, R } dirs[12];
271670:  struct tree *t, *r, *l, *rl, *lr;
271706:
271707:  kwset = (struct kwset *) kws;
271739:  trie = kwset->trie;
271761:  text += len;
271776:
271777:  /* Descend the trie (built of reversed keywords) character-by-character,
271852:     installing new nodes when necessary. */
271897:  while (len--)
271913:    {
271919:      label = kwset->trans ? kwset->trans[(unsigned char) *--text] : *--text;
271997:
271998:      /* Descend the tree of outgoing links for this trie node,
272062:	 looking for the current character and keeping track
272116:	 of the path followed. */
272143:      link = trie->links;
272169:      links[0] = (struct tree *) &trie->links;
272216:      dirs[0] = L;
272235:      depth = 1;
272252:
272253:      while (link && label != link->label)
272296:	{
272299:	  links[depth] = link;
272323:	  if (label < link->label)
272351:	    dirs[depth++] = L, link = link->llink;
272395:	  else
272403:	    dirs[depth++] = R, link = link->rlink;
272447:	}
272450:
272451:      /* The current character doesn't have an outgoing link at
272515:	 this trie node, so build a new trie node and install
272570:	 a link in the current trie node's tree. */
272615:      if (!link)
272632:	{
272635:	  link = (struct tree *) obstack_alloc(&kwset->obstack,
272692:					       sizeof (struct tree));
272727:	  if (!link)
272741:	    return "memory exhausted";
272773:	  link->llink = 0;
272793:	  link->rlink = 0;
272813:	  link->trie = (struct trie *) obstack_alloc(&kwset->obstack,
272876:						     sizeof (struct trie));
272910:	  if (!link->trie)
272930:	    return "memory exhausted";
272962:	  link->trie->accepting = 0;
272992:	  link->trie->links = 0;
273018:	  link->trie->parent = trie;
273048:	  link->trie->next = 0;
273073:	  link->trie->fail = 0;
273098:	  link->trie->depth = trie->depth + 1;
273138:	  link->trie->shift = 0;
273164:	  link->label = label;
273188:	  link->balance = 0;
273210:
273211:	  /* Install the new tree node in its parent. */
273261:	  if (dirs[--depth] == L)
273288:	    links[depth]->llink = link;
273321:	  else
273329:	    links[depth]->rlink = link;
273362:
273363:	  /* Back up the tree fixing the balance flags. */
273415:	  while (depth && !links[depth]->balance)
273458:	    {
273465:	      if (dirs[depth] == L)
273494:		--links[depth]->balance;
273521:	      else
273533:		++links[depth]->balance;
273560:	      --depth;
273576:	    }
273583:
273584:	  /* Rebalance the tree by pointer rotations if necessary. */
273647:	  if (depth && ((dirs[depth] == L && --links[depth]->balance)
273710:			|| (dirs[depth] == R && ++links[depth]->balance)))
273764:	    {
273771:	      switch (links[depth]->balance)
273809:		{
273813:		case (char) -2:
273831:		  switch (dirs[depth + 1])
273860:		    {
273868:		    case L:
273882:		      r = links[depth], t = r->llink, rl = t->rlink;
273937:		      t->rlink = r, r->llink = rl;
273974:		      t->balance = r->balance = 0;
274011:		      break;
274026:		    case R:
274040:		      r = links[depth], l = r->llink, t = l->rlink;
274094:		      rl = t->rlink, lr = t->llink;
274132:		      t->llink = l, l->rlink = lr, t->rlink = r, r->llink = rl;
274198:		      l->balance = t->balance != 1 ? 0 : -1;
274245:		      r->balance = t->balance != (char) -1 ? 0 : 1;
274299:		      t->balance = 0;
274323:		      break;
274338:		    }
274346:		  break;
274357:		case 2:
274367:		  switch (dirs[depth + 1])
274396:		    {
274404:		    case R:
274418:		      l = links[depth], t = l->rlink, lr = t->llink;
274473:		      t->llink = l, l->rlink = lr;
274510:		      t->balance = l->balance = 0;
274547:		      break;
274562:		    case L:
274576:		      l = links[depth], r = l->rlink, t = r->llink;
274630:		      lr = t->llink, rl = t->rlink;
274668:		      t->llink = l, l->rlink = lr, t->rlink = r, r->llink = rl;
274734:		      l->balance = t->balance != 1 ? 0 : -1;
274781:		      r->balance = t->balance != (char) -1 ? 0 : 1;
274835:		      t->balance = 0;
274859:		      break;
274874:		    }
274882:		  break;
274893:		}
274897:
274898:	      if (dirs[depth - 1] == L)
274931:		links[depth - 1]->llink = t;
274962:	      else
274974:		links[depth - 1]->rlink = t;
275005:	    }
275012:	}
275015:
275016:      trie = link->trie;
275041:    }
275047:
275048:  /* Mark the node we finally reached as accepting, encoding the
275113:     index number of this word in the keyword set so far. */
275174:  if (!trie->accepting)
275198:    trie->accepting = 1 + 2 * kwset->words;
275242:  ++kwset->words;
275260:
275261:  /* Keep track of the longest and shortest string of the keyword set. */
275335:  if (trie->depth < kwset->mind)
275368:    kwset->mind = trie->depth;
275399:  if (trie->depth > kwset->maxd)
275432:    kwset->maxd = trie->depth;
275463:
275464:  return 0;
275476:}
275478:
275479:/* Enqueue the trie nodes referenced from the given tree in the
275543:   given queue. */
275562:static void
275574:enqueue(tree, last)
275594:     struct tree *tree;
275618:     struct trie **last;
275643:{
275645:  if (!tree)
275658:    return;
275670:  enqueue(tree->llink, last);
275700:  enqueue(tree->rlink, last);
275730:  (*last) = (*last)->next = tree->trie;
275770:}
275772:
275773:/* Compute the Aho-Corasick failure function for the trie nodes referenced
275848:   from the given tree, given the failure function for their parent as
275919:   well as a last resort failure node. */
275961:static void
275973:treefails(tree, fail, recourse)
276005:     register struct tree *tree;
276038:     struct trie *fail;
276062:     struct trie *recourse;
276090:{
276092:  register struct tree *link;
276122:
276123:  if (!tree)
276136:    return;
276148:
276149:  treefails(tree->llink, fail, recourse);
276191:  treefails(tree->rlink, fail, recourse);
276233:
276234:  /* Find, in the chain of fails going back to the root, the first
276301:     node that has a descendent on the current label. */
276358:  while (fail)
276373:    {
276379:      link = fail->links;
276405:      while (link && tree->label != link->label)
276454:	if (tree->label < link->label)
276486:	  link = link->llink;
276509:	else
276515:	  link = link->rlink;
276538:      if (link)
276554:	{
276557:	  tree->trie->fail = link->trie;
276591:	  return;
276602:	}
276605:      fail = fail->fail;
276630:    }
276636:
276637:  tree->trie->fail = recourse;
276668:}
276670:
276671:/* Set delta entries for the links of the given tree such that
276734:   the preexisting delta value is larger than the current depth. */
276802:static void
276814:treedelta(tree, depth, delta)
276844:     register struct tree *tree;
276877:     register unsigned int depth;
276911:     unsigned char delta[];
276939:{
276941:  if (!tree)
276954:    return;
276966:  treedelta(tree->llink, depth, delta);
277006:  treedelta(tree->rlink, depth, delta);
277046:  if (depth < delta[tree->label])
277080:    delta[tree->label] = depth;
277112:}
277114:
277115:/* Return true if A has every label in B. */
277160:static int
277171:hasevery(a, b)
277186:     register struct tree *a;
277216:     register struct tree *b;
277246:{
277248:  if (!b)
277258:    return 1;
277272:  if (!hasevery(a, b->llink))
277302:    return 0;
277316:  if (!hasevery(a, b->rlink))
277346:    return 0;
277360:  while (a && b->label != a->label)
277396:    if (b->label < a->label)
277425:      a = a->llink;
277445:    else
277454:      a = a->rlink;
277474:  return !!a;
277488:}
277490:
277491:/* Compute a vector, indexed by character code, of the trie nodes
277557:   referenced from the given tree. */
277595:static void
277607:treenext(tree, next)
277628:     struct tree *tree;
277652:     struct trie *next[];
277678:{
277680:  if (!tree)
277693:    return;
277705:  treenext(tree->llink, next);
277736:  treenext(tree->rlink, next);
277767:  next[tree->label] = tree->trie;
277801:}
277803:
277804:/* Compute the shift for each trie node, as well as the delta
277866:   table and next cache for the given keyword set. */
277920:char *
277927:kwsprep(kws)
277940:     kwset_t kws;
277958:{
277960:  register struct kwset *kwset;
277992:  register int i;
278010:  register struct trie *curr, *fail;
278047:  register char *trans;
278071:  unsigned char delta[NCHAR];
278101:  struct trie *last, *next[NCHAR];
278136:
278137:  kwset = (struct kwset *) kws;
278169:
278170:  /* Initial values for the delta table; will be changed later.  The
278239:     delta entry for a given character is the smallest depth of any
278307:     node at which an outgoing edge is labeled by that character. */
278376:  if (kwset->mind < 256)
278401:    for (i = 0; i < NCHAR; ++i)
278433:      delta[i] = kwset->mind;
278463:  else
278470:    for (i = 0; i < NCHAR; ++i)
278502:      delta[i] = 255;
278524:
278525:  /* Check if we can use the simple boyer-moore algorithm, instead
278592:     of the hairy commentz-walter algorithm. */
278640:  if (kwset->words == 1 && kwset->trans == 0)
278686:    {
278692:      /* Looking for just one string.  Extract it from the trie. */
278760:      kwset->target = obstack_alloc(&kwset->obstack, kwset->mind);
278827:      for (i = kwset->mind - 1, curr = kwset->trie; i >= 0; --i)
278892:	{
278895:	  kwset->target[i] = curr->links->label;
278937:	  curr = curr->links->trie;
278966:	}
278969:      /* Build the Boyer Moore delta.  Boy that's easy compared to CW. */
279043:      for (i = 0; i < kwset->mind; ++i)
279083:	delta[(unsigned char) kwset->target[i]] = kwset->mind - (i + 1);
279149:      kwset->mind2 = kwset->mind;
279183:      /* Find the minimal delta2 shift that we might make after
279247:	 a backwards match has failed. */
279282:      for (i = 0; i < kwset->mind - 1; ++i)
279326:	if (kwset->target[i] == kwset->target[kwset->mind - 1])
279383:	  kwset->mind2 = kwset->mind - (i + 1);
279424:    }
279430:  else
279437:    {
279443:      /* Traverse the nodes of the trie in level order, simultaneously
279514:	 computing the delta table, failure function, and shift function. */
279584:      for (curr = last = kwset->trie; curr; curr = curr->next)
279647:	{
279650:	  /* Enqueue the immediate descendents in the level order queue. */
279719:	  enqueue(curr->links, &last);
279751:
279752:	  curr->shift = kwset->mind;
279782:	  curr->maxshift = kwset->mind;
279815:
279816:	  /* Update the delta table for the descendents of this node. */
279882:	  treedelta(curr->links, curr->depth, delta);
279929:
279930:	  /* Compute the failure function for the decendents of this node. */
280001:	  treefails(curr->links, curr->fail, kwset->trie);
280053:
280054:	  /* Update the shifts at each node in the current node's chain
280119:	     of fails back to the root. */
280155:	  for (fail = curr->fail; fail; fail = fail->fail)
280207:	    {
280214:	      /* If the current node has some outgoing edge that the fail
280281:		 doesn't, then the shift at the fail should be no larger
280340:		 than the difference of their depths. */
280383:	      if (!hasevery(fail->links, curr->links))
280431:		if (curr->depth - fail->depth < fail->shift)
280478:		  fail->shift = curr->depth - fail->depth;
280523:
280524:	      /* If the current node is accepting then the shift at the
280589:		 fail and its descendents should be no larger than the
280646:		 difference of their depths. */
280680:	      if (curr->accepting && fail->maxshift > curr->depth - fail->depth)
280754:		fail->maxshift = curr->depth - fail->depth;
280800:	    }
280807:	}
280810:
280811:      /* Traverse the trie in level order again, fixing up all nodes whose
280886:	 shift exceeds their inherited maxshift. */
280931:      for (curr = kwset->trie->next; curr; curr = curr->next)
280993:	{
280996:	  if (curr->maxshift > curr->parent->maxshift)
281044:	    curr->maxshift = curr->parent->maxshift;
281090:	  if (curr->shift > curr->maxshift)
281127:	    curr->shift = curr->maxshift;
281162:	}
281165:
281166:      /* Create a vector, indexed by character code, of the outgoing links
281241:	 from the root node. */
281266:      for (i = 0; i < NCHAR; ++i)
281300:	next[i] = 0;
281314:      treenext(kwset->trie->links, next);
281356:
281357:      if ((trans = kwset->trans) != 0)
281396:	for (i = 0; i < NCHAR; ++i)
281425:	  kwset->next[i] = next[(unsigned char) trans[i]];
281477:      else
281488:	for (i = 0; i < NCHAR; ++i)
281517:	  kwset->next[i] = next[i];
281546:    }
281552:
281553:  /* Fix things up for any translation table. */
281602:  if ((trans = kwset->trans) != 0)
281637:    for (i = 0; i < NCHAR; ++i)
281669:      kwset->delta[i] = delta[(unsigned char) trans[i]];
281726:  else
281733:    for (i = 0; i < NCHAR; ++i)
281765:      kwset->delta[i] = delta[i];
281799:
281800:  return 0;
281812:}
281814:
281815:#define U(C) ((unsigned char) (C))
281850:
281851:/* Fast boyer-moore search. */
281882:static char *
281896:bmexec(kws, text, size)
281920:     kwset_t kws;
281938:     char *text;
281955:     size_t size;
281973:{
281975:  struct kwset *kwset;
281998:  register unsigned char *d1;
282028:  register char *ep, *sp, *tp;
282059:  register int d, gc, i, len, md2;
282094:
282095:  kwset = (struct kwset *) kws;
282127:  len = kwset->mind;
282148:
282149:  if (len == 0)
282165:    return text;
282182:  if (len > size)
282200:    return 0;
282214:  if (len == 1)
282230:    return memchr(text, kwset->target[0], size);
282279:
282280:  d1 = kwset->delta;
282301:  sp = kwset->target + len;
282329:  gc = U(sp[-2]);
282347:  md2 = kwset->mind2;
282369:  tp = text + len;
282388:
282389:  /* Significance of 12: 1 (initial offset) + 10 (skip loop) + 1 (md2). */
282464:  if (size > 12 * len)
282487:    /* 11 is not a bug, the initial offset happens only once. */
282552:    for (ep = text + size - 11 * len;;)
282592:      {
282600:	while (tp <= ep)
282618:	  {
282623:	    d = d1[U(tp[-1])], tp += d;
282656:	    d = d1[U(tp[-1])], tp += d;
282689:	    if (d == 0)
282706:	      goto found;
282725:	    d = d1[U(tp[-1])], tp += d;
282758:	    d = d1[U(tp[-1])], tp += d;
282791:	    d = d1[U(tp[-1])], tp += d;
282824:	    if (d == 0)
282841:	      goto found;
282860:	    d = d1[U(tp[-1])], tp += d;
282893:	    d = d1[U(tp[-1])], tp += d;
282926:	    d = d1[U(tp[-1])], tp += d;
282959:	    if (d == 0)
282976:	      goto found;
282995:	    d = d1[U(tp[-1])], tp += d;
283028:	    d = d1[U(tp[-1])], tp += d;
283061:	  }
283066:	break;
283074:      found:
283087:	if (U(tp[-2]) == gc)
283109:	  {
283114:	    for (i = 3; i <= len && U(tp[-i]) == U(sp[-i]); ++i)
283172:	      ;
283181:	    if (i > len)
283199:	      return tp - len;
283223:	  }
283228:	tp += md2;
283240:      }
283248:
283249:  /* Now we have only a few characters left to search.  We
283308:     carefully avoid ever producing an out-of-bounds pointer. */
283373:  ep = text + size;
283393:  d = d1[U(tp[-1])];
283414:  while (d <= ep - tp)
283437:    {
283443:      d = d1[U((tp += d)[-1])];
283475:      if (d != 0)
283493:	continue;
283504:      if (tp[-2] == gc)
283528:	{
283531:	  for (i = 3; i <= len && U(tp[-i]) == U(sp[-i]); ++i)
283587:	    ;
283594:	  if (i > len)
283610:	    return tp - len;
283632:	}
283635:      d = md2;
283650:    }
283656:
283657:  return 0;
283669:}
283671:
283672:/* Hairy multiple string search. */
283708:static char *
283722:cwexec(kws, text, len, kwsmatch)
283755:     kwset_t kws;
283773:     char *text;
283790:     size_t len;
283807:     struct kwsmatch *kwsmatch;
283839:{
283841:  struct kwset *kwset;
283864:  struct trie **next, *trie, *accept;
283902:  char *beg, *lim, *mch, *lmch;
283934:  register unsigned char c, *delta;
283970:  register int d;
283988:  register char *end, *qlim;
284017:  register struct tree *tree;
284047:  register char *trans;
284071:
284072:  /* Initialize register copies and look for easy ways out. */
284135:  kwset = (struct kwset *) kws;
284167:  if (len < kwset->mind)
284192:    return 0;
284206:  next = kwset->next;
284228:  delta = kwset->delta;
284252:  trans = kwset->trans;
284276:  lim = text + len;
284296:  end = text;
284310:  if ((d = kwset->mind) != 0)
284340:    mch = 0;
284353:  else
284360:    {
284366:      mch = text, accept = kwset->trie;
284406:      goto match;
284424:    }
284430:
284431:  if (len >= 4 * kwset->mind)
284461:    qlim = lim - 4 * kwset->mind;
284495:  else
284502:    qlim = 0;
284516:
284517:  while (lim - end >= d)
284542:    {
284548:      if (qlim && end <= qlim)
284579:	{
284582:	  end += d - 1;
284599:	  while ((d = delta[c = *end]) && end < qlim)
284646:	    {
284653:	      end += d;
284670:	      end += delta[(unsigned char) *end];
284713:	      end += delta[(unsigned char) *end];
284756:	    }
284763:	  ++end;
284773:	}
284776:      else
284787:	d = delta[c = (end += d)[-1]];
284819:      if (d)
284832:	continue;
284843:      beg = end - 1;
284864:      trie = next[c];
284886:      if (trie->accepting)
284913:	{
284916:	  mch = beg;
284930:	  accept = trie;
284948:	}
284951:      d = trie->shift;
284974:      while (beg > text)
284999:	{
285002:	  c = trans ? trans[(unsigned char) *--beg] : *--beg;
285057:	  tree = trie->links;
285080:	  while (tree && c != tree->label)
285116:	    if (c < tree->label)
285142:	      tree = tree->llink;
285169:	    else
285179:	      tree = tree->rlink;
285206:	  if (tree)
285219:	    {
285226:	      trie = tree->trie;
285252:	      if (trie->accepting)
285280:		{
285284:		  mch = beg;
285299:		  accept = trie;
285318:		}
285322:	    }
285329:	  else
285337:	    break;
285349:	  d = trie->shift;
285369:	}
285372:      if (mch)
285387:	goto match;
285400:    }
285406:  return 0;
285418:
285419: match:
285427:  /* Given a known match, find the longest possible match anchored
285494:     at or before its starting point.  This is nearly a verbatim
285559:     copy of the preceding main search loops. */
285608:  if (lim - mch > kwset->maxd)
285639:    lim = mch + kwset->maxd;
285668:  lmch = 0;
285680:  d = 1;
285689:  while (lim - end >= d)
285714:    {
285720:      if ((d = delta[c = (end += d)[-1]]) != 0)
285768:	continue;
285779:      beg = end - 1;
285800:      if (!(trie = next[c]))
285829:	{
285832:	  d = 1;
285842:	  continue;
285855:	}
285858:      if (trie->accepting && beg <= mch)
285899:	{
285902:	  lmch = beg;
285917:	  accept = trie;
285935:	}
285938:      d = trie->shift;
285961:      while (beg > text)
285986:	{
285989:	  c = trans ? trans[(unsigned char) *--beg] : *--beg;
286044:	  tree = trie->links;
286067:	  while (tree && c != tree->label)
286103:	    if (c < tree->label)
286129:	      tree = tree->llink;
286156:	    else
286166:	      tree = tree->rlink;
286193:	  if (tree)
286206:	    {
286213:	      trie = tree->trie;
286239:	      if (trie->accepting && beg <= mch)
286281:		{
286285:		  lmch = beg;
286301:		  accept = trie;
286320:		}
286324:	    }
286331:	  else
286339:	    break;
286351:	  d = trie->shift;
286371:	}
286374:      if (lmch)
286390:	{
286393:	  mch = lmch;
286408:	  goto match;
286423:	}
286426:      if (!d)
286440:	d = 1;
286448:    }
286454:
286455:  if (kwsmatch)
286471:    {
286477:      kwsmatch->index = accept->accepting / 2;
286524:      kwsmatch->beg[0] = mch;
286554:      kwsmatch->size[0] = accept->depth;
286595:    }
286601:  return mch;
286615:}
286617:  
286620:/* Search through the given text for a match of any member of the
286686:   given keyword set.  Return a pointer to the first character of
286752:   the matching substring, or NULL if no match is found.  If FOUNDLEN
286822:   is non-NULL store in the referenced location the length of the
286888:   matching substring.  Similarly, if FOUNDIDX is non-NULL, store
286954:   in the referenced location the index number of the particular
287019:   keyword matched. */
287042:char *
287049:kwsexec(kws, text, size, kwsmatch)
287084:     kwset_t kws;
287102:     char *text;
287119:     size_t size;
287137:     struct kwsmatch *kwsmatch;
287169:{
287171:  struct kwset *kwset;
287194:  char *ret;
287207:
287208:  kwset = (struct kwset *) kws;
287240:  if (kwset->words == 1 && kwset->trans == 0)
287286:    {
287292:      ret = bmexec(kws, text, size);
287329:      if (kwsmatch != 0 && ret != 0)
287366:	{
287369:	  kwsmatch->index = 0;
287393:	  kwsmatch->beg[0] = ret;
287420:	  kwsmatch->size[0] = kwset->mind;
287456:	}
287459:      return ret;
287477:    }
287483:  else
287490:    return cwexec(kws, text, size, kwsmatch);
287536:}
287538:
287539:/* Free the components of the given keyword set. */
287591:void
287596:kwsfree(kws)
287609:     kwset_t kws;
287627:{
287629:  struct kwset *kwset;
287652:
287653:  kwset = (struct kwset *) kws;
287685:  obstack_free(&kwset->obstack, 0);
287721:  free(kws);
287734:}
287736:/* obstack.c - subroutines used implicitly by object stack macros
287802:   Copyright (C) 1988, 1993 Free Software Foundation, Inc.
287861:
287862:This program is free software; you can redistribute it and/or modify it
287934:under the terms of the GNU General Public License as published by the
288004:Free Software Foundation; either version 2, or (at your option) any
288072:later version.
288087:
288088:This program is distributed in the hope that it will be useful,
288152:but WITHOUT ANY WARRANTY; without even the implied warranty of
288215:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
288277:GNU General Public License for more details.
288322:
288323:You should have received a copy of the GNU General Public License
288389:along with this program; if not, write to the Free Software
288449:Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
288505:
288531:
288532:/* This is just to get __GNU_LIBRARY__ defined.  */
288607:
288608:/* Comment out all this code if we are using the GNU C Library, and are not
288684:   actually compiling the library itself.  This code is part of the GNU C
288832:   and linking in this code is a waste when using the GNU C library
288900:   (especially if it is a shared library).  Rather than having every GNU
288973:   program understand `configure --with-gnu-libc' and omit the object files,
289050:   it is simpler to just do this in the source for each such file.  */
289121:
289122:#if defined (_LIBC) || !defined (__GNU_LIBRARY__)
289172:
289173:
289174:#ifdef __STDC__
289190:#define POINTER void *
289213:#else
289219:#define POINTER char *
289242:#endif
289249:
289250:/* Determine default alignment.  */
289286:struct fooalign {char x; double d;};
289323:#define DEFAULT_ALIGNMENT  \
289352:  ((PTR_INT_TYPE) ((char *)&((struct fooalign *) 0)->d - (char *)0))
289421:/* If malloc were really smart, it would round addresses to DEFAULT_ALIGNMENT.
289500:   But in fact it might be less smart and round addresses to as much as
289572:   DEFAULT_ROUNDING.  So we prepare for it to do that.  */
289631:union fooround {long x; double d;};
289667:#define DEFAULT_ROUNDING (sizeof (union fooround))
289718:
289719:/* When we copy a long block of data, this is the unit to do it with.
289789:   On some machines, copying successive ints does not work;
289849:   in such a case, redefine COPYING_UNIT to `long' (if that works)
289916:   or `char' as a last resort.  */
289951:#ifndef COPYING_UNIT
289972:#define COPYING_UNIT int
289997:#endif
290004:
290005:/* The non-GNU-C macros copy the obstack into this global variable
290072:   to avoid multiple evaluation.  */
290109:
290110:struct obstack *_obstack;
290136:
290137:/* Define a macro that either calls functions with the traditional malloc/free
290216:   calling interface, or calls functions with the mmalloc/mfree interface
290290:   (that adds an extra first argument), based on the state of use_extra_arg.
290367:   For free, do not use ?:, since some compilers, like the MIPS compilers,
290442:   do not allow (expr) ? void : void.  */
290484:
290485:#define CALL_CHUNKFUN(h, size) \
290518:  (((h) -> use_extra_arg) \
290546:   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
290595:   : (*(h)->chunkfun) ((size)))
290627:
290628:#define CALL_FREEFUN(h, old_chunk) \
290665:  do { \
290674:    if ((h) -> use_extra_arg) \
290706:      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
290761:    else \
290772:      (*(h)->freefun) ((old_chunk)); \
290811:  } while (0)
290825:
290826:
290828:/* Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).
290908:   Objects start on multiples of ALIGNMENT (0 means use default).
290974:   CHUNKFUN is the function to use to allocate chunks,
291029:   and FREEFUN the function to free them.  */
291075:
291076:void
291081:_obstack_begin (h, size, alignment, chunkfun, freefun)
291136:     struct obstack *h;
291160:     int size;
291175:     int alignment;
291195:     POINTER (*chunkfun) ();
291224:     void (*freefun) ();
291249:{
291251:  register struct _obstack_chunk* chunk; /* points to new chunk */
291318:
291319:  if (alignment == 0)
291341:    alignment = DEFAULT_ALIGNMENT;
291376:  if (size == 0)
291393:    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
291466:    {
291472:      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
291534:	 Use the values for range checking, because if range checking is off,
291605:	 the extra bytes won't be missed terribly, but if range checking is on
291677:	 and we used a larger request, a whole extra 4096 bytes would be
291743:	 allocated.
291756:
291757:	 These number are irrelevant to the new GNU malloc.  I suspect it is
291827:	 less sensitive to the size of the request.  */
291876:      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
291952:		    + 4 + DEFAULT_ROUNDING - 1)
291986:		   & ~(DEFAULT_ROUNDING - 1));
292019:      size = 4096 - extra;
292046:    }
292052:
292053:  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
292111:  h->freefun = freefun;
292135:  h->chunk_size = size;
292159:  h->alignment_mask = alignment - 1;
292196:  h->use_extra_arg = 0;
292220:
292221:  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
292278:  h->next_free = h->object_base = chunk->contents;
292329:  h->chunk_limit = chunk->limit
292361:    = (char *) chunk + h->chunk_size;
292399:  chunk->prev = 0;
292418:  /* The initial chunk now contains no empty object.  */
292475:  h->maybe_empty_object = 0;
292504:}
292506:
292507:void
292512:_obstack_begin_1 (h, size, alignment, chunkfun, freefun, arg)
292574:     struct obstack *h;
292598:     int size;
292613:     int alignment;
292633:     POINTER (*chunkfun) ();
292662:     void (*freefun) ();
292687:     POINTER arg;
292705:{
292707:  register struct _obstack_chunk* chunk; /* points to new chunk */
292774:
292775:  if (alignment == 0)
292797:    alignment = DEFAULT_ALIGNMENT;
292832:  if (size == 0)
292849:    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
292922:    {
292928:      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
292990:	 Use the values for range checking, because if range checking is off,
293061:	 the extra bytes won't be missed terribly, but if range checking is on
293133:	 and we used a larger request, a whole extra 4096 bytes would be
293199:	 allocated.
293212:
293213:	 These number are irrelevant to the new GNU malloc.  I suspect it is
293283:	 less sensitive to the size of the request.  */
293332:      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
293408:		    + 4 + DEFAULT_ROUNDING - 1)
293442:		   & ~(DEFAULT_ROUNDING - 1));
293475:      size = 4096 - extra;
293502:    }
293508:
293509:  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
293567:  h->freefun = freefun;
293591:  h->chunk_size = size;
293615:  h->alignment_mask = alignment - 1;
293652:  h->extra_arg = arg;
293674:  h->use_extra_arg = 1;
293698:
293699:  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
293756:  h->next_free = h->object_base = chunk->contents;
293807:  h->chunk_limit = chunk->limit
293839:    = (char *) chunk + h->chunk_size;
293877:  chunk->prev = 0;
293896:  /* The initial chunk now contains no empty object.  */
293953:  h->maybe_empty_object = 0;
293982:}
293984:
293985:/* Allocate a new current chunk for the obstack *H
294036:   on the assumption that LENGTH bytes need to be added
294092:   to the current object, or a new object of length LENGTH allocated.
294162:   Copies any partial object from the end of the old chunk
294221:   to the beginning of the new one.  */
294261:
294262:void
294267:_obstack_newchunk (h, length)
294297:     struct obstack *h;
294321:     int length;
294338:{
294340:  register struct _obstack_chunk*	old_chunk = h->chunk;
294396:  register struct _obstack_chunk*	new_chunk;
294441:  register long	new_size;
294467:  register int obj_size = h->next_free - h->object_base;
294524:  register int i;
294542:  int already;
294557:
294558:  /* Compute size for new chunk.  */
294595:  new_size = (obj_size + length) + (obj_size >> 3) + 100;
294653:  if (new_size < h->chunk_size)
294685:    new_size = h->chunk_size;
294715:
294716:  /* Allocate and initialize the new chunk.  */
294764:  new_chunk = h->chunk = CALL_CHUNKFUN (h, new_size);
294818:  new_chunk->prev = old_chunk;
294849:  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;
294918:
294919:  /* Move the existing object to the new chunk.
294967:     Word at a time is fast and is safe if the object
295021:     is sufficiently aligned.  */
295055:  if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)
295105:    {
295111:      for (i = obj_size / sizeof (COPYING_UNIT) - 1;
295164:	   i >= 0; i--)
295181:	((COPYING_UNIT *)new_chunk->contents)[i]
295223:	  = ((COPYING_UNIT *)h->object_base)[i];
295265:      /* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,
295345:	 but that can cross a page boundary on a machine
295395:	 which does not do strict alignment for COPYING_UNITS.  */
295455:      already = obj_size / sizeof (COPYING_UNIT) * sizeof (COPYING_UNIT);
295529:    }
295535:  else
295542:    already = 0;
295559:  /* Copy remaining bytes one by one.  */
295601:  for (i = already; i < obj_size; i++)
295640:    new_chunk->contents[i] = h->object_base[i];
295688:
295689:  /* If the object just copied was the only data in OLD_CHUNK,
295752:     free that chunk and remove it from the chain.
295803:     But not if that chunk might contain an empty object.  */
295865:  if (h->object_base == old_chunk->contents && ! h->maybe_empty_object)
295937:    {
295943:      new_chunk->prev = old_chunk->prev;
295984:      CALL_FREEFUN (h, old_chunk);
296019:    }
296025:
296026:  h->object_base = new_chunk->contents;
296066:  h->next_free = h->object_base + obj_size;
296110:  /* The new chunk certainly contains no empty object yet.  */
296173:  h->maybe_empty_object = 0;
296202:}
296204:
296205:/* Return nonzero if object OBJ has been allocated from obstack H.
296272:   This is here for debugging.
296303:   If you use it in a program, you are probably losing.  */
296363:
296364:int
296368:_obstack_allocated_p (h, obj)
296398:     struct obstack *h;
296422:     POINTER obj;
296440:{
296442:  register struct _obstack_chunk*  lp;	/* below addr of any objects in this chunk */
296527:  register struct _obstack_chunk*  plp;	/* point to previous chunk if any */
296604:
296605:  lp = (h)->chunk;
296624:  /* We use >= rather than > since the object cannot be exactly at
296691:     the beginning of the chunk but might be an empty object exactly
296760:     at the end of an adjacent chunk. */
296801:  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
296873:    {
296879:      plp = lp->prev;
296901:      lp = plp;
296917:    }
296923:  return lp != 0;
296941:}
296943:
296945:/* Free objects in obstack H, including OBJ and everything allocate
297013:   more recently than OBJ.  If OBJ is zero, free everything in H.  */
297083:
297084:#undef obstack_free
297104:
297105:/* This function has two names with identical definitions.
297164:   This is the first one, called from non-ANSI code.  */
297221:
297222:void
297227:_obstack_free (h, obj)
297250:     struct obstack *h;
297274:     POINTER obj;
297292:{
297294:  register struct _obstack_chunk*  lp;	/* below addr of any objects in this chunk */
297379:  register struct _obstack_chunk*  plp;	/* point to previous chunk if any */
297456:
297457:  lp = h->chunk;
297474:  /* We use >= because there cannot be an object at the beginning of a chunk.
297552:     But there can be an empty object at that address
297606:     at the end of another chunk.  */
297644:  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
297716:    {
297722:      plp = lp->prev;
297744:      CALL_FREEFUN (h, lp);
297772:      lp = plp;
297788:      /* If we switch chunks, we can't tell whether the new current
297856:	 chunk contains an empty object, so assume that it may.  */
297917:      h->maybe_empty_object = 1;
297950:    }
297956:  if (lp)
297966:    {
297972:      h->object_base = h->next_free = (char *)(obj);
298025:      h->chunk_limit = lp->limit;
298059:      h->chunk = lp;
298080:    }
298086:  else if (obj != 0)
298107:    /* obj is not in any of the chunks! */
298150:    abort ();
298164:}
298166:
298167:/* This function is used from ANSI code.  */
298212:
298213:void
298218:obstack_free (h, obj)
298240:     struct obstack *h;
298264:     POINTER obj;
298282:{
298284:  register struct _obstack_chunk*  lp;	/* below addr of any objects in this chunk */
298369:  register struct _obstack_chunk*  plp;	/* point to previous chunk if any */
298446:
298447:  lp = h->chunk;
298464:  /* We use >= because there cannot be an object at the beginning of a chunk.
298542:     But there can be an empty object at that address
298596:     at the end of another chunk.  */
298634:  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
298706:    {
298712:      plp = lp->prev;
298734:      CALL_FREEFUN (h, lp);
298762:      lp = plp;
298778:      /* If we switch chunks, we can't tell whether the new current
298846:	 chunk contains an empty object, so assume that it may.  */
298907:      h->maybe_empty_object = 1;
298940:    }
298946:  if (lp)
298956:    {
298962:      h->object_base = h->next_free = (char *)(obj);
299015:      h->chunk_limit = lp->limit;
299049:      h->chunk = lp;
299070:    }
299076:  else if (obj != 0)
299097:    /* obj is not in any of the chunks! */
299140:    abort ();
299154:}
299156:
299158:#if 0
299164:/* These are now turned off because the applications do not use it
299231:   and it uses bcopy via obstack_grow, which causes trouble on sysV.  */
299304:
299305:/* Now define the functional versions of the obstack macros.
299366:   Define them to simply use the corresponding macros to do the job.  */
299439:
299440:#ifdef __STDC__
299456:/* These function definitions do not work with non-ANSI preprocessors;
299527:   they won't pass through the macro names in parentheses.  */
299590:
299591:/* The function names appear in parentheses in order to prevent
299655:   the macro-definitions of the names from being expanded there.  */
299724:
299725:POINTER (obstack_base) (obstack)
299758:     struct obstack *obstack;
299788:{
299790:  return obstack_base (obstack);
299823:}
299825:
299826:POINTER (obstack_next_free) (obstack)
299864:     struct obstack *obstack;
299894:{
299896:  return obstack_next_free (obstack);
299934:}
299936:
299937:int (obstack_object_size) (obstack)
299973:     struct obstack *obstack;
300003:{
300005:  return obstack_object_size (obstack);
300045:}
300047:
300048:int (obstack_room) (obstack)
300077:     struct obstack *obstack;
300107:{
300109:  return obstack_room (obstack);
300142:}
300144:
300145:void (obstack_grow) (obstack, pointer, length)
300192:     struct obstack *obstack;
300222:     POINTER pointer;
300244:     int length;
300261:{
300263:  obstack_grow (obstack, pointer, length);
300306:}
300308:
300309:void (obstack_grow0) (obstack, pointer, length)
300357:     struct obstack *obstack;
300387:     POINTER pointer;
300409:     int length;
300426:{
300428:  obstack_grow0 (obstack, pointer, length);
300472:}
300474:
300475:void (obstack_1grow) (obstack, character)
300517:     struct obstack *obstack;
300547:     int character;
300567:{
300569:  obstack_1grow (obstack, character);
300607:}
300609:
300610:void (obstack_blank) (obstack, length)
300649:     struct obstack *obstack;
300679:     int length;
300696:{
300698:  obstack_blank (obstack, length);
300733:}
300735:
300736:void (obstack_1grow_fast) (obstack, character)
300783:     struct obstack *obstack;
300813:     int character;
300833:{
300835:  obstack_1grow_fast (obstack, character);
300878:}
300880:
300881:void (obstack_blank_fast) (obstack, length)
300925:     struct obstack *obstack;
300955:     int length;
300972:{
300974:  obstack_blank_fast (obstack, length);
301014:}
301016:
301017:POINTER (obstack_finish) (obstack)
301052:     struct obstack *obstack;
301082:{
301084:  return obstack_finish (obstack);
301119:}
301121:
301122:POINTER (obstack_alloc) (obstack, length)
301164:     struct obstack *obstack;
301194:     int length;
301211:{
301213:  return obstack_alloc (obstack, length);
301255:}
301257:
301258:POINTER (obstack_copy) (obstack, pointer, length)
301308:     struct obstack *obstack;
301338:     POINTER pointer;
301360:     int length;
301377:{
301379:  return obstack_copy (obstack, pointer, length);
301429:}
301431:
301432:POINTER (obstack_copy0) (obstack, pointer, length)
301483:     struct obstack *obstack;
301513:     POINTER pointer;
301535:     int length;
301552:{
301554:  return obstack_copy0 (obstack, pointer, length);
301605:}
301607:
301608:#endif /* __STDC__ */
301630:
301631:#endif /* 0 */
301646:
301647:#endif	/* _LIBC or not __GNU_LIBRARY__.  */
301691:/* search.c - searching subroutines using dfa, kwset and regex for grep.
301764:   Copyright (C) 1992 Free Software Foundation, Inc.
301817:
301818:   This program is free software; you can redistribute it and/or modify
301890:   it under the terms of the GNU General Public License as published by
301962:   the Free Software Foundation; either version 2, or (at your option)
302033:   any later version.
302055:
302056:   This program is distributed in the hope that it will be useful,
302123:   but WITHOUT ANY WARRANTY; without even the implied warranty of
302189:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
302254:   GNU General Public License for more details.
302302:
302303:   You should have received a copy of the GNU General Public License
302372:   along with this program; if not, write to the Free Software
302435:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
302496:
302497:   Written August 1992 by Mike Haertel. */
302540:
302564:
302565:#ifdef STDC_HEADERS
302585:#if flag_limits==0
302604:#undef RE_DUP_MAX
302642:#define flag_limits 1
302664:#endif
302671:#if flag_stdlib==0
302710:#define flag_stdlib 1
302732:#endif
302739:#else
302745:#define UCHAR_MAX 255
302767:#if flag_systypes==0
302811:#define flag_systypes 1
302835:#endif
302842:extern char *malloc();
302865:#endif
302872:
302873:#ifdef HAVE_MEMCHR
302892:#if flag_string==0
302931:#define flag_string 1
302953:#endif
302960:#ifdef NEED_MEMORY_H
302981:#if flag_memory==0
303020:#define flag_memory 1
303042:#endif
303049:#endif
303056:#else
303062:#ifdef __STDC__
303078:extern void *memchr();
303101:#else
303107:extern char *memchr();
303130:#endif
303137:#endif
303144:
303145:#if defined(HAVE_STRING_H) || defined(STDC_HEADERS)
303197:#undef bcopy
303210:#define bcopy(s, d, n) memcpy((d), (s), (n))
303255:#endif
303262:
303263:#ifdef isascii
303278:#define ISALNUM(C) (isascii(C) && isalnum(C))
303324:#define ISUPPER(C) (isascii(C) && isupper(C))
303370:#else
303376:#define ISALNUM(C) isalnum(C)
303406:#define ISUPPER(C) isupper(C)
303436:#endif
303443:
303444:#define TOLOWER(C) (ISUPPER(C) ? tolower(C) : (C))
303495:
303585:
303586:#define NCHAR (UCHAR_MAX + 1)
303616:
303617:#if __STDC__
303630:static void Gcompile(char *, size_t);
303668:static void Ecompile(char *, size_t);
303706:static char *EGexecute(char *, size_t, char **);
303755:static void Fcompile(char *, size_t);
303793:static char *Fexecute(char *, size_t, char **);
303841:#else
303847:static void Gcompile();
303871:static void Ecompile();
303895:static char *EGexecute();
303921:static void Fcompile();
303945:static char *Fexecute();
303970:#endif
303977:
303978:/* Here is the matchers vector for the main program. */
304034:struct matcher matchers[] = {
304064:  { "default", Gcompile, EGexecute },
304102:  { "grep", Gcompile, EGexecute },
304137:  { "ggrep", Gcompile, EGexecute },
304173:  { "egrep", Ecompile, EGexecute },
304209:  { "posix-egrep", Ecompile, EGexecute },
304251:  { "gegrep", Ecompile, EGexecute },
304288:  { "fgrep", Fcompile, Fexecute },
304323:  { "gfgrep", Fcompile, Fexecute },
304359:  { 0, 0, 0 },
304374:};
304377:
304378:/* For -w, we also consider _ to be word constituent.  */
304436:#define WCHAR(C) (ISALNUM(C) || (C) == '_')
304480:
304481:/* DFA compiled regexp. */
304508:static struct dfa dfa_1;
304533:
304534:/* Regex compiled regexp. */
304563:static struct re_pattern_buffer regex;
304602:
304603:/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
304669:   a list of strings, at least one of which is known to occur in
304734:   any string matching the regexp. */
304772:static kwset_t kwset;
304794:
304795:/* Last compiled fixed string known to exactly match the regexp.
304860:   If kwsexec() returns < lastexact, then we don't need to
304919:   call the regexp matcher at all. */
304957:static int lastexact;
304979:
304980:void
304985:dfaerror(mesg)
305000:     char *mesg;
305017:{
305019:  fatal(mesg, 0);
305037:}
305039:
305040:static void
305052:kwsinit()
305062:{
305064:  static char trans[NCHAR];
305092:  int i;
305101:
305102:  if (match_icase)
305121:    for (i = 0; i < NCHAR; ++i)
305153:      trans[i] = TOLOWER(i);
305182:
305183:  if (!(kwset = kwsalloc(match_icase ? trans : (char *) 0)))
305244:    fatal("memory exhausted", 0);
305278:}  
305282:
305283:/* If the DFA turns out to have some set of fixed strings one of
305348:   which must occur in the match, then we build a kwset matcher
305412:   to find those strings, and thus quickly filter out impossible
305477:   matches. */
305492:static void
305504:kwsmusts()
305515:{
305517:  struct dfamust *dm;
305539:  char *err;
305552:
305553:  if (dfa_1.musts)
305572:    {
305578:      kwsinit();
305595:      /* First, we compile in the substrings known to be exact
305658:	 matches.  The kwset matcher will return the index
305710:	 of the matching string that it chooses. */
305755:      for (dm = dfa_1.musts; dm; dm = dm->next)
305803:	{
305806:	  if (!dm->exact)
305825:	    continue;
305840:	  ++lastexact;
305856:	  if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0)
305920:	    fatal(err, 0);
305940:	}
305943:      /* Now, we compile the substrings that will require
306001:	 the use of the regexp matcher.  */
306038:      for (dm = dfa_1.musts; dm; dm = dm->next)
306086:	{
306089:	  if (dm->exact)
306107:	    continue;
306122:	  if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0)
306186:	    fatal(err, 0);
306206:	}
306209:      if ((err = kwsprep(kwset)) != 0)
306248:	fatal(err, 0);
306264:    }
306270:}
306272:
306273:static void
306285:Gcompile(pattern, size)
306309:     char *pattern;
306329:     size_t size;
306347:{
306349:#ifdef __STDC__
306365:  const
306373:#endif
306380:  char *err;
306393:
306394:  re_set_syntax(RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
306454:  dfasyntax(RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE, match_icase);
306523:
306524:  if ((err = re_compile_pattern(pattern, size, &regex)) != 0)
306586:    fatal(err, 0);
306605:
306606:  dfainit(&dfa_1);
306625:
306626:  /* In the match_words and match_lines cases, we use a different pattern
306700:     for the DFA matcher that will quickly throw out cases that won't work.
306776:     Then if DFA succeeds we do some hairy stuff using the regex matcher
306849:     to decide whether the match should really count. */
306906:  if (match_words || match_lines)
306940:    {
306946:      /* In the whole-word case, we use the pattern:
306999:	 (^|[^A-Za-z_])(userpattern)([^A-Za-z_]|$).
307044:	 In the whole-line case, we use the pattern:
307090:	 ^(userpattern)$.
307109:	 BUG: Using [A-Za-z_] is locale-dependent!  */
307157:
307158:      char *n = malloc(size + 50);
307193:      int i = 0;
307210:
307211:      strcpy(n, "");
307232:
307233:      if (match_lines)
307256:	strcpy(n, "^\\(");
307276:      if (match_words)
307299:	strcpy(n, "\\(^\\|[^0-9A-Za-z_]\\)\\(");
307341:
307342:      i = strlen(n);
307363:      bcopy(pattern, n + i, size);
307398:      i += size;
307415:
307416:      if (match_words)
307439:	strcpy(n + i, "\\)\\([^0-9A-Za-z_]\\|$\\)");
307485:      if (match_lines)
307508:	strcpy(n + i, "\\)$");
307532:
307533:      i += strlen(n + i);
307559:      dfacomp(n, i, &dfa_1, 1);
307591:    }
307597:  else
307604:    dfacomp(pattern, size, &dfa_1, 1);
307643:
307644:  kwsmusts();
307658:}
307660:
307661:static void
307673:Ecompile(pattern, size)
307697:     char *pattern;
307717:     size_t size;
307735:{
307737:#ifdef __STDC__
307753:  const
307761:#endif
307768:  char *err;
307781:
307782:  if (strcmp(matcher, "posix-egrep") == 0)
307825:    {
307831:      re_set_syntax(RE_SYNTAX_POSIX_EGREP);
307875:      dfasyntax(RE_SYNTAX_POSIX_EGREP, match_icase);
307928:    }
307934:  else
307941:    {
307947:      re_set_syntax(RE_SYNTAX_EGREP);
307985:      dfasyntax(RE_SYNTAX_EGREP, match_icase);
308032:    }
308038:
308039:  if ((err = re_compile_pattern(pattern, size, &regex)) != 0)
308101:    fatal(err, 0);
308120:
308121:  dfainit(&dfa_1);
308140:
308141:  /* In the match_words and match_lines cases, we use a different pattern
308215:     for the DFA matcher that will quickly throw out cases that won't work.
308291:     Then if DFA succeeds we do some hairy stuff using the regex matcher
308364:     to decide whether the match should really count. */
308421:  if (match_words || match_lines)
308455:    {
308461:      /* In the whole-word case, we use the pattern:
308514:	 (^|[^A-Za-z_])(userpattern)([^A-Za-z_]|$).
308559:	 In the whole-line case, we use the pattern:
308605:	 ^(userpattern)$.
308624:	 BUG: Using [A-Za-z_] is locale-dependent!  */
308672:
308673:      char *n = malloc(size + 50);
308708:      int i = 0;
308725:
308726:      strcpy(n, "");
308747:
308748:      if (match_lines)
308771:	strcpy(n, "^(");
308789:      if (match_words)
308812:	strcpy(n, "(^|[^0-9A-Za-z_])(");
308846:
308847:      i = strlen(n);
308868:      bcopy(pattern, n + i, size);
308903:      i += size;
308920:
308921:      if (match_words)
308944:	strcpy(n + i, ")([^0-9A-Za-z_]|$)");
308982:      if (match_lines)
309005:	strcpy(n + i, ")$");
309027:
309028:      i += strlen(n + i);
309054:      dfacomp(n, i, &dfa_1, 1);
309086:    }
309092:  else
309099:    dfacomp(pattern, size, &dfa_1, 1);
309138:
309139:  kwsmusts();
309153:}
309155:
309156:static char *
309170:EGexecute(buf, size, endp)
309197:     char *buf;
309213:     size_t size;
309231:     char **endp;
309249:{
309251:  register char *buflim, *beg, *end, save;
309294:  int backref, start, len;
309321:  struct kwsmatch kwsm;
309345:  static struct re_registers regs; /* This is static on account of a BRAIN-DEAD
309425:				    Q@#%!# library interface in regex.c.  */
309474:
309475:  buflim = buf + size;
309498:
309499:  for (beg = end = buf; end < buflim; beg = end + 1)
309552:    {
309558:      if (kwset)
309575:	{
309578:	  /* Find a possible match using the KWset matcher. */
309634:	  beg = kwsexec(kwset, beg, buflim - beg, &kwsm);
309685:	  if (!beg)
309698:	    goto failure;
309717:	  /* Narrow down to the line containing the candidate, and
309777:	     run it through DFA. */
309806:	  end = memchr(beg, '\n', buflim - beg);
309848:	  if (!end)
309861:	    end = buflim;
309880:	  while (beg > buf && beg[-1] != '\n')
309920:	    --beg;
309932:	  save = *end;
309948:	  if (kwsm.index < lastexact)
309979:	    goto success;
309998:	  if (!dfaexec(&dfa_1, beg, end, 0, (int *) 0, &backref))
310057:	    {
310064:	      *end = save;
310084:	      continue;
310101:	    }
310108:	  *end = save;
310124:	  /* Successful, no backreferences encountered. */
310176:	  if (!backref)
310193:	    goto success;
310212:	}
310215:      else
310226:	{
310229:	  /* No good fixed strings; start with DFA. */
310277:	  save = *buflim;
310296:	  beg = dfaexec(&dfa_1, beg, buflim, 0, (int *) 0, &backref);
310359:	  *buflim = save;
310378:	  if (!beg)
310391:	    goto failure;
310410:	  /* Narrow down to the line we've found. */
310456:	  end = memchr(beg, '\n', buflim - beg);
310498:	  if (!end)
310511:	    end = buflim;
310530:	  while (beg > buf && beg[-1] != '\n')
310570:	    --beg;
310582:	  /* Successful, no backreferences encountered! */
310634:	  if (!backref)
310651:	    goto success;
310670:	}
310673:      /* If we've made it to this point, this means DFA has seen
310738:	 a probable match, and we need to run it through Regex. */
310798:      regex.not_eol = 0;
310823:      if ((start = re_search(&regex, beg, end - beg, 0, end - beg, &regs)) >= 0)
310904:	{
310907:	  len = regs.end[0] - start;
310937:	  if (!match_lines && !match_words || match_lines && len == end - beg)
311009:	    goto success;
311028:	  /* If -w, check if the match aligns with word boundaries.
311089:	     We do this iteratively because:
311127:	     (a) the line may contain more than one occurence of the pattern, and
311202:	     (b) Several alternatives in the pattern might be valid at a given
311274:	     point, and we may need to consider a shorter one to find a word
311344:	     boundary. */
311363:	  if (match_words)
311383:	    while (start >= 0)
311407:	      {
311416:		if ((start == 0 || !WCHAR(beg[start - 1]))
311461:		    && (len == end - beg || !WCHAR(beg[start + len])))
311518:		  goto success;
311536:		if (len > 0)
311551:		  {
311557:		    /* Try a shorter length anchored at the same place. */
311618:		    --len;
311631:		    regex.not_eol = 1;
311656:		    len = re_match(&regex, beg, start + len, start, &regs);
311718:		  }
311724:		if (len <= 0)
311740:		  {
311746:		    /* Try looking further on. */
311782:		    if (start == end - beg)
311812:		      break;
311827:		    ++start;
311842:		    regex.not_eol = 0;
311867:		    start = re_search(&regex, beg, end - beg,
311915:				      start, end - beg - start, &regs);
311959:		    len = regs.end[0] - start;
311992:		  }
311998:	      }
312007:	}
312010:    }
312016:
312017: failure:
312027:  return 0;
312039:
312040: success:
312050:  *endp = end < buflim ? end + 1 : end;
312090:  return beg;
312104:}
312106:
312107:static void
312119:Fcompile(pattern, size)
312143:     char *pattern;
312163:     size_t size;
312181:{
312183:  char *beg, *lim, *err;
312208:
312209:  kwsinit();
312222:  beg = pattern;
312239:  do
312244:    {
312250:      for (lim = beg; lim < pattern + size && *lim != '\n'; ++lim)
312317:	;
312320:      if ((err = kwsincr(kwset, beg, lim - beg)) != 0)
312375:	fatal(err, 0);
312391:      if (lim < pattern + size)
312423:	++lim;
312431:      beg = lim;
312448:    }
312454:  while (beg < pattern + size);
312486:
312487:  if ((err = kwsprep(kwset)) != 0)
312522:    fatal(err, 0);
312541:}
312543:
312544:static char *
312558:Fexecute(buf, size, endp)
312584:     char *buf;
312600:     size_t size;
312618:     char **endp;
312636:{
312638:  register char *beg, *try, *end;
312672:  register size_t len;
312695:  struct kwsmatch kwsmatch;
312723:
312724:  for (beg = buf; beg <= buf + size; ++beg)
312768:    {
312774:      if (!(beg = kwsexec(kwset, beg, buf + size - beg, &kwsmatch)))
312843:	return 0;
312854:      len = kwsmatch.size[0];
312884:      if (match_lines)
312907:	{
312910:	  if (beg > buf && beg[-1] != '\n')
312947:	    continue;
312962:	  if (beg + len < buf + size && beg[len] != '\n')
313013:	    continue;
313028:	  goto success;
313045:	}
313048:      else if (match_words)
313076:	for (try = beg; len && try;)
313106:	  {
313111:	    if (try > buf && WCHAR((unsigned char) try[-1]))
313165:	      break;
313179:	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
313247:	      {
313256:		try = kwsexec(kwset, beg, --len, &kwsmatch);
313303:		len = kwsmatch.size[0];
313329:	      }
313338:	    else
313348:	      goto success;
313369:	  }
313374:      else
313385:	goto success;
313400:    }
313406:
313407:  return 0;
313419:
313420: success:
313430:  if ((end = memchr(beg + len, '\n', (buf + size) - (beg + len))) != 0)
313502:    ++end;
313513:  else
313520:    end = buf + size;
313542:  *endp = end;
313557:  while (beg > buf && beg[-1] != '\n')
313596:    --beg;
313607:  return beg;
313621:}
313623:
313624:if (out)
313633:if (gout)
313643:if (gsth)
313653:if out
313660:if gout
313668:if agout
313677:if agout end = buf + size;
313704:if aout
313712:if ag
313718:if g
313723:if a
313728:
313729:swswsif (out)
313743:wwif (gout)
313755:wssif (gsth)
313768:wswswsif out
313781:3if gout
313790:wsif agout
313801:3eif agout end = buf + size;
313830:dseif aout
313841:dsif ag
313849:isxsif g
313858:xxsxif awwsw
313871:
313872:swswsif (out)fvvfvf
313892:wwif (gout)
313904:wssif (gsth)
313917:wswswsif outvfvf
313934:3if goutfvf
313946:wsif agoutvfv
313960:3eif agoutvf end = buf + size;
313991:dseif aoutvfv
314005:dsif agvff
314016:isxsif gvfv
314028:xxsxif awwsw
314041:
314042:s  if (out)
314054:    if (gout)
314068: sds if (gsth)
314083:  if out
314092:dc if gout
314103:dv if agout
314115:argue if agout end = buf + size;
314148:  if aout
314158:          if ag
314174:  argue if g
314187: if a