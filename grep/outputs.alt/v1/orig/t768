/* grep.c - main driver file for grep.
   Written July 1992 by Mike Haertel.  */
/* I added a series define from makefile here in order to run cfe */
/*** end of cfe purpose **/
extern char *malloc(), *realloc();
extern void *memchr();
extern char *memchr();
/* Provide missing ANSI features if necessary. */
extern char *sys_errlist[];
VOID *
     VOID *vp;
  unsigned char *p;
  for (p = (unsigned char *) vp; n--; ++p)
    if (*p == c)
      return (VOID *) p;
/* Define flags declared in grep.h. */
char *matcher;
/* Functions we'll use to search. */
static void (*compile)();
static char *(*execute)();
/* For error messages. */
static char *prog;
static char *filename;
/* Print a message and possibly an error string.  Remember
   that something awful happened. */
     char *mesg;
/* Like error(), but die horribly after printing. */
     char *mesg;
/* Interface to handle errors and fix library lossage. */
char *
  char *result;
/* Interface to handle errors and fix some library lossage. */
char *
     char *ptr;
  char *result;
extern void *valloc(size_t);
extern char *valloc();
/* Hairy buffering mechanism for grep.  The intent is to keep
   page size. */
static char *buffer;		/* Base of buffer. */
static size_t bufsalloc;	/* Allocated size of buffer save region. */
static size_t bufalloc;		/* Total buffer size. */
static int bufdesc;		/* File descriptor. */
static char *bufbeg;		/* Beginning of user-visible stuff. */
static char *buflim;		/* Limit of user-visible stuff. */
static int bufmapped;		/* True for ordinary files. */
static struct stat bufstat;	/* From fstat(). */
static off_t bufoffset;		/* What read() normally remembers. */
/* Reset the buffer for a new file.  Initialize
   on the first time through. */
      bufalloc = 5 * bufsalloc;
      /* The 1 byte of overflow is a kludge for dfaexec(), which
	 being searched.  There's gotta be a better way... */
/* Read new stuff into the buffer, saving the specified
   points just after the end.  Return count of new stuff. */
  char *nbuffer, *dp, *sp;
	bufsalloc *= 2;
      bufalloc = 5 * bufsalloc;
    *dp++ = *sp++;
  /* We may have allocated a new, larger buffer.  Since
     about the old one.  Sorry. */
      /* You might thing this (or MADV_WILLNEED) would help,
	 In fact, it actually slows us down about 30%! */
      /* We come here when we're not going to use mmap() any more.
	 first time through. */
/* Flags controlling the style of output. */
static int out_quiet;		/* Suppress all normal output. */
static int out_invert;		/* Print nonmatching stuff. */
static int out_file;		/* Print filenames. */
static int out_line;		/* Print line numbers. */
static int out_byte;		/* Print byte offsets. */
static int out_before;		/* Lines of leading context. */
static int out_after;		/* Lines of trailing context. */
/* Internal variables to keep track of byte count, context, etc. */
static size_t totalcc;		/* Total character count before bufbeg. */
static char *lastnl;		/* Pointer after last newline counted. */
static char *lastout;		/* Pointer after last character output;
				   or if it's conceptually before bufbeg. */
static size_t totalnl;		/* Total newline count before lastnl. */
static int pending;		/* Pending lines of output. */
     char *lim;
  char *beg;
    if (*beg == '\n')
     char *beg;
     char *lim;
/* Print pending lines of trailing context prior to LIM. */
     char *lim;
  char *nl;
/* Print the lines between BEG and LIM.  Deal with context crap.
   If NLINESP is non-null, store a count of lines between BEG and LIM. */
     char *beg;
     char *lim;
     int *nlinesp;
  static int used;		/* avoid printing "--" before any output */
  char *bp, *p, *nl;
      /* Deal with leading context crap. */
      /* We only print the "--" separator if our output is
	 discontiguous from the last output in the file. */
      /* Caller wants a line count. */
      *nlinesp = n;
/* Scan the specified portion of the buffer, matching lines (or
   lines printed. */
     char *beg;
     char *lim;
  register char *p, *b;
  char *endp;
  while ((b = (*execute)(p, lim - p, &endp)) != 0)
      /* Avoid matching the empty line at the end of the buffer. */
	  prtext(b, endp, (int *) 0);
/* Search a given file.  Return a count of lines printed. */
  char *beg, *lim;
/* Go through the matchers vector and look for the specified matcher.
   If we find it, install it in compile and execute, and return 1.  */
     char *name;
     char *argv[];
  char *keys;
  FILE *fp;
  extern char *optarg;
	out_before = 10 * out_before + opt - '0';
	out_after = 10 * out_after + opt - '0';
	for (keyalloc = 1; keyalloc <= keycc; keyalloc *= 2)
	      keys = xrealloc(keys, keyalloc *= 2);
	/* Nuke the final newline to avoid matching a null string. */
      case 'y':			/* For old-timers . . . */
	/* Like -l, except list files that don't contain matches.
	   Inspired by the same option in Hume's gre. */
  (*compile)(keys, keycc);
/* Getopt for GNU.
   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
/* NOTE!!!  AIX requires this to be the first thing in the file.
   Do not put ANYTHING before it!  */
#else /* not __GNUC__ */
char *alloca ();
#endif /* alloca.h */
#endif /* not __GNUC__ */
/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.  */
/*#include <stdio.h> */
/* Comment out all this code if we are using the GNU C Library, and are not
   it is simpler to just do this in the source for each such file.  */
/* This needs to come after some library #include
   to get __GNU_LIBRARY__ defined.  */
/* Don't include stdlib.h for non-GNU C libraries because some of them
   contain conflicting prototypes for getopt.  */
#else	/* Not GNU C library.  */
#endif	/* GNU C library.  */
/* If GETOPT_COMPAT is defined, `+' as well as `--' can introduce a
   being phased out.  */
/* #define GETOPT_COMPAT */
/* This version of `getopt' appears to the caller like standard Unix `getopt'
   they can distinguish the relative order of options and other arguments.  */
/* For communication from `getopt' to the caller.
   each non-option ARGV-element is returned here.  */
char *optarg = 0;
/* Index in ARGV of the next element to be scanned.
   how much of ARGV has been scanned so far.  */
/* XXX 1003.2 says this must be 1 before any call.  */
/* The next char to be scanned in the option-element
   by advancing to the next ARGV-element.  */
static char *nextchar;
/* Callers store zero here to inhibit the error message
   for unrecognized options.  */
/* Set to an option character which was unrecognized.
   system's own getopt implementation.  */
/* Describe how to deal with options that follow non-option ARGV-elements.
   `--' can cause `getopt' to return EOF with `optind' != ARGC.  */
/* We want to avoid inclusion of string.h with non-GNU libraries
   in GCC.  */
/* Avoid depending on library functions or files
   whose names are inconsistent.  */
char *getenv ();
static char *
     const char *str;
  while (*str)
      if (*str == chr)
	return (char *) str;
     const char *from;
     char *to;
#endif				/* GNU C library.  */
/* Handle permutation of arguments.  */
/* Describe the part of ARGV that contains non-options that have
   `last_nonopt' is the index after the last of them.  */
/* Exchange two adjacent subsequences of ARGV.
   the new indices of the non-options in ARGV after they are moved.  */
     char **argv;
  int nonopts_size = (last_nonopt - first_nonopt) * sizeof (char *);
  char **temp = (char **) __alloca (nonopts_size);
  /* Interchange the two blocks of data in ARGV.  */
  my_bcopy ((char *) &argv[first_nonopt], (char *) temp, nonopts_size);
  my_bcopy ((char *) &argv[last_nonopt], (char *) &argv[first_nonopt],
	    (optind - last_nonopt) * sizeof (char *));
  my_bcopy ((char *) temp,
	    (char *) &argv[first_nonopt + optind - last_nonopt],
  /* Update records for the slots the non-options now occupy.  */
/* Scan elements of ARGV (whose length is ARGC) for option characters
   long-named options.  */
     char *const *argv;
     const char *optstring;
     const struct option *longopts;
     int *longind;
  /* Initialize the internal data when the first call is made.
     non-option ARGV-elements is empty.  */
      /* Determine how to handle the ordering of options and nonoptions.  */
  if (nextchar == NULL || *nextchar == '\0')
	  /* If we have just processed some options following some non-options,
	     exchange them so that the options come first.  */
	    exchange ((char **) argv);
	  /* Now skip any additional non-options
	     and extend the range of non-options previously skipped.  */
#endif				/* GETOPT_COMPAT */
      /* Special ARGV-element `--' means premature end of options.
	 then skip everything else like a non-option.  */
	    exchange ((char **) argv);
      /* If we have done all the ARGV-elements, stop the scan
	 and back over any non-options that we skipped and permuted.  */
	  /* Set the next-arg-index to point at the non-options
	     that we previously skipped, so the caller will digest them.  */
      /* If we have come to a non-option and did not permute it,
	 either stop the scan or describe it to the caller and pass it by.  */
#endif				/* GETOPT_COMPAT */
      /* We have found another option-ARGV-element.
	 Start decoding its characters.  */
#endif				/* GETOPT_COMPAT */
      const struct option *p;
      char *s = nextchar;
      const struct option *pfound = NULL;
      while (*s && *s != '=')
      /* Test all options for either exact match or abbreviated matches.  */
		/* Exact match found.  */
		/* First nonexact match found.  */
	      /* Second nonexact match found.  */
	  if (*s)
	      /* Don't test has_arg with >, because some C compilers don't
		 allow it to be used on enums.  */
			/* --option */
			/* +option or -option */
	    *longind = option_index;
	      *(pfound->flag) = pfound->val;
      /* Can't find it as a long option.  If this is not getopt_long_only,
	 Otherwise interpret it as a short option.  */
#endif				/* GETOPT_COMPAT */
	  || my_index (optstring, *nextchar) == NULL)
		/* --option */
		/* +option or -option */
	  nextchar = (char *) "";
  /* Look at and handle the next option-character.  */
    char c = *nextchar++;
    char *temp = my_index (optstring, c);
    /* Increment `optind' when we start to process its last character.  */
    if (*nextchar == '\0')
	    /* 1003.2 specifies the format of this message.  */
	    /* This is an option that accepts an argument optionally.  */
	    if (*nextchar != '\0')
	    /* This is an option that requires an argument.  */
	    if (*nextchar != '\0')
		/* If we end this ARGV-element by taking the rest as an arg,
		   we must advance to the next element now.  */
		    /* 1003.2 specifies the format of this message.  */
	      /* We already incremented `optind' once;
		 increment it again when taking next ARGV-elt as argument.  */
     char *const *argv;
     const char *optstring;
			   (const struct option *) 0,
			   (int *) 0,
#endif	/* _LIBC or not __GNU_LIBRARY__.  */
/* Compile with -DTEST to make an executable for use in testing
   the above definition of `getopt'.  */
     char **argv;
#endif /* TEST */
/* Extended regular expression matching and search library,
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
/* AIX requires this to be the first thing in the file. */
/* We need this for `regex.h', and perhaps for the Emacs include files.  */
/* The `emacs' switch turns on certain matching commands
   that make sense only in Emacs. */
/* Emacs uses `NULL' as a predicate.  */
#else  /* not emacs */
/* We used to test for `BSTRING' here, but only GCC and Emacs define
   `BSTRING', as far as I know, and neither of them use this code.  */
char *malloc ();
char *realloc ();
/* Define the syntax stuff for \<, \>, etc.  */
/* This must be nonzero for the wordchar and notwordchar pattern
   commands in re_match_2.  */
extern char *re_syntax_table;
#else /* not SYNTAX_TABLE */
/* How many characters in the character set.  */
#endif /* not SYNTAX_TABLE */
#endif /* not emacs */
/* Get the interface, including the syntax bits.  */
/* isalpha etc. are used for the character classes.  */
/* Jim Meyering writes:
   eliminate the && through constant folding."  */
/* We remove any previous definition of `SIGN_EXTEND_CHAR',
   (Per Bothner suggested the basic approach.)  */
#else  /* not __STDC__ */
/* As in Harbison and Steele.  */
/* Should we use malloc or alloca?  If REGEX_MALLOC is not defined, we
   re_search* or re_match* could cause memory leaks when C-g is used in
   function it is called in.  */
#else /* not REGEX_MALLOC  */
/* Emacs already defines alloca, sometimes.  */
/* Make alloca work the best possible way.  */
#else /* not __GNUC__ */
#else /* not __GNUC__ or HAVE_ALLOCA_H */
#ifndef _AIX /* Already did AIX, up at the top.  */
char *alloca ();
#endif /* not _AIX */
#endif /* not HAVE_ALLOCA_H */ 
#endif /* not __GNUC__ */
#endif /* not alloca */
/* Assumes a `char *destination' variable.  */
  (destination = (char *) alloca (nsize),				\
#endif /* not REGEX_MALLOC */
/* True if `size1' is non-NULL and PTR is pointing anywhere inside
   a good thing.  */
/* (Re)Allocate N items of type T using malloc, or fail.  */
#define TALLOC(n, t) ((t *) malloc ((n) * sizeof (t)))
#define RETALLOC(addr, n, t) ((addr) = (t *) realloc (addr, (n) * sizeof (t)))
#define REGEX_TALLOC(n, t) ((t *) REGEX_ALLOCATE ((n) * sizeof (t)))
#define BYTEWIDTH 8 /* In bits.  */
#undef MAX               /****** added later *******/
/* These are the command codes that appear in compiled regular
   `exactn' we use here must also be 1.  */
        /* Followed by one byte giving n, then by n literal bytes.  */
        /* Matches any (more or less) character.  */
        /* Matches any one char belonging to specified set.  First
           automatically not in the set.  */
        /* Same parameters as charset, but match any character that is
           not one of those specified.  */
        /* Start remembering the text that is matched, for storing in a
           of re_match_2.)  */
        /* Stop remembering the text that is matched and store it in a
           corresponding start_memory when we're at a stop_memory.)  */
        /* Match a duplicate of something remembered. Followed by one
           byte containing the register number.  */
        /* Fail unless at beginning of line.  */
        /* Fail unless at end of line.  */
        /* Succeeds if at beginning of buffer (if emacs) or at beginning
           of string to be matched (if not).  */
        /* Analogously, for end of buffer/string.  */
        /* Followed by two byte relative address to which to jump.  */
	/* Same as jump, but marks the end of an alternative.  */
        /* Followed by two-byte relative address of place to resume at
           in case of failure.  */
        /* Like on_failure_jump, but pushes a placeholder instead of the
           current string position when executed.  */
        /* Throw away latest failure point and then jump to following
           two-byte relative address.  */
        /* Change to pop_failure_jump if know won't have to backtrack to
           Followed by two-byte address.  */
        /* Jump to following two-byte address, and push a dummy failure
           of jump when compiling an alternative.  */
	/* Push a dummy failure point and continue.  Used at the end of
	   alternatives.  */
        /* Followed by two-byte relative address and two-byte number n.
           After matching N times, jump to the address upon failure.  */
        /* Followed by two-byte relative address, and two-byte number n.
           Jump to the address N times, then fail.  */
        /* Set the following two-byte relative address to the
           subsequent two-byte number.  The address *includes* the two
           bytes of number.  */
  wordchar,	/* Matches any word-constituent character.  */
  notwordchar,	/* Matches any char that is not a word-constituent.  */
  wordbeg,	/* Succeeds if at word beginning.  */
  wordend,	/* Succeeds if at word end.  */
  wordbound,	/* Succeeds if at a word boundary.  */
  notwordbound	/* Succeeds if not at a word boundary.  */
  ,before_dot,	/* Succeeds if before point.  */
  at_dot,	/* Succeeds if at point.  */
  after_dot,	/* Succeeds if after point.  */
	/* Matches any character whose syntax is specified.  Followed by
           a byte which contains a syntax code, e.g., Sword.  */
	/* Matches any character whose syntax is not that specified.  */
#endif /* emacs */
/* Common operations on the compiled pattern.  */
/* Store NUMBER in two contiguous bytes starting at DESTINATION.  */
/* Same as STORE_NUMBER, except increment DESTINATION to
   must be an lvalue.  */
/* Put into DESTINATION a number stored in two contiguous bytes starting
   at SOURCE.  */
    (destination) = *(source) & 0377;					\
    (destination) += SIGN_EXTEND_CHAR (*((source) + 1)) << 8;		\
    int *dest;
    unsigned char *source;
  int temp = SIGN_EXTEND_CHAR (*(source + 1)); 
  *dest = *source & 0377;
  *dest += temp << 8;
#ifndef EXTRACT_MACROS /* To debug the macros.  */
#endif /* not EXTRACT_MACROS */
#endif /* DEBUG */
/* Same as EXTRACT_NUMBER, except increment SOURCE to after the number.
   SOURCE must be an lvalue.  */
    int *destination;
    unsigned char **source;
  extract_number (destination, *source);
  *source += 2;
#endif /* not EXTRACT_MACROS */
#endif /* DEBUG */
/* If DEBUG is defined, Regex prints many voluminous messages about what
   the other test files, you can run the already-written tests.  */
/* We use standard I/O for debugging.  */
/*#include <stdio.h>*/
/* It is useful to test things that ``must'' be true when debugging.  */
/* Print the fastmap in human-readable form.  */
    char *fastmap;
/* Print a compiled pattern string in human-readable form, starting at
   the START pointer into it and ending just before the pointer END.  */
    unsigned char *start;
    unsigned char *end;
  unsigned char *p = start;
  unsigned char *pend = end;
  /* Loop over pattern commands.  */
      switch ((re_opcode_t) *p++)
	  mcnt = *p++;
	      printchar (*p++);
          mcnt = *p++;
          printf ("/start_memory/%d/%d", mcnt, *p++);
          mcnt = *p++;
	  printf ("/stop_memory/%d/%d", mcnt, *p++);
	  printf ("/duplicate/%d", *p++);
	            (re_opcode_t) *(p - 1) == charset_not ? "^" : "");
            assert (p + *p < pend);
	      if (c / 8 < *p
		  /* Are we starting a range?  */
		  /* Have we broken a range?  */
	    p += 1 + *p;
	  mcnt = *p++;
	  mcnt = *p++;
#endif /* emacs */
          printf ("?%d", *(p-1));
    struct re_pattern_buffer *bufp;
  unsigned char *buffer = bufp->buffer;
  /* Perhaps we should print the translate table?  */
    const char *where;
    const char *string1;
    const char *string2;
#else /* not DEBUG */
#endif /* not DEBUG */
/* Set by `re_set_syntax' to the current regexp syntax to recognize.  Can
   syntax, so it can be changed between regex compilations.  */
/* Specify the precise syntax of regexps for compilation.  This provides
   defined in regex.h.  We return the old syntax.  */
/* This table gives an error message for each of the error codes listed
   in regex.h.  Obviously the order here has to be same as there.  */
static const char *re_error_msg[] =
  { NULL,					/* REG_NOERROR */
    "No match",					/* REG_NOMATCH */
    "Invalid regular expression",		/* REG_BADPAT */
    "Invalid collation character",		/* REG_ECOLLATE */
    "Invalid character class name",		/* REG_ECTYPE */
    "Trailing backslash",			/* REG_EESCAPE */
    "Invalid back reference",			/* REG_ESUBREG */
    "Unmatched [ or [^",			/* REG_EBRACK */
    "Unmatched ( or \\(",			/* REG_EPAREN */
    "Unmatched \\{",				/* REG_EBRACE */
    "Invalid content of \\{\\}",		/* REG_BADBR */
    "Invalid range end",			/* REG_ERANGE */
    "Memory exhausted",				/* REG_ESPACE */
    "Invalid preceding regular expression",	/* REG_BADRPT */
    "Premature end of regular expression",	/* REG_EEND */
    "Regular expression too big",		/* REG_ESIZE */
    "Unmatched ) or \\)",			/* REG_ERPAREN */
/* Subroutine declarations and macros for regex_compile.  */
/* Fetch the next character in the uncompiled pattern---translating it 
   as an array index (in, e.g., `translate').  */
    c = (unsigned char) *p++;						\
/* Fetch the next character in the uncompiled pattern, with no
   translation.  */
    c = (unsigned char) *p++; 						\
/* Go backwards one character in the pattern.  */
/* If `translate' is non-null, return translate[D], else just D.  We
   `char *', to avoid warnings when a string constant is passed.  But
   when we use a character as a subscript we must make it unsigned.  */
/* Macros for outputting the compiled pattern into `buffer'.  */
/* If the buffer isn't allocated when it comes in, use this.  */
/* Make sure we have at least N more bytes of space in buffer.  */
/* Make sure we have one more byte of buffer space and then add C to it.  */
    *b++ = (unsigned char) (c);						\
/* Ensure we have two more bytes of buffer space and then append C1 and C2.  */
    *b++ = (unsigned char) (c1);					\
    *b++ = (unsigned char) (c2);					\
/* As with BUF_PUSH_2, except for three bytes.  */
    *b++ = (unsigned char) (c1);					\
    *b++ = (unsigned char) (c2);					\
    *b++ = (unsigned char) (c3);					\
/* Store a jump with opcode OP at LOC to location TO.  We store a
   relative address offset by the three bytes the jump itself occupies.  */
/* Likewise, for a two-argument jump.  */
/* Like `STORE_JUMP', but for inserting.  Assume `b' is the buffer end.  */
/* Like `STORE_JUMP2', but for inserting.  Assume `b' is the buffer end.  */
/* This is not an arbitrary limit: the arguments which represent offsets
   be too small, many things would have to change.  */
/* Extend the buffer by twice its current size via realloc and
   being larger than MAX_BUF_SIZE, then flag memory exhausted.  */
    unsigned char *old_buffer = bufp->buffer;				\
    bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated);\
    /* If the buffer moved, move all the pointers into it.  */		\
/* Since we have one byte reserved for the register number argument to
   things about is what fits in that byte.  */
/* But patterns can have more than `MAX_REGNUM' registers.  We just
   ignore the excess.  */
/* Macros for the compile stack.  */
/* Since offsets can go either forwards or backwards, this type needs to
   be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
  compile_stack_elt_t *stack;
  unsigned avail;			/* Offset of next open position.  */
/* The next available element.  */
/* Set the bit for character C in a list.  */
/* Get the next unsigned number in the uncompiled pattern.  */
           num = num * 10 + c - '0'; 					\
#define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */
/* `regex_compile' compiles PATTERN (of length SIZE) according to SYNTAX.
   examined nor set.  */
     const char *pattern;
     struct re_pattern_buffer *bufp;
  /* We fetch characters from PATTERN here.  Even though PATTERN is
     `char *' (i.e., signed), we declare these variables as unsigned, so
     they can be reliably used as array indices.  */
  /* A random tempory spot in PATTERN.  */
  const char *p1;
  /* Points to the end of the buffer, where we should append.  */
  register unsigned char *b;
  /* Keeps track of unclosed groups.  */
  /* Points to the current (ending) position in the pattern.  */
  const char *p = pattern;
  const char *pend = pattern + size;
  /* How to translate the characters in the pattern.  */
  char *translate = bufp->translate;
  /* Address of the count-byte of the most recently inserted `exactn'
     a new `exactn' command.  */
  unsigned char *pending_exact = 0;
  /* Address of start of the most recently finished expression.
     This tells, e.g., postfix * where to find the start of its
     operand.  Reset at the beginning of groups and alternatives.  */
  unsigned char *laststart = 0;
  /* Address of beginning of regexp, or inside of last group.  */
  unsigned char *begalt;
  /* Place in the uncompiled pattern (i.e., the {) to
     which to go back if the interval is invalid.  */
  const char *beg_interval;
  /* Address of the place where a forward jump should go to the end of
     last -- ends with a forward jump of this sort.  */
  unsigned char *fixup_alt_jump = 0;
  /* Counts open-groups as they are encountered.  Remembered for the
     number is put in the stop_memory as the start_memory.  */
#endif /* DEBUG */
  /* Initialize the compile stack.  */
  /* Initialize the pattern buffer.  */
  /* Set `used' to zero, so that if we return an error, the pattern
     at the end.  */
  /* Always count groups, whether or not bufp->no_sub is set.  */
  /* Initialize the syntax table.  */
	{ /* If zero allocated, but buffer is non-null, try to realloc
             that is the user's responsibility.  */
        { /* Caller did not allocate a buffer.  Do it for them.  */
  /* Loop through the uncompiled pattern until we're at the end.  */
            if (   /* If at start of pattern, it's an operator.  */
                   /* If context independent, it's an operator.  */
                   /* Otherwise, depends on what's come before.  */
            if (   /* If at end of pattern, it's an operator.  */
                   /* If context independent, it's an operator.  */
                   /* Otherwise, depends on what's next.  */
        case '*':
          /* If there is no previous pattern... */
            /* Are we optimizing this jump?  */
            /* 1 means zero (many) matches is allowed.  */
            /* If there is a sequence of repetition chars, collapse it
               interval operators with these because of, e.g., `a{2}*',
               which should only match an even number of `a's.  */
                if (c == '*'
                /* If we get here, we found another repeat character.  */
            /* Star, etc. applied to an empty pattern is equivalent
               to an empty pattern.  */
            /* Now we know whether or not zero matches is allowed
               and also whether or not two or more matches is allowed.  */
              { /* More than one repetition is allowed, so put in at the
                   But if we are at the `*' in the exact sequence `.*\n',
                   through the loop.  */
                /* Allocate the space for the jump.  */
                /* We know we are not at the first character of the pattern,
                   the `*'.  Do we have to do something analogous here
                   for null bytes, because of RE_DOT_NOT_NULL?  */
                if (TRANSLATE (*(p - 2)) == TRANSLATE ('.')
                    && p < pend && TRANSLATE (*p) == TRANSLATE ('\n')
                  { /* We have .*\n.  */
                  /* Anything else.  */
                /* We've added more stuff to the buffer.  */
            /* On failure, jump from laststart to b + 3, which will be the
               end of the buffer after this jump is inserted.  */
                /* At least one repetition is required, so insert a
                   we hit that loop.  */
            /* Ensure that we have enough space to push a charset: the
               opcode, the length count, and the bitset; 34 bytes in all.  */
            /* We test `*p == '^' twice, instead of using an if
               statement, so we only need one BUF_PUSH.  */
            BUF_PUSH (*p == '^' ? charset_not : charset); 
            if (*p == '^')
            /* Remember the first position in the bracket expression.  */
            /* Push the number of bytes in the bitmap.  */
            /* Clear the whole map.  */
            /* charset_not matches newline according to a syntax bit.  */
            /* Read in characters and ranges, setting map bits.  */
                /* \ might escape characters inside [...] and [^...].  */
                /* Could be the end of the bracket expression.  If it's
                   far), the ']' character bit gets set way below.  */
                /* Look ahead to see if it's a range when the last thing
                   was a character class.  */
                if (had_char_class && c == '-' && *p != ']')
                /* Look ahead to see if it's a range when the last thing
                   operator.  */
                    && *p != ']')
                  { /* This handles ranges made up of characters only.  */
		    /* Move past the `-'.  */
                /* See if we're at the beginning of a possible character
                   class.  */
                else if (syntax & RE_CHAR_CLASSES && c == '[' && *p == ':')
                  { /* Leave room for the null.  */
                    /* If pattern is `[[:'.  */
                    /* If isn't a word bracketed by `[:' and:`]':
                       the leading `:' and `[' (but set bits for them).  */
                    if (c == ':' && *p == ']')
                        /* Throw away the ] at the end of the character
                           class.  */
            /* Discard any (non)matching list bytes that are all 0 at the
               end of the map.  Decrease the map-length byte too.  */
          /* Do not translate the character after the \, so that we can
             translate, e.g., B to b.  */
              /* These are the values to restore when we hit end of this
                 be valid.  */
              /* We will eventually replace the 0 with the number of
                 represent in the compiled pattern.  */
	      /* If we've reached MAX_REGNUM groups, then this open
		 clear pending_exact explicitly.  */
                { /* Push a dummy failure point at the end of the
                     `push_dummy_failure' in `re_match_2'.  */
                  /* We allocated space for this jump when we assigned
                     to `fixup_alt_jump', in the `handle_alt' case below.  */
              /* See similar code for backslashed left paren above.  */
              /* Since we just checked for an empty stack above, this
                 ``can't happen''.  */
                /* We don't just want to restore into `regnum', because
                   as in `(ab)c(de)' -- the second group is #2.  */
		/* If we've reached MAX_REGNUM groups, then this open
		   clear pending_exact explicitly.  */
                /* We're at the end of the group, so now we know how many
                   groups were inside this one.  */
                    unsigned char *inner_group_loc
                    *inner_group_loc = regnum - this_group_regnum;
            case '|':					/* `\|'.  */
              /* Insert before the previous alternative a jump which
                 jumps to this alternative if the former fails.  */
              /* The alternative before this one has a jump after it
                 bytes which we'll fill in when we get to after `c'.  */
              /* Mark and leave space for a jump after this alternative,
                 when know we're at the end of a series of alternatives.  */
              /* If \{ is a literal.  */
                     /* If we're at `\{' and it's not the open-interval 
                        operator.  */
                /* If got here, then the syntax allows intervals.  */
                /* At least (most) this many matches must be made.  */
                  /* Interval such as `{1}' => match exactly once. */
                /* We just parsed a valid interval.  */
                /* If it's invalid to have no preceding re.  */
                /* If the upper bound is zero, don't want to succeed at
                   the end of the buffer after we insert the jump.  */
                 /* Otherwise, we have a nontrivial interval.  When
                    `upper_bound' is 1, though.)  */
                   { /* If the upper bound is > 1, we need to insert
                        more at the end of the loop.  */
                     unsigned nbytes = 10 + (upper_bound > 1) * 10;
                     /* Initialize lower bound of the `succeed_n', even
                        Jump to the `jump_n' we might insert below.  */
                                   b + 5 + (upper_bound > 1) * 5,
                     /* Code to initialize the lower bound.  Insert 
                        the following `succeed_n'.  */
                       { /* More than one repetition is allowed, so
                            jump back only `upper_bound - 1' times.  */
                         /* The location we want to set is the second
                            reinitialize the bounds.  */
              /* If an invalid interval, match the characters as literals.  */
               /* normal_char and normal_backslash need `c'.  */
            /* There is no way to specify the before_dot and after_dot
               operators.  rms says this is ok.  --karl  */
#endif /* emacs */
              /* Can't back reference to a subexpression if inside of it.  */
              /* You might think it would be useful for \ to mean
                 it will never match anything.  */
        /* Expects the character in `c'.  */
	      /* If no exactn currently being built.  */
              /* If last exactn not at current position.  */
              || pending_exact + *pending_exact + 1 != b
              /* We have only one byte following the exactn for the count.  */
	      || *pending_exact == (1 << BYTEWIDTH) - 1
              /* If followed by a repetition operator.  */
              || *p == '*' || *p == '^'
		  ? *p == '\\' && (p[1] == '+' || p[1] == '?')
		  : (*p == '+' || *p == '?'))
		      ? *p == '{'
	      /* Start building a new exactn.  */
          (*pending_exact)++;
        } /* switch (c) */
    } /* while p != pend */
  /* Through the pattern now.  */
  /* We have succeeded; set the length of the buffer.  */
#endif /* DEBUG */
} /* regex_compile */
/* Subroutines for `regex_compile'.  */
/* Store OP at LOC followed by two-byte integer parameter ARG.  */
    unsigned char *loc;
  *loc = (unsigned char) op;
/* Like `store_op1', but" for 'two two-byte parameters ARG1 and ARG2.  */
    unsigned char *loc;
  *loc = (unsigned char) op;
/* Copy the bytes from LOC to END to open up three bytes of space at LOC
   for OP followed by two-byte integer parameter ARG.  */
    unsigned char *loc;
    unsigned char *end;    
  register unsigned char *pfrom = end;
  register unsigned char *pto = end + 3;
    *--pto = *--pfrom;
/* Like `insert_op1', but for two two-byte parameters ARG1 and ARG2.  */
    unsigned char *loc;
    unsigned char *end;    
  register unsigned char *pfrom = end;
  register unsigned char *pto = end + 5;
    *--pto = *--pfrom;
/* P points to just after a ^ in PATTERN.  Return true if that ^ comes
   least one character before the ^.  */
    const char *pattern, *p;
  const char *prev = p - 2;
       /* After a subexpression?  */
       (*prev == '(' && (syntax & RE_NO_BK_PARENS || prev_prev_backslash))
       /* After an alternative?  */
    || (*prev == '|' && (syntax & RE_NO_BK_VBAR || prev_prev_backslash));
/* The dual of at_begline_loc_p.  This one is for $.  We assume there is
   at least one character after the $, i.e., `P < PEND'.  */
    const char *p, *pend;
  const char *next = p;
  boolean next_backslash = *next == '\\';
  const char *next_next = p + 1 < pend ? p + 1 : NULL;
       /* Before a subexpression?  */
       (syntax & RE_NO_BK_PARENS ? *next == ')'
        : next_backslash && next_next && *next_next == ')')
       /* Before an alternative?  */
    || (syntax & RE_NO_BK_VBAR ? *next == '|'
        : next_backslash && next_next && *next_next == '|');
/* Returns true if REGNUM is in one of COMPILE_STACK's elements and 
   false if it's not.  */
/* Read the ending character of a range (in a bracket expression) from the
   uncompiled pattern *P_PTR (which ends at PEND).  We assume the
   `regex_compile' itself.  */
    const char **p_ptr, *pend;
    char *translate;
    unsigned char *b;
  const char *p = *p_ptr;
  /* Even though the pattern is a signed `char *', we need to fetch
     with unsigned char *'s; if the high bit of the pattern character
     signed char *.
     appropriate translation is done in the bit-setting loop below.  */
  range_start = ((unsigned char *) p)[-2];
  range_end   = ((unsigned char *) p)[0];
  /* Have to increment the pointer into the pattern string, so the
     caller isn't still at the ending character.  */
  (*p_ptr)++;
  /* If the start is after the end, the range is empty.  */
  /* Here we see why `this_char' has to be larger than an `unsigned
     loop, since all characters <= 0xff.  */
/* Failure stack declarations and macros; both re_compile_fastmap and
   REGEX_ALLOCATE.  */
/* Number of failure points for which to initially allocate space
   space, so it is not a hard limit.  */
/* Roughly the maximum number of failure points on the stack.  Would be
   change it ourselves.  */
typedef const unsigned char *fail_stack_elt_t;
  fail_stack_elt_t *stack;
  unsigned avail;			/* Offset of next open position.  */
/* Initialize `fail_stack'.  Do `return -2' if the alloc fails.  */
    fail_stack.stack = (fail_stack_elt_t *)				\
      REGEX_ALLOCATE (INIT_FAILURE_ALLOC * sizeof (fail_stack_elt_t));	\
/* Double the size of FAIL_STACK, up to approximately `re_max_failures' items.
   REGEX_REALLOCATE requires `destination' be declared.   */
  ((fail_stack).size > re_max_failures * MAX_FAILURE_ITEMS		\
   : ((fail_stack).stack = (fail_stack_elt_t *)				\
          (fail_stack).size * sizeof (fail_stack_elt_t),		\
          ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),	\
/* Push PATTERN_OP on FAIL_STACK. 
   space to do so.  */
/* This pushes an item onto the failure stack.  Must be a four-byte
   be called from within `PUSH_FAILURE_POINT'.  */
/* The complement operation.  Assumes `fail_stack' is nonempty.  */
/* Used to omit pushing failure point id's when we're not debugging.  */
#define DEBUG_POP(item_addr) *(item_addr) = POP_FAILURE_ITEM ()
/* Push the information about the state we will need
   Does `return FAILURE_CODE' if runs out of memory.  */
    char *destination;							\
    /* Must be int, so when we don't save any registers, the arithmetic	\
       of 0 + -1 isn't done as unsigned.  */				\
    /* Ensure we have enough space allocated for what we will push.  */	\
    /* Push the info, starting with the registers.  */			\
/* This is the number of items that are pushed and popped on the stack
   for each register.  */
/* Individual items aside from the registers.  */
#define NUM_NONREG_ITEMS 5 /* Includes failure point id.  */
/* We push at most this many items on the stack.  */
#define MAX_FAILURE_ITEMS ((num_regs - 1) * NUM_REG_ITEMS + NUM_NONREG_ITEMS)
/* We actually push this many items.  */
  ((highest_active_reg - lowest_active_reg + 1) * NUM_REG_ITEMS 	\
/* How many items can still be added to the stack without overflowing it.  */
/* Pops what PUSH_FAIL_STACK pushes.
   `pend', `string1', `size1', `string2', and `size2'.  */
  const unsigned char *string_temp;					\
  /* Remove failure points and point to how many regs pushed.  */	\
  /* If the saved string location is NULL, it came from an		\
     saved NULL, thus retaining our current position in the string.  */	\
    str = (const char *) string_temp;					\
  pat = (unsigned char *) POP_FAILURE_ITEM ();				\
  /* Restore register info.  */						\
      regend[this_reg] = (const char *) POP_FAILURE_ITEM ();		\
      regstart[this_reg] = (const char *) POP_FAILURE_ITEM ();		\
} /* POP_FAILURE_POINT */
/* re_compile_fastmap computes a ``fastmap'' for the compiled pattern in
   Returns 0 if we succeed, -2 if an internal error.   */
     struct re_pattern_buffer *bufp;
  char *destination;
  /* We don't push any register information onto the failure stack.  */
  register char *fastmap = bufp->fastmap;
  unsigned char *pattern = bufp->buffer;
  const unsigned char *p = pattern;
  register unsigned char *pend = pattern + size;
  /* Assume that each path through the pattern can be null until
     match the empty string.  */
  /* We aren't doing a `succeed_n' to begin with.  */
  bzero (fastmap, 1 << BYTEWIDTH);  /* Assume nothing's valid.  */
  bufp->fastmap_accurate = 1;	    /* It will be when we're done.  */
          /* Reset for next path.  */
      /* We should never be about to go beyond the end of the pattern.  */
      switch ((int) ((re_opcode_t) *p++))
      switch ((re_opcode_t) *p++)
        /* I guess the idea here is to simply not bother with a fastmap
           that is all we do.  */
      /* Following are the cases which match a character.  These end
         with `break'.  */
          for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
	  /* Chars beyond end of map must be allowed.  */
	  for (j = *p * BYTEWIDTH; j < (1 << BYTEWIDTH); j++)
	  for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
          /* `.' matches anything ...  */
          /* ... except perhaps newline.  */
          /* Return if we have already set `can_be_null'; if we have,
             then the fastmap is irrelevant.  Something's wrong here.  */
          /* Otherwise, have to check alternative paths.  */
	  k = *p++;
	  k = *p++;
      /* All cases after this match the empty string.  These end with
         `continue'.  */
#endif /* not emacs */
          /* Jump backward implies we just went through the body of a
             ordinary jump.  For a * loop, it has pushed its failure
             point already; if so, discard that as redundant.  */
          if ((re_opcode_t) *p != on_failure_jump
	      && (re_opcode_t) *p != succeed_n)
          /* If what's on the stack is where we are now, pop it.  */
          /* For some patterns, e.g., `(a?)?', `p+j' here points to the
             the null string, though.  */
              EXTRACT_NUMBER_AND_INCR (k, p);	/* Skip the n.  */
          /* Get to the number of times to succeed.  */
          /* Increment p past the n for when k != 0.  */
  	      succeed_n_p = true;  /* Spaghetti code alert.  */
          abort (); /* We have listed all the cases.  */
        } /* switch *p++ */
      /* Getting here means we have found the possible starting
         does these things.  */
    } /* while p */
  /* Set `can_be_null' for the last path (also the first path, if the
     pattern is empty).  */
} /* re_compile_fastmap */
/* Set REGS to hold NUM_REGS registers, storing them in STARTS and
   be at least NUM_REGS * sizeof (regoff_t) bytes long.
   freeing the old data.  */
    struct re_pattern_buffer *bufp;
    struct re_registers *regs;
    regoff_t *starts, *ends;
/* Searching routines.  */
/* Like re_search_2, below, but only one string is specified, and
   doesn't let you say where to stop matching. */
     struct re_pattern_buffer *bufp;
     const char *string;
     struct re_registers *regs;
/* Using the compiled pattern in BUFP->buffer, first tries to match the
   stack overflow).  */
     struct re_pattern_buffer *bufp;
     const char *string1, *string2;
     struct re_registers *regs;
  register char *fastmap = bufp->fastmap;
  register char *translate = bufp->translate;
  /* Check for out-of-range STARTPOS.  */
  /* Fix up RANGE if it might eventually take us outside
     the virtual concatenation of STRING1 and STRING2.  */
  /* If the search isn't to be a backwards one, don't waste time in a
     search for a pattern that must be anchored.  */
  /* Update the fastmap now if not correct already.  */
  /* Loop through the string, looking for a place to start matching.  */
      /* If a fastmap is supplied, skip quickly over characters that
         the first null string.  */
	  if (range > 0)	/* Searching forwards.  */
	      register const char *d;
              /* Written out as an if-else to avoid testing `translate'
                 inside the loop.  */
				   translate[(unsigned char) *d++]])
                while (range > lim && !fastmap[(unsigned char) *d++])
	  else				/* Searching backwards.  */
      /* If can't match the null string, and that's all we have left, fail.  */
} /* re_search_2 */
/* Declarations and macros for re_match_2.  */
/* Structure for per-register (a.k.a. per-group) information.
   failure stack.  */
      /* This field is one if this group can match the empty string,
         zero if not.  If not yet determined,  `MATCH_NULL_UNSET_VALUE'.  */
/* Call this when have matched a real character; it sets `matched' flags
   that those subexprs have matched.  */
/* This converts PTR, a pointer into one of the search strings `string1'
   and `string2' into an offset from the beginning of that string.  */
/* Registers are set to a sentinel when they haven't yet matched.  */
#define REG_UNSET_VALUE ((char *) -1)
/* Macros for dealing with the split strings in re_match_2.  */
/* Call before fetching a character with *d.  This switches over to
   string2 if necessary.  */
      /* End of string2 => fail.  */					\
      /* End of string1 => advance to string2.  */ 			\
/* Test if at very beginning or at very end of the virtual concatenation
   of `string1' and `string2'.  If only one string, it's `string2'.  */
/* Test if D points to a character which is word-constituent.  We have
   string2, look at the last character in string1.  */
  (SYNTAX ((d) == end1 ? *string2					\
           : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\
/* Test if the character before D and the one at D differ with respect
   to being word-constituent.  */
/* Free everything we malloc.  */
#else /* not REGEX_MALLOC */
/* Some MIPS systems (at least) want this to free alloca'd storage.  */
#endif /* not REGEX_MALLOC */
/* These values must meet several constraints.  They must not be valid
   to actually save any registers when none are active.  */
/* Matching routines.  */
#ifndef emacs   /* Emacs never uses this.  */
/* re_match is like re_match_2 except it takes only a single string.  */
     struct re_pattern_buffer *bufp;
     const char *string;
     struct re_registers *regs;
#endif /* not emacs */
/* re_match_2 matches the compiled pattern in BUFP against the
   matched substring.  */
     struct re_pattern_buffer *bufp;
     const char *string1, *string2;
     struct re_registers *regs;
  /* General temporaries.  */
  unsigned char *p1;
  /* Just past the end of the corresponding string.  */
  const char *end1, *end2;
  /* Pointers into string1 and string2, just past the last characters in
     each to consider matching.  */
  const char *end_match_1, *end_match_2;
  /* Where we are in the data, and the end of the current string.  */
  const char *d, *dend;
  /* Where we are in the pattern, and the end of the pattern.  */
  unsigned char *p = bufp->buffer;
  register unsigned char *pend = p + bufp->used;
  /* We use this to map every character in the string.  */
  char *translate = bufp->translate;
  /* Failure point stack.  Each place that can handle a failure further
     registers, and, finally, two char *'s.  The first char * is where
     it gets discarded and the next next one is tried.  */
  /* We fill all the registers internally, independent of what we
     an element for register zero.  */
  /* The currently active registers.  */
  /* Information on the contents of registers. These are pointers into
     keeps track of what the whole pattern matches.)  */
  const char **regstart, **regend;
  /* If a group that's operated upon by a repetition operator fails to
     register's end.  */
  const char **old_regstart, **old_regend;
  /* The is_active field of reg_info helps us keep track of which (possibly
     loop their register is in.  */
  register_info_type *reg_info; 
  /* The following record the register info as found in the above
     turn happens only if we have not yet matched the entire string. */
  const char **best_regstart, **best_regend;
  /* Logically, this is `best_regend[0]'.  But we don't want to have to
     and need to test it, it's not garbage.  */
  const char *match_end = NULL;
  /* Used when we pop values we don't care about.  */
  const char **reg_dummy;
  register_info_type *reg_info_dummy;
  /* Counts the total number of registers pushed.  */
  /* Do not bother to initialize all the register variables if there are
     array indexing.  We should fix this.  */
      regstart = REGEX_TALLOC (num_regs, const char *);
      regend = REGEX_TALLOC (num_regs, const char *);
      old_regstart = REGEX_TALLOC (num_regs, const char *);
      old_regend = REGEX_TALLOC (num_regs, const char *);
      best_regstart = REGEX_TALLOC (num_regs, const char *);
      best_regend = REGEX_TALLOC (num_regs, const char *);
      reg_dummy = REGEX_TALLOC (num_regs, const char *);
      /* We must initialize all our variables to NULL, so that
         `FREE_VARIABLES' doesn't try to free them.  */
      reg_info = reg_info_dummy = (register_info_type *) NULL;
#endif /* REGEX_MALLOC */
  /* The starting position is bogus.  */
  /* Initialize subexpression text positions to -1 to mark ones that no
     register information struct.  */
  /* We move `string1' into `string2' if the latter's empty -- but not if
     `string1' is null.  */
  /* Compute where to stop matching, within the two strings.  */
  /* `p' scans through the pattern as `d' scans through the data. 
     equal `string2'.  */
  /* This loops over pattern commands.  It exits by returning from the
     fails at this starting point in the input data.  */
	{ /* End of pattern means we might have succeeded.  */
	  /* If we haven't matched the entire string, and we want the
             longest match, try backtracking.  */
                { /* More failure points to try.  */
                  /* If exceeds best match so far, save it.  */
              /* If no failure points, don't restore garbage.  */
                  /* Restore best match.  It may happen that `dend ==
                     For example, the pattern `x.*y.*z' against the
                     not consecutive in memory.  */
            } /* d != end_match_2 */
          /* If caller wants register contents data back, do it.  */
              /* Have the register data arrays been allocated?  */
                { /* No.  So allocate them with malloc.  We need one
                     GNU code uses.  */
                { /* Yes.  If we need more elements than were already
                     leave it alone.  */
		  /* These braces fend off a "empty body in an else-statement"
		     warning under GCC when assert expands to nothing.  */
              /* Convert the pointer data in `regstart' and `regend' to
                 since we haven't kept track of any info for it.  */
              /* Go through the first `min (num_regs, regs->num_regs)'
                 registers, since that is all we initialized.  */
              /* If the regs structure we return has more elements than
                 -1 at the end.  */
	    } /* regs && !bufp->no_sub */
      /* Otherwise match next pattern command.  */
      switch ((int) ((re_opcode_t) *p++))
      switch ((re_opcode_t) *p++)
        /* Ignore these.  Used to ignore the n of succeed_n's which
           currently have n == 0.  */
        /* Match the next n pattern characters exactly.  The following
           are the characters to match.  */
	  mcnt = *p++;
          /* This is written out as an if-else so we don't waste time
             testing `translate' inside the loop.  */
		  if (translate[(unsigned char) *d++] != (char) *p++)
		  if (*d++ != (char) *p++) goto fail;
        /* Match any character except possibly a newline or a null.  */
          if ((!(bufp->syntax & RE_DOT_NEWLINE) && TRANSLATE (*d) == '\n')
              || (bufp->syntax & RE_DOT_NOT_NULL && TRANSLATE (*d) == '\000'))
          DEBUG_PRINT2 ("  Matched `%d'.\n", *d);
	    boolean not = (re_opcode_t) *(p - 1) == charset_not;
	    c = TRANSLATE (*d); /* The character to match.  */
            /* Cast to `unsigned' instead of `unsigned char' in case the
               bit list is a full 32 bytes long.  */
	    if (c < (unsigned) (*p * BYTEWIDTH)
	    p += 1 + *p;
        /* The beginning of a group is represented by start_memory.
           registers data structure) under the register number.  */
	  DEBUG_PRINT3 ("EXECUTING start_memory %d (%d):\n", *p, p[1]);
          /* Find out if this group can match the empty string.  */
	  p1 = p;		/* To send to group_match_null_string_p.  */
          if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)
            REG_MATCH_NULL_STRING_P (reg_info[*p]) 
          /* Save the position in the string where we were the last time
             operated upon by a repetition operator, e.g., with `(a*)*b'
             the string in case this attempt to match fails.  */
          old_regstart[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
                             ? REG_UNSET (regstart[*p]) ? d : regstart[*p]
                             : regstart[*p];
			 POINTER_TO_OFFSET (old_regstart[*p]));
          regstart[*p] = d;
	  DEBUG_PRINT2 ("  regstart: %d\n", POINTER_TO_OFFSET (regstart[*p]));
          IS_ACTIVE (reg_info[*p]) = 1;
          MATCHED_SOMETHING (reg_info[*p]) = 0;
          /* This is the new highest active register.  */
          highest_active_reg = *p;
          /* If nothing was active before, this is the new lowest active
             register.  */
            lowest_active_reg = *p;
          /* Move past the register number and inner group count.  */
        /* The stop_memory opcode represents the end of a group.  Its
           number, and the number of inner groups.  */
	  DEBUG_PRINT3 ("EXECUTING stop_memory %d (%d):\n", *p, p[1]);
          /* We need to save the string position the last time we were at
             upon by a repetition operator, e.g., with `((a*)*(b*)*)*'
             the string in case this attempt to match fails.  */
          old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
                           ? REG_UNSET (regend[*p]) ? d : regend[*p]
			   : regend[*p];
			 POINTER_TO_OFFSET (old_regend[*p]));
          regend[*p] = d;
	  DEBUG_PRINT2 ("      regend: %d\n", POINTER_TO_OFFSET (regend[*p]));
          /* This register isn't active anymore.  */
          IS_ACTIVE (reg_info[*p]) = 0;
          /* If this was the only register active, nothing is active
             anymore.  */
            { /* We must scan for the new highest active register, since
                 new highest active register is 1.  */
              unsigned char r = *p - 1;
              /* If we end up at register zero, that means that we saved
                 `stop_memory'.  For example, in ((.)*) we save
                 registers 1 and 2 as a result of the *, but when we pop
                 Thus, nothing is active.  */
          /* If just failed to match something this time around with a
             last match.  */
          if ((!MATCHED_SOMETHING (reg_info[*p])
              switch ((re_opcode_t) *p1++)
                    /* do nothing */ ;
              /* If the next operation is a jump backwards in the pattern
                 on_failure_jump's jump in the pattern, and d.  */
              if (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump
                  && (re_opcode_t) p1[3] == start_memory && p1[4] == *p)
                  /* If this group ever matched anything, then restore
                     failed match, e.g., with `(a*)*b' against `ab' for
                     regstart[1], and, e.g., with `((a*)*(b*)*)*'
                     e.g., `((a*)(b*))*' against `aba' (register 3 would
                     otherwise get trashed).  */
                  if (EVER_MATCHED_SOMETHING (reg_info[*p]))
                      EVER_MATCHED_SOMETHING (reg_info[*p]) = 0;
		      /* Restore this and inner groups' (if any) registers.  */
                      for (r = *p; r < *p + *(p + 1); r++)
                          /* xx why this test?  */
          /* Move past the register number and the inner group count.  */
	/* \<digit> has been turned into a `duplicate' command which is
           followed by the numeric value of <digit> as the register number.  */
	    register const char *d2, *dend2;
	    int regno = *p++;   /* Get which register to match against.  */
	    /* Can't back reference a group which we've never matched.  */
            /* Where in input to try to start matching.  */
            /* Where to stop matching; if both the place to start and
               the end of the first string.  */
		/* If necessary, advance to next segment in register
                   contents.  */
                    /* End of string1 => advance to string2. */
		/* At end of register contents => success */
		/* If necessary, advance to next segment in data.  */
		/* How many characters left in this segment to match.  */
		/* Want how many consecutive characters we can match in
                   one shot, so, if necessary, adjust the count.  */
		/* Compare that many; failure if mismatch, else move
                   past them.  */
        /* begline matches the empty string at the beginning of the string
           `newline_anchor' is set, after newlines.  */
          /* In all other cases, we fail.  */
        /* endline is the dual of begline.  */
          /* We have to ``prefetch'' the next character.  */
          else if ((d == end1 ? *string2 : *d) == '\n'
	/* Match at the very beginning of the data.  */
	/* Match at the very end of the data.  */
        /* on_failure_keep_string_jump is used to optimize `.*\n'.  It
           matching `foo\nbar' against `.*\n'.  The .* matches the foo;
           case; that seems worse than this.  */
	/* Uses of on_failure_jump:
           pop_failure_jump back to this on_failure_jump.  */
          /* If this on_failure_jump comes right before a group (i.e.,
             the original * applied to a group), save the information
             For example, in \(a*\)*\1, we need the preceding group,
             and in \(\(a*\)b*\)\2, we need the inner group.  */
          /* We can't use `p' to check ahead because we push
             a failure point to `p + mcnt' after we do this.  */
          /* We need to skip no_op's before we look for the
             against aba.  */
          while (p1 < pend && (re_opcode_t) *p1 == no_op)
          if (p1 < pend && (re_opcode_t) *p1 == start_memory)
              /* We have a new highest active register now.  This will
                 this repetition op, as described above.  */
              highest_active_reg = *(p1 + 1) + *(p1 + 2);
                lowest_active_reg = *(p1 + 1);
        /* A smart repeat ends with `maybe_pop_jump'.
	   We change it to either `pop_failure_jump' or `jump'.  */
	    register unsigned char *p2 = p;
            /* Compare the beginning of the repeat with what in the
               would have to backtrack because of (as in, e.g., `a*a')
               `(a|ab)*' we do need to backtrack to the `ab' alternative
               failure point which is what we will end up popping.  */
	    /* Skip over open/close-group commands.  */
		   && ((re_opcode_t) *p2 == stop_memory
		       || (re_opcode_t) *p2 == start_memory))
	      p2 += 3;			/* Skip over args, too.  */
            /* If we're at the end of the pattern, we can change.  */
		/* Consider what happens when matching ":\(.*\)"
		   yet.  */
            else if ((re_opcode_t) *p2 == exactn
		     || (bufp->newline_anchor && (re_opcode_t) *p2 == endline))
                  = *p2 == (unsigned char) endline ? '\n' : p2[2];
                /* p1[0] ... p1[2] are the `on_failure_jump' corresponding
                   follows.  */
		    if (c < (unsigned char) (p1[4] * BYTEWIDTH)
                    /* `not' is equal to 1 if c would match, which means
                        that we can't change to pop_failure_jump.  */
	  p -= 2;		/* Point at relative address again.  */
        /* Note fall through.  */
	/* The end of a simple repeat has a pop_failure_jump back to
           matching on_failure_jump, so didn't fail.  */
            /* We need to pass separate storage for the lowest and
               `pop_failure_point'.  */
            unsigned char *pdummy;
            const char *sdummy;
          /* Note fall through.  */
        /* Unconditionally jump (without popping any failure points).  */
	  EXTRACT_NUMBER_AND_INCR (mcnt, p);	/* Get the amount to jump.  */
	  p += mcnt;				/* Do the jump.  */
        /* We need this opcode so we can detect where alternatives end
           in `group_match_null_string_p' et al.  */
        /* Normally, the on_failure_jump pushes a failure point, which
           something meaningless for pop_failure_jump to pop.  */
          /* It doesn't matter what we push for the string here.  What
             the code at `fail' tests is the value for the pattern.  */
        /* At the end of an alternative, we need to push a dummy failure
           popped.  For example, matching `(a|ab)*' against `aab'
           requires that we match the `ab' alternative.  */
          /* See comments just above at `dummy_failure_jump' about the
             two zeroes.  */
        /* Have to succeed matching what follows at least n times.
           After that, handle like `on_failure_jump'.  */
          /* Originally, this is how many times we HAVE to succeed.  */
          /* Originally, this is how many times we CAN jump.  */
          /* If don't have to jump any more, skip over the rest of command.  */
 	  if (PTR_CHAR_POS ((unsigned char *) d) >= point)
 	  if (PTR_CHAR_POS ((unsigned char *) d) != point)
          if (PTR_CHAR_POS ((unsigned char *) d) <= point)
#else /* not emacs19 */
	  if (PTR_CHAR_POS ((unsigned char *) d) + 1 != point)
#endif /* not emacs19 */
	  mcnt = *p++;
	  if (SYNTAX (*d++) != (enum syntaxcode) mcnt)
	  mcnt = *p++;
	  if (SYNTAX (*d++) == (enum syntaxcode) mcnt)
#else /* not emacs */
#endif /* not emacs */
      continue;  /* Successfully executed one pattern command; keep going.  */
    /* We goto here if a matching operation fails. */
	{ /* A restart point is known.  Restore to that state.  */
          /* If this failure point is a dummy, try the next one.  */
          /* If we failed to the end of the pattern, don't examine *p.  */
              /* If failed to a backwards jump that's part of a repetition
                 loop, need to pop this failure point and use the next one.  */
              switch ((re_opcode_t) *p)
                  if ((is_a_jump_n && (re_opcode_t) *p1 == succeed_n)
                          && (re_opcode_t) *p1 == on_failure_jump))
                  /* do nothing */ ;
        break;   /* Matching at this starting point really fails.  */
    } /* for (;;) */
  return -1;         			/* Failure to match.  */
} /* re_match_2 */
/* Subroutine definitions for re_match_2.  */
/* We are passed P pointing to a register number after a start_memory.
   We don't handle duplicates properly (yet).  */
    unsigned char **p, *end;
    register_info_type *reg_info;
  /* Point to after the args to the start_memory.  */
  unsigned char *p1 = *p + 2;
      /* Skip over opcodes that can match nothing, and return true or
         matching stop_memory.  */
      switch ((re_opcode_t) *p1)
        /* Could be either a loop or a series of alternatives.  */
          /* If the next operation is not a jump backwards in the
	     pattern.  */
              /* Go through the on_failure_jumps of the alternatives,
                 alternatives and then deal with the last one separately.  */
              /* Deal with the first (n-1) alternatives, which start
                 past a jump_past_alt.  */
                  /* `mcnt' holds how many bytes long the alternative
                     its number.  */
                  /* Move to right after this alternative, including the
		     jump_past_alt.  */
                  /* Break if it's the beginning of an n-th alternative
                     that doesn't begin with an on_failure_jump.  */
                  if ((re_opcode_t) *p1 != on_failure_jump)
		  /* Still have to check that it's not an n-th
		     alternative that starts with an on_failure_jump.  */
		      /* Get to the beginning of the n-th alternative.  */
              /* Deal with the last alternative: go back and get number
                 the length of the alternative.  */
              p1 += mcnt;	/* Get past the n-th alternative.  */
            } /* if mcnt > 0 */
	  assert (p1[1] == **p);
          *p = p1 + 2;
    } /* while p1 < end */
} /* group_match_null_string_p */
/* Similar to group_match_null_string_p, but doesn't deal with alternatives:
   byte past the last. The alternative can contain groups.  */
    unsigned char *p, *end;
    register_info_type *reg_info;
  unsigned char *p1 = p;
      /* Skip over opcodes that can match nothing, and break when we get 
         to one that can't.  */
      switch ((re_opcode_t) *p1)
	/* It's a loop.  */
    }  /* while p1 < end */
} /* alt_match_null_string_p */
/* Deals with the ops common to group_match_null_string_p and
   Sets P to one after the op and its arguments, if any.  */
    unsigned char **p, *end;
    register_info_type *reg_info;
  unsigned char *p1 = *p;
  switch ((re_opcode_t) *p1++)
      reg_no = *p1;
      /* Have to set this here in case we're checking a group which
         contains a group and a back reference to it.  */
    /* If this is an optimized succeed_n for zero times, make the jump.  */
      /* Get to the number of times to succeed.  */
      if (!REG_MATCH_NULL_STRING_P (reg_info[*p1]))
      /* All other opcodes mean we cannot match the empty string.  */
  *p = p1;
} /* common_op_match_null_string_p */
/* Return zero if TRANSLATE[S1] and TRANSLATE[S2] are identical for LEN
   bytes; nonzero otherwise.  */
     unsigned char *s1, *s2;
     char *translate;
  register unsigned char *p1 = s1, *p2 = s2;
      if (translate[*p1++] != translate[*p2++]) return 1;
/* Entry points for GNU code.  */
/* re_compile_pattern is the GNU regular expression compiler: it
   We call regex_compile to do the actual compilation.  */
const char *
     const char *pattern;
     struct re_pattern_buffer *bufp;
  /* GNU code is written to assume at least RE_NREGS registers will be set
     (and at least one extra will be -1).  */
  /* And GNU code determines whether or not to get register information
     setting no_sub.  */
  /* Match anchors at newline.  */
/* Entry points compatible with 4.2 BSD regex library.  We don't define
   them if this is an Emacs or POSIX compilation.  */
/* BSD has one and only one pattern buffer.  */
char *
    const char *s;
      re_comp_buf.buffer = (unsigned char *) malloc (200);
      re_comp_buf.fastmap = (char *) malloc (1 << BYTEWIDTH);
  /* Since `re_exec' always passes NULL for the `regs' argument, we
     don't need to initialize the pattern buffer fields which affect it.  */
  /* Match anchors at newlines.  */
  /* Yes, we're discarding `const' here.  */
  return (char *) re_error_msg[(int) ret];
    const char *s;
    0 <= re_search (&re_comp_buf, s, len, 0, len, (struct re_registers *) 0);
#endif /* not emacs and not _POSIX_SOURCE */
/* POSIX.2 functions.  Don't define these for Emacs.  */
/* regcomp takes a regular expression as a string and compiles it.
   PREG is a regex_t *.  We do not expect any fields to be initialized,
   the return codes and their meanings.)  */
    regex_t *preg;
    const char *pattern; 
  /* regex_compile will allocate the space for the compiled pattern.  */
  /* Don't bother to use a fastmap when searching.  This simplifies the
     every character.  */
      preg->translate = (char *) malloc (CHAR_SET_SIZE);
      /* Map uppercase characters to corresponding lowercase ones.  */
  /* If REG_NEWLINE is set, newlines are treated differently.  */
    { /* REG_NEWLINE implies neither . nor [^...] match newline.  */
      /* It also changes the matching behavior.  */
  /* POSIX says a null character in the pattern terminates it, so we 
     can use strlen here in compiling the pattern.  */
  /* POSIX doesn't distinguish between an unmatched open-group and an
     unmatched close-group: both are REG_EPAREN.  */
/* regexec searches for a given pattern, specified by PREG, in the
   We return 0 if we find a match and REG_NOMATCH if not.  */
    const regex_t *preg;
    const char *string; 
  private_preg = *preg;
  /* The user has told us exactly how many registers to return
     matching routines.  */
  /* Perform the searching operation.  */
                   /* start: */ 0, /* range: */ len,
                   want_reg_info ? &regs : (struct re_registers *) 0);
  /* Copy the register information to the POSIX structure.  */
      /* If we needed the temporary register info, free the space now.  */
  /* We want zero return to mean success, unlike `re_search'.  */
/* Returns a message corresponding to an error code, ERRCODE, returned
   from either regcomp or regexec.   We don't use PREG here.  */
    const regex_t *preg;
    char *errbuf;
  const char *msg;
    /* Only error codes returned by the rest of the code should be passed 
       Dump core so we can fix it.  */
  /* POSIX doesn't require that we do anything in this case, but why
     not be nice.  */
  msg_size = strlen (msg) + 1; /* Includes the null.  */
/* Free dynamically allocated space used by PREG.  */
    regex_t *preg;
#endif /* not emacs  */
/*
*/
/* dfa.c - deterministic extended regexp routines for GNU
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
/* Written June, 1988 by Mike Haertel
   Modified July, 1988 by Arthur David Olson to assist BMG speedups  */
/*#include <assert.h> */
/*#include <ctype.h> */
/*#include <stdio.h> */
extern char *calloc(), *malloc(), *realloc();
/*#include "regex.h"*/
typedef void *ptr_t;
typedef char *ptr_t;
#define CALLOC(p, t, n) ((p) = (t *) xcalloc((n), sizeof (t)))
#define MALLOC(p, t, n) ((p) = (t *) xmalloc_1((n) * sizeof (t)))
#define REALLOC(p, t, n) ((p) = (t *) xrealloc_1((ptr_t) (p), (n) * sizeof (t)))
/* Reallocate an array of type t if nalloc is too small for index. */
	(nalloc) *= 2;				  \
  char *s;
#endif /* DEBUG */
/* Stuff pertaining to charclasses. */
/* A pointer to the current dfa is kept here during parsing. */
static struct dfa *dfa;
/* Find the index of charclass s in dfa->charclasses, or allocate a new charclass. */
/* Syntax bits controlling the behavior of the lexical analyzer. */
/* Flag for case-folding letters into sets. */
/* Entry point to set syntax options. */
/* Lexical analyzer.  All the dross that deals with the obnoxious
   meaning of the @#%!@#%^!@ syntax bits. */
static char *lexstart;		/* Pointer to beginning of input string. */
static char *lexptr;		/* Pointer to next input character. */
static lexleft;			/* Number of characters remaining. */
static token lasttok;		/* Previous token returned; initially END. */
static int laststart;		/* True if we're separated from beginning or (, |
				   only by zero-width characters. */
static int parens;		/* Count of outstanding left parens. */
static int minrep, maxrep;	/* Repeat counts for {m,n}. */
/* Note that characters become unsigned here. */
    (c) = (unsigned char) *lexptr++;  \
/* The following list maps the names of the Posix named character classes
   the class.  The leading [ has already been eaten by the lexical analyzer. */
  char *name;
  int (*pred)();
     char *s;
  /* Basic plan: We fetch a character.  If it's a backslash,
     "if (backslash) ...".  */
		  ? lexleft > 0 && *lexptr == ')'
		  ? lexleft > 0 && *lexptr == '|'
	          && lexleft > 0 && *lexptr == '\n'))
	case '*':
	  /* Cases:
	     {M,N} - M through N */
		  minrep = 10 * minrep + c - '0';
		maxrep = 10 * maxrep + c - '0';
	      /* Nobody ever said this had to be fast. :-)
		 dfa is ever called. */
			if ((*prednames[c1].pred)(c2))
		      /* In the case [x-], the - is an ordinary hyphen,
			 which is left in c1, the lookahead character. */
  /* The above loop should consume at most a backslash
     and some other character. */
/* Recursive descent parser for regular expressions. */
static token tok;		/* Lookahead token. */
static depth;			/* Current depth of a hypothetical stack
				   dfaanalyze(). */
/* Add the given token to the parse tree, maintaining the depth count and
   updating the maximum depth if necessary. */
/* The grammar understood by the parser is as follows.
   The parser builds a parse tree in postfix form in an array of tokens. */
/* Return the number of tokens in the given subexpression. */
/* Copy the given subexpression to the top of the tree. */
/* Main entry point for the parser.  S is a string to be parsed, len is the
   the struct dfa to parse into. */
     char *s;
     struct dfa *d;
/* Some primitives for operating on sets of positions. */
/* Copy one set to another; the destination must be large enough. */
     position_set *src;
     position_set *dst;
/* Insert a position in a set.  Position sets are maintained in sorted
   S->elems must point to an array large enough to hold the resulting set. */
     position_set *s;
/* Merge two sets of positions into a third.  The result is exactly as if
   the positions of both sets were inserted into an initially empty set. */
     position_set *s1;
     position_set *s2;
     position_set *m;
/* Delete a position from a set. */
     position_set *s;
/* Find the index of the state corresponding to the given position set with
   letter, respectively. */
     struct dfa *d;
     position_set *s;
  /* Try to find a state that exactly matches the proposed one. */
  /* We'll have to create a new state. */
/* Find the epsilon closure of a set of positions.  If any position of the set
   S->elems must be large enough to hold the result. */
     position_set *s;
     struct dfa *d;
  int *visited;
	/* Force rescan to start at the beginning. */
/* Perform bottom-up analysis on the parse tree, computing various functions.
   *  EMPTY leaves are nullable.
   * No other leaf is nullable.
   * A QMARK or STAR node is nullable.
   * A PLUS node is nullable if its argument is nullable.
   * A CAT node is nullable if both its arguments are nullable.
   * An OR node is nullable if either argument is nullable.
   * EMPTY leaves have empty firstpos.
   * The firstpos of a nonempty leaf is that leaf itself.
   * The firstpos of a QMARK, STAR, or PLUS node is the firstpos of its
   * The firstpos of a CAT node is the firstpos of the left argument, union
   * The firstpos of an OR node is the union of firstpos of each argument.
   * EMPTY leaves have empty lastpos.
   * The lastpos of a nonempty leaf is that leaf itself.
   * The lastpos of a QMARK, STAR, or PLUS node is the lastpos of its
   * The lastpos of a CAT node is the lastpos of its right argument, union
   * The lastpos of an OR node is the union of the lastpos of each argument.
   * Every node in the firstpos of the argument of a STAR or PLUS node is in
   * Every node in the firstpos of the second argument of a CAT node is in
   used to determine the address of a particular set's array. */
     struct dfa *d;
  int *nullable;		/* Nullable stack. */
  int *nfirstpos;		/* Element count stack for firstpos sets. */
  position *firstpos;		/* Array where firstpos elements are stored. */
  int *nlastpos;		/* Element count stack for lastpos sets. */
  position *lastpos;		/* Array where lastpos elements are stored. */
  int *nalloc;			/* Sizes of arrays allocated to follow sets. */
  position_set tmp;		/* Temporary set for merging sets. */
  position_set merged;		/* Result of merging sets. */
  int wants_newline;		/* True if some position wants newline info. */
  int *o_nullable;
  int *o_nfirst, *o_nlast;
  position *o_firstpos, *o_lastpos;
  position *pos;
    {				/* Nonsyntactic #ifdef goo... */
	/* The empty set is nullable. */
	*nullable++ = 1;
	/* The firstpos and lastpos of the empty leaf are both empty. */
	*nfirstpos++ = *nlastpos++ = 0;
	/* Every element in the firstpos of the argument is in the follow
	   of every element in the lastpos. */
	/* A QMARK or STAR node is automatically nullable. */
	/* Every element in the firstpos of the second argument is in the
	   follow of every element in the lastpos of the first argument. */
	/* The firstpos of a CAT node is the firstpos of the first argument,
	   union that of the second argument if the first is nullable. */
	/* The lastpos of a CAT node is the lastpos of the second argument,
	   union that of the first argument if the second is nullable. */
	/* A CAT node is nullable if both arguments are nullable. */
	/* The firstpos is the union of the firstpos of each argument. */
	/* The lastpos is the union of the lastpos of each argument. */
	/* An OR node is nullable if either argument is nullable. */
	/* Anything else is a nonempty position.  (Note that special
	   transitions on them later.  But they are nullable. */
	*nullable++ = d->tokens[i] == BACKREF;
	/* This position is in its own firstpos and lastpos. */
	*nfirstpos++ = *nlastpos++ = 1;
	/* Allocate the follow set for this position. */
    /* ... balance the above nonsyntactic #ifdef goo... */
  /* For each follow set that is the follow set of a real position, replace
     it with its epsilon closure. */
  /* Get the epsilon closure of the firstpos of the regexp.  The result will
     be the set of positions of state 0. */
  /* Check if any of the positions of state 0 will want newline context. */
  /* Build the initial state. */
/* Find, for each character, the transition out of state s of d, and store
   position in that group. */
     struct dfa *d;
  position_set grps[NOTCHAR];	/* As many as will ever be needed. */
  charclass labels[NOTCHAR];	/* Labels corresponding to the groups. */
  int ngrps = 0;		/* Number of groups actually used. */
  position pos;			/* Current position being considered. */
  charclass matches;		/* Set of matching characters. */
  int matchesf;			/* True if matches is nonempty. */
  charclass intersect;		/* Intersection with some label set. */
  int intersectf;		/* True if intersect is nonempty. */
  charclass leftovers;		/* Stuff in the label that didn't match. */
  int leftoversf;		/* True if leftovers is nonempty. */
  static charclass letters;	/* Set of characters considered letters. */
  static charclass newline;	/* Set of characters that aren't newline. */
  position_set follows;		/* Union of the follows of some group. */
  position_set tmp;		/* Temporary space for merging sets. */
  int state;			/* New state. */
  int wants_newline;		/* New state wants to know newline context. */
  int state_newline;		/* New state on a newline transition. */
  int wants_letter;		/* New state wants to know letter context. */
  int state_letter;		/* New state on a letter transition. */
  static initialized;		/* Flag for static initialization. */
  /* Initialize the set of letters, if necessary. */
      /* Some characters may need to be eliminated from matches because
	 they fail in the current context. */
	  /* If there are no characters left, there's no point in going on. */
	  /* If matches contains a single character only, and the current
	     next group. */
	  /* Check if this group's label has a nonempty intersection with
	     matches. */
	  /* It does; now find the set differences both ways. */
	      /* Even an optimizing compiler can't know this for sure. */
	  /* If there were leftovers, create a new group labeled with them. */
	  /* Put the position in the current group.  Note that there is no
	     reason to call insert() here. */
	  /* If every character matching the current position has been
	     accounted for, we're done. */
      /* If we've passed the last group, and there are still characters
	 unaccounted for, then we'll have to create a new group. */
  /* If we are a searching matcher, the default transition is to a state
     is to fail miserably. */
      /* Find the union of the follows of the positions of the group.
	 This is a hideously inefficient loop.  Fix it someday. */
      /* If we are building a searching matcher, throw in the positions
	 of state 0 as well. */
      /* Find out if the new state will want any context information. */
      /* Find the state(s) corresponding to the union of the follows. */
      /* Set the transitions for each character in the current label. */
	      int c = j * INTBITS + k;
/* Some routines for manipulating a compiled dfa's transition tables.
   TODO: Improve this comment, get rid of the unnecessary redundancy. */
     struct dfa *d;
  int *trans;			/* The new transition table. */
  /* Set an upper limit on the number of transition tables that will ever
     were only needed once or twice will be cleared away. */
  /* Set up the success bits for this state. */
      s, *d))
      s, *d))
      s, *d))
  /* Now go through the new transition table, and make sure that the trans
     largest state mentioned in the table. */
	  d->tralloc *= 2;
	REALLOC(d->realtrans, int *, d->tralloc + 1);
	REALLOC(d->fails, int *, d->tralloc);
  /* Keep the newline transition in a special place so we can use it as
     a sentinel. */
  if (ACCEPTING(s, *d))
     struct dfa *d;
  CALLOC(d->realtrans, int *, d->tralloc + 1);
  CALLOC(d->fails, int *, d->tralloc);
/* Search through a buffer looking for a match to the given struct dfa.
   its end.  We store a newline in *end to act as a sentinel, so end had
   we store a 0 in *backref. */
char *
     struct dfa *d;
     char *begin;
     char *end;
     int *count;
     int *backref;
  register s, s1, tmp;		/* Current state. */
  register unsigned char *p;	/* Current input character. */
  register **trans, *t;		/* Copy of d->trans so it can be optimized
				   into a register. */
  static sbit[NOTCHAR];	/* Table for anding with d->success. */
  p = (unsigned char *) begin;
  *end = '\n';
      /* The dreaded inner loop. */
	    s1 = t[*p++];
	    s = t[*p++];
      if (s >= 0 && p <= (unsigned char *) end && d->fails[s])
	  if (d->success[s] & sbit[*p])
		  *backref = 1;
		  *backref = 0;
	      return (char *) p;
	  s = d->fails[s][*p++];
      /* If the previous character was a newline, count it. */
      if (count && (char *) p <= end && p[-1] == '\n')
	++*count;
      /* Check if we've run off the end of the buffer. */
      if ((char *) p > end)
/* Initialize the components of a dfa that the other routines don't
   initialize for themselves. */
     struct dfa *d;
/* Parse and analyze a single string of the given length. */
     char *s;
     struct dfa *d;
  if (case_fold)	/* dummy folding in service of dfamust() */
      char *copy;
      /* This is a kludge. */
/* Free the storage held by the components of a dfa. */
     struct dfa *d;
  struct dfamust *dm, *ndm;
/* Having found the postfix representation of the regular expression,
					simplify the *entire* r.e. being sought)
	grep 'ab*'		->	grep 'a'
	grep 'a*b'		->	grep 'b'
   (something like 'ab*' is probably unlikely; something like is
   'psi|epsilon' is likelier)? */
static char *
     char *old;
     char *new;
  char *result;
    result = (char *) malloc(newsize + 1);
    result = (char *) realloc((void *) old, oldsize + newsize + 1);
static char *
     char *string;
  return icatalloc((char *) NULL, string);
static char *
     char *lookin;
     char *lookfor;
  char *cp;
  for (cp = lookin; *cp != '\0'; ++cp)
     char *cp;
     char **cpp;
static char **
     char **cpp;
     char *new;
  /* Is there already something in the list that's new (or longer)? */
  /* Eliminate any obsoleted strings. */
  /* Add the new string. */
  cpp = (char **) realloc((char *) cpp, (i + 2) * sizeof *cpp);
/* Given pointers to two strings, return a pointer to an allocated
   seems wild. */
static char **
     char *left;
     char *right;
  char **cpp;
  char *lcp;
  char *rcp;
  cpp = (char **) malloc(sizeof *cpp);
  for (lcp = left; *lcp != '\0'; ++lcp)
      rcp = index(right, *lcp);
	  rcp = index(rcp + 1, *lcp);
static char **
char **old;
char **new;
/* Given two lists of substrings, return a new list giving substrings
   common to both. */
static char **
     char **left;
     char **right;
  char **both;
  char **temp;
  both = (char **) malloc(sizeof *both);
  char **in;
  char *left;
  char *right;
  char *is;
must *mp;
struct dfa *dfa;
  must *musts;
  must *mp;
  char *result;
  struct dfamust *dm;
  musts = (must *) malloc((dfa->tindex + 1) * sizeof *musts);
      mp[i].in = (char **) malloc(sizeof *mp[i].in);
	  goto done;		/* "cannot happen" */
	    goto done;		/* "cannot happen" */
	    goto done;		/* "cannot happen" */
	    char **new;
	    must *lmp;
	    must *rmp;
	    /* Guaranteed to be.  Unlikely, but. . . */
	    /* Left side--easy */
	    /* Right side */
	    free((char *) lmp->in);
	    goto done;		/* "cannot happen" */
	    goto done;		/* "cannot happen" */
	    goto done;		/* "cannot happen" */
	    must *lmp;
	    must *rmp;
	    /* In.  Everything in left, plus everything in
	       left's right and right's left. */
		char *tp;
	    /* Left-hand */
	    /* Right-hand */
	    /* Guaranteed to be */
	      /* "cannot happen" */
	      /* not on *my* shift */
	      /* easy enough */
	      /* plain character */
      dm = (struct dfamust *) malloc(sizeof (struct dfamust));
      ifree((char *) mp[i].in);
  free((char *) mp);
/* kwset.c - search for any of a set of keywords.
   or (US mail) as Mike Haertel c/o Free Software Foundation. */
/* The algorithm implemented by these routines bears a startling resemblence
   Vol. 18, No. 6, which describes the failure function used below. */
extern char *malloc();
extern void *memchr();
extern char *memchr();
extern char *xmalloc();
/* Balanced tree of edges and labels leaving a given trie node. */
  struct tree *llink;		/* Left link; MUST be first field. */
  struct tree *rlink;		/* Right link (to larger labels). */
  struct trie *trie;		/* Trie node pointed to by this edge. */
  unsigned char label;		/* Label on this edge. */
  char balance;			/* Difference in depths of subtrees. */
/* Node of a trie representing a set of reversed keywords. */
  unsigned int accepting;	/* Word index of accepted word, or zero. */
  struct tree *links;		/* Tree of edges leaving this node. */
  struct trie *parent;		/* Parent of this node. */
  struct trie *next;		/* List of all trie nodes in level order. */
  struct trie *fail;		/* Aho-Corasick failure function. */
  int depth;			/* Depth of this node from the root. */
  int shift;			/* Shift function for search failures. */
  int maxshift;			/* Max shift of self and descendents. */
/* Structure returned opaquely to the caller, containing everything. */
  struct obstack obstack;	/* Obstack for node allocation. */
  int words;			/* Number of words in the trie. */
  struct trie *trie;		/* The trie itself. */
  int mind;			/* Minimum depth of an accepting node. */
  int maxd;			/* Maximum depth of any node. */
  unsigned char delta[NCHAR];	/* Delta table for rapid search. */
  struct trie *next[NCHAR];	/* Table of children of the root. */
  char *target;			/* Target string if there's only one. */
  int mind2;			/* Used in Boyer-Moore search for one string. */
  char *trans;			/* Character translation table. */
/* Allocate and initialize a keyword set object, returning an opaque
   pointer to it.  Return NULL if memory is not available. */
     char *trans;
  struct kwset *kwset;
  kwset = (struct kwset *) malloc(sizeof (struct kwset));
    = (struct trie *) obstack_alloc(&kwset->obstack, sizeof (struct trie));
/* Add the given string to the contents of the keyword set.  Return NULL
   for success, an error message otherwise. */
char *
     char *text;
  struct kwset *kwset;
  register struct trie *trie;
  register struct tree *link;
  struct tree *links[12];
  struct tree *t, *r, *l, *rl, *lr;
  kwset = (struct kwset *) kws;
  /* Descend the trie (built of reversed keywords) character-by-character,
     installing new nodes when necessary. */
      label = kwset->trans ? kwset->trans[(unsigned char) *--text] : *--text;
      /* Descend the tree of outgoing links for this trie node,
	 of the path followed. */
      links[0] = (struct tree *) &trie->links;
      /* The current character doesn't have an outgoing link at
	 a link in the current trie node's tree. */
	  link = (struct tree *) obstack_alloc(&kwset->obstack,
	  link->trie = (struct trie *) obstack_alloc(&kwset->obstack,
	  /* Install the new tree node in its parent. */
	  /* Back up the tree fixing the balance flags. */
	  /* Rebalance the tree by pointer rotations if necessary. */
  /* Mark the node we finally reached as accepting, encoding the
     index number of this word in the keyword set so far. */
    trie->accepting = 1 + 2 * kwset->words;
  /* Keep track of the longest and shortest string of the keyword set. */
/* Enqueue the trie nodes referenced from the given tree in the
   given queue. */
     struct tree *tree;
     struct trie **last;
  (*last) = (*last)->next = tree->trie;
/* Compute the Aho-Corasick failure function for the trie nodes referenced
   well as a last resort failure node. */
     register struct tree *tree;
     struct trie *fail;
     struct trie *recourse;
  register struct tree *link;
  /* Find, in the chain of fails going back to the root, the first
     node that has a descendent on the current label. */
/* Set delta entries for the links of the given tree such that
   the preexisting delta value is larger than the current depth. */
     register struct tree *tree;
/* Return true if A has every label in B. */
     register struct tree *a;
     register struct tree *b;
/* Compute a vector, indexed by character code, of the trie nodes
   referenced from the given tree. */
     struct tree *tree;
     struct trie *next[];
/* Compute the shift for each trie node, as well as the delta
   table and next cache for the given keyword set. */
char *
  register struct kwset *kwset;
  register struct trie *curr, *fail;
  register char *trans;
  struct trie *last, *next[NCHAR];
  kwset = (struct kwset *) kws;
  /* Initial values for the delta table; will be changed later.  The
     node at which an outgoing edge is labeled by that character. */
  /* Check if we can use the simple boyer-moore algorithm, instead
     of the hairy commentz-walter algorithm. */
      /* Looking for just one string.  Extract it from the trie. */
      /* Build the Boyer Moore delta.  Boy that's easy compared to CW. */
      /* Find the minimal delta2 shift that we might make after
	 a backwards match has failed. */
      /* Traverse the nodes of the trie in level order, simultaneously
	 computing the delta table, failure function, and shift function. */
	  /* Enqueue the immediate descendents in the level order queue. */
	  /* Update the delta table for the descendents of this node. */
	  /* Compute the failure function for the decendents of this node. */
	  /* Update the shifts at each node in the current node's chain
	     of fails back to the root. */
	      /* If the current node has some outgoing edge that the fail
		 than the difference of their depths. */
	      /* If the current node is accepting then the shift at the
		 difference of their depths. */
      /* Traverse the trie in level order again, fixing up all nodes whose
	 shift exceeds their inherited maxshift. */
      /* Create a vector, indexed by character code, of the outgoing links
	 from the root node. */
  /* Fix things up for any translation table. */
/* Fast boyer-moore search. */
static char *
     char *text;
  struct kwset *kwset;
  register unsigned char *d1;
  register char *ep, *sp, *tp;
  kwset = (struct kwset *) kws;
  /* Significance of 12: 1 (initial offset) + 10 (skip loop) + 1 (md2). */
  if (size > 12 * len)
    /* 11 is not a bug, the initial offset happens only once. */
    for (ep = text + size - 11 * len;;)
  /* Now we have only a few characters left to search.  We
     carefully avoid ever producing an out-of-bounds pointer. */
/* Hairy multiple string search. */
static char *
     char *text;
     struct kwsmatch *kwsmatch;
  struct kwset *kwset;
  struct trie **next, *trie, *accept;
  char *beg, *lim, *mch, *lmch;
  register unsigned char c, *delta;
  register char *end, *qlim;
  register struct tree *tree;
  register char *trans;
  /* Initialize register copies and look for easy ways out. */
  kwset = (struct kwset *) kws;
  if (len >= 4 * kwset->mind)
    qlim = lim - 4 * kwset->mind;
	  while ((d = delta[c = *end]) && end < qlim)
	      end += delta[(unsigned char) *end];
	      end += delta[(unsigned char) *end];
	  c = trans ? trans[(unsigned char) *--beg] : *--beg;
  /* Given a known match, find the longest possible match anchored
     copy of the preceding main search loops. */
	  c = trans ? trans[(unsigned char) *--beg] : *--beg;
/* Search through the given text for a match of any member of the
   keyword matched. */
char *
     char *text;
     struct kwsmatch *kwsmatch;
  struct kwset *kwset;
  char *ret;
  kwset = (struct kwset *) kws;
/* Free the components of the given keyword set. */
  struct kwset *kwset;
  kwset = (struct kwset *) kws;
/* obstack.c - subroutines used implicitly by object stack macros
Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
/*#include "obstack.h"*/
/* This is just to get __GNU_LIBRARY__ defined.  */
/*#include <stdio.h>*/
/* Comment out all this code if we are using the GNU C Library, and are not
   it is simpler to just do this in the source for each such file.  */
#define POINTER void *
#define POINTER char *
/* Determine default alignment.  */
  ((PTR_INT_TYPE) ((char *)&((struct fooalign *) 0)->d - (char *)0))
/* If malloc were really smart, it would round addresses to DEFAULT_ALIGNMENT.
   DEFAULT_ROUNDING.  So we prepare for it to do that.  */
/* When we copy a long block of data, this is the unit to do it with.
   or `char' as a last resort.  */
/* The non-GNU-C macros copy the obstack into this global variable
   to avoid multiple evaluation.  */
struct obstack *_obstack;
/* Define a macro that either calls functions with the traditional malloc/free
   do not allow (expr) ? void : void.  */
   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
   : (*(h)->chunkfun) ((size)))
      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
      (*(h)->freefun) ((old_chunk)); \
/* Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).
   and FREEFUN the function to free them.  */
     struct obstack *h;
     POINTER (*chunkfun) ();
     void (*freefun) ();
  register struct _obstack_chunk* chunk; /* points to new chunk */
    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
	 less sensitive to the size of the request.  */
  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
    = (char *) chunk + h->chunk_size;
  /* The initial chunk now contains no empty object.  */
     struct obstack *h;
     POINTER (*chunkfun) ();
     void (*freefun) ();
  register struct _obstack_chunk* chunk; /* points to new chunk */
    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
	 less sensitive to the size of the request.  */
  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
    = (char *) chunk + h->chunk_size;
  /* The initial chunk now contains no empty object.  */
/* Allocate a new current chunk for the obstack *H
   to the beginning of the new one.  */
     struct obstack *h;
  register struct _obstack_chunk*	old_chunk = h->chunk;
  register struct _obstack_chunk*	new_chunk;
  /* Compute size for new chunk.  */
  /* Allocate and initialize the new chunk.  */
  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;
  /* Move the existing object to the new chunk.
     is sufficiently aligned.  */
	((COPYING_UNIT *)new_chunk->contents)[i]
	  = ((COPYING_UNIT *)h->object_base)[i];
      /* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,
	 which does not do strict alignment for COPYING_UNITS.  */
      already = obj_size / sizeof (COPYING_UNIT) * sizeof (COPYING_UNIT);
  /* Copy remaining bytes one by one.  */
  /* If the object just copied was the only data in OLD_CHUNK,
     But not if that chunk might contain an empty object.  */
  /* The new chunk certainly contains no empty object yet.  */
/* Return nonzero if object OBJ has been allocated from obstack H.
   If you use it in a program, you are probably losing.  */
     struct obstack *h;
  register struct _obstack_chunk*  lp;	/* below addr of any objects in this chunk */
  register struct _obstack_chunk*  plp;	/* point to previous chunk if any */
  /* We use >= rather than > since the object cannot be exactly at
     at the end of an adjacent chunk. */
/* Free objects in obstack H, including OBJ and everything allocate
   more recently than OBJ.  If OBJ is zero, free everything in H.  */
/* This function has two names with identical definitions.
   This is the first one, called from non-ANSI code.  */
     struct obstack *h;
  register struct _obstack_chunk*  lp;	/* below addr of any objects in this chunk */
  register struct _obstack_chunk*  plp;	/* point to previous chunk if any */
  /* We use >= because there cannot be an object at the beginning of a chunk.
     at the end of another chunk.  */
      /* If we switch chunks, we can't tell whether the new current
	 chunk contains an empty object, so assume that it may.  */
      h->object_base = h->next_free = (char *)(obj);
    /* obj is not in any of the chunks! */
/* This function is used from ANSI code.  */
     struct obstack *h;
  register struct _obstack_chunk*  lp;	/* below addr of any objects in this chunk */
  register struct _obstack_chunk*  plp;	/* point to previous chunk if any */
  /* We use >= because there cannot be an object at the beginning of a chunk.
     at the end of another chunk.  */
      /* If we switch chunks, we can't tell whether the new current
	 chunk contains an empty object, so assume that it may.  */
      h->object_base = h->next_free = (char *)(obj);
    /* obj is not in any of the chunks! */
/* These are now turned off because the applications do not use it
   and it uses bcopy via obstack_grow, which causes trouble on sysV.  */
/* Now define the functional versions of the obstack macros.
   Define them to simply use the corresponding macros to do the job.  */
/* These function definitions do not work with non-ANSI preprocessors;
   they won't pass through the macro names in parentheses.  */
/* The function names appear in parentheses in order to prevent
   the macro-definitions of the names from being expanded there.  */
     struct obstack *obstack;
     struct obstack *obstack;
     struct obstack *obstack;
     struct obstack *obstack;
     struct obstack *obstack;
     struct obstack *obstack;
     struct obstack *obstack;
     struct obstack *obstack;
     struct obstack *obstack;
     struct obstack *obstack;
     struct obstack *obstack;
     struct obstack *obstack;
     struct obstack *obstack;
     struct obstack *obstack;
#endif /* __STDC__ */
#endif /* 0 */
#endif	/* _LIBC or not __GNU_LIBRARY__.  */
/* search.c - searching subroutines using dfa, kwset and regex for grep.
   Written August 1992 by Mike Haertel. */
/*#include <ctype.h>*/
extern char *malloc();
extern void *memchr();
extern char *memchr();
/*#include "grep.h"*/
/*#include "dfa.h"*/
/*#include "kwset.h"*/
/*#include "regex.h"*/
static void Gcompile(char *, size_t);
static void Ecompile(char *, size_t);
static char *EGexecute(char *, size_t, char **);
static void Fcompile(char *, size_t);
static char *Fexecute(char *, size_t, char **);
static char *EGexecute();
static char *Fexecute();
/* Here is the matchers vector for the main program. */
/* For -w, we also consider _ to be word constituent.  */
/* DFA compiled regexp. */
/* Regex compiled regexp. */
/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
   any string matching the regexp. */
/* Last compiled fixed string known to exactly match the regexp.
   call the regexp matcher at all. */
     char *mesg;
  if (!(kwset = kwsalloc(match_icase ? trans : (char *) 0)))
/* If the DFA turns out to have some set of fixed strings one of
   matches. */
  struct dfamust *dm;
  char *err;
      /* First, we compile in the substrings known to be exact
	 of the matching string that it chooses. */
      /* Now, we compile the substrings that will require
	 the use of the regexp matcher.  */
     char *pattern;
  char *err;
  /* In the match_words and match_lines cases, we use a different pattern
     to decide whether the match should really count. */
      /* In the whole-word case, we use the pattern:
	 BUG: Using [A-Za-z_] is locale-dependent!  */
      char *n = malloc(size + 50);
     char *pattern;
  char *err;
  /* In the match_words and match_lines cases, we use a different pattern
     to decide whether the match should really count. */
      /* In the whole-word case, we use the pattern:
	 BUG: Using [A-Za-z_] is locale-dependent!  */
      char *n = malloc(size + 50);
static char *
     char *buf;
     char **endp;
  register char *buflim, *beg, *end, save;
  static struct re_registers regs; /* This is static on account of a BRAIN-DEAD
				    Q@#%!# library interface in regex.c.  */
	  /* Find a possible match using the KWset matcher. */
	  /* Narrow down to the line containing the candidate, and
	     run it through DFA. */
	  save = *end;
	  if (!dfaexec(&dfa_1, beg, end, 0, (int *) 0, &backref))
	      *end = save;
	  *end = save;
	  /* Successful, no backreferences encountered. */
	  /* No good fixed strings; start with DFA. */
	  save = *buflim;
	  beg = dfaexec(&dfa_1, beg, buflim, 0, (int *) 0, &backref);
	  *buflim = save;
	  /* Narrow down to the line we've found. */
	  /* Successful, no backreferences encountered! */
      /* If we've made it to this point, this means DFA has seen
	 a probable match, and we need to run it through Regex. */
	  /* If -w, check if the match aligns with word boundaries.
	     boundary. */
		    /* Try a shorter length anchored at the same place. */
		    /* Try looking further on. */
  *endp = end < buflim ? end + 1 : end;
     char *pattern;
  char *beg, *lim, *err;
      for (lim = beg; lim < pattern + size && *lim != '\n'; ++lim)
static char *
     char *buf;
     char **endp;
  register char *beg, *try, *end;
  *endp = end;
