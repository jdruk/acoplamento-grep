../inputs/grep0.dat:1:0:Before an alternative
../inputs/grep0.dat:2:22:store_op2 (op, loc, arg1, arg2)
../inputs/grep0.dat:3:54:store_op2 (op, loc, arg1, arg2)
../inputs/grep0.dat:4:86:syntax & RE_NO_BK_PARENS ? *next == ')'
../inputs/grep0.dat:5:126:re_opcode_t op;
../inputs/grep0.dat:6:142:static void
../inputs/grep0.dat:7:154:syntax & RE_NO_BK_PARENS ? *next == ')'
../inputs/grep0.dat:8:194:        : next_backslash && next_next && *next_next == ')')
../inputs/grep0.dat:9:254:Before an alternative
../inputs/grep0.dat:11:284:struct trie
../inputs/grep0.dat:12:296: ../inputs/grep1.dat:1:0:/* grep.c - main driver file for grep.
../inputs/grep1.dat:2:39:   Copyright (C) 1992 Free Software Foundation, Inc.
../inputs/grep1.dat:3:92:
../inputs/grep1.dat:4:93:   This program is free software; you can redistribute it and/or modify
../inputs/grep1.dat:5:165:   it under the terms of the GNU General Public License as published by
../inputs/grep1.dat:6:237:   the Free Software Foundation; either version 2, or (at your option)
../inputs/grep1.dat:7:308:   any later version.
../inputs/grep1.dat:8:330:
../inputs/grep1.dat:9:331:   This program is distributed in the hope that it will be useful,
../inputs/grep1.dat:10:398:   but WITHOUT ANY WARRANTY; without even the implied warranty of
../inputs/grep1.dat:11:464:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
../inputs/grep1.dat:12:529:   GNU General Public License for more details.
../inputs/grep1.dat:13:577:
../inputs/grep1.dat:14:578:   You should have received a copy of the GNU General Public License
../inputs/grep1.dat:15:647:   along with this program; if not, write to the Free Software
../inputs/grep1.dat:16:710:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
../inputs/grep1.dat:17:771:
../inputs/grep1.dat:18:772:   Written July 1992 by Mike Haertel.  */
../inputs/grep1.dat:19:814:
../inputs/grep1.dat:20:815:
../inputs/grep1.dat:21:816:/* I added a series define from makefile here in order to run cfe */
../inputs/grep1.dat:22:885:#define GREP 1
../inputs/grep1.dat:23:900:#define STDC_HEADERS 1
../inputs/grep1.dat:24:923:#define HAVE_STRING_H 1
../inputs/grep1.dat:25:947:#define HAVE_SYS_PARAM_H 1
../inputs/grep1.dat:26:974:#define HAVE_UNISTD_H 1
../inputs/grep1.dat:27:998:#define HAVE_ALLOCA_H 1
../inputs/grep1.dat:28:1022:#define HAVE_GETPAGESIZE 1
../inputs/grep1.dat:29:1049:#define HAVE_MEMCHR 1
../inputs/grep1.dat:30:1071:#define HAVE_STRERROR 1
../inputs/grep1.dat:31:1095:#define HAVE_VALLOC 1
../inputs/grep1.dat:32:1117:#define HAVE_WORKING_MMAP 1
../inputs/grep1.dat:33:1145:/*** end of cfe purpose **/
../inputs/grep1.dat:34:1173:
../inputs/grep1.dat:37:1212:
../inputs/grep1.dat:38:1213:#ifndef errno
../inputs/grep1.dat:39:1227:extern int errno;
../inputs/grep1.dat:40:1245:#endif
../inputs/grep1.dat:41:1252:
../inputs/grep1.dat:42:1253:#ifdef STDC_HEADERS
../inputs/grep1.dat:44:1293:#define flag_stdlib 1
../inputs/grep1.dat:45:1315:#else
../inputs/grep1.dat:47:1344:#define flag_systypes 1
../inputs/grep1.dat:48:1368:extern char *malloc(), *realloc();
../inputs/grep1.dat:49:1403:extern void free();
../inputs/grep1.dat:50:1423:#endif
../inputs/grep1.dat:51:1430:
../inputs/grep1.dat:52:1431:#if defined(STDC_HEADERS) || defined(HAVE_STRING_H)
../inputs/grep1.dat:54:1503:#define flag_string 1
../inputs/grep1.dat:55:1525:#ifdef NEED_MEMORY_H
../inputs/grep1.dat:57:1566:#define flag_memory 1
../inputs/grep1.dat:58:1588:#endif
../inputs/grep1.dat:59:1595:#else
../inputs/grep1.dat:61:1622:#define flag_strings 1
../inputs/grep1.dat:62:1645:#ifdef __STDC__
../inputs/grep1.dat:63:1661:extern void *memchr();
../inputs/grep1.dat:64:1684:#else
../inputs/grep1.dat:65:1690:extern char *memchr();
../inputs/grep1.dat:66:1713:#endif
../inputs/grep1.dat:67:1720:#define strrchr rindex
../inputs/grep1.dat:68:1743:#endif
../inputs/grep1.dat:69:1750:
../inputs/grep1.dat:70:1751:#ifdef HAVE_UNISTD_H
../inputs/grep1.dat:71:1772:#if flag_systypes==0
../inputs/grep1.dat:73:1816:#define flag_systypes 1
../inputs/grep1.dat:74:1840:#endif
../inputs/grep1.dat:77:1886:#else
../inputs/grep1.dat:78:1892:#define O_RDONLY 0
../inputs/grep1.dat:79:1911:extern int open(), read(), close();
../inputs/grep1.dat:80:1947:#endif
../inputs/grep1.dat:81:1954:
../inputs/grep1.dat:84:1998:
../inputs/grep1.dat:85:1999:#undef MAX
../inputs/grep1.dat:86:2010:#define MAX(A,B) ((A) > (B) ? (A) : (B))
../inputs/grep1.dat:87:2051:
../inputs/grep1.dat:88:2052:/* Provide missing ANSI features if necessary. */
../inputs/grep1.dat:89:2102:
../inputs/grep1.dat:90:2103:#ifndef HAVE_STRERROR
../inputs/grep1.dat:91:2125:extern int sys_nerr;
../inputs/grep1.dat:92:2146:extern char *sys_errlist[];
../inputs/grep1.dat:93:2174:#define strerror(E) ((E) < sys_nerr ? sys_errlist[(E)] : "bogus error number")
../inputs/grep1.dat:94:2253:#endif
../inputs/grep1.dat:95:2260:
../inputs/grep1.dat:96:2261:#ifndef HAVE_MEMCHR
../inputs/grep1.dat:97:2281:#ifdef __STDC__
../inputs/grep1.dat:98:2297:#define VOID void
../inputs/grep1.dat:99:2315:#else
../inputs/grep1.dat:100:2321:#define VOID char
../inputs/grep1.dat:101:2339:#endif
../inputs/grep1.dat:102:2346:VOID *
../inputs/grep1.dat:103:2353:memchr(vp, c, n)
../inputs/grep1.dat:104:2370:     VOID *vp;
../inputs/grep1.dat:105:2385:     int c;
../inputs/grep1.dat:106:2397:     size_t n;
../inputs/grep1.dat:107:2412:{
../inputs/grep1.dat:108:2414:  unsigned char *p;
../inputs/grep1.dat:109:2434:
../inputs/grep1.dat:110:2435:  for (p = (unsigned char *) vp; n--; ++p)
../inputs/grep1.dat:111:2478:    if (*p == c)
../inputs/grep1.dat:112:2495:      return (VOID *) p;
../inputs/grep1.dat:113:2520:  return 0;
../inputs/grep1.dat:114:2532:}
../inputs/grep1.dat:115:2534:#endif
../inputs/grep1.dat:116:2541:    
../inputs/grep1.dat:117:2546:/* Define flags declared in grep.h. */
../inputs/grep1.dat:118:2585:char *matcher;
../inputs/grep1.dat:119:2600:int match_icase;
../inputs/grep1.dat:120:2617:int match_words;
../inputs/grep1.dat:121:2634:int match_lines;
../inputs/grep1.dat:122:2651:
../inputs/grep1.dat:123:2652:/* Functions we'll use to search. */
../inputs/grep1.dat:124:2689:static void (*compile)();
../inputs/grep1.dat:125:2715:static char *(*execute)();
../inputs/grep1.dat:126:2742:
../inputs/grep1.dat:127:2743:/* For error messages. */
../inputs/grep1.dat:128:2769:static char *prog;
../inputs/grep1.dat:129:2788:static char *filename;
../inputs/grep1.dat:130:2811:static int errseen;
../inputs/grep1.dat:131:2831:
../inputs/grep1.dat:132:2832:/* Print a message and possibly an error string.  Remember
../inputs/grep1.dat:133:2891:   that something awful happened. */
../inputs/grep1.dat:134:2928:static void
../inputs/grep1.dat:135:2940:error(mesg, errnum)
../inputs/grep1.dat:136:2960:#ifdef __STDC__
../inputs/grep1.dat:137:2976:     const
../inputs/grep1.dat:138:2987:#endif
../inputs/grep1.dat:139:2994:     char *mesg;
../inputs/grep1.dat:140:3011:     int errnum;
../inputs/grep1.dat:141:3028:{
../inputs/grep1.dat:142:3030:  if (errnum)
../inputs/grep1.dat:143:3044:    fprintf(stderr, "%s: %s: %s\n", prog, mesg, strerror(errnum));
../inputs/grep1.dat:144:3111:  else
../inputs/grep1.dat:145:3118:    fprintf(stderr, "%s: %s\n", prog, mesg);
../inputs/grep1.dat:146:3163:  errseen = 1;
../inputs/grep1.dat:147:3178:}
../inputs/grep1.dat:148:3180:
../inputs/grep1.dat:149:3181:/* Like error(), but die horribly after printing. */
../inputs/grep1.dat:150:3234:void
../inputs/grep1.dat:151:3239:fatal(mesg, errnum)
../inputs/grep1.dat:152:3259:#ifdef __STDC__
../inputs/grep1.dat:153:3275:     const
../inputs/grep1.dat:154:3286:#endif
../inputs/grep1.dat:155:3293:     char *mesg;
../inputs/grep1.dat:156:3310:     int errnum;
../inputs/grep1.dat:157:3327:{
../inputs/grep1.dat:158:3329:  error(mesg, errnum);
../inputs/grep1.dat:159:3352:  exit(2);
../inputs/grep1.dat:160:3363:}
../inputs/grep1.dat:161:3365:
../inputs/grep1.dat:162:3366:/* Interface to handle errors and fix library lossage. */
../inputs/grep1.dat:163:3424:char *
../inputs/grep1.dat:164:3431:xmalloc(size)
../inputs/grep1.dat:165:3445:     size_t size;
../inputs/grep1.dat:166:3463:{
../inputs/grep1.dat:167:3465:  char *result;
../inputs/grep1.dat:168:3481:
../inputs/grep1.dat:169:3482:  result = malloc(size);
../inputs/grep1.dat:170:3507:  if (size && !result)
../inputs/grep1.dat:171:3530:    fatal("memory exhausted", 0);
../inputs/grep1.dat:172:3564:  return result;
../inputs/grep1.dat:173:3581:}
../inputs/grep1.dat:174:3583:
../inputs/grep1.dat:175:3584:/* Interface to handle errors and fix some library lossage. */
../inputs/grep1.dat:176:3647:char *
../inputs/grep1.dat:177:3654:xrealloc(ptr, size)
../inputs/grep1.dat:178:3674:     char *ptr;
../inputs/grep1.dat:179:3690:     size_t size;
../inputs/grep1.dat:180:3708:{
../inputs/grep1.dat:181:3710:  char *result;
../inputs/grep1.dat:182:3726:
../inputs/grep1.dat:183:3727:  if (ptr)
../inputs/grep1.dat:184:3738:    result = realloc(ptr, size);
../inputs/grep1.dat:185:3771:  else
../inputs/grep1.dat:186:3778:    result = malloc(size);
../inputs/grep1.dat:187:3805:  if (size && !result)
../inputs/grep1.dat:188:3828:    fatal("memory exhausted", 0);
../inputs/grep1.dat:189:3862:  return result;
../inputs/grep1.dat:190:3879:}
../inputs/grep1.dat:191:3881:
../inputs/grep1.dat:192:3882:#if !defined(HAVE_VALLOC)
../inputs/grep1.dat:193:3908:#define valloc malloc
../inputs/grep1.dat:194:3930:#else
../inputs/grep1.dat:195:3936:#ifdef __STDC__
../inputs/grep1.dat:196:3952:extern void *valloc(size_t);
../inputs/grep1.dat:197:3981:#else
../inputs/grep1.dat:198:3987:extern char *valloc();
../inputs/grep1.dat:199:4010:#endif
../inputs/grep1.dat:200:4017:#endif
../inputs/grep1.dat:201:4024:
../inputs/grep1.dat:202:4025:/* Hairy buffering mechanism for grep.  The intent is to keep
../inputs/grep1.dat:203:4087:   all reads aligned on a page boundary and multiples of the
../inputs/grep1.dat:204:4148:   page size. */
../inputs/grep1.dat:205:4165:
../inputs/grep1.dat:206:4166:static char *buffer;		/* Base of buffer. */
../inputs/grep1.dat:207:4210:static size_t bufsalloc;	/* Allocated size of buffer save region. */
../inputs/grep1.dat:208:4279:static size_t bufalloc;		/* Total buffer size. */
../inputs/grep1.dat:209:4329:static int bufdesc;		/* File descriptor. */
../inputs/grep1.dat:210:4373:static char *bufbeg;		/* Beginning of user-visible stuff. */
../inputs/grep1.dat:211:4434:static char *buflim;		/* Limit of user-visible stuff. */
../inputs/grep1.dat:212:4491:
../inputs/grep1.dat:213:4492:#if defined(HAVE_WORKING_MMAP)
../inputs/grep1.dat:214:4523:#if flag_systypes==0
../inputs/grep1.dat:216:4567:#define flag_systypes 1
../inputs/grep1.dat:217:4591:#endif
../inputs/grep1.dat:220:4642:
../inputs/grep1.dat:221:4643:static int bufmapped;		/* True for ordinary files. */
../inputs/grep1.dat:222:4697:static struct stat bufstat;	/* From fstat(). */
../inputs/grep1.dat:223:4745:static off_t bufoffset;		/* What read() normally remembers. */
../inputs/grep1.dat:224:4808:#endif
../inputs/grep1.dat:225:4815:
../inputs/grep1.dat:226:4816:/* Reset the buffer for a new file.  Initialize
../inputs/grep1.dat:227:4864:   on the first time through. */
../inputs/grep1.dat:228:4897:void
../inputs/grep1.dat:229:4902:reset(fd)
../inputs/grep1.dat:230:4912:     int fd;
../inputs/grep1.dat:231:4925:{
../inputs/grep1.dat:232:4927:  static int initialized;
../inputs/grep1.dat:233:4953:
../inputs/grep1.dat:234:4954:  if (!initialized)
../inputs/grep1.dat:235:4974:    {
../inputs/grep1.dat:236:4980:      initialized = 1;
../inputs/grep1.dat:237:5003:#ifndef BUFSALLOC
../inputs/grep1.dat:238:5021:      bufsalloc = MAX(8192, getpagesize());
../inputs/grep1.dat:239:5065:#else
../inputs/grep1.dat:240:5071:      bufsalloc = BUFSALLOC;
../inputs/grep1.dat:241:5100:#endif
../inputs/grep1.dat:242:5107:      bufalloc = 5 * bufsalloc;
../inputs/grep1.dat:243:5139:      /* The 1 byte of overflow is a kludge for dfaexec(), which
../inputs/grep1.dat:244:5204:	 inserts a sentinel newline at the end of the buffer
../inputs/grep1.dat:245:5258:	 being searched.  There's gotta be a better way... */
../inputs/grep1.dat:246:5313:      buffer = valloc(bufalloc + 1);
../inputs/grep1.dat:247:5350:      if (!buffer)
../inputs/grep1.dat:248:5369:	fatal("memory exhausted", 0);
../inputs/grep1.dat:249:5400:      bufbeg = buffer;
../inputs/grep1.dat:250:5423:      buflim = buffer;
../inputs/grep1.dat:251:5446:    }
../inputs/grep1.dat:252:5452:  bufdesc = fd;
../inputs/grep1.dat:253:5468:#if defined(HAVE_WORKING_MMAP)
../inputs/grep1.dat:254:5499:  if (fstat(fd, &bufstat) < 0 || !S_ISREG(bufstat.st_mode))
../inputs/grep1.dat:255:5559:    bufmapped = 0;
../inputs/grep1.dat:256:5578:  else
../inputs/grep1.dat:257:5585:    {
../inputs/grep1.dat:258:5591:      bufmapped = 1;
../inputs/grep1.dat:259:5612:      bufoffset = lseek(fd, 0, 1);
../inputs/grep1.dat:260:5647:    }
../inputs/grep1.dat:261:5653:#endif
../inputs/grep1.dat:262:5660:}
../inputs/grep1.dat:263:5662:
../inputs/grep1.dat:264:5663:/* Read new stuff into the buffer, saving the specified
../inputs/grep1.dat:265:5719:   amount of old stuff.  When we're done, 'bufbeg' points
../inputs/grep1.dat:266:5777:   to the beginning of the buffer contents, and 'buflim'
../inputs/grep1.dat:267:5834:   points just after the end.  Return count of new stuff. */
../inputs/grep1.dat:268:5895:static int
../inputs/grep1.dat:269:5906:fillbuf(save)
../inputs/grep1.dat:270:5920:     size_t save;
../inputs/grep1.dat:271:5938:{
../inputs/grep1.dat:272:5940:  char *nbuffer, *dp, *sp;
../inputs/grep1.dat:273:5967:  int cc;
../inputs/grep1.dat:274:5977:#if defined(HAVE_WORKING_MMAP)
../inputs/grep1.dat:275:6008:  caddr_t maddr;
../inputs/grep1.dat:276:6025:#endif
../inputs/grep1.dat:277:6032:  static int pagesize;
../inputs/grep1.dat:278:6055:
../inputs/grep1.dat:279:6056:  if (pagesize == 0 && (pagesize = getpagesize()) == 0)
../inputs/grep1.dat:280:6112:    abort();
../inputs/grep1.dat:281:6125:
../inputs/grep1.dat:282:6126:  if (save > bufsalloc)
../inputs/grep1.dat:283:6150:    {
../inputs/grep1.dat:284:6156:      while (save > bufsalloc)
../inputs/grep1.dat:285:6187:	bufsalloc *= 2;
../inputs/grep1.dat:286:6204:      bufalloc = 5 * bufsalloc;
../inputs/grep1.dat:287:6236:      nbuffer = valloc(bufalloc + 1);
../inputs/grep1.dat:288:6274:      if (!nbuffer)
../inputs/grep1.dat:289:6294:	fatal("memory exhausted", 0);
../inputs/grep1.dat:290:6325:    }
../inputs/grep1.dat:291:6331:  else
../inputs/grep1.dat:292:6338:    nbuffer = buffer;
../inputs/grep1.dat:293:6360:
../inputs/grep1.dat:294:6361:  sp = buflim - save;
../inputs/grep1.dat:295:6383:  dp = nbuffer + bufsalloc - save;
../inputs/grep1.dat:296:6418:  bufbeg = dp;
../inputs/grep1.dat:297:6433:  while (save--)
../inputs/grep1.dat:298:6450:    *dp++ = *sp++;
../inputs/grep1.dat:299:6469:
../inputs/grep1.dat:300:6470:  /* We may have allocated a new, larger buffer.  Since
../inputs/grep1.dat:301:6526:     there is no portable vfree(), we just have to forget
../inputs/grep1.dat:302:6584:     about the old one.  Sorry. */
../inputs/grep1.dat:303:6619:  buffer = nbuffer;
../inputs/grep1.dat:304:6639:
../inputs/grep1.dat:305:6640:#if defined(HAVE_WORKING_MMAP)
../inputs/grep1.dat:306:6671:  if (bufmapped && bufoffset % pagesize == 0
../inputs/grep1.dat:307:6716:      && bufstat.st_size - bufoffset >= bufalloc - bufsalloc)
../inputs/grep1.dat:308:6778:    {
../inputs/grep1.dat:309:6784:      maddr = buffer + bufsalloc;
../inputs/grep1.dat:310:6818:      maddr = mmap(maddr, bufalloc - bufsalloc, PROT_READ | PROT_WRITE,
../inputs/grep1.dat:311:6890:		   MAP_PRIVATE | MAP_FIXED, bufdesc, bufoffset);
../inputs/grep1.dat:312:6941:      if (maddr == (caddr_t) -1)
../inputs/grep1.dat:313:6974:	{
../inputs/grep1.dat:314:6977:	  fprintf(stderr, "%s: warning: %s: %s\n", filename,
../inputs/grep1.dat:315:7031:		  strerror(errno));
../inputs/grep1.dat:316:7053:	  goto tryread;
../inputs/grep1.dat:317:7070:	}
../inputs/grep1.dat:318:7073:#if 0
../inputs/grep1.dat:319:7079:      /* You might thing this (or MADV_WILLNEED) would help,
../inputs/grep1.dat:320:7140:	 but it doesn't, at least not on a Sun running 4.1.
../inputs/grep1.dat:321:7193:	 In fact, it actually slows us down about 30%! */
../inputs/grep1.dat:322:7244:      madvise(maddr, bufalloc - bufsalloc, MADV_SEQUENTIAL);
../inputs/grep1.dat:323:7305:#endif
../inputs/grep1.dat:324:7312:      cc = bufalloc - bufsalloc;
../inputs/grep1.dat:325:7345:      bufoffset += cc;
../inputs/grep1.dat:326:7368:    }
../inputs/grep1.dat:327:7374:  else
../inputs/grep1.dat:328:7381:    {
../inputs/grep1.dat:329:7387:    tryread:
../inputs/grep1.dat:330:7400:      /* We come here when we're not going to use mmap() any more.
../inputs/grep1.dat:331:7467:	 Note that we need to synchronize the file offset the
../inputs/grep1.dat:332:7522:	 first time through. */
../inputs/grep1.dat:333:7547:      if (bufmapped)
../inputs/grep1.dat:334:7568:	{
../inputs/grep1.dat:335:7571:	  bufmapped = 0;
../inputs/grep1.dat:336:7589:	  lseek(bufdesc, bufoffset, 0);
../inputs/grep1.dat:337:7622:	}
../inputs/grep1.dat:338:7625:      cc = read(bufdesc, buffer + bufsalloc, bufalloc - bufsalloc);
../inputs/grep1.dat:339:7693:    }
../inputs/grep1.dat:340:7699:#else
../inputs/grep1.dat:341:7705:  cc = read(bufdesc, buffer + bufsalloc, bufalloc - bufsalloc);
../inputs/grep1.dat:342:7769:#endif
../inputs/grep1.dat:343:7776:  if (cc > 0)
../inputs/grep1.dat:344:7790:    buflim = buffer + bufsalloc + cc;
../inputs/grep1.dat:345:7828:  else
../inputs/grep1.dat:346:7835:    buflim = buffer + bufsalloc;
../inputs/grep1.dat:347:7868:  return cc;
../inputs/grep1.dat:348:7881:}
../inputs/grep1.dat:349:7883:
../inputs/grep1.dat:350:7884:/* Flags controlling the style of output. */
../inputs/grep1.dat:351:7929:static int out_quiet;		/* Suppress all normal output. */
../inputs/grep1.dat:352:7986:static int out_invert;		/* Print nonmatching stuff. */
../inputs/grep1.dat:353:8041:static int out_file;		/* Print filenames. */
../inputs/grep1.dat:354:8086:static int out_line;		/* Print line numbers. */
../inputs/grep1.dat:355:8134:static int out_byte;		/* Print byte offsets. */
../inputs/grep1.dat:356:8182:static int out_before;		/* Lines of leading context. */
../inputs/grep1.dat:357:8238:static int out_after;		/* Lines of trailing context. */
../inputs/grep1.dat:358:8294:
../inputs/grep1.dat:359:8295:/* Internal variables to keep track of byte count, context, etc. */
../inputs/grep1.dat:360:8363:static size_t totalcc;		/* Total character count before bufbeg. */
../inputs/grep1.dat:361:8430:static char *lastnl;		/* Pointer after last newline counted. */
../inputs/grep1.dat:362:8494:static char *lastout;		/* Pointer after last character output;
../inputs/grep1.dat:363:8557:				   NULL if no character has been output
../inputs/grep1.dat:364:8601:				   or if it's conceptually before bufbeg. */
../inputs/grep1.dat:365:8650:static size_t totalnl;		/* Total newline count before lastnl. */
../inputs/grep1.dat:366:8715:static int pending;		/* Pending lines of output. */
../inputs/grep1.dat:367:8767:
../inputs/grep1.dat:368:8768:static void
../inputs/grep1.dat:369:8780:nlscan(lim)
../inputs/grep1.dat:370:8792:     char *lim;
../inputs/grep1.dat:371:8808:{
../inputs/grep1.dat:372:8810:  char *beg;
../inputs/grep1.dat:373:8823:
../inputs/grep1.dat:374:8824:  for (beg = lastnl; beg < lim; ++beg)
../inputs/grep1.dat:375:8863:    if (*beg == '\n')
../inputs/grep1.dat:376:8885:      ++totalnl;
../inputs/grep1.dat:377:8902:  lastnl = beg;
../inputs/grep1.dat:378:8918:}
../inputs/grep1.dat:379:8920:
../inputs/grep1.dat:380:8921:static void
../inputs/grep1.dat:381:8933:prline(beg, lim, sep)
../inputs/grep1.dat:382:8955:     char *beg;
../inputs/grep1.dat:383:8971:     char *lim;
../inputs/grep1.dat:384:8987:     char sep;
../inputs/grep1.dat:385:9002:{
../inputs/grep1.dat:386:9004:  if (out_file)
../inputs/grep1.dat:387:9020:    printf("%s%c", filename, sep);
../inputs/grep1.dat:388:9055:  if (out_line)
../inputs/grep1.dat:389:9071:    {
../inputs/grep1.dat:390:9077:      nlscan(beg);
../inputs/grep1.dat:391:9096:      printf("%d%c", ++totalnl, sep);
../inputs/grep1.dat:392:9134:      lastnl = lim;
../inputs/grep1.dat:393:9154:    }
../inputs/grep1.dat:394:9160:  if (out_byte)
../inputs/grep1.dat:395:9176:    printf("%lu%c", totalcc + (beg - bufbeg), sep);
../inputs/grep1.dat:396:9228:  fwrite(beg, 1, lim - beg, stdout);
../inputs/grep1.dat:397:9265:  if (ferror(stdout))
../inputs/grep1.dat:398:9287:    error("writing output", errno);
../inputs/grep1.dat:399:9323:  lastout = lim;
../inputs/grep1.dat:400:9340:}
../inputs/grep1.dat:401:9342:
../inputs/grep1.dat:402:9343:/* Print pending lines of trailing context prior to LIM. */
../inputs/grep1.dat:403:9403:static void
../inputs/grep1.dat:404:9415:prpending(lim)
../inputs/grep1.dat:405:9430:     char *lim;
../inputs/grep1.dat:406:9446:{
../inputs/grep1.dat:407:9448:  char *nl;
../inputs/grep1.dat:408:9460:
../inputs/grep1.dat:409:9461:  if (!lastout)
../inputs/grep1.dat:410:9477:    lastout = bufbeg;
../inputs/grep1.dat:411:9499:  while (pending > 0 && lastout < lim)
../inputs/grep1.dat:412:9538:    {
../inputs/grep1.dat:413:9544:      --pending;
../inputs/grep1.dat:414:9561:      if ((nl = memchr(lastout, '\n', lim - lastout)) != 0)
../inputs/grep1.dat:415:9621:	++nl;
../inputs/grep1.dat:416:9628:      else
../inputs/grep1.dat:417:9639:	nl = lim;
../inputs/grep1.dat:418:9650:      prline(lastout, nl, '-');
../inputs/grep1.dat:419:9682:    }
../inputs/grep1.dat:420:9688:}
../inputs/grep1.dat:421:9690:
../inputs/grep1.dat:422:9691:/* Print the lines between BEG and LIM.  Deal with context crap.
../inputs/grep1.dat:423:9756:   If NLINESP is non-null, store a count of lines between BEG and LIM. */
../inputs/grep1.dat:424:9830:static void
../inputs/grep1.dat:425:9842:prtext(beg, lim, nlinesp)
../inputs/grep1.dat:426:9868:     char *beg;
../inputs/grep1.dat:427:9884:     char *lim;
../inputs/grep1.dat:428:9900:     int *nlinesp;
../inputs/grep1.dat:429:9919:{
../inputs/grep1.dat:430:9921:  static int used;		/* avoid printing "--" before any output */
../inputs/grep1.dat:431:9985:  char *bp, *p, *nl;
../inputs/grep1.dat:432:10006:  int i, n;
../inputs/grep1.dat:433:10018:
../inputs/grep1.dat:434:10019:  if (!out_quiet && pending > 0)
../inputs/grep1.dat:435:10052:    prpending(beg);
../inputs/grep1.dat:436:10072:
../inputs/grep1.dat:437:10073:  p = beg;
../inputs/grep1.dat:438:10084:
../inputs/grep1.dat:439:10085:  if (!out_quiet)
../inputs/grep1.dat:440:10103:    {
../inputs/grep1.dat:441:10109:      /* Deal with leading context crap. */
../inputs/grep1.dat:442:10153:
../inputs/grep1.dat:443:10154:      bp = lastout ? lastout : bufbeg;
../inputs/grep1.dat:444:10193:      for (i = 0; i < out_before; ++i)
../inputs/grep1.dat:445:10232:	if (p > bp)
../inputs/grep1.dat:446:10245:	  do
../inputs/grep1.dat:447:10251:	    --p;
../inputs/grep1.dat:448:10261:	  while (p > bp && p[-1] != '\n');
../inputs/grep1.dat:449:10297:
../inputs/grep1.dat:450:10298:      /* We only print the "--" separator if our output is
../inputs/grep1.dat:451:10357:	 discontiguous from the last output in the file. */
../inputs/grep1.dat:452:10410:      if ((out_before || out_after) && used && p != lastout)
../inputs/grep1.dat:453:10471:	puts("--");
../inputs/grep1.dat:454:10484:
../inputs/grep1.dat:455:10485:      while (p < beg)
../inputs/grep1.dat:456:10507:	{
../inputs/grep1.dat:457:10510:	  nl = memchr(p, '\n', beg - p);
../inputs/grep1.dat:458:10544:	  prline(p, nl + 1, '-');
../inputs/grep1.dat:459:10571:	  p = nl + 1;
../inputs/grep1.dat:460:10586:	}
../inputs/grep1.dat:461:10589:    }
../inputs/grep1.dat:462:10595:
../inputs/grep1.dat:463:10596:  if (nlinesp)
../inputs/grep1.dat:464:10611:    {
../inputs/grep1.dat:465:10617:      /* Caller wants a line count. */
../inputs/grep1.dat:466:10656:      for (n = 0; p < lim; ++n)
../inputs/grep1.dat:467:10688:	{
../inputs/grep1.dat:468:10691:	  if ((nl = memchr(p, '\n', lim - p)) != 0)
../inputs/grep1.dat:469:10736:	    ++nl;
../inputs/grep1.dat:470:10747:	  else
../inputs/grep1.dat:471:10755:	    nl = lim;
../inputs/grep1.dat:472:10770:	  if (!out_quiet)
../inputs/grep1.dat:473:10789:	    prline(p, nl, ':');
../inputs/grep1.dat:474:10814:	  p = nl;
../inputs/grep1.dat:475:10825:	}
../inputs/grep1.dat:476:10828:      *nlinesp = n;
../inputs/grep1.dat:477:10848:    }
../inputs/grep1.dat:478:10854:  else
../inputs/grep1.dat:479:10861:    if (!out_quiet)
../inputs/grep1.dat:480:10881:      prline(beg, lim, ':');
../inputs/grep1.dat:481:10910:
../inputs/grep1.dat:482:10911:  pending = out_after;
../inputs/grep1.dat:483:10934:  used = 1;
../inputs/grep1.dat:484:10946:}
../inputs/grep1.dat:485:10948:
../inputs/grep1.dat:486:10949:/* Scan the specified portion of the buffer, matching lines (or
../inputs/grep1.dat:487:11013:   between matching lines if OUT_INVERT is true).  Return a count of
../inputs/grep1.dat:488:11082:   lines printed. */
../inputs/grep1.dat:489:11103:static int
../inputs/grep1.dat:490:11114:grepbuf(beg, lim)
../inputs/grep1.dat:491:11132:     char *beg;
../inputs/grep1.dat:492:11148:     char *lim;
../inputs/grep1.dat:493:11164:{
../inputs/grep1.dat:494:11166:  int nlines, n;
../inputs/grep1.dat:495:11183:  register char *p, *b;
../inputs/grep1.dat:496:11207:  char *endp;
../inputs/grep1.dat:497:11221:
../inputs/grep1.dat:498:11222:  nlines = 0;
../inputs/grep1.dat:499:11236:  p = beg;
../inputs/grep1.dat:500:11247:  while ((b = (*execute)(p, lim - p, &endp)) != 0)
../inputs/grep1.dat:501:11298:    {
../inputs/grep1.dat:502:11304:      /* Avoid matching the empty line at the end of the buffer. */
../inputs/grep1.dat:503:11372:      if (b == lim && ((b > beg && b[-1] == '\n') || b == beg))
../inputs/grep1.dat:504:11436:	break;
../inputs/grep1.dat:505:11444:      if (!out_invert)
../inputs/grep1.dat:506:11467:	{
../inputs/grep1.dat:507:11470:	  prtext(b, endp, (int *) 0);
../inputs/grep1.dat:508:11501:	  nlines += 1;
../inputs/grep1.dat:509:11517:	}
../inputs/grep1.dat:510:11520:      else if (p < b)
../inputs/grep1.dat:511:11542:	{
../inputs/grep1.dat:512:11545:	  prtext(p, b, &n);
../inputs/grep1.dat:513:11566:	  nlines += n;
../inputs/grep1.dat:514:11582:	}
../inputs/grep1.dat:515:11585:      p = endp;
../inputs/grep1.dat:516:11601:    }
../inputs/grep1.dat:517:11607:  if (out_invert && p < lim)
../inputs/grep1.dat:518:11636:    {
../inputs/grep1.dat:519:11642:      prtext(p, lim, &n);
../inputs/grep1.dat:520:11668:      nlines += n;
../inputs/grep1.dat:521:11687:    }
../inputs/grep1.dat:522:11693:  return nlines;
../inputs/grep1.dat:523:11710:}
../inputs/grep1.dat:524:11712:
../inputs/grep1.dat:525:11713:/* Search a given file.  Return a count of lines printed. */
../inputs/grep1.dat:526:11774:static int
../inputs/grep1.dat:527:11785:grep(fd)
../inputs/grep1.dat:528:11794:     int fd;
../inputs/grep1.dat:529:11807:{
../inputs/grep1.dat:530:11809:  int nlines, i;
../inputs/grep1.dat:531:11826:  size_t residue, save;
../inputs/grep1.dat:532:11850:  char *beg, *lim;
../inputs/grep1.dat:533:11869:
../inputs/grep1.dat:534:11870:  reset(fd);
../inputs/grep1.dat:535:11883:
../inputs/grep1.dat:536:11884:  totalcc = 0;
../inputs/grep1.dat:537:11899:  lastout = 0;
../inputs/grep1.dat:538:11914:  totalnl = 0;
../inputs/grep1.dat:539:11929:  pending = 0;
../inputs/grep1.dat:540:11944:
../inputs/grep1.dat:541:11945:  nlines = 0;
../inputs/grep1.dat:542:11959:  residue = 0;
../inputs/grep1.dat:543:11974:  save = 0;
../inputs/grep1.dat:544:11986:
../inputs/grep1.dat:545:11987:  for (;;)
../inputs/grep1.dat:546:11998:    {
../inputs/grep1.dat:547:12004:      if (fillbuf(save) < 0)
../inputs/grep1.dat:548:12033:	{
../inputs/grep1.dat:549:12036:	  error(filename, errno);
../inputs/grep1.dat:550:12063:	  return nlines;
../inputs/grep1.dat:551:12081:	}
../inputs/grep1.dat:552:12084:      lastnl = bufbeg;
../inputs/grep1.dat:553:12107:      if (lastout)
../inputs/grep1.dat:554:12126:	lastout = bufbeg;
../inputs/grep1.dat:555:12145:      if (buflim - bufbeg == save)
../inputs/grep1.dat:556:12180:	break;
../inputs/grep1.dat:557:12188:      beg = bufbeg + save - residue;
../inputs/grep1.dat:558:12225:      for (lim = buflim; lim > beg && lim[-1] != '\n'; --lim)
../inputs/grep1.dat:559:12287:	;
../inputs/grep1.dat:560:12290:      residue = buflim - lim;
../inputs/grep1.dat:561:12320:      if (beg < lim)
../inputs/grep1.dat:562:12341:	{
../inputs/grep1.dat:563:12344:	  nlines += grepbuf(beg, lim);
../inputs/grep1.dat:564:12376:	  if (pending)
../inputs/grep1.dat:565:12392:	    prpending(lim);
../inputs/grep1.dat:566:12413:	}
../inputs/grep1.dat:567:12416:      i = 0;
../inputs/grep1.dat:568:12429:      beg = lim;
../inputs/grep1.dat:569:12446:      while (i < out_before && beg > bufbeg && beg != lastout)
../inputs/grep1.dat:570:12509:	{
../inputs/grep1.dat:571:12512:	  ++i;
../inputs/grep1.dat:572:12520:	  do
../inputs/grep1.dat:573:12526:	    --beg;
../inputs/grep1.dat:574:12538:	  while (beg > bufbeg && beg[-1] != '\n');
../inputs/grep1.dat:575:12582:	}
../inputs/grep1.dat:576:12585:      if (beg != lastout)
../inputs/grep1.dat:577:12611:	lastout = 0;
../inputs/grep1.dat:578:12625:      save = residue + lim - beg;
../inputs/grep1.dat:579:12659:      totalcc += buflim - bufbeg - save;
../inputs/grep1.dat:580:12700:      if (out_line)
../inputs/grep1.dat:581:12720:	nlscan(beg);
../inputs/grep1.dat:582:12734:    }
../inputs/grep1.dat:583:12740:  if (residue)
../inputs/grep1.dat:584:12755:    {
../inputs/grep1.dat:585:12761:      nlines += grepbuf(bufbeg + save - residue, buflim);
../inputs/grep1.dat:586:12819:      if (pending)
../inputs/grep1.dat:587:12838:	prpending(buflim);
../inputs/grep1.dat:588:12858:    }
../inputs/grep1.dat:589:12864:  return nlines;
../inputs/grep1.dat:590:12881:}
../inputs/grep1.dat:591:12883:
../inputs/grep1.dat:592:12884:static char version[] = "GNU grep version 2.0";
../inputs/grep1.dat:593:12932:
../inputs/grep1.dat:594:12933:#define USAGE \
../inputs/grep1.dat:595:12949:  "usage: %s [-[[AB] ]<num>] [-[CEFGVchilnqsvwx]] [-[ef]] <expr> [<files...>]\n"
../inputs/grep1.dat:596:13030:
../inputs/grep1.dat:597:13031:static void
../inputs/grep1.dat:598:13043:usage()
../inputs/grep1.dat:599:13051:{
../inputs/grep1.dat:600:13053:  fprintf(stderr, USAGE, prog);
../inputs/grep1.dat:601:13085:  exit(2);
../inputs/grep1.dat:602:13096:}
../inputs/grep1.dat:603:13098:
../inputs/grep1.dat:604:13099:/* Go through the matchers vector and look for the specified matcher.
../inputs/grep1.dat:605:13169:   If we find it, install it in compile and execute, and return 1.  */
../inputs/grep1.dat:606:13240:int
../inputs/grep1.dat:607:13244:setmatcher(name)
../inputs/grep1.dat:608:13261:     char *name;
../inputs/grep1.dat:609:13278:{
../inputs/grep1.dat:610:13280:  int i;
../inputs/grep1.dat:611:13289:
../inputs/grep1.dat:612:13290:  for (i = 0; matchers[i].name; ++i)
../inputs/grep1.dat:613:13327:    if (strcmp(name, matchers[i].name) == 0)
../inputs/grep1.dat:614:13372:      {
../inputs/grep1.dat:615:13380:	compile = matchers[i].compile;
../inputs/grep1.dat:616:13412:	execute = matchers[i].execute;
../inputs/grep1.dat:617:13444:	return 1;
../inputs/grep1.dat:618:13455:      }
../inputs/grep1.dat:619:13463:  return 0;
../inputs/grep1.dat:620:13475:}  
../inputs/grep1.dat:621:13479:
../inputs/grep1.dat:622:13480:int
../inputs/grep1.dat:623:13484:main(argc, argv)
../inputs/grep1.dat:624:13501:     int argc;
../inputs/grep1.dat:625:13516:     char *argv[];
../inputs/grep1.dat:626:13535:{
../inputs/grep1.dat:627:13537:  char *keys;
../inputs/grep1.dat:628:13551:  size_t keycc, oldcc, keyalloc;
../inputs/grep1.dat:629:13584:  int keyfound, count_matches, no_filenames, list_files, suppress_errors;
../inputs/grep1.dat:630:13658:  int opt, cc, desc, count, status;
../inputs/grep1.dat:631:13694:  FILE *fp;
../inputs/grep1.dat:632:13706:  extern char *optarg;
../inputs/grep1.dat:633:13729:  extern int optind;
../inputs/grep1.dat:634:13750:
../inputs/grep1.dat:635:13751:  prog = argv[0];
../inputs/grep1.dat:636:13769:  if (prog && strrchr(prog, '/'))
../inputs/grep1.dat:637:13803:    prog = strrchr(prog, '/') + 1;
../inputs/grep1.dat:638:13838:
../inputs/grep1.dat:639:13839:  keys = NULL;
../inputs/grep1.dat:640:13854:  keycc = 0;
../inputs/grep1.dat:641:13867:  keyfound = 0;
../inputs/grep1.dat:642:13883:  count_matches = 0;
../inputs/grep1.dat:643:13904:  no_filenames = 0;
../inputs/grep1.dat:644:13924:  list_files = 0;
../inputs/grep1.dat:645:13942:  suppress_errors = 0;
../inputs/grep1.dat:646:13965:  matcher = NULL;
../inputs/grep1.dat:647:13983:
../inputs/grep1.dat:648:13984:  while ((opt = getopt(argc, argv, "0123456789A:B:CEFGVX:bce:f:hiLlnqsvwxy"))
../inputs/grep1.dat:649:14062:	 != EOF)
../inputs/grep1.dat:650:14072:    switch (opt)
../inputs/grep1.dat:651:14089:      {
../inputs/grep1.dat:652:14097:      case '0':
../inputs/grep1.dat:653:14113:      case '1':
../inputs/grep1.dat:654:14129:      case '2':
../inputs/grep1.dat:655:14145:      case '3':
../inputs/grep1.dat:656:14161:      case '4':
../inputs/grep1.dat:657:14177:      case '5':
../inputs/grep1.dat:658:14193:      case '6':
../inputs/grep1.dat:659:14209:      case '7':
../inputs/grep1.dat:660:14225:      case '8':
../inputs/grep1.dat:661:14241:      case '9':
../inputs/grep1.dat:662:14257:	out_before = 10 * out_before + opt - '0';
../inputs/grep1.dat:663:14300:	out_after = 10 * out_after + opt - '0';
../inputs/grep1.dat:664:14341:	break;
../inputs/grep1.dat:665:14349:      case 'A':
../inputs/grep1.dat:666:14365:	out_after = atoi(optarg);
../inputs/grep1.dat:667:14392:	if (out_after < 0)
../inputs/grep1.dat:668:14412:	  usage();
../inputs/grep1.dat:669:14424:	break;
../inputs/grep1.dat:670:14432:      case 'B':
../inputs/grep1.dat:671:14448:	out_before = atoi(optarg);
../inputs/grep1.dat:672:14476:	if (out_before < 0)
../inputs/grep1.dat:673:14497:	  usage();
../inputs/grep1.dat:674:14509:	break;
../inputs/grep1.dat:675:14517:      case 'C':
../inputs/grep1.dat:676:14533:	out_before = out_after = 2;
../inputs/grep1.dat:677:14562:	break;
../inputs/grep1.dat:678:14570:      case 'E':
../inputs/grep1.dat:679:14586:	if (matcher && strcmp(matcher, "egrep") != 0)
../inputs/grep1.dat:680:14633:	  fatal("you may specify only one of -E, -F, or -G", 0);
../inputs/grep1.dat:681:14691:	matcher = "posix-egrep";
../inputs/grep1.dat:682:14717:	break;
../inputs/grep1.dat:683:14725:      case 'F':
../inputs/grep1.dat:684:14741:	if (matcher && strcmp(matcher, "fgrep") != 0)
../inputs/grep1.dat:685:14788:	  fatal("you may specify only one of -E, -F, or -G", 0);;
../inputs/grep1.dat:686:14847:	matcher = "fgrep";
../inputs/grep1.dat:687:14867:	break;
../inputs/grep1.dat:688:14875:      case 'G':
../inputs/grep1.dat:689:14891:	if (matcher && strcmp(matcher, "grep") != 0)
../inputs/grep1.dat:690:14937:	  fatal("you may specify only one of -E, -F, or -G", 0);
../inputs/grep1.dat:691:14995:	matcher = "grep";
../inputs/grep1.dat:692:15014:	break;
../inputs/grep1.dat:693:15022:      case 'V':
../inputs/grep1.dat:694:15038:	fprintf(stderr, "%s\n", version);
../inputs/grep1.dat:695:15073:	break;
../inputs/grep1.dat:696:15081:      case 'X':
../inputs/grep1.dat:697:15097:	if (matcher)
../inputs/grep1.dat:698:15111:	  fatal("matcher already specified", 0);
../inputs/grep1.dat:699:15153:	matcher = optarg;
../inputs/grep1.dat:700:15172:	break;
../inputs/grep1.dat:701:15180:      case 'b':
../inputs/grep1.dat:702:15196:	out_byte = 1;
../inputs/grep1.dat:703:15211:	break;
../inputs/grep1.dat:704:15219:      case 'c':
../inputs/grep1.dat:705:15235:	out_quiet = 1;
../inputs/grep1.dat:706:15251:	count_matches = 1;
../inputs/grep1.dat:707:15271:	break;
../inputs/grep1.dat:708:15279:      case 'e':
../inputs/grep1.dat:709:15295:	cc = strlen(optarg);
../inputs/grep1.dat:710:15317:	keys = xrealloc(keys, keycc + cc + 1);
../inputs/grep1.dat:711:15357:	if (keyfound)
../inputs/grep1.dat:712:15372:	  keys[keycc++] = '\n';
../inputs/grep1.dat:713:15397:	strcpy(&keys[keycc], optarg);
../inputs/grep1.dat:714:15428:	keycc += cc;
../inputs/grep1.dat:715:15442:	keyfound = 1;
../inputs/grep1.dat:716:15457:	break;
../inputs/grep1.dat:717:15465:      case 'f':
../inputs/grep1.dat:718:15481:	fp = strcmp(optarg, "-") != 0 ? fopen(optarg, "r") : stdin;
../inputs/grep1.dat:719:15542:	if (!fp)
../inputs/grep1.dat:720:15552:	  fatal(optarg, errno);
../inputs/grep1.dat:721:15577:	for (keyalloc = 1; keyalloc <= keycc; keyalloc *= 2)
../inputs/grep1.dat:722:15631:	  ;
../inputs/grep1.dat:723:15636:	keys = xrealloc(keys, keyalloc);
../inputs/grep1.dat:724:15670:	oldcc = keycc;
../inputs/grep1.dat:725:15686:	if (keyfound)
../inputs/grep1.dat:726:15701:	  keys[keycc++] = '\n';
../inputs/grep1.dat:727:15726:	while (!feof(fp)
../inputs/grep1.dat:728:15744:	       && (cc = fread(keys + keycc, 1, keyalloc - keycc, fp)) > 0)
../inputs/grep1.dat:729:15812:	  {
../inputs/grep1.dat:730:15817:	    keycc += cc;
../inputs/grep1.dat:731:15835:	    if (keycc == keyalloc)
../inputs/grep1.dat:732:15863:	      keys = xrealloc(keys, keyalloc *= 2);
../inputs/grep1.dat:733:15908:	  }
../inputs/grep1.dat:734:15913:	if (fp != stdin)
../inputs/grep1.dat:735:15931:	  fclose(fp);
../inputs/grep1.dat:736:15946:	/* Nuke the final newline to avoid matching a null string. */
../inputs/grep1.dat:737:16009:	if (keycc - oldcc > 0 && keys[keycc - 1] == '\n')
../inputs/grep1.dat:738:16060:	  --keycc;
../inputs/grep1.dat:739:16072:	keyfound = 1;
../inputs/grep1.dat:740:16087:	break;
../inputs/grep1.dat:741:16095:      case 'h':
../inputs/grep1.dat:742:16111:	no_filenames = 1;
../inputs/grep1.dat:743:16130:	break;
../inputs/grep1.dat:744:16138:      case 'i':
../inputs/grep1.dat:745:16154:      case 'y':			/* For old-timers . . . */
../inputs/grep1.dat:746:16199:	match_icase = 1;
../inputs/grep1.dat:747:16217:	break;
../inputs/grep1.dat:748:16225:      case 'L':
../inputs/grep1.dat:749:16241:	/* Like -l, except list files that don't contain matches.
../inputs/grep1.dat:750:16300:	   Inspired by the same option in Hume's gre. */
../inputs/grep1.dat:751:16350:	out_quiet = 1;
../inputs/grep1.dat:752:16366:	list_files = -1;
../inputs/grep1.dat:753:16384:	break;
../inputs/grep1.dat:754:16392:      case 'l':
../inputs/grep1.dat:755:16408:	out_quiet = 1;
../inputs/grep1.dat:756:16424:	list_files = 1;
../inputs/grep1.dat:757:16441:	break;
../inputs/grep1.dat:758:16449:      case 'n':
../inputs/grep1.dat:759:16465:	out_line = 1;
../inputs/grep1.dat:760:16480:	break;
../inputs/grep1.dat:761:16488:      case 'q':
../inputs/grep1.dat:762:16504:	out_quiet = 1;
../inputs/grep1.dat:763:16520:	break;
../inputs/grep1.dat:764:16528:      case 's':
../inputs/grep1.dat:765:16544:	suppress_errors = 1;
../inputs/grep1.dat:766:16566:	break;
../inputs/grep1.dat:767:16574:      case 'v':
../inputs/grep1.dat:768:16590:	out_invert = 1;
../inputs/grep1.dat:769:16607:	break;
../inputs/grep1.dat:770:16615:      case 'w':
../inputs/grep1.dat:771:16631:	match_words = 1;
../inputs/grep1.dat:772:16649:	break;
../inputs/grep1.dat:773:16657:      case 'x':
../inputs/grep1.dat:774:16673:	match_lines = 1;
../inputs/grep1.dat:775:16691:	break;
../inputs/grep1.dat:776:16699:      default:
../inputs/grep1.dat:777:16714:	usage();
../inputs/grep1.dat:778:16724:	break;
../inputs/grep1.dat:779:16732:      }
../inputs/grep1.dat:780:16740:
../inputs/grep1.dat:781:16741:  if (!keyfound)
../inputs/grep1.dat:782:16758:    if (optind < argc)
../inputs/grep1.dat:783:16781:      {
../inputs/grep1.dat:784:16789:	keys = argv[optind++];
../inputs/grep1.dat:785:16813:	keycc = strlen(keys);
../inputs/grep1.dat:786:16836:      }
../inputs/grep1.dat:787:16844:    else
../inputs/grep1.dat:788:16853:      usage();
../inputs/grep1.dat:789:16868:
../inputs/grep1.dat:790:16869:  if (!matcher)
../inputs/grep1.dat:791:16885:    matcher = prog;
../inputs/grep1.dat:792:16905:
../inputs/grep1.dat:793:16906:  if (!setmatcher(matcher) && !setmatcher("default"))
../inputs/grep1.dat:794:16960:    abort();
../inputs/grep1.dat:795:16973:
../inputs/grep1.dat:796:16974:  (*compile)(keys, keycc);
../inputs/grep1.dat:797:17001:
../inputs/grep1.dat:798:17002:  if (argc - optind > 1 && !no_filenames)
../inputs/grep1.dat:799:17044:    out_file = 1;
../inputs/grep1.dat:800:17062:
../inputs/grep1.dat:801:17063:  status = 1;
../inputs/grep1.dat:802:17077:
../inputs/grep1.dat:803:17078:  if (optind < argc)
../inputs/grep1.dat:804:17099:    while (optind < argc)
../inputs/grep1.dat:805:17125:      {
../inputs/grep1.dat:806:17133:	desc = strcmp(argv[optind], "-") ? open(argv[optind], O_RDONLY) : 0;
../inputs/grep1.dat:807:17203:	if (desc < 0)
../inputs/grep1.dat:808:17218:	  {
../inputs/grep1.dat:809:17223:	    if (!suppress_errors)
../inputs/grep1.dat:810:17250:	      error(argv[optind], errno);
../inputs/grep1.dat:811:17285:	  }
../inputs/grep1.dat:812:17290:	else
../inputs/grep1.dat:813:17296:	  {
../inputs/grep1.dat:814:17301:	    filename = desc == 0 ? "(standard input)" : argv[optind];
../inputs/grep1.dat:815:17364:	    count = grep(desc);
../inputs/grep1.dat:816:17389:	    if (count_matches)
../inputs/grep1.dat:817:17413:	      {
../inputs/grep1.dat:818:17422:		if (out_file)
../inputs/grep1.dat:819:17438:		  printf("%s:", filename);
../inputs/grep1.dat:820:17467:		printf("%d\n", count);
../inputs/grep1.dat:821:17492:	      }
../inputs/grep1.dat:822:17501:	    if (count)
../inputs/grep1.dat:823:17517:	      {
../inputs/grep1.dat:824:17526:		status = 0;
../inputs/grep1.dat:825:17540:		if (list_files == 1)
../inputs/grep1.dat:826:17563:		  printf("%s\n", filename);
../inputs/grep1.dat:827:17593:	      }
../inputs/grep1.dat:828:17602:	    else if (list_files == -1)
../inputs/grep1.dat:829:17634:	      printf("%s\n", filename);
../inputs/grep1.dat:830:17667:	  }
../inputs/grep1.dat:831:17672:	if (desc != 0)
../inputs/grep1.dat:832:17688:	  close(desc);
../inputs/grep1.dat:833:17704:	++optind;
../inputs/grep1.dat:834:17715:      }
../inputs/grep1.dat:835:17723:  else
../inputs/grep1.dat:836:17730:    {
../inputs/grep1.dat:837:17736:      filename = "(standard input)";
../inputs/grep1.dat:838:17773:      count = grep(0);
../inputs/grep1.dat:839:17796:      if (count_matches)
../inputs/grep1.dat:840:17821:	printf("%d\n", count);
../inputs/grep1.dat:841:17845:      if (count)
../inputs/grep1.dat:842:17862:	{
../inputs/grep1.dat:843:17865:	  status = 0;
../inputs/grep1.dat:844:17880:	  if (list_files == 1)
../inputs/grep1.dat:845:17904:	    printf("(standard input)\n");
../inputs/grep1.dat:846:17939:	}
../inputs/grep1.dat:847:17942:      else if (list_files == -1)
../inputs/grep1.dat:848:17975:	printf("(standard input)\n");
../inputs/grep1.dat:849:18006:    }
../inputs/grep1.dat:850:18012:
../inputs/grep1.dat:851:18013:  exit(errseen ? 2 : status);
../inputs/grep1.dat:852:18043:}
../inputs/grep1.dat:853:18045:/* Getopt for GNU.
../inputs/grep1.dat:854:18064:   NOTE: getopt is now part of the C library, so if you don't know what
../inputs/grep1.dat:855:18136:   "Keep this file name-space clean" means, talk to roland@gnu.ai.mit.edu
../inputs/grep1.dat:856:18210:   before changing it!
../inputs/grep1.dat:857:18233:
../inputs/grep1.dat:858:18234:   Copyright (C) 1987, 88, 89, 90, 91, 92, 1993
../inputs/grep1.dat:859:18282:   	Free Software Foundation, Inc.
../inputs/grep1.dat:860:18317:
../inputs/grep1.dat:861:18318:   This program is free software; you can redistribute it and/or modify it
../inputs/grep1.dat:862:18393:   under the terms of the GNU General Public License as published by the
../inputs/grep1.dat:863:18466:   Free Software Foundation; either version 2, or (at your option) any
../inputs/grep1.dat:864:18537:   later version.
../inputs/grep1.dat:865:18555:
../inputs/grep1.dat:866:18556:   This program is distributed in the hope that it will be useful,
../inputs/grep1.dat:867:18623:   but WITHOUT ANY WARRANTY; without even the implied warranty of
../inputs/grep1.dat:868:18689:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
../inputs/grep1.dat:869:18754:   GNU General Public License for more details.
../inputs/grep1.dat:870:18802:
../inputs/grep1.dat:871:18803:   You should have received a copy of the GNU General Public License
../inputs/grep1.dat:872:18872:   along with this program; if not, write to the Free Software
../inputs/grep1.dat:873:18935:   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
../inputs/grep1.dat:874:18994:
../inputs/grep1.dat:875:18996:/* NOTE!!!  AIX requires this to be the first thing in the file.
../inputs/grep1.dat:876:19061:   Do not put ANYTHING before it!  */
../inputs/grep1.dat:877:19099:#if !defined (__GNUC__) && defined (_AIX)
../inputs/grep1.dat:878:19141: #pragma alloca
../inputs/grep1.dat:879:19157:#endif
../inputs/grep1.dat:880:19164:
../inputs/grep1.dat:881:19165:#ifdef HAVE_CONFIG_H
../inputs/grep1.dat:883:19206:#define flag_config 1
../inputs/grep1.dat:884:19228:#endif
../inputs/grep1.dat:885:19235:
../inputs/grep1.dat:886:19236:#ifdef __GNUC__
../inputs/grep1.dat:887:19252:#define alloca __builtin_alloca
../inputs/grep1.dat:888:19284:#else /* not __GNUC__ */
../inputs/grep1.dat:889:19309:#if defined (HAVE_ALLOCA_H) || (defined(sparc) && (defined(sun) || (!defined(USG) && !defined(SVR4) && !defined(__svr4__))))
../inputs/grep1.dat:891:19454:#define flag_alloca 1
../inputs/grep1.dat:892:19476:#else
../inputs/grep1.dat:893:19482:#ifndef _AIX
../inputs/grep1.dat:894:19495:char *alloca ();
../inputs/grep1.dat:895:19512:#endif
../inputs/grep1.dat:896:19519:#endif /* alloca.h */
../inputs/grep1.dat:897:19541:#endif /* not __GNUC__ */
../inputs/grep1.dat:898:19567:
../inputs/grep1.dat:899:19568:#if !__STDC__ && !defined(const) && IN_GCC
../inputs/grep1.dat:900:19611:#define const
../inputs/grep1.dat:901:19625:#endif
../inputs/grep1.dat:902:19632:
../inputs/grep1.dat:903:19633:/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.  */
../inputs/grep1.dat:904:19710:#ifndef _NO_PROTO
../inputs/grep1.dat:905:19728:#define _NO_PROTO
../inputs/grep1.dat:906:19746:#endif
../inputs/grep1.dat:907:19753:
../inputs/grep1.dat:909:19778:
../inputs/grep1.dat:910:19779:/* Comment out all this code if we are using the GNU C Library, and are not
../inputs/grep1.dat:911:19855:   actually compiling the library itself.  This code is part of the GNU C
../inputs/grep1.dat:913:20003:   and linking in this code is a waste when using the GNU C library
../inputs/grep1.dat:914:20071:   (especially if it is a shared library).  Rather than having every GNU
../inputs/grep1.dat:915:20144:   program understand `configure --with-gnu-libc' and omit the object files,
../inputs/grep1.dat:916:20221:   it is simpler to just do this in the source for each such file.  */
../inputs/grep1.dat:917:20292:
../inputs/grep1.dat:918:20293:#if defined (_LIBC) || !defined (__GNU_LIBRARY__)
../inputs/grep1.dat:919:20343:
../inputs/grep1.dat:920:20344:
../inputs/grep1.dat:922:20395:   to get __GNU_LIBRARY__ defined.  */
../inputs/grep1.dat:923:20434:#ifdef	__GNU_LIBRARY__
../inputs/grep1.dat:924:20457:#undef	alloca
../inputs/grep1.dat:926:20542:   contain conflicting prototypes for getopt.  */
../inputs/grep1.dat:927:20592:#if flag_stdlib==0   
../inputs/grep1.dat:929:20634:#define flag_stdlib 1
../inputs/grep1.dat:930:20656:#endif
../inputs/grep1.dat:931:20663:#else	/* Not GNU C library.  */
../inputs/grep1.dat:932:20695:#define	__alloca	alloca
../inputs/grep1.dat:933:20719:#endif	/* GNU C library.  */
../inputs/grep1.dat:934:20748:
../inputs/grep1.dat:935:20749:/* If GETOPT_COMPAT is defined, `+' as well as `--' can introduce a
../inputs/grep1.dat:936:20817:   long-named option.  Because this is not POSIX.2 compliant, it is
../inputs/grep1.dat:937:20885:   being phased out.  */
../inputs/grep1.dat:938:20910:/* #define GETOPT_COMPAT */
../inputs/grep1.dat:939:20938:
../inputs/grep1.dat:940:20939:/* This version of `getopt' appears to the caller like standard Unix `getopt'
../inputs/grep1.dat:941:21017:   but it behaves differently for the user, since it allows the user
../inputs/grep1.dat:942:21086:   to intersperse the options with the other arguments.
../inputs/grep1.dat:943:21142:
../inputs/grep1.dat:944:21143:   As `getopt' works, it permutes the elements of ARGV so that,
../inputs/grep1.dat:945:21207:   when it is done, all the options precede everything else.  Thus
../inputs/grep1.dat:946:21274:   all application programs are extended to handle flexible argument order.
../inputs/grep1.dat:947:21350:
../inputs/grep1.dat:948:21351:   Setting the environment variable POSIXLY_CORRECT disables permutation.
../inputs/grep1.dat:949:21425:   Then the behavior is completely standard.
../inputs/grep1.dat:950:21470:
../inputs/grep1.dat:951:21471:   GNU application programs can use a third alternative mode in which
../inputs/grep1.dat:952:21541:   they can distinguish the relative order of options and other arguments.  */
../inputs/grep1.dat:953:21620:
../inputs/grep1.dat:955:21641:
../inputs/grep1.dat:956:21642:/* For communication from `getopt' to the caller.
../inputs/grep1.dat:957:21692:   When `getopt' finds an option that takes an argument,
../inputs/grep1.dat:958:21749:   the argument value is returned here.
../inputs/grep1.dat:959:21789:   Also, when `ordering' is RETURN_IN_ORDER,
../inputs/grep1.dat:960:21834:   each non-option ARGV-element is returned here.  */
../inputs/grep1.dat:961:21888:
../inputs/grep1.dat:962:21889:char *optarg = 0;
../inputs/grep1.dat:963:21907:
../inputs/grep1.dat:964:21908:/* Index in ARGV of the next element to be scanned.
../inputs/grep1.dat:965:21960:   This is used for communication to and from the caller
../inputs/grep1.dat:966:22017:   and for communication between successive calls to `getopt'.
../inputs/grep1.dat:967:22080:
../inputs/grep1.dat:968:22081:   On entry to `getopt', zero means this is the first call; initialize.
../inputs/grep1.dat:969:22153:
../inputs/grep1.dat:970:22154:   When `getopt' returns EOF, this is the index of the first of the
../inputs/grep1.dat:971:22222:   non-option elements that the caller should itself scan.
../inputs/grep1.dat:972:22281:
../inputs/grep1.dat:973:22282:   Otherwise, `optind' communicates from one call to the next
../inputs/grep1.dat:974:22344:   how much of ARGV has been scanned so far.  */
../inputs/grep1.dat:975:22393:
../inputs/grep1.dat:976:22394:/* XXX 1003.2 says this must be 1 before any call.  */
../inputs/grep1.dat:977:22449:int optind = 0;
../inputs/grep1.dat:978:22465:
../inputs/grep1.dat:979:22466:/* The next char to be scanned in the option-element
../inputs/grep1.dat:980:22519:   in which the last option character we returned was found.
../inputs/grep1.dat:981:22580:   This allows us to pick up the scan where we left off.
../inputs/grep1.dat:982:22637:
../inputs/grep1.dat:983:22638:   If this is zero, or a null string, it means resume the scan
../inputs/grep1.dat:984:22701:   by advancing to the next ARGV-element.  */
../inputs/grep1.dat:985:22747:
../inputs/grep1.dat:986:22748:static char *nextchar;
../inputs/grep1.dat:987:22771:
../inputs/grep1.dat:988:22772:/* Callers store zero here to inhibit the error message
../inputs/grep1.dat:989:22828:   for unrecognized options.  */
../inputs/grep1.dat:990:22861:
../inputs/grep1.dat:991:22862:int opterr = 1;
../inputs/grep1.dat:992:22878:
../inputs/grep1.dat:993:22879:/* Set to an option character which was unrecognized.
../inputs/grep1.dat:994:22933:   This must be initialized on some systems to avoid linking in the
../inputs/grep1.dat:995:23001:   system's own getopt implementation.  */
../inputs/grep1.dat:996:23044:
../inputs/grep1.dat:997:23045:int optopt = '?';
../inputs/grep1.dat:998:23063:
../inputs/grep1.dat:999:23064:/* Describe how to deal with options that follow non-option ARGV-elements.
../inputs/grep1.dat:1000:23139:
../inputs/grep1.dat:1001:23140:   If the caller did not specify anything,
../inputs/grep1.dat:1002:23183:   the default is REQUIRE_ORDER if the environment variable
../inputs/grep1.dat:1003:23243:   POSIXLY_CORRECT is defined, PERMUTE otherwise.
../inputs/grep1.dat:1004:23293:
../inputs/grep1.dat:1005:23294:   REQUIRE_ORDER means don't recognize them as options;
../inputs/grep1.dat:1006:23350:   stop option processing when the first non-option is seen.
../inputs/grep1.dat:1007:23411:   This is what Unix does.
../inputs/grep1.dat:1008:23438:   This mode of operation is selected by either setting the environment
../inputs/grep1.dat:1009:23510:   variable POSIXLY_CORRECT, or using `+' as the first character
../inputs/grep1.dat:1010:23575:   of the list of option characters.
../inputs/grep1.dat:1011:23612:
../inputs/grep1.dat:1012:23613:   PERMUTE is the default.  We permute the contents of ARGV as we scan,
../inputs/grep1.dat:1013:23685:   so that eventually all the non-options are at the end.  This allows options
../inputs/grep1.dat:1014:23764:   to be given in any order, even with programs that were not written to
../inputs/grep1.dat:1015:23837:   expect this.
../inputs/grep1.dat:1016:23853:
../inputs/grep1.dat:1017:23854:   RETURN_IN_ORDER is an option available to programs that were written
../inputs/grep1.dat:1018:23926:   to expect options and other ARGV-elements in any order and that care about
../inputs/grep1.dat:1019:24004:   the ordering of the two.  We describe each non-option ARGV-element
../inputs/grep1.dat:1020:24074:   as if it were the argument of an option with character code 1.
../inputs/grep1.dat:1021:24140:   Using `-' as the first character of the list of option characters
../inputs/grep1.dat:1022:24209:   selects this mode of operation.
../inputs/grep1.dat:1023:24244:
../inputs/grep1.dat:1024:24245:   The special argument `--' forces an end of option-scanning regardless
../inputs/grep1.dat:1025:24318:   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
../inputs/grep1.dat:1026:24387:   `--' can cause `getopt' to return EOF with `optind' != ARGC.  */
../inputs/grep1.dat:1027:24455:
../inputs/grep1.dat:1028:24456:static enum
../inputs/grep1.dat:1029:24468:{
../inputs/grep1.dat:1030:24470:  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
../inputs/grep1.dat:1031:24512:} ordering;
../inputs/grep1.dat:1032:24524:
../inputs/grep1.dat:1033:24526:#ifdef	__GNU_LIBRARY__
../inputs/grep1.dat:1034:24549:/* We want to avoid inclusion of string.h with non-GNU libraries
../inputs/grep1.dat:1035:24614:   because there are many ways it can cause trouble.
../inputs/grep1.dat:1036:24667:   On some systems, it contains special magic macros that don't work
../inputs/grep1.dat:1037:24736:   in GCC.  */
../inputs/grep1.dat:1038:24751:#if flag_string==0   
../inputs/grep1.dat:1040:24793:#define flag_string 1
../inputs/grep1.dat:1041:24815:#endif
../inputs/grep1.dat:1042:24822:#define	my_index	strchr
../inputs/grep1.dat:1043:24846:#define	my_bcopy(src, dst, n)	memcpy ((dst), (src), (n))
../inputs/grep1.dat:1044:24903:#else
../inputs/grep1.dat:1045:24909:
../inputs/grep1.dat:1046:24910:/* Avoid depending on library functions or files
../inputs/grep1.dat:1047:24959:   whose names are inconsistent.  */
../inputs/grep1.dat:1048:24996:
../inputs/grep1.dat:1049:24997:char *getenv ();
../inputs/grep1.dat:1050:25014:
../inputs/grep1.dat:1051:25015:static char *
../inputs/grep1.dat:1052:25029:my_index (str, chr)
../inputs/grep1.dat:1053:25049:     const char *str;
../inputs/grep1.dat:1054:25071:     int chr;
../inputs/grep1.dat:1055:25085:{
../inputs/grep1.dat:1056:25087:  while (*str)
../inputs/grep1.dat:1057:25102:    {
../inputs/grep1.dat:1058:25108:      if (*str == chr)
../inputs/grep1.dat:1059:25131:	return (char *) str;
../inputs/grep1.dat:1060:25153:      str++;
../inputs/grep1.dat:1061:25166:    }
../inputs/grep1.dat:1062:25172:  return 0;
../inputs/grep1.dat:1063:25184:}
../inputs/grep1.dat:1064:25186:
../inputs/grep1.dat:1065:25187:static void
../inputs/grep1.dat:1066:25199:my_bcopy (from, to, size)
../inputs/grep1.dat:1067:25225:     const char *from;
../inputs/grep1.dat:1068:25248:     char *to;
../inputs/grep1.dat:1069:25263:     int size;
../inputs/grep1.dat:1070:25278:{
../inputs/grep1.dat:1071:25280:  int i;
../inputs/grep1.dat:1072:25289:  for (i = 0; i < size; i++)
../inputs/grep1.dat:1073:25318:    to[i] = from[i];
../inputs/grep1.dat:1074:25339:}
../inputs/grep1.dat:1075:25341:#endif				/* GNU C library.  */
../inputs/grep1.dat:1076:25373:
../inputs/grep1.dat:1077:25375:/* Handle permutation of arguments.  */
../inputs/grep1.dat:1078:25415:
../inputs/grep1.dat:1079:25416:/* Describe the part of ARGV that contains non-options that have
../inputs/grep1.dat:1080:25481:   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
../inputs/grep1.dat:1081:25557:   `last_nonopt' is the index after the last of them.  */
../inputs/grep1.dat:1082:25615:
../inputs/grep1.dat:1083:25616:static int first_nonopt;
../inputs/grep1.dat:1084:25641:static int last_nonopt;
../inputs/grep1.dat:1085:25665:
../inputs/grep1.dat:1086:25666:/* Exchange two adjacent subsequences of ARGV.
../inputs/grep1.dat:1087:25713:   One subsequence is elements [first_nonopt,last_nonopt)
../inputs/grep1.dat:1088:25771:   which contains all the non-options that have been skipped so far.
../inputs/grep1.dat:1089:25840:   The other is elements [last_nonopt,optind), which contains all
../inputs/grep1.dat:1090:25906:   the options processed since those non-options were skipped.
../inputs/grep1.dat:1091:25969:
../inputs/grep1.dat:1092:25970:   `first_nonopt' and `last_nonopt' are relocated so that they describe
../inputs/grep1.dat:1093:26042:   the new indices of the non-options in ARGV after they are moved.  */
../inputs/grep1.dat:1094:26114:
../inputs/grep1.dat:1095:26115:static void
../inputs/grep1.dat:1096:26127:exchange (argv)
../inputs/grep1.dat:1097:26143:     char **argv;
../inputs/grep1.dat:1098:26161:{
../inputs/grep1.dat:1099:26163:  int nonopts_size = (last_nonopt - first_nonopt) * sizeof (char *);
../inputs/grep1.dat:1100:26232:  char **temp = (char **) __alloca (nonopts_size);
../inputs/grep1.dat:1101:26283:
../inputs/grep1.dat:1102:26284:  /* Interchange the two blocks of data in ARGV.  */
../inputs/grep1.dat:1103:26337:
../inputs/grep1.dat:1104:26338:  my_bcopy ((char *) &argv[first_nonopt], (char *) temp, nonopts_size);
../inputs/grep1.dat:1105:26410:  my_bcopy ((char *) &argv[last_nonopt], (char *) &argv[first_nonopt],
../inputs/grep1.dat:1106:26481:	    (optind - last_nonopt) * sizeof (char *));
../inputs/grep1.dat:1107:26529:  my_bcopy ((char *) temp,
../inputs/grep1.dat:1108:26556:	    (char *) &argv[first_nonopt + optind - last_nonopt],
../inputs/grep1.dat:1109:26614:	    nonopts_size);
../inputs/grep1.dat:1110:26634:
../inputs/grep1.dat:1111:26635:  /* Update records for the slots the non-options now occupy.  */
../inputs/grep1.dat:1112:26701:
../inputs/grep1.dat:1113:26702:  first_nonopt += (optind - last_nonopt);
../inputs/grep1.dat:1114:26744:  last_nonopt = optind;
../inputs/grep1.dat:1115:26768:}
../inputs/grep1.dat:1116:26770:
../inputs/grep1.dat:1117:26772:/* Scan elements of ARGV (whose length is ARGC) for option characters
../inputs/grep1.dat:1118:26842:   given in OPTSTRING.
../inputs/grep1.dat:1119:26865:
../inputs/grep1.dat:1120:26866:   If an element of ARGV starts with '-', and is not exactly "-" or "--",
../inputs/grep1.dat:1121:26940:   then it is an option element.  The characters of this element
../inputs/grep1.dat:1122:27005:   (aside from the initial '-') are option characters.  If `getopt'
../inputs/grep1.dat:1123:27073:   is called repeatedly, it returns successively each of the option characters
../inputs/grep1.dat:1124:27152:   from each of the option elements.
../inputs/grep1.dat:1125:27189:
../inputs/grep1.dat:1126:27190:   If `getopt' finds another option character, it returns that character,
../inputs/grep1.dat:1127:27264:   updating `optind' and `nextchar' so that the next call to `getopt' can
../inputs/grep1.dat:1128:27338:   resume the scan with the following option character or ARGV-element.
../inputs/grep1.dat:1129:27410:
../inputs/grep1.dat:1130:27411:   If there are no more option characters, `getopt' returns `EOF'.
../inputs/grep1.dat:1131:27478:   Then `optind' is the index in ARGV of the first ARGV-element
../inputs/grep1.dat:1132:27542:   that is not an option.  (The ARGV-elements have been permuted
../inputs/grep1.dat:1133:27607:   so that those that are not options now come last.)
../inputs/grep1.dat:1134:27661:
../inputs/grep1.dat:1135:27662:   OPTSTRING is a string containing the legitimate option characters.
../inputs/grep1.dat:1136:27732:   If an option character is seen that is not listed in OPTSTRING,
../inputs/grep1.dat:1137:27799:   return '?' after printing an error message.  If you set `opterr' to
../inputs/grep1.dat:1138:27870:   zero, the error message is suppressed but we still return '?'.
../inputs/grep1.dat:1139:27936:
../inputs/grep1.dat:1140:27937:   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
../inputs/grep1.dat:1141:28015:   so the following text in the same ARGV-element, or the text of the following
../inputs/grep1.dat:1142:28095:   ARGV-element, is returned in `optarg'.  Two colons mean an option that
../inputs/grep1.dat:1143:28169:   wants an optional arg; if there is text in the current ARGV-element,
../inputs/grep1.dat:1144:28241:   it is returned in `optarg', otherwise `optarg' is set to zero.
../inputs/grep1.dat:1145:28307:
../inputs/grep1.dat:1146:28308:   If OPTSTRING starts with `-' or `+', it requests different methods of
../inputs/grep1.dat:1147:28381:   handling the non-option ARGV-elements.
../inputs/grep1.dat:1148:28423:   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
../inputs/grep1.dat:1149:28491:
../inputs/grep1.dat:1150:28492:   Long-named options begin with `--' instead of `-'.
../inputs/grep1.dat:1151:28546:   Their names may be abbreviated as long as the abbreviation is unique
../inputs/grep1.dat:1152:28618:   or is an exact match for some defined option.  If they have an
../inputs/grep1.dat:1153:28684:   argument, it follows the option name in the same ARGV-element, separated
../inputs/grep1.dat:1154:28760:   from the option name by a `=', or else the in next ARGV-element.
../inputs/grep1.dat:1155:28828:   When `getopt' finds a long-named option, it returns 0 if that option's
../inputs/grep1.dat:1156:28902:   `flag' field is nonzero, the value of the option's `val' field
../inputs/grep1.dat:1157:28968:   if the `flag' field is zero.
../inputs/grep1.dat:1158:29000:
../inputs/grep1.dat:1159:29001:   The elements of ARGV aren't really const, because we permute them.
../inputs/grep1.dat:1160:29071:   But we pretend they're const in the prototype to be compatible
../inputs/grep1.dat:1161:29137:   with other systems.
../inputs/grep1.dat:1162:29160:
../inputs/grep1.dat:1163:29161:   LONGOPTS is a vector of `struct option' terminated by an
../inputs/grep1.dat:1164:29221:   element containing a name which is zero.
../inputs/grep1.dat:1165:29265:
../inputs/grep1.dat:1166:29266:   LONGIND returns the index in LONGOPT of the long-named option found.
../inputs/grep1.dat:1167:29338:   It is only valid when a long-named option has been found by the most
../inputs/grep1.dat:1168:29410:   recent call.
../inputs/grep1.dat:1169:29426:
../inputs/grep1.dat:1170:29427:   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
../inputs/grep1.dat:1171:29489:   long-named options.  */
../inputs/grep1.dat:1172:29516:
../inputs/grep1.dat:1173:29517:int
../inputs/grep1.dat:1174:29521:_getopt_internal (argc, argv, optstring, longopts, longind, long_only)
../inputs/grep1.dat:1175:29592:     int argc;
../inputs/grep1.dat:1176:29607:     char *const *argv;
../inputs/grep1.dat:1177:29631:     const char *optstring;
../inputs/grep1.dat:1178:29659:     const struct option *longopts;
../inputs/grep1.dat:1179:29695:     int *longind;
../inputs/grep1.dat:1180:29714:     int long_only;
../inputs/grep1.dat:1181:29734:{
../inputs/grep1.dat:1182:29736:  int option_index;
../inputs/grep1.dat:1183:29756:
../inputs/grep1.dat:1184:29757:  optarg = 0;
../inputs/grep1.dat:1185:29771:
../inputs/grep1.dat:1186:29772:  /* Initialize the internal data when the first call is made.
../inputs/grep1.dat:1187:29835:     Start processing options with ARGV-element 1 (since ARGV-element 0
../inputs/grep1.dat:1188:29907:     is the program name); the sequence of previously skipped
../inputs/grep1.dat:1189:29969:     non-option ARGV-elements is empty.  */
../inputs/grep1.dat:1190:30013:
../inputs/grep1.dat:1191:30014:  if (optind == 0)
../inputs/grep1.dat:1192:30033:    {
../inputs/grep1.dat:1193:30039:      first_nonopt = last_nonopt = optind = 1;
../inputs/grep1.dat:1194:30086:
../inputs/grep1.dat:1195:30087:      nextchar = NULL;
../inputs/grep1.dat:1196:30110:
../inputs/grep1.dat:1197:30111:      /* Determine how to handle the ordering of options and nonoptions.  */
../inputs/grep1.dat:1198:30188:
../inputs/grep1.dat:1199:30189:      if (optstring[0] == '-')
../inputs/grep1.dat:1200:30220:	{
../inputs/grep1.dat:1201:30223:	  ordering = RETURN_IN_ORDER;
../inputs/grep1.dat:1202:30254:	  ++optstring;
../inputs/grep1.dat:1203:30270:	}
../inputs/grep1.dat:1204:30273:      else if (optstring[0] == '+')
../inputs/grep1.dat:1205:30309:	{
../inputs/grep1.dat:1206:30312:	  ordering = REQUIRE_ORDER;
../inputs/grep1.dat:1207:30341:	  ++optstring;
../inputs/grep1.dat:1208:30357:	}
../inputs/grep1.dat:1209:30360:      else if (getenv ("POSIXLY_CORRECT") != NULL)
../inputs/grep1.dat:1210:30411:	ordering = REQUIRE_ORDER;
../inputs/grep1.dat:1211:30438:      else
../inputs/grep1.dat:1212:30449:	ordering = PERMUTE;
../inputs/grep1.dat:1213:30470:    }
../inputs/grep1.dat:1214:30476:
../inputs/grep1.dat:1215:30477:  if (nextchar == NULL || *nextchar == '\0')
../inputs/grep1.dat:1216:30522:    {
../inputs/grep1.dat:1217:30528:      if (ordering == PERMUTE)
../inputs/grep1.dat:1218:30559:	{
../inputs/grep1.dat:1219:30562:	  /* If we have just processed some options following some non-options,
../inputs/grep1.dat:1220:30635:	     exchange them so that the options come first.  */
../inputs/grep1.dat:1221:30691:
../inputs/grep1.dat:1222:30692:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
../inputs/grep1.dat:1223:30753:	    exchange ((char **) argv);
../inputs/grep1.dat:1224:30785:	  else if (last_nonopt != optind)
../inputs/grep1.dat:1225:30820:	    first_nonopt = optind;
../inputs/grep1.dat:1226:30848:
../inputs/grep1.dat:1227:30849:	  /* Now skip any additional non-options
../inputs/grep1.dat:1228:30891:	     and extend the range of non-options previously skipped.  */
../inputs/grep1.dat:1229:30957:
../inputs/grep1.dat:1230:30958:	  while (optind < argc
../inputs/grep1.dat:1231:30982:		 && (argv[optind][0] != '-' || argv[optind][1] == '\0')
../inputs/grep1.dat:1232:31040:#ifdef GETOPT_COMPAT
../inputs/grep1.dat:1233:31061:		 && (longopts == NULL
../inputs/grep1.dat:1234:31085:		     || argv[optind][0] != '+' || argv[optind][1] == '\0')
../inputs/grep1.dat:1235:31146:#endif				/* GETOPT_COMPAT */
../inputs/grep1.dat:1236:31176:		 )
../inputs/grep1.dat:1237:31181:	    optind++;
../inputs/grep1.dat:1238:31196:	  last_nonopt = optind;
../inputs/grep1.dat:1239:31221:	}
../inputs/grep1.dat:1240:31224:
../inputs/grep1.dat:1241:31225:      /* Special ARGV-element `--' means premature end of options.
../inputs/grep1.dat:1242:31292:	 Skip it like a null option,
../inputs/grep1.dat:1243:31322:	 then exchange with previous non-options as if it were an option,
../inputs/grep1.dat:1244:31389:	 then skip everything else like a non-option.  */
../inputs/grep1.dat:1245:31440:
../inputs/grep1.dat:1246:31441:      if (optind != argc && !strcmp (argv[optind], "--"))
../inputs/grep1.dat:1247:31499:	{
../inputs/grep1.dat:1248:31502:	  optind++;
../inputs/grep1.dat:1249:31515:
../inputs/grep1.dat:1250:31516:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
../inputs/grep1.dat:1251:31577:	    exchange ((char **) argv);
../inputs/grep1.dat:1252:31609:	  else if (first_nonopt == last_nonopt)
../inputs/grep1.dat:1253:31650:	    first_nonopt = optind;
../inputs/grep1.dat:1254:31678:	  last_nonopt = argc;
../inputs/grep1.dat:1255:31701:
../inputs/grep1.dat:1256:31702:	  optind = argc;
../inputs/grep1.dat:1257:31720:	}
../inputs/grep1.dat:1258:31723:
../inputs/grep1.dat:1259:31724:      /* If we have done all the ARGV-elements, stop the scan
../inputs/grep1.dat:1260:31786:	 and back over any non-options that we skipped and permuted.  */
../inputs/grep1.dat:1261:31852:
../inputs/grep1.dat:1262:31853:      if (optind == argc)
../inputs/grep1.dat:1263:31879:	{
../inputs/grep1.dat:1264:31882:	  /* Set the next-arg-index to point at the non-options
../inputs/grep1.dat:1265:31939:	     that we previously skipped, so the caller will digest them.  */
../inputs/grep1.dat:1266:32009:	  if (first_nonopt != last_nonopt)
../inputs/grep1.dat:1267:32045:	    optind = first_nonopt;
../inputs/grep1.dat:1268:32073:	  return EOF;
../inputs/grep1.dat:1269:32088:	}
../inputs/grep1.dat:1270:32091:
../inputs/grep1.dat:1271:32092:      /* If we have come to a non-option and did not permute it,
../inputs/grep1.dat:1272:32157:	 either stop the scan or describe it to the caller and pass it by.  */
../inputs/grep1.dat:1273:32229:
../inputs/grep1.dat:1274:32230:      if ((argv[optind][0] != '-' || argv[optind][1] == '\0')
../inputs/grep1.dat:1275:32292:#ifdef GETOPT_COMPAT
../inputs/grep1.dat:1276:32313:	  && (longopts == NULL
../inputs/grep1.dat:1277:32337:	      || argv[optind][0] != '+' || argv[optind][1] == '\0')
../inputs/grep1.dat:1278:32398:#endif				/* GETOPT_COMPAT */
../inputs/grep1.dat:1279:32428:	  )
../inputs/grep1.dat:1280:32433:	{
../inputs/grep1.dat:1281:32436:	  if (ordering == REQUIRE_ORDER)
../inputs/grep1.dat:1282:32470:	    return EOF;
../inputs/grep1.dat:1283:32487:	  optarg = argv[optind++];
../inputs/grep1.dat:1284:32515:	  return 1;
../inputs/grep1.dat:1285:32528:	}
../inputs/grep1.dat:1286:32531:
../inputs/grep1.dat:1287:32532:      /* We have found another option-ARGV-element.
../inputs/grep1.dat:1288:32584:	 Start decoding its characters.  */
../inputs/grep1.dat:1289:32621:
../inputs/grep1.dat:1290:32622:      nextchar = (argv[optind] + 1
../inputs/grep1.dat:1291:32657:		  + (longopts != NULL && argv[optind][1] == '-'));
../inputs/grep1.dat:1292:32710:    }
../inputs/grep1.dat:1293:32716:
../inputs/grep1.dat:1294:32717:  if (longopts != NULL
../inputs/grep1.dat:1295:32740:      && ((argv[optind][0] == '-'
../inputs/grep1.dat:1296:32774:	   && (argv[optind][1] == '-' || long_only))
../inputs/grep1.dat:1297:32820:#ifdef GETOPT_COMPAT
../inputs/grep1.dat:1298:32841:	  || argv[optind][0] == '+'
../inputs/grep1.dat:1299:32870:#endif				/* GETOPT_COMPAT */
../inputs/grep1.dat:1300:32900:	  ))
../inputs/grep1.dat:1301:32906:    {
../inputs/grep1.dat:1302:32912:      const struct option *p;
../inputs/grep1.dat:1303:32942:      char *s = nextchar;
../inputs/grep1.dat:1304:32968:      int exact = 0;
../inputs/grep1.dat:1305:32989:      int ambig = 0;
../inputs/grep1.dat:1306:33010:      const struct option *pfound = NULL;
../inputs/grep1.dat:1307:33052:      int indfound;
../inputs/grep1.dat:1308:33072:
../inputs/grep1.dat:1309:33073:      while (*s && *s != '=')
../inputs/grep1.dat:1310:33103:	s++;
../inputs/grep1.dat:1311:33109:
../inputs/grep1.dat:1312:33110:      /* Test all options for either exact match or abbreviated matches.  */
../inputs/grep1.dat:1313:33187:      for (p = longopts, option_index = 0; p->name;
../inputs/grep1.dat:1314:33239:	   p++, option_index++)
../inputs/grep1.dat:1315:33264:	if (!strncmp (p->name, nextchar, s - nextchar))
../inputs/grep1.dat:1316:33313:	  {
../inputs/grep1.dat:1317:33318:	    if (s - nextchar == strlen (p->name))
../inputs/grep1.dat:1318:33361:	      {
../inputs/grep1.dat:1319:33370:		/* Exact match found.  */
../inputs/grep1.dat:1320:33398:		pfound = p;
../inputs/grep1.dat:1321:33412:		indfound = option_index;
../inputs/grep1.dat:1322:33439:		exact = 1;
../inputs/grep1.dat:1323:33452:		break;
../inputs/grep1.dat:1324:33461:	      }
../inputs/grep1.dat:1325:33470:	    else if (pfound == NULL)
../inputs/grep1.dat:1326:33500:	      {
../inputs/grep1.dat:1327:33509:		/* First nonexact match found.  */
../inputs/grep1.dat:1328:33546:		pfound = p;
../inputs/grep1.dat:1329:33560:		indfound = option_index;
../inputs/grep1.dat:1330:33587:	      }
../inputs/grep1.dat:1331:33596:	    else
../inputs/grep1.dat:1332:33606:	      /* Second nonexact match found.  */
../inputs/grep1.dat:1333:33649:	      ambig = 1;
../inputs/grep1.dat:1334:33667:	  }
../inputs/grep1.dat:1335:33672:
../inputs/grep1.dat:1336:33673:      if (ambig && !exact)
../inputs/grep1.dat:1337:33700:	{
../inputs/grep1.dat:1338:33703:	  if (opterr)
../inputs/grep1.dat:1339:33718:	    fprintf (stderr, "%s: option `%s' is ambiguous\n",
../inputs/grep1.dat:1340:33774:		     argv[0], argv[optind]);
../inputs/grep1.dat:1341:33805:	  nextchar += strlen (nextchar);
../inputs/grep1.dat:1342:33839:	  optind++;
../inputs/grep1.dat:1343:33852:	  return '?';
../inputs/grep1.dat:1344:33867:	}
../inputs/grep1.dat:1345:33870:
../inputs/grep1.dat:1346:33871:      if (pfound != NULL)
../inputs/grep1.dat:1347:33897:	{
../inputs/grep1.dat:1348:33900:	  option_index = indfound;
../inputs/grep1.dat:1349:33928:	  optind++;
../inputs/grep1.dat:1350:33941:	  if (*s)
../inputs/grep1.dat:1351:33952:	    {
../inputs/grep1.dat:1352:33959:	      /* Don't test has_arg with >, because some C compilers don't
../inputs/grep1.dat:1353:34027:		 allow it to be used on enums.  */
../inputs/grep1.dat:1354:34064:	      if (pfound->has_arg)
../inputs/grep1.dat:1355:34092:		optarg = s + 1;
../inputs/grep1.dat:1356:34110:	      else
../inputs/grep1.dat:1357:34122:		{
../inputs/grep1.dat:1358:34126:		  if (opterr)
../inputs/grep1.dat:1359:34142:		    {
../inputs/grep1.dat:1360:34150:		      if (argv[optind - 1][1] == '-')
../inputs/grep1.dat:1361:34190:			/* --option */
../inputs/grep1.dat:1362:34208:			fprintf (stderr,
../inputs/grep1.dat:1363:34228:				 "%s: option `--%s' doesn't allow an argument\n",
../inputs/grep1.dat:1364:34282:				 argv[0], pfound->name);
../inputs/grep1.dat:1365:34311:		      else
../inputs/grep1.dat:1366:34324:			/* +option or -option */
../inputs/grep1.dat:1367:34352:			fprintf (stderr,
../inputs/grep1.dat:1368:34372:			     "%s: option `%c%s' doesn't allow an argument\n",
../inputs/grep1.dat:1369:34429:			     argv[0], argv[optind - 1][0], pfound->name);
../inputs/grep1.dat:1370:34482:		    }
../inputs/grep1.dat:1371:34490:		  nextchar += strlen (nextchar);
../inputs/grep1.dat:1372:34525:		  return '?';
../inputs/grep1.dat:1373:34541:		}
../inputs/grep1.dat:1374:34545:	    }
../inputs/grep1.dat:1375:34552:	  else if (pfound->has_arg == 1)
../inputs/grep1.dat:1376:34586:	    {
../inputs/grep1.dat:1377:34593:	      if (optind < argc)
../inputs/grep1.dat:1378:34619:		optarg = argv[optind++];
../inputs/grep1.dat:1379:34646:	      else
../inputs/grep1.dat:1380:34658:		{
../inputs/grep1.dat:1381:34662:		  if (opterr)
../inputs/grep1.dat:1382:34678:		    fprintf (stderr, "%s: option `%s' requires an argument\n",
../inputs/grep1.dat:1383:34743:			     argv[0], argv[optind - 1]);
../inputs/grep1.dat:1384:34779:		  nextchar += strlen (nextchar);
../inputs/grep1.dat:1385:34814:		  return optstring[0] == ':' ? ':' : '?';
../inputs/grep1.dat:1386:34858:		}
../inputs/grep1.dat:1387:34862:	    }
../inputs/grep1.dat:1388:34869:	  nextchar += strlen (nextchar);
../inputs/grep1.dat:1389:34903:	  if (longind != NULL)
../inputs/grep1.dat:1390:34927:	    *longind = option_index;
../inputs/grep1.dat:1391:34957:	  if (pfound->flag)
../inputs/grep1.dat:1392:34978:	    {
../inputs/grep1.dat:1393:34985:	      *(pfound->flag) = pfound->val;
../inputs/grep1.dat:1394:35023:	      return 0;
../inputs/grep1.dat:1395:35040:	    }
../inputs/grep1.dat:1396:35047:	  return pfound->val;
../inputs/grep1.dat:1397:35070:	}
../inputs/grep1.dat:1398:35073:      /* Can't find it as a long option.  If this is not getopt_long_only,
../inputs/grep1.dat:1399:35148:	 or the option starts with '--' or is not a valid short
../inputs/grep1.dat:1400:35205:	 option, then it's an error.
../inputs/grep1.dat:1401:35235:	 Otherwise interpret it as a short option.  */
../inputs/grep1.dat:1402:35283:      if (!long_only || argv[optind][1] == '-'
../inputs/grep1.dat:1403:35330:#ifdef GETOPT_COMPAT
../inputs/grep1.dat:1404:35351:	  || argv[optind][0] == '+'
../inputs/grep1.dat:1405:35380:#endif				/* GETOPT_COMPAT */
../inputs/grep1.dat:1406:35410:	  || my_index (optstring, *nextchar) == NULL)
../inputs/grep1.dat:1407:35457:	{
../inputs/grep1.dat:1408:35460:	  if (opterr)
../inputs/grep1.dat:1409:35475:	    {
../inputs/grep1.dat:1410:35482:	      if (argv[optind][1] == '-')
../inputs/grep1.dat:1411:35517:		/* --option */
../inputs/grep1.dat:1412:35534:		fprintf (stderr, "%s: unrecognized option `--%s'\n",
../inputs/grep1.dat:1413:35589:			 argv[0], nextchar);
../inputs/grep1.dat:1414:35613:	      else
../inputs/grep1.dat:1415:35625:		/* +option or -option */
../inputs/grep1.dat:1416:35652:		fprintf (stderr, "%s: unrecognized option `%c%s'\n",
../inputs/grep1.dat:1417:35707:			 argv[0], argv[optind][0], nextchar);
../inputs/grep1.dat:1418:35748:	    }
../inputs/grep1.dat:1419:35755:	  nextchar = (char *) "";
../inputs/grep1.dat:1420:35782:	  optind++;
../inputs/grep1.dat:1421:35795:	  return '?';
../inputs/grep1.dat:1422:35810:	}
../inputs/grep1.dat:1423:35813:    }
../inputs/grep1.dat:1424:35819:
../inputs/grep1.dat:1425:35820:  /* Look at and handle the next option-character.  */
../inputs/grep1.dat:1426:35875:
../inputs/grep1.dat:1427:35876:  {
../inputs/grep1.dat:1428:35880:    char c = *nextchar++;
../inputs/grep1.dat:1429:35906:    char *temp = my_index (optstring, c);
../inputs/grep1.dat:1430:35948:
../inputs/grep1.dat:1431:35949:    /* Increment `optind' when we start to process its last character.  */
../inputs/grep1.dat:1432:36024:    if (*nextchar == '\0')
../inputs/grep1.dat:1433:36051:      ++optind;
../inputs/grep1.dat:1434:36067:
../inputs/grep1.dat:1435:36068:    if (temp == NULL || c == ':')
../inputs/grep1.dat:1436:36102:      {
../inputs/grep1.dat:1437:36110:	if (opterr)
../inputs/grep1.dat:1438:36123:	  {
../inputs/grep1.dat:1439:36128:#if 0
../inputs/grep1.dat:1440:36134:	    if (c < 040 || c >= 0177)
../inputs/grep1.dat:1441:36165:	      fprintf (stderr, "%s: unrecognized option, character code 0%o\n",
../inputs/grep1.dat:1442:36238:		       argv[0], c);
../inputs/grep1.dat:1443:36260:	    else
../inputs/grep1.dat:1444:36270:	      fprintf (stderr, "%s: unrecognized option `-%c'\n", argv[0], c);
../inputs/grep1.dat:1445:36342:#else
../inputs/grep1.dat:1446:36348:	    /* 1003.2 specifies the format of this message.  */
../inputs/grep1.dat:1447:36405:	    fprintf (stderr, "%s: illegal option -- %c\n", argv[0], c);
../inputs/grep1.dat:1448:36470:#endif
../inputs/grep1.dat:1449:36477:	  }
../inputs/grep1.dat:1450:36482:	optopt = c;
../inputs/grep1.dat:1451:36495:	return '?';
../inputs/grep1.dat:1452:36508:      }
../inputs/grep1.dat:1453:36516:    if (temp[1] == ':')
../inputs/grep1.dat:1454:36540:      {
../inputs/grep1.dat:1455:36548:	if (temp[2] == ':')
../inputs/grep1.dat:1456:36569:	  {
../inputs/grep1.dat:1457:36574:	    /* This is an option that accepts an argument optionally.  */
../inputs/grep1.dat:1458:36641:	    if (*nextchar != '\0')
../inputs/grep1.dat:1459:36669:	      {
../inputs/grep1.dat:1460:36678:		optarg = nextchar;
../inputs/grep1.dat:1461:36699:		optind++;
../inputs/grep1.dat:1462:36711:	      }
../inputs/grep1.dat:1463:36720:	    else
../inputs/grep1.dat:1464:36730:	      optarg = 0;
../inputs/grep1.dat:1465:36749:	    nextchar = NULL;
../inputs/grep1.dat:1466:36771:	  }
../inputs/grep1.dat:1467:36776:	else
../inputs/grep1.dat:1468:36782:	  {
../inputs/grep1.dat:1469:36787:	    /* This is an option that requires an argument.  */
../inputs/grep1.dat:1470:36844:	    if (*nextchar != '\0')
../inputs/grep1.dat:1471:36872:	      {
../inputs/grep1.dat:1472:36881:		optarg = nextchar;
../inputs/grep1.dat:1473:36902:		/* If we end this ARGV-element by taking the rest as an arg,
../inputs/grep1.dat:1474:36965:		   we must advance to the next element now.  */
../inputs/grep1.dat:1475:37015:		optind++;
../inputs/grep1.dat:1476:37027:	      }
../inputs/grep1.dat:1477:37036:	    else if (optind == argc)
../inputs/grep1.dat:1478:37066:	      {
../inputs/grep1.dat:1479:37075:		if (opterr)
../inputs/grep1.dat:1480:37089:		  {
../inputs/grep1.dat:1481:37095:#if 0
../inputs/grep1.dat:1482:37101:		    fprintf (stderr, "%s: option `-%c' requires an argument\n",
../inputs/grep1.dat:1483:37167:			     argv[0], c);
../inputs/grep1.dat:1484:37188:#else
../inputs/grep1.dat:1485:37194:		    /* 1003.2 specifies the format of this message.  */
../inputs/grep1.dat:1486:37252:		    fprintf (stderr, "%s: option requires an argument -- %c\n",
../inputs/grep1.dat:1487:37318:			     argv[0], c);
../inputs/grep1.dat:1488:37339:#endif
../inputs/grep1.dat:1489:37346:		  }
../inputs/grep1.dat:1490:37352:		optopt = c;
../inputs/grep1.dat:1491:37366:		if (optstring[0] == ':')
../inputs/grep1.dat:1492:37393:		  c = ':';
../inputs/grep1.dat:1493:37406:		else
../inputs/grep1.dat:1494:37413:		  c = '?';
../inputs/grep1.dat:1495:37426:	      }
../inputs/grep1.dat:1496:37435:	    else
../inputs/grep1.dat:1497:37445:	      /* We already incremented `optind' once;
../inputs/grep1.dat:1498:37493:		 increment it again when taking next ARGV-elt as argument.  */
../inputs/grep1.dat:1499:37558:	      optarg = argv[optind++];
../inputs/grep1.dat:1500:37590:	    nextchar = NULL;
../inputs/grep1.dat:1501:37612:	  }
../inputs/grep1.dat:1502:37617:      }
../inputs/grep1.dat:1503:37625:    return c;
../inputs/grep1.dat:1504:37639:  }
../inputs/grep1.dat:1505:37643:}
../inputs/grep1.dat:1506:37645:
../inputs/grep1.dat:1507:37646:int
../inputs/grep1.dat:1508:37650:getopt (argc, argv, optstring)
../inputs/grep1.dat:1509:37681:     int argc;
../inputs/grep1.dat:1510:37696:     char *const *argv;
../inputs/grep1.dat:1511:37720:     const char *optstring;
../inputs/grep1.dat:1512:37748:{
../inputs/grep1.dat:1513:37750:  return _getopt_internal (argc, argv, optstring,
../inputs/grep1.dat:1514:37800:			   (const struct option *) 0,
../inputs/grep1.dat:1515:37833:			   (int *) 0,
../inputs/grep1.dat:1516:37850:			   0);
../inputs/grep1.dat:1517:37860:}
../inputs/grep1.dat:1518:37862:
../inputs/grep1.dat:1519:37863:#endif	/* _LIBC or not __GNU_LIBRARY__.  */
../inputs/grep1.dat:1520:37907:
../inputs/grep1.dat:1521:37909:#ifdef TEST
../inputs/grep1.dat:1522:37921:
../inputs/grep1.dat:1523:37922:/* Compile with -DTEST to make an executable for use in testing
../inputs/grep1.dat:1524:37986:   the above definition of `getopt'.  */
../inputs/grep1.dat:1525:38027:
../inputs/grep1.dat:1526:38028:int
../inputs/grep1.dat:1527:38032:main (argc, argv)
../inputs/grep1.dat:1528:38050:     int argc;
../inputs/grep1.dat:1529:38065:     char **argv;
../inputs/grep1.dat:1530:38083:{
../inputs/grep1.dat:1531:38085:  int c;
../inputs/grep1.dat:1532:38094:  int digit_optind = 0;
../inputs/grep1.dat:1533:38118:
../inputs/grep1.dat:1534:38119:  while (1)
../inputs/grep1.dat:1535:38131:    {
../inputs/grep1.dat:1536:38137:      int this_option_optind = optind ? optind : 1;
../inputs/grep1.dat:1537:38189:
../inputs/grep1.dat:1538:38190:      c = getopt (argc, argv, "abc:d:0123456789");
../inputs/grep1.dat:1539:38241:      if (c == EOF)
../inputs/grep1.dat:1540:38261:	break;
../inputs/grep1.dat:1541:38269:
../inputs/grep1.dat:1542:38270:      switch (c)
../inputs/grep1.dat:1543:38287:	{
../inputs/grep1.dat:1544:38290:	case '0':
../inputs/grep1.dat:1545:38301:	case '1':
../inputs/grep1.dat:1546:38312:	case '2':
../inputs/grep1.dat:1547:38323:	case '3':
../inputs/grep1.dat:1548:38334:	case '4':
../inputs/grep1.dat:1549:38345:	case '5':
../inputs/grep1.dat:1550:38356:	case '6':
../inputs/grep1.dat:1551:38367:	case '7':
../inputs/grep1.dat:1552:38378:	case '8':
../inputs/grep1.dat:1553:38389:	case '9':
../inputs/grep1.dat:1554:38400:	  if (digit_optind != 0 && digit_optind != this_option_optind)
../inputs/grep1.dat:1555:38464:	    printf ("digits occur in two different argv-elements.\n");
../inputs/grep1.dat:1556:38528:	  digit_optind = this_option_optind;
../inputs/grep1.dat:1557:38566:	  printf ("option %c\n", c);
../inputs/grep1.dat:1558:38596:	  break;
../inputs/grep1.dat:1559:38606:
../inputs/grep1.dat:1560:38607:	case 'a':
../inputs/grep1.dat:1561:38618:	  printf ("option a\n");
../inputs/grep1.dat:1562:38644:	  break;
../inputs/grep1.dat:1563:38654:
../inputs/grep1.dat:1564:38655:	case 'b':
../inputs/grep1.dat:1565:38666:	  printf ("option b\n");
../inputs/grep1.dat:1566:38692:	  break;
../inputs/grep1.dat:1567:38702:
../inputs/grep1.dat:1568:38703:	case 'c':
../inputs/grep1.dat:1569:38714:	  printf ("option c with value `%s'\n", optarg);
../inputs/grep1.dat:1570:38764:	  break;
../inputs/grep1.dat:1571:38774:
../inputs/grep1.dat:1572:38775:	case '?':
../inputs/grep1.dat:1573:38786:	  break;
../inputs/grep1.dat:1574:38796:
../inputs/grep1.dat:1575:38797:	default:
../inputs/grep1.dat:1576:38807:	  printf ("?? getopt returned character code 0%o ??\n", c);
../inputs/grep1.dat:1577:38868:	}
../inputs/grep1.dat:1578:38871:    }
../inputs/grep1.dat:1579:38877:
../inputs/grep1.dat:1580:38878:  if (optind < argc)
../inputs/grep1.dat:1581:38899:    {
../inputs/grep1.dat:1582:38905:      printf ("non-option ARGV-elements: ");
../inputs/grep1.dat:1583:38950:      while (optind < argc)
../inputs/grep1.dat:1584:38978:	printf ("%s ", argv[optind++]);
../inputs/grep1.dat:1585:39011:      printf ("\n");
../inputs/grep1.dat:1586:39032:    }
../inputs/grep1.dat:1587:39038:
../inputs/grep1.dat:1588:39039:  exit (0);
../inputs/grep1.dat:1589:39051:}
../inputs/grep1.dat:1590:39053:
../inputs/grep1.dat:1591:39054:#endif /* TEST */
../inputs/grep1.dat:1592:39072:/* Extended regular expression matching and search library,
../inputs/grep1.dat:1593:39132:   version 0.12.
../inputs/grep1.dat:1594:39149:   (Implements POSIX draft P10003.2/D11.2, except for
../inputs/grep1.dat:1595:39203:   internationalization features.)
../inputs/grep1.dat:1596:39238:
../inputs/grep1.dat:1597:39239:   Copyright (C) 1993 Free Software Foundation, Inc.
../inputs/grep1.dat:1598:39292:
../inputs/grep1.dat:1599:39293:   This program is free software; you can redistribute it and/or modify
../inputs/grep1.dat:1600:39365:   it under the terms of the GNU General Public License as published by
../inputs/grep1.dat:1601:39437:   the Free Software Foundation; either version 2, or (at your option)
../inputs/grep1.dat:1602:39508:   any later version.
../inputs/grep1.dat:1603:39530:
../inputs/grep1.dat:1604:39531:   This program is distributed in the hope that it will be useful,
../inputs/grep1.dat:1605:39598:   but WITHOUT ANY WARRANTY; without even the implied warranty of
../inputs/grep1.dat:1606:39664:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
../inputs/grep1.dat:1607:39729:   GNU General Public License for more details.
../inputs/grep1.dat:1608:39777:
../inputs/grep1.dat:1609:39778:   You should have received a copy of the GNU General Public License
../inputs/grep1.dat:1610:39847:   along with this program; if not, write to the Free Software
../inputs/grep1.dat:1611:39910:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
../inputs/grep1.dat:1612:39975:
../inputs/grep1.dat:1613:39976:/* AIX requires this to be the first thing in the file. */
../inputs/grep1.dat:1614:40035:#if defined (_AIX) && !defined (REGEX_MALLOC)
../inputs/grep1.dat:1615:40081:  #pragma alloca
../inputs/grep1.dat:1616:40098:#endif
../inputs/grep1.dat:1617:40105:
../inputs/grep1.dat:1618:40106:#define _GNU_SOURCE
../inputs/grep1.dat:1619:40126:
../inputs/grep1.dat:1621:40203:#if flag_systypes==0
../inputs/grep1.dat:1623:40247:#define flag_systypes 1
../inputs/grep1.dat:1624:40271:#endif
../inputs/grep1.dat:1625:40278:
../inputs/grep1.dat:1626:40279:#ifdef HAVE_CONFIG_H
../inputs/grep1.dat:1627:40300:#if flag_config==0
../inputs/grep1.dat:1629:40339:#define flag_config 1
../inputs/grep1.dat:1630:40361:#endif
../inputs/grep1.dat:1631:40368:#endif
../inputs/grep1.dat:1632:40375:
../inputs/grep1.dat:1633:40376:/* The `emacs' switch turns on certain matching commands
../inputs/grep1.dat:1634:40433:   that make sense only in Emacs. */
../inputs/grep1.dat:1635:40470:#ifdef emacs
../inputs/grep1.dat:1636:40483:
../inputs/grep1.dat:1640:40542:
../inputs/grep1.dat:1641:40543:/* Emacs uses `NULL' as a predicate.  */
../inputs/grep1.dat:1642:40584:#undef NULL
../inputs/grep1.dat:1643:40596:
../inputs/grep1.dat:1644:40597:#else  /* not emacs */
../inputs/grep1.dat:1645:40620:
../inputs/grep1.dat:1646:40621:/* We used to test for `BSTRING' here, but only GCC and Emacs define
../inputs/grep1.dat:1647:40690:   `BSTRING', as far as I know, and neither of them use this code.  */
../inputs/grep1.dat:1648:40761:#if HAVE_STRING_H || STDC_HEADERS
../inputs/grep1.dat:1649:40795:#if flag_string==0
../inputs/grep1.dat:1651:40834:#define flag_string 1
../inputs/grep1.dat:1652:40856:#endif
../inputs/grep1.dat:1653:40863:#ifndef bcmp
../inputs/grep1.dat:1654:40876:#define bcmp(s1, s2, n)	memcmp ((s1), (s2), (n))
../inputs/grep1.dat:1655:40925:#endif
../inputs/grep1.dat:1656:40932:#ifndef bcopy
../inputs/grep1.dat:1657:40946:#define bcopy(s, d, n)	memcpy ((d), (s), (n))
../inputs/grep1.dat:1658:40992:#endif
../inputs/grep1.dat:1659:40999:#ifndef bzero
../inputs/grep1.dat:1660:41013:#define bzero(s, n)	memset ((s), 0, (n))
../inputs/grep1.dat:1661:41054:#endif
../inputs/grep1.dat:1662:41061:#else
../inputs/grep1.dat:1663:41067:#if flag_strings==0
../inputs/grep1.dat:1665:41108:#define flag_strings 1
../inputs/grep1.dat:1666:41131:#endif
../inputs/grep1.dat:1667:41138:#endif
../inputs/grep1.dat:1668:41145:
../inputs/grep1.dat:1669:41146:#ifdef STDC_HEADERS
../inputs/grep1.dat:1670:41166:#if flag_stdlib==0 
../inputs/grep1.dat:1672:41206:#define flag_stdlib 1
../inputs/grep1.dat:1673:41228:#endif
../inputs/grep1.dat:1674:41235:#else
../inputs/grep1.dat:1675:41241:char *malloc ();
../inputs/grep1.dat:1676:41258:char *realloc ();
../inputs/grep1.dat:1677:41276:#endif
../inputs/grep1.dat:1678:41283:
../inputs/grep1.dat:1679:41284:
../inputs/grep1.dat:1680:41285:/* Define the syntax stuff for \<, \>, etc.  */
../inputs/grep1.dat:1681:41333:
../inputs/grep1.dat:1682:41334:/* This must be nonzero for the wordchar and notwordchar pattern
../inputs/grep1.dat:1683:41399:   commands in re_match_2.  */
../inputs/grep1.dat:1684:41430:#ifndef Sword 
../inputs/grep1.dat:1685:41445:#define Sword 1
../inputs/grep1.dat:1686:41461:#endif
../inputs/grep1.dat:1687:41468:
../inputs/grep1.dat:1688:41469:#ifdef SYNTAX_TABLE
../inputs/grep1.dat:1689:41489:
../inputs/grep1.dat:1690:41490:extern char *re_syntax_table;
../inputs/grep1.dat:1691:41520:
../inputs/grep1.dat:1692:41521:#else /* not SYNTAX_TABLE */
../inputs/grep1.dat:1693:41550:
../inputs/grep1.dat:1694:41551:/* How many characters in the character set.  */
../inputs/grep1.dat:1695:41600:#define CHAR_SET_SIZE 256
../inputs/grep1.dat:1696:41626:
../inputs/grep1.dat:1697:41627:static char re_syntax_table[CHAR_SET_SIZE];
../inputs/grep1.dat:1698:41671:
../inputs/grep1.dat:1699:41672:static void
../inputs/grep1.dat:1700:41684:init_syntax_once ()
../inputs/grep1.dat:1701:41704:{
../inputs/grep1.dat:1702:41706:   register int c;
../inputs/grep1.dat:1703:41725:   static int done = 0;
../inputs/grep1.dat:1704:41749:
../inputs/grep1.dat:1705:41750:   if (done)
../inputs/grep1.dat:1706:41763:     return;
../inputs/grep1.dat:1707:41776:
../inputs/grep1.dat:1708:41777:   bzero (re_syntax_table, sizeof re_syntax_table);
../inputs/grep1.dat:1709:41829:
../inputs/grep1.dat:1710:41830:   for (c = 'a'; c <= 'z'; c++)
../inputs/grep1.dat:1711:41862:     re_syntax_table[c] = Sword;
../inputs/grep1.dat:1712:41895:
../inputs/grep1.dat:1713:41896:   for (c = 'A'; c <= 'Z'; c++)
../inputs/grep1.dat:1714:41928:     re_syntax_table[c] = Sword;
../inputs/grep1.dat:1715:41961:
../inputs/grep1.dat:1716:41962:   for (c = '0'; c <= '9'; c++)
../inputs/grep1.dat:1717:41994:     re_syntax_table[c] = Sword;
../inputs/grep1.dat:1718:42027:
../inputs/grep1.dat:1719:42028:   re_syntax_table['_'] = Sword;
../inputs/grep1.dat:1720:42061:
../inputs/grep1.dat:1721:42062:   done = 1;
../inputs/grep1.dat:1722:42075:}
../inputs/grep1.dat:1723:42077:
../inputs/grep1.dat:1724:42078:#endif /* not SYNTAX_TABLE */
../inputs/grep1.dat:1725:42108:
../inputs/grep1.dat:1726:42109:#define SYNTAX(c) re_syntax_table[c]
../inputs/grep1.dat:1727:42146:
../inputs/grep1.dat:1728:42147:#endif /* not emacs */
../inputs/grep1.dat:1729:42170:
../inputs/grep1.dat:1730:42172:/* Get the interface, including the syntax bits.  */
../inputs/grep1.dat:1732:42244:
../inputs/grep1.dat:1733:42245:/* isalpha etc. are used for the character classes.  */
../inputs/grep1.dat:1735:42320:
../inputs/grep1.dat:1736:42321:/* Jim Meyering writes:
../inputs/grep1.dat:1737:42345:
../inputs/grep1.dat:1738:42346:   "... Some ctype macros are valid only for character codes that
../inputs/grep1.dat:1739:42412:   isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
../inputs/grep1.dat:1740:42482:   using /bin/cc or gcc but without giving an ansi option).  So, all
../inputs/grep1.dat:1741:42551:   ctype uses should be through macros like ISPRINT...  If
../inputs/grep1.dat:1742:42610:   STDC_HEADERS is defined, then autoconf has verified that the ctype
../inputs/grep1.dat:1743:42680:   macros don't need to be guarded with references to isascii. ...
../inputs/grep1.dat:1744:42747:   Defining isascii to 1 should let any compiler worth its salt
../inputs/grep1.dat:1745:42811:   eliminate the && through constant folding."  */
../inputs/grep1.dat:1746:42862:#if ! defined (isascii) || defined (STDC_HEADERS)
../inputs/grep1.dat:1747:42912:#undef isascii
../inputs/grep1.dat:1748:42927:#define isascii(c) 1
../inputs/grep1.dat:1749:42948:#endif
../inputs/grep1.dat:1750:42955:
../inputs/grep1.dat:1751:42956:#ifdef isblank
../inputs/grep1.dat:1752:42971:#define ISBLANK(c) (isascii (c) && isblank (c))
../inputs/grep1.dat:1753:43019:#else
../inputs/grep1.dat:1754:43025:#define ISBLANK(c) ((c) == ' ' || (c) == '\t')
../inputs/grep1.dat:1755:43072:#endif
../inputs/grep1.dat:1756:43079:#ifdef isgraph
../inputs/grep1.dat:1757:43094:#define ISGRAPH(c) (isascii (c) && isgraph (c))
../inputs/grep1.dat:1758:43142:#else
../inputs/grep1.dat:1759:43148:#define ISGRAPH(c) (isascii (c) && isprint (c) && !isspace (c))
../inputs/grep1.dat:1760:43212:#endif
../inputs/grep1.dat:1761:43219:
../inputs/grep1.dat:1762:43220:#define ISPRINT(c) (isascii (c) && isprint (c))
../inputs/grep1.dat:1763:43268:#define ISDIGIT(c) (isascii (c) && isdigit (c))
../inputs/grep1.dat:1764:43316:#define ISALNUM(c) (isascii (c) && isalnum (c))
../inputs/grep1.dat:1765:43364:#define ISALPHA(c) (isascii (c) && isalpha (c))
../inputs/grep1.dat:1766:43412:#define ISCNTRL(c) (isascii (c) && iscntrl (c))
../inputs/grep1.dat:1767:43460:#define ISLOWER(c) (isascii (c) && islower (c))
../inputs/grep1.dat:1768:43508:#define ISPUNCT(c) (isascii (c) && ispunct (c))
../inputs/grep1.dat:1769:43556:#define ISSPACE(c) (isascii (c) && isspace (c))
../inputs/grep1.dat:1770:43604:#define ISUPPER(c) (isascii (c) && isupper (c))
../inputs/grep1.dat:1771:43652:#define ISXDIGIT(c) (isascii (c) && isxdigit (c))
../inputs/grep1.dat:1772:43702:
../inputs/grep1.dat:1773:43703:#ifndef NULL
../inputs/grep1.dat:1774:43716:#define NULL 0
../inputs/grep1.dat:1775:43731:#endif
../inputs/grep1.dat:1776:43738:
../inputs/grep1.dat:1777:43739:/* We remove any previous definition of `SIGN_EXTEND_CHAR',
../inputs/grep1.dat:1778:43799:   since ours (we hope) works properly with all combinations of
../inputs/grep1.dat:1779:43863:   machines, compilers, `char' and `unsigned char' argument types.
../inputs/grep1.dat:1780:43930:   (Per Bothner suggested the basic approach.)  */
../inputs/grep1.dat:1781:43981:#undef SIGN_EXTEND_CHAR
../inputs/grep1.dat:1782:44005:#if __STDC__
../inputs/grep1.dat:1783:44018:#define SIGN_EXTEND_CHAR(c) ((signed char) (c))
../inputs/grep1.dat:1784:44066:#else  /* not __STDC__ */
../inputs/grep1.dat:1785:44092:/* As in Harbison and Steele.  */
../inputs/grep1.dat:1786:44126:#define SIGN_EXTEND_CHAR(c) ((((unsigned char) (c)) ^ 128) - 128)
../inputs/grep1.dat:1787:44192:#endif
../inputs/grep1.dat:1788:44199:
../inputs/grep1.dat:1789:44201:/* Should we use malloc or alloca?  If REGEX_MALLOC is not defined, we
../inputs/grep1.dat:1790:44272:   use `alloca' instead of `malloc'.  This is because using malloc in
../inputs/grep1.dat:1791:44342:   re_search* or re_match* could cause memory leaks when C-g is used in
../inputs/grep1.dat:1792:44414:   Emacs; also, malloc is slower and causes storage fragmentation.  On
../inputs/grep1.dat:1793:44485:   the other hand, malloc is more portable, and easier to debug.  
../inputs/grep1.dat:1794:44552:   
../inputs/grep1.dat:1795:44556:   Because we sometimes use alloca, some routines have to be macros,
../inputs/grep1.dat:1796:44625:   not functions -- `alloca'-allocated space disappears at the end of the
../inputs/grep1.dat:1797:44699:   function it is called in.  */
../inputs/grep1.dat:1798:44732:
../inputs/grep1.dat:1799:44733:#ifdef REGEX_MALLOC
../inputs/grep1.dat:1800:44753:
../inputs/grep1.dat:1801:44754:#define REGEX_ALLOCATE malloc
../inputs/grep1.dat:1802:44784:#define REGEX_REALLOCATE(source, osize, nsize) realloc (source, nsize)
../inputs/grep1.dat:1803:44855:
../inputs/grep1.dat:1804:44856:#else /* not REGEX_MALLOC  */
../inputs/grep1.dat:1805:44886:
../inputs/grep1.dat:1806:44887:/* Emacs already defines alloca, sometimes.  */
../inputs/grep1.dat:1807:44935:#ifndef alloca
../inputs/grep1.dat:1808:44950:
../inputs/grep1.dat:1809:44951:/* Make alloca work the best possible way.  */
../inputs/grep1.dat:1810:44998:#ifdef __GNUC__
../inputs/grep1.dat:1811:45014:#define alloca __builtin_alloca
../inputs/grep1.dat:1812:45046:#else /* not __GNUC__ */
../inputs/grep1.dat:1813:45071:#if HAVE_ALLOCA_H
../inputs/grep1.dat:1814:45089:#if flag_alloca==0
../inputs/grep1.dat:1816:45128:#define flag_alloca 1
../inputs/grep1.dat:1817:45150:#endif 
../inputs/grep1.dat:1818:45158:#else /* not __GNUC__ or HAVE_ALLOCA_H */
../inputs/grep1.dat:1819:45200:#ifndef _AIX /* Already did AIX, up at the top.  */
../inputs/grep1.dat:1820:45252:char *alloca ();
../inputs/grep1.dat:1821:45269:#endif /* not _AIX */
../inputs/grep1.dat:1822:45291:#endif /* not HAVE_ALLOCA_H */ 
../inputs/grep1.dat:1823:45323:#endif /* not __GNUC__ */
../inputs/grep1.dat:1824:45349:
../inputs/grep1.dat:1825:45350:#endif /* not alloca */
../inputs/grep1.dat:1826:45374:
../inputs/grep1.dat:1827:45375:#define REGEX_ALLOCATE alloca
../inputs/grep1.dat:1828:45405:
../inputs/grep1.dat:1829:45406:/* Assumes a `char *destination' variable.  */
../inputs/grep1.dat:1830:45453:#define REGEX_REALLOCATE(source, osize, nsize)				\
../inputs/grep1.dat:1831:45505:  (destination = (char *) alloca (nsize),				\
../inputs/grep1.dat:1832:45552:   bcopy (source, destination, osize),					\
../inputs/grep1.dat:1833:45597:   destination)
../inputs/grep1.dat:1834:45613:
../inputs/grep1.dat:1835:45614:#endif /* not REGEX_MALLOC */
../inputs/grep1.dat:1836:45644:
../inputs/grep1.dat:1837:45645:
../inputs/grep1.dat:1838:45646:/* True if `size1' is non-NULL and PTR is pointing anywhere inside
../inputs/grep1.dat:1839:45713:   `string1' or just past its end.  This works if PTR is NULL, which is
../inputs/grep1.dat:1840:45785:   a good thing.  */
../inputs/grep1.dat:1841:45806:#define FIRST_STRING_P(ptr) 					\
../inputs/grep1.dat:1842:45841:  (size1 && string1 <= (ptr) && (ptr) <= string1 + size1)
../inputs/grep1.dat:1843:45899:
../inputs/grep1.dat:1844:45900:/* (Re)Allocate N items of type T using malloc, or fail.  */
../inputs/grep1.dat:1845:45961:#define TALLOC(n, t) ((t *) malloc ((n) * sizeof (t)))
../inputs/grep1.dat:1846:46016:#define RETALLOC(addr, n, t) ((addr) = (t *) realloc (addr, (n) * sizeof (t)))
../inputs/grep1.dat:1847:46095:#define REGEX_TALLOC(n, t) ((t *) REGEX_ALLOCATE ((n) * sizeof (t)))
../inputs/grep1.dat:1848:46164:
../inputs/grep1.dat:1849:46165:#define BYTEWIDTH 8 /* In bits.  */
../inputs/grep1.dat:1850:46201:
../inputs/grep1.dat:1851:46202:#define STREQ(s1, s2) ((strcmp (s1, s2) == 0))
../inputs/grep1.dat:1852:46249:
../inputs/grep1.dat:1853:46250:#undef MAX               /****** added later *******/
../inputs/grep1.dat:1854:46304:#define MAX(a, b) ((a) > (b) ? (a) : (b))
../inputs/grep1.dat:1855:46346:#define MIN(a, b) ((a) < (b) ? (a) : (b))
../inputs/grep1.dat:1856:46388:
../inputs/grep1.dat:1857:46389:typedef char boolean;
../inputs/grep1.dat:1858:46411:#define false 0
../inputs/grep1.dat:1859:46427:#define true 1
../inputs/grep1.dat:1860:46442:
../inputs/grep1.dat:1861:46444:/* These are the command codes that appear in compiled regular
../inputs/grep1.dat:1862:46507:   expressions.  Some opcodes are followed by argument bytes.  A
../inputs/grep1.dat:1863:46572:   command code can specify any interpretation whatsoever for its
../inputs/grep1.dat:1864:46638:   arguments.  Zero bytes may appear in the compiled regular expression.
../inputs/grep1.dat:1865:46711:
../inputs/grep1.dat:1866:46712:   The value of `exactn' is needed in search.c (search_buffer) in Emacs.
../inputs/grep1.dat:1867:46785:   So regex.h defines a symbol `RE_EXACTN_VALUE' to be 1; the value of
../inputs/grep1.dat:1868:46856:   `exactn' we use here must also be 1.  */
../inputs/grep1.dat:1869:46900:
../inputs/grep1.dat:1870:46901:typedef enum
../inputs/grep1.dat:1871:46914:{
../inputs/grep1.dat:1872:46916:  no_op = 0,
../inputs/grep1.dat:1873:46929:
../inputs/grep1.dat:1874:46930:        /* Followed by one byte giving n, then by n literal bytes.  */
../inputs/grep1.dat:1875:47001:  exactn = 1,
../inputs/grep1.dat:1876:47015:
../inputs/grep1.dat:1877:47016:        /* Matches any (more or less) character.  */
../inputs/grep1.dat:1878:47069:  anychar,
../inputs/grep1.dat:1879:47080:
../inputs/grep1.dat:1880:47081:        /* Matches any one char belonging to specified set.  First
../inputs/grep1.dat:1881:47148:           following byte is number of bitmap bytes.  Then come bytes
../inputs/grep1.dat:1882:47218:           for a bitmap saying which chars are in.  Bits in each byte
../inputs/grep1.dat:1883:47288:           are ordered low-bit-first.  A character is in the set if its
../inputs/grep1.dat:1884:47360:           bit is 1.  A character too large to have a bit in the map is
../inputs/grep1.dat:1885:47432:           automatically not in the set.  */
../inputs/grep1.dat:1886:47477:  charset,
../inputs/grep1.dat:1887:47488:
../inputs/grep1.dat:1888:47489:        /* Same parameters as charset, but match any character that is
../inputs/grep1.dat:1889:47560:           not one of those specified.  */
../inputs/grep1.dat:1890:47603:  charset_not,
../inputs/grep1.dat:1891:47618:
../inputs/grep1.dat:1892:47619:        /* Start remembering the text that is matched, for storing in a
../inputs/grep1.dat:1893:47691:           register.  Followed by one byte with the register number, in
../inputs/grep1.dat:1894:47763:           the range 0 to one less than the pattern buffer's re_nsub
../inputs/grep1.dat:1895:47832:           field.  Then followed by one byte with the number of groups
../inputs/grep1.dat:1896:47903:           inner to this one.  (This last has to be part of the
../inputs/grep1.dat:1897:47967:           start_memory only because we need it in the on_failure_jump
../inputs/grep1.dat:1898:48038:           of re_match_2.)  */
../inputs/grep1.dat:1899:48069:  start_memory,
../inputs/grep1.dat:1900:48085:
../inputs/grep1.dat:1901:48086:        /* Stop remembering the text that is matched and store it in a
../inputs/grep1.dat:1902:48157:           memory register.  Followed by one byte with the register
../inputs/grep1.dat:1903:48225:           number, in the range 0 to one less than `re_nsub' in the
../inputs/grep1.dat:1904:48293:           pattern buffer, and one byte with the number of inner groups,
../inputs/grep1.dat:1905:48366:           just like `start_memory'.  (We need the number of inner
../inputs/grep1.dat:1906:48433:           groups here because we don't have any easy way of finding the
../inputs/grep1.dat:1907:48506:           corresponding start_memory when we're at a stop_memory.)  */
../inputs/grep1.dat:1908:48578:  stop_memory,
../inputs/grep1.dat:1909:48593:
../inputs/grep1.dat:1910:48594:        /* Match a duplicate of something remembered. Followed by one
../inputs/grep1.dat:1911:48664:           byte containing the register number.  */
../inputs/grep1.dat:1912:48716:  duplicate,
../inputs/grep1.dat:1913:48729:
../inputs/grep1.dat:1914:48730:        /* Fail unless at beginning of line.  */
../inputs/grep1.dat:1915:48779:  begline,
../inputs/grep1.dat:1916:48790:
../inputs/grep1.dat:1917:48791:        /* Fail unless at end of line.  */
../inputs/grep1.dat:1918:48834:  endline,
../inputs/grep1.dat:1919:48845:
../inputs/grep1.dat:1920:48846:        /* Succeeds if at beginning of buffer (if emacs) or at beginning
../inputs/grep1.dat:1921:48919:           of string to be matched (if not).  */
../inputs/grep1.dat:1922:48968:  begbuf,
../inputs/grep1.dat:1923:48978:
../inputs/grep1.dat:1924:48979:        /* Analogously, for end of buffer/string.  */
../inputs/grep1.dat:1925:49033:  endbuf,
../inputs/grep1.dat:1926:49043: 
../inputs/grep1.dat:1927:49045:        /* Followed by two byte relative address to which to jump.  */
../inputs/grep1.dat:1928:49116:  jump, 
../inputs/grep1.dat:1929:49125:
../inputs/grep1.dat:1930:49126:	/* Same as jump, but marks the end of an alternative.  */
../inputs/grep1.dat:1931:49185:  jump_past_alt,
../inputs/grep1.dat:1932:49202:
../inputs/grep1.dat:1933:49203:        /* Followed by two-byte relative address of place to resume at
../inputs/grep1.dat:1934:49274:           in case of failure.  */
../inputs/grep1.dat:1935:49309:  on_failure_jump,
../inputs/grep1.dat:1936:49328:	
../inputs/grep1.dat:1937:49330:        /* Like on_failure_jump, but pushes a placeholder instead of the
../inputs/grep1.dat:1938:49403:           current string position when executed.  */
../inputs/grep1.dat:1939:49457:  on_failure_keep_string_jump,
../inputs/grep1.dat:1940:49488:  
../inputs/grep1.dat:1941:49491:        /* Throw away latest failure point and then jump to following
../inputs/grep1.dat:1942:49561:           two-byte relative address.  */
../inputs/grep1.dat:1943:49603:  pop_failure_jump,
../inputs/grep1.dat:1944:49623:
../inputs/grep1.dat:1945:49624:        /* Change to pop_failure_jump if know won't have to backtrack to
../inputs/grep1.dat:1946:49697:           match; otherwise change to jump.  This is used to jump
../inputs/grep1.dat:1947:49763:           back to the beginning of a repeat.  If what follows this jump
../inputs/grep1.dat:1948:49836:           clearly won't match what the repeat does, such that we can be
../inputs/grep1.dat:1949:49909:           sure that there is no use backtracking out of repetitions
../inputs/grep1.dat:1950:49978:           already matched, then we change it to a pop_failure_jump.
../inputs/grep1.dat:1951:50047:           Followed by two-byte address.  */
../inputs/grep1.dat:1952:50092:  maybe_pop_jump,
../inputs/grep1.dat:1953:50110:
../inputs/grep1.dat:1954:50111:        /* Jump to following two-byte address, and push a dummy failure
../inputs/grep1.dat:1955:50183:           point. This failure point will be thrown away if an attempt
../inputs/grep1.dat:1956:50254:           is made to use it for a failure.  A `+' construct makes this
../inputs/grep1.dat:1957:50326:           before the first repeat.  Also used as an intermediary kind
../inputs/grep1.dat:1958:50397:           of jump when compiling an alternative.  */
../inputs/grep1.dat:1959:50451:  dummy_failure_jump,
../inputs/grep1.dat:1960:50473:
../inputs/grep1.dat:1961:50474:	/* Push a dummy failure point and continue.  Used at the end of
../inputs/grep1.dat:1962:50539:	   alternatives.  */
../inputs/grep1.dat:1963:50561:  push_dummy_failure,
../inputs/grep1.dat:1964:50583:
../inputs/grep1.dat:1965:50584:        /* Followed by two-byte relative address and two-byte number n.
../inputs/grep1.dat:1966:50656:           After matching N times, jump to the address upon failure.  */
../inputs/grep1.dat:1967:50729:  succeed_n,
../inputs/grep1.dat:1968:50742:
../inputs/grep1.dat:1969:50743:        /* Followed by two-byte relative address, and two-byte number n.
../inputs/grep1.dat:1970:50816:           Jump to the address N times, then fail.  */
../inputs/grep1.dat:1971:50871:  jump_n,
../inputs/grep1.dat:1972:50881:
../inputs/grep1.dat:1973:50882:        /* Set the following two-byte relative address to the
../inputs/grep1.dat:1975:51015:           bytes of number.  */
../inputs/grep1.dat:1976:51047:  set_number_at,
../inputs/grep1.dat:1977:51064:
../inputs/grep1.dat:1978:51065:  wordchar,	/* Matches any word-constituent character.  */
../inputs/grep1.dat:1979:51124:  notwordchar,	/* Matches any char that is not a word-constituent.  */
../inputs/grep1.dat:1980:51195:
../inputs/grep1.dat:1981:51196:  wordbeg,	/* Succeeds if at word beginning.  */
../inputs/grep1.dat:1982:51245:  wordend,	/* Succeeds if at word end.  */
../inputs/grep1.dat:1983:51288:
../inputs/grep1.dat:1984:51289:  wordbound,	/* Succeeds if at a word boundary.  */
../inputs/grep1.dat:1985:51341:  notwordbound	/* Succeeds if not at a word boundary.  */
../inputs/grep1.dat:1986:51399:
../inputs/grep1.dat:1987:51400:#ifdef emacs
../inputs/grep1.dat:1988:51413:  ,before_dot,	/* Succeeds if before point.  */
../inputs/grep1.dat:1989:51461:  at_dot,	/* Succeeds if at point.  */
../inputs/grep1.dat:1990:51500:  after_dot,	/* Succeeds if after point.  */
../inputs/grep1.dat:1991:51545:
../inputs/grep1.dat:1992:51546:	/* Matches any character whose syntax is specified.  Followed by
../inputs/grep1.dat:1993:51612:           a byte which contains a syntax code, e.g., Sword.  */
../inputs/grep1.dat:1994:51677:  syntaxspec,
../inputs/grep1.dat:1995:51691:
../inputs/grep1.dat:1996:51692:	/* Matches any character whose syntax is not that specified.  */
../inputs/grep1.dat:1997:51758:  notsyntaxspec
../inputs/grep1.dat:1998:51774:#endif /* emacs */
../inputs/grep1.dat:1999:51793:} re_opcode_t;
../inputs/grep1.dat:2000:51808:
../inputs/grep1.dat:2001:51810:/* Common operations on the compiled pattern.  */
../inputs/grep1.dat:2002:51860:
../inputs/grep1.dat:2003:51861:/* Store NUMBER in two contiguous bytes starting at DESTINATION.  */
../inputs/grep1.dat:2004:51930:
../inputs/grep1.dat:2005:51931:#define STORE_NUMBER(destination, number)				\
../inputs/grep1.dat:2006:51978:  do {									\
../inputs/grep1.dat:2007:51995:    (destination)[0] = (number) & 0377;					\
../inputs/grep1.dat:2008:52041:    (destination)[1] = (number) >> 8;					\
../inputs/grep1.dat:2009:52085:  } while (0)
../inputs/grep1.dat:2010:52099:
../inputs/grep1.dat:2011:52100:/* Same as STORE_NUMBER, except increment DESTINATION to
../inputs/grep1.dat:2012:52157:   the byte after where the number is stored.  Therefore, DESTINATION
../inputs/grep1.dat:2013:52227:   must be an lvalue.  */
../inputs/grep1.dat:2014:52253:
../inputs/grep1.dat:2015:52254:#define STORE_NUMBER_AND_INCR(destination, number)			\
../inputs/grep1.dat:2016:52309:  do {									\
../inputs/grep1.dat:2017:52326:    STORE_NUMBER (destination, number);					\
../inputs/grep1.dat:2018:52372:    (destination) += 2;							\
../inputs/grep1.dat:2019:52404:  } while (0)
../inputs/grep1.dat:2020:52418:
../inputs/grep1.dat:2021:52419:/* Put into DESTINATION a number stored in two contiguous bytes starting
../inputs/grep1.dat:2022:52492:   at SOURCE.  */
../inputs/grep1.dat:2023:52510:
../inputs/grep1.dat:2024:52511:#define EXTRACT_NUMBER(destination, source)				\
../inputs/grep1.dat:2025:52560:  do {									\
../inputs/grep1.dat:2026:52577:    (destination) = *(source) & 0377;					\
../inputs/grep1.dat:2027:52621:    (destination) += SIGN_EXTEND_CHAR (*((source) + 1)) << 8;		\
../inputs/grep1.dat:2028:52686:  } while (0)
../inputs/grep1.dat:2029:52700:
../inputs/grep1.dat:2030:52701:#ifdef DEBUG
../inputs/grep1.dat:2031:52714:static void
../inputs/grep1.dat:2032:52726:extract_number (dest, source)
../inputs/grep1.dat:2033:52756:    int *dest;
../inputs/grep1.dat:2034:52771:    unsigned char *source;
../inputs/grep1.dat:2035:52798:{
../inputs/grep1.dat:2036:52800:  int temp = SIGN_EXTEND_CHAR (*(source + 1)); 
../inputs/grep1.dat:2037:52848:  *dest = *source & 0377;
../inputs/grep1.dat:2038:52874:  *dest += temp << 8;
../inputs/grep1.dat:2039:52896:}
../inputs/grep1.dat:2040:52898:
../inputs/grep1.dat:2041:52899:#ifndef EXTRACT_MACROS /* To debug the macros.  */
../inputs/grep1.dat:2042:52950:#undef EXTRACT_NUMBER
../inputs/grep1.dat:2043:52972:#define EXTRACT_NUMBER(dest, src) extract_number (&dest, src)
../inputs/grep1.dat:2044:53034:#endif /* not EXTRACT_MACROS */
../inputs/grep1.dat:2045:53066:
../inputs/grep1.dat:2046:53067:#endif /* DEBUG */
../inputs/grep1.dat:2047:53086:
../inputs/grep1.dat:2048:53087:/* Same as EXTRACT_NUMBER, except increment SOURCE to after the number.
../inputs/grep1.dat:2049:53159:   SOURCE must be an lvalue.  */
../inputs/grep1.dat:2050:53192:
../inputs/grep1.dat:2051:53193:#define EXTRACT_NUMBER_AND_INCR(destination, source)			\
../inputs/grep1.dat:2052:53250:  do {									\
../inputs/grep1.dat:2053:53267:    EXTRACT_NUMBER (destination, source);				\
../inputs/grep1.dat:2054:53314:    (source) += 2; 							\
../inputs/grep1.dat:2055:53342:  } while (0)
../inputs/grep1.dat:2056:53356:
../inputs/grep1.dat:2057:53357:#ifdef DEBUG
../inputs/grep1.dat:2058:53370:static void
../inputs/grep1.dat:2059:53382:extract_number_and_incr (destination, source)
../inputs/grep1.dat:2060:53428:    int *destination;
../inputs/grep1.dat:2061:53450:    unsigned char **source;
../inputs/grep1.dat:2062:53478:{ 
../inputs/grep1.dat:2063:53481:  extract_number (destination, *source);
../inputs/grep1.dat:2064:53522:  *source += 2;
../inputs/grep1.dat:2065:53538:}
../inputs/grep1.dat:2066:53540:
../inputs/grep1.dat:2067:53541:#ifndef EXTRACT_MACROS
../inputs/grep1.dat:2068:53564:#undef EXTRACT_NUMBER_AND_INCR
../inputs/grep1.dat:2069:53595:#define EXTRACT_NUMBER_AND_INCR(dest, src) \
../inputs/grep1.dat:2070:53640:  extract_number_and_incr (&dest, &src)
../inputs/grep1.dat:2071:53680:#endif /* not EXTRACT_MACROS */
../inputs/grep1.dat:2072:53712:
../inputs/grep1.dat:2073:53713:#endif /* DEBUG */
../inputs/grep1.dat:2074:53732:
../inputs/grep1.dat:2075:53734:/* If DEBUG is defined, Regex prints many voluminous messages about what
../inputs/grep1.dat:2076:53807:   it is doing (if the variable `debug' is nonzero).  If linked with the
../inputs/grep1.dat:2077:53880:   main program in `iregex.c', you can enter patterns and strings
../inputs/grep1.dat:2078:53946:   interactively.  And if linked with the main program in `main.c' and
../inputs/grep1.dat:2079:54017:   the other test files, you can run the already-written tests.  */
../inputs/grep1.dat:2080:54085:
../inputs/grep1.dat:2081:54086:#ifdef DEBUG
../inputs/grep1.dat:2082:54099:
../inputs/grep1.dat:2083:54100:/* We use standard I/O for debugging.  */
../inputs/grep1.dat:2085:54165:
../inputs/grep1.dat:2086:54166:/* It is useful to test things that ``must'' be true when debugging.  */
../inputs/grep1.dat:2088:54259:
../inputs/grep1.dat:2089:54260:static int debug = 0;
../inputs/grep1.dat:2090:54282:
../inputs/grep1.dat:2091:54283:#define DEBUG_STATEMENT(e) e
../inputs/grep1.dat:2092:54312:#define DEBUG_PRINT1(x) if (debug) printf (x)
../inputs/grep1.dat:2093:54358:#define DEBUG_PRINT2(x1, x2) if (debug) printf (x1, x2)
../inputs/grep1.dat:2094:54414:#define DEBUG_PRINT3(x1, x2, x3) if (debug) printf (x1, x2, x3)
../inputs/grep1.dat:2095:54478:#define DEBUG_PRINT4(x1, x2, x3, x4) if (debug) printf (x1, x2, x3, x4)
../inputs/grep1.dat:2096:54550:#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e) 				\
../inputs/grep1.dat:2097:54602:  if (debug) print_partial_compiled_pattern (s, e)
../inputs/grep1.dat:2098:54653:#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)			\
../inputs/grep1.dat:2099:54712:  if (debug) print_double_string (w, s1, sz1, s2, sz2)
../inputs/grep1.dat:2100:54767:
../inputs/grep1.dat:2101:54768:
../inputs/grep1.dat:2102:54769:extern void printchar ();
../inputs/grep1.dat:2103:54795:
../inputs/grep1.dat:2104:54796:/* Print the fastmap in human-readable form.  */
../inputs/grep1.dat:2105:54845:
../inputs/grep1.dat:2106:54846:void
../inputs/grep1.dat:2107:54851:print_fastmap (fastmap)
../inputs/grep1.dat:2108:54875:    char *fastmap;
../inputs/grep1.dat:2109:54894:{
../inputs/grep1.dat:2110:54896:  unsigned was_a_range = 0;
../inputs/grep1.dat:2111:54924:  unsigned i = 0;  
../inputs/grep1.dat:2112:54944:  
../inputs/grep1.dat:2113:54947:  while (i < (1 << BYTEWIDTH))
../inputs/grep1.dat:2114:54978:    {
../inputs/grep1.dat:2115:54984:      if (fastmap[i++])
../inputs/grep1.dat:2116:55008:	{
../inputs/grep1.dat:2117:55011:	  was_a_range = 0;
../inputs/grep1.dat:2118:55031:          printchar (i - 1);
../inputs/grep1.dat:2119:55060:          while (i < (1 << BYTEWIDTH)  &&  fastmap[i])
../inputs/grep1.dat:2120:55115:            {
../inputs/grep1.dat:2121:55129:              was_a_range = 1;
../inputs/grep1.dat:2122:55160:              i++;
../inputs/grep1.dat:2123:55179:            }
../inputs/grep1.dat:2124:55193:	  if (was_a_range)
../inputs/grep1.dat:2125:55213:            {
../inputs/grep1.dat:2126:55227:              printf ("-");
../inputs/grep1.dat:2127:55255:              printchar (i - 1);
../inputs/grep1.dat:2128:55288:            }
../inputs/grep1.dat:2129:55302:        }
../inputs/grep1.dat:2130:55312:    }
../inputs/grep1.dat:2131:55318:  putchar ('\n'); 
../inputs/grep1.dat:2132:55337:}
../inputs/grep1.dat:2133:55339:
../inputs/grep1.dat:2134:55340:
../inputs/grep1.dat:2135:55341:/* Print a compiled pattern string in human-readable form, starting at
../inputs/grep1.dat:2136:55412:   the START pointer into it and ending just before the pointer END.  */
../inputs/grep1.dat:2137:55485:
../inputs/grep1.dat:2138:55486:void
../inputs/grep1.dat:2139:55491:print_partial_compiled_pattern (start, end)
../inputs/grep1.dat:2140:55535:    unsigned char *start;
../inputs/grep1.dat:2141:55561:    unsigned char *end;
../inputs/grep1.dat:2142:55585:{
../inputs/grep1.dat:2143:55587:  int mcnt, mcnt2;
../inputs/grep1.dat:2144:55606:  unsigned char *p = start;
../inputs/grep1.dat:2145:55634:  unsigned char *pend = end;
../inputs/grep1.dat:2146:55663:
../inputs/grep1.dat:2147:55664:  if (start == NULL)
../inputs/grep1.dat:2148:55685:    {
../inputs/grep1.dat:2149:55691:      printf ("(null)\n");
../inputs/grep1.dat:2150:55718:      return;
../inputs/grep1.dat:2151:55732:    }
../inputs/grep1.dat:2152:55738:    
../inputs/grep1.dat:2153:55743:  /* Loop over pattern commands.  */
../inputs/grep1.dat:2154:55780:  while (p < pend)
../inputs/grep1.dat:2155:55799:    {
../inputs/grep1.dat:2156:55805:      printf ("%d:\t", p - start);
../inputs/grep1.dat:2157:55840:
../inputs/grep1.dat:2158:55841:      switch ((re_opcode_t) *p++)
../inputs/grep1.dat:2159:55875:	{
../inputs/grep1.dat:2160:55878:        case no_op:
../inputs/grep1.dat:2161:55898:          printf ("/no_op");
../inputs/grep1.dat:2162:55927:          break;
../inputs/grep1.dat:2163:55944:
../inputs/grep1.dat:2164:55945:	case exactn:
../inputs/grep1.dat:2165:55959:	  mcnt = *p++;
../inputs/grep1.dat:2166:55975:          printf ("/exactn/%d", mcnt);
../inputs/grep1.dat:2167:56014:          do
../inputs/grep1.dat:2168:56027:	    {
../inputs/grep1.dat:2169:56034:              putchar ('/');
../inputs/grep1.dat:2170:56063:	      printchar (*p++);
../inputs/grep1.dat:2171:56088:            }
../inputs/grep1.dat:2172:56102:          while (--mcnt);
../inputs/grep1.dat:2173:56128:          break;
../inputs/grep1.dat:2174:56145:
../inputs/grep1.dat:2175:56146:	case start_memory:
../inputs/grep1.dat:2176:56166:          mcnt = *p++;
../inputs/grep1.dat:2177:56189:          printf ("/start_memory/%d/%d", mcnt, *p++);
../inputs/grep1.dat:2178:56243:          break;
../inputs/grep1.dat:2179:56260:
../inputs/grep1.dat:2180:56261:	case stop_memory:
../inputs/grep1.dat:2181:56280:          mcnt = *p++;
../inputs/grep1.dat:2182:56303:	  printf ("/stop_memory/%d/%d", mcnt, *p++);
../inputs/grep1.dat:2183:56349:          break;
../inputs/grep1.dat:2184:56366:
../inputs/grep1.dat:2185:56367:	case duplicate:
../inputs/grep1.dat:2186:56384:	  printf ("/duplicate/%d", *p++);
../inputs/grep1.dat:2187:56419:	  break;
../inputs/grep1.dat:2188:56429:
../inputs/grep1.dat:2189:56430:	case anychar:
../inputs/grep1.dat:2190:56445:	  printf ("/anychar");
../inputs/grep1.dat:2191:56469:	  break;
../inputs/grep1.dat:2192:56479:
../inputs/grep1.dat:2193:56480:	case charset:
../inputs/grep1.dat:2194:56495:        case charset_not:
../inputs/grep1.dat:2195:56521:          {
../inputs/grep1.dat:2196:56533:            register int c, last = -100;
../inputs/grep1.dat:2197:56574:	    register int in_range = 0;
../inputs/grep1.dat:2198:56606:
../inputs/grep1.dat:2199:56607:	    printf ("/charset [%s",
../inputs/grep1.dat:2200:56636:	            (re_opcode_t) *(p - 1) == charset_not ? "^" : "");
../inputs/grep1.dat:2201:56700:            
../inputs/grep1.dat:2202:56713:            assert (p + *p < pend);
../inputs/grep1.dat:2203:56749:
../inputs/grep1.dat:2204:56750:            for (c = 0; c < 256; c++)
../inputs/grep1.dat:2205:56788:	      if (c / 8 < *p
../inputs/grep1.dat:2206:56810:		  && (p[1 + (c/8)] & (1 << (c % 8))))
../inputs/grep1.dat:2207:56850:		{
../inputs/grep1.dat:2208:56854:		  /* Are we starting a range?  */
../inputs/grep1.dat:2209:56890:		  if (last + 1 == c && ! in_range)
../inputs/grep1.dat:2210:56927:		    {
../inputs/grep1.dat:2211:56935:		      putchar ('-');
../inputs/grep1.dat:2212:56958:		      in_range = 1;
../inputs/grep1.dat:2213:56980:		    }
../inputs/grep1.dat:2214:56988:		  /* Have we broken a range?  */
../inputs/grep1.dat:2215:57023:		  else if (last + 1 != c && in_range)
../inputs/grep1.dat:2216:57063:              {
../inputs/grep1.dat:2217:57079:		      printchar (last);
../inputs/grep1.dat:2218:57105:		      in_range = 0;
../inputs/grep1.dat:2219:57127:		    }
../inputs/grep1.dat:2220:57135:                
../inputs/grep1.dat:2221:57152:		  if (! in_range)
../inputs/grep1.dat:2222:57172:		    printchar (c);
../inputs/grep1.dat:2223:57193:
../inputs/grep1.dat:2224:57194:		  last = c;
../inputs/grep1.dat:2225:57208:              }
../inputs/grep1.dat:2226:57224:
../inputs/grep1.dat:2227:57225:	    if (in_range)
../inputs/grep1.dat:2228:57244:	      printchar (last);
../inputs/grep1.dat:2229:57269:
../inputs/grep1.dat:2230:57270:	    putchar (']');
../inputs/grep1.dat:2231:57290:
../inputs/grep1.dat:2232:57291:	    p += 1 + *p;
../inputs/grep1.dat:2233:57309:	  }
../inputs/grep1.dat:2234:57314:	  break;
../inputs/grep1.dat:2235:57324:
../inputs/grep1.dat:2236:57325:	case begline:
../inputs/grep1.dat:2237:57340:	  printf ("/begline");
../inputs/grep1.dat:2238:57364:          break;
../inputs/grep1.dat:2239:57381:
../inputs/grep1.dat:2240:57382:	case endline:
../inputs/grep1.dat:2241:57397:          printf ("/endline");
../inputs/grep1.dat:2242:57428:          break;
../inputs/grep1.dat:2243:57445:
../inputs/grep1.dat:2244:57446:	case on_failure_jump:
../inputs/grep1.dat:2245:57469:          extract_number_and_incr (&mcnt, &p);
../inputs/grep1.dat:2246:57516:  	  printf ("/on_failure_jump to %d", p + mcnt - start);
../inputs/grep1.dat:2247:57574:          break;
../inputs/grep1.dat:2248:57591:
../inputs/grep1.dat:2249:57592:	case on_failure_keep_string_jump:
../inputs/grep1.dat:2250:57627:          extract_number_and_incr (&mcnt, &p);
../inputs/grep1.dat:2251:57674:  	  printf ("/on_failure_keep_string_jump to %d", p + mcnt - start);
../inputs/grep1.dat:2252:57744:          break;
../inputs/grep1.dat:2253:57761:
../inputs/grep1.dat:2254:57762:	case dummy_failure_jump:
../inputs/grep1.dat:2255:57788:          extract_number_and_incr (&mcnt, &p);
../inputs/grep1.dat:2256:57835:  	  printf ("/dummy_failure_jump to %d", p + mcnt - start);
../inputs/grep1.dat:2257:57896:          break;
../inputs/grep1.dat:2258:57913:
../inputs/grep1.dat:2259:57914:	case push_dummy_failure:
../inputs/grep1.dat:2260:57940:          printf ("/push_dummy_failure");
../inputs/grep1.dat:2261:57982:          break;
../inputs/grep1.dat:2262:57999:          
../inputs/grep1.dat:2263:58010:        case maybe_pop_jump:
../inputs/grep1.dat:2264:58039:          extract_number_and_incr (&mcnt, &p);
../inputs/grep1.dat:2265:58086:  	  printf ("/maybe_pop_jump to %d", p + mcnt - start);
../inputs/grep1.dat:2266:58143:	  break;
../inputs/grep1.dat:2267:58153:
../inputs/grep1.dat:2268:58154:        case pop_failure_jump:
../inputs/grep1.dat:2269:58185:	  extract_number_and_incr (&mcnt, &p);
../inputs/grep1.dat:2270:58225:  	  printf ("/pop_failure_jump to %d", p + mcnt - start);
../inputs/grep1.dat:2271:58284:	  break;          
../inputs/grep1.dat:2272:58304:          
../inputs/grep1.dat:2273:58315:        case jump_past_alt:
../inputs/grep1.dat:2274:58343:	  extract_number_and_incr (&mcnt, &p);
../inputs/grep1.dat:2275:58383:  	  printf ("/jump_past_alt to %d", p + mcnt - start);
../inputs/grep1.dat:2276:58439:	  break;          
../inputs/grep1.dat:2277:58459:          
../inputs/grep1.dat:2278:58470:        case jump:
../inputs/grep1.dat:2279:58489:	  extract_number_and_incr (&mcnt, &p);
../inputs/grep1.dat:2280:58529:  	  printf ("/jump to %d", p + mcnt - start);
../inputs/grep1.dat:2281:58576:	  break;
../inputs/grep1.dat:2282:58586:
../inputs/grep1.dat:2283:58587:        case succeed_n: 
../inputs/grep1.dat:2284:58612:          extract_number_and_incr (&mcnt, &p);
../inputs/grep1.dat:2285:58659:          extract_number_and_incr (&mcnt2, &p);
../inputs/grep1.dat:2286:58707:	  printf ("/succeed_n to %d, %d times", p + mcnt - start, mcnt2);
../inputs/grep1.dat:2287:58774:          break;
../inputs/grep1.dat:2288:58791:        
../inputs/grep1.dat:2289:58800:        case jump_n: 
../inputs/grep1.dat:2290:58822:          extract_number_and_incr (&mcnt, &p);
../inputs/grep1.dat:2291:58869:          extract_number_and_incr (&mcnt2, &p);
../inputs/grep1.dat:2292:58917:	  printf ("/jump_n to %d, %d times", p + mcnt - start, mcnt2);
../inputs/grep1.dat:2293:58981:          break;
../inputs/grep1.dat:2294:58998:        
../inputs/grep1.dat:2295:59007:        case set_number_at: 
../inputs/grep1.dat:2296:59036:          extract_number_and_incr (&mcnt, &p);
../inputs/grep1.dat:2297:59083:          extract_number_and_incr (&mcnt2, &p);
../inputs/grep1.dat:2298:59131:	  printf ("/set_number_at location %d to %d", p + mcnt - start, mcnt2);
../inputs/grep1.dat:2299:59204:          break;
../inputs/grep1.dat:2300:59221:        
../inputs/grep1.dat:2301:59230:        case wordbound:
../inputs/grep1.dat:2302:59254:	  printf ("/wordbound");
../inputs/grep1.dat:2303:59280:	  break;
../inputs/grep1.dat:2304:59290:
../inputs/grep1.dat:2305:59291:	case notwordbound:
../inputs/grep1.dat:2306:59311:	  printf ("/notwordbound");
../inputs/grep1.dat:2307:59340:          break;
../inputs/grep1.dat:2308:59357:
../inputs/grep1.dat:2309:59358:	case wordbeg:
../inputs/grep1.dat:2310:59373:	  printf ("/wordbeg");
../inputs/grep1.dat:2311:59397:	  break;
../inputs/grep1.dat:2312:59407:          
../inputs/grep1.dat:2313:59418:	case wordend:
../inputs/grep1.dat:2314:59433:	  printf ("/wordend");
../inputs/grep1.dat:2315:59457:          
../inputs/grep1.dat:2316:59468:#ifdef emacs
../inputs/grep1.dat:2317:59481:	case before_dot:
../inputs/grep1.dat:2318:59499:	  printf ("/before_dot");
../inputs/grep1.dat:2319:59526:          break;
../inputs/grep1.dat:2320:59543:
../inputs/grep1.dat:2321:59544:	case at_dot:
../inputs/grep1.dat:2322:59558:	  printf ("/at_dot");
../inputs/grep1.dat:2323:59581:          break;
../inputs/grep1.dat:2324:59598:
../inputs/grep1.dat:2325:59599:	case after_dot:
../inputs/grep1.dat:2326:59616:	  printf ("/after_dot");
../inputs/grep1.dat:2327:59642:          break;
../inputs/grep1.dat:2328:59659:
../inputs/grep1.dat:2329:59660:	case syntaxspec:
../inputs/grep1.dat:2330:59678:          printf ("/syntaxspec");
../inputs/grep1.dat:2331:59712:	  mcnt = *p++;
../inputs/grep1.dat:2332:59728:	  printf ("/%d", mcnt);
../inputs/grep1.dat:2333:59753:          break;
../inputs/grep1.dat:2334:59770:	  
../inputs/grep1.dat:2335:59774:	case notsyntaxspec:
../inputs/grep1.dat:2336:59795:          printf ("/notsyntaxspec");
../inputs/grep1.dat:2337:59832:	  mcnt = *p++;
../inputs/grep1.dat:2338:59848:	  printf ("/%d", mcnt);
../inputs/grep1.dat:2339:59873:	  break;
../inputs/grep1.dat:2340:59883:#endif /* emacs */
../inputs/grep1.dat:2341:59902:
../inputs/grep1.dat:2342:59903:	case wordchar:
../inputs/grep1.dat:2343:59919:	  printf ("/wordchar");
../inputs/grep1.dat:2344:59944:          break;
../inputs/grep1.dat:2345:59961:	  
../inputs/grep1.dat:2346:59965:	case notwordchar:
../inputs/grep1.dat:2347:59984:	  printf ("/notwordchar");
../inputs/grep1.dat:2348:60012:          break;
../inputs/grep1.dat:2349:60029:
../inputs/grep1.dat:2350:60030:	case begbuf:
../inputs/grep1.dat:2351:60044:	  printf ("/begbuf");
../inputs/grep1.dat:2352:60067:          break;
../inputs/grep1.dat:2353:60084:
../inputs/grep1.dat:2354:60085:	case endbuf:
../inputs/grep1.dat:2355:60099:	  printf ("/endbuf");
../inputs/grep1.dat:2356:60122:          break;
../inputs/grep1.dat:2357:60139:
../inputs/grep1.dat:2358:60140:        default:
../inputs/grep1.dat:2359:60157:          printf ("?%d", *(p-1));
../inputs/grep1.dat:2360:60191:	}
../inputs/grep1.dat:2361:60194:
../inputs/grep1.dat:2362:60195:      putchar ('\n');
../inputs/grep1.dat:2363:60217:    }
../inputs/grep1.dat:2364:60223:
../inputs/grep1.dat:2365:60224:  printf ("%d:\tend of pattern.\n", p - start);
../inputs/grep1.dat:2366:60272:}
../inputs/grep1.dat:2367:60274:
../inputs/grep1.dat:2368:60275:
../inputs/grep1.dat:2369:60276:void
../inputs/grep1.dat:2370:60281:print_compiled_pattern (bufp)
../inputs/grep1.dat:2371:60311:    struct re_pattern_buffer *bufp;
../inputs/grep1.dat:2372:60347:{
../inputs/grep1.dat:2373:60349:  unsigned char *buffer = bufp->buffer;
../inputs/grep1.dat:2374:60389:
../inputs/grep1.dat:2375:60390:  print_partial_compiled_pattern (buffer, buffer + bufp->used);
../inputs/grep1.dat:2376:60454:  printf ("%d bytes used/%d bytes allocated.\n", bufp->used, bufp->allocated);
../inputs/grep1.dat:2377:60533:
../inputs/grep1.dat:2378:60534:  if (bufp->fastmap_accurate && bufp->fastmap)
../inputs/grep1.dat:2379:60581:    {
../inputs/grep1.dat:2380:60587:      printf ("fastmap: ");
../inputs/grep1.dat:2381:60615:      print_fastmap (bufp->fastmap);
../inputs/grep1.dat:2382:60652:    }
../inputs/grep1.dat:2383:60658:
../inputs/grep1.dat:2384:60659:  printf ("re_nsub: %d\t", bufp->re_nsub);
../inputs/grep1.dat:2385:60702:  printf ("regs_alloc: %d\t", bufp->regs_allocated);
../inputs/grep1.dat:2386:60755:  printf ("can_be_null: %d\t", bufp->can_be_null);
../inputs/grep1.dat:2387:60806:  printf ("newline_anchor: %d\n", bufp->newline_anchor);
../inputs/grep1.dat:2388:60863:  printf ("no_sub: %d\t", bufp->no_sub);
../inputs/grep1.dat:2389:60904:  printf ("not_bol: %d\t", bufp->not_bol);
../inputs/grep1.dat:2390:60947:  printf ("not_eol: %d\t", bufp->not_eol);
../inputs/grep1.dat:2391:60990:  printf ("syntax: %d\n", bufp->syntax);
../inputs/grep1.dat:2392:61031:  /* Perhaps we should print the translate table?  */
../inputs/grep1.dat:2393:61085:}
../inputs/grep1.dat:2394:61087:
../inputs/grep1.dat:2395:61088:
../inputs/grep1.dat:2396:61089:void
../inputs/grep1.dat:2397:61094:print_double_string (where, string1, size1, string2, size2)
../inputs/grep1.dat:2398:61154:    const char *where;
../inputs/grep1.dat:2399:61177:    const char *string1;
../inputs/grep1.dat:2400:61202:    const char *string2;
../inputs/grep1.dat:2401:61227:    int size1;
../inputs/grep1.dat:2402:61242:    int size2;
../inputs/grep1.dat:2403:61257:{
../inputs/grep1.dat:2404:61259:  unsigned this_char;
../inputs/grep1.dat:2405:61281:  
../inputs/grep1.dat:2406:61284:  if (where == NULL)
../inputs/grep1.dat:2407:61305:    printf ("(null)");
../inputs/grep1.dat:2408:61328:  else
../inputs/grep1.dat:2409:61335:    {
../inputs/grep1.dat:2410:61341:      if (FIRST_STRING_P (where))
../inputs/grep1.dat:2411:61375:        {
../inputs/grep1.dat:2412:61385:          for (this_char = where - string1; this_char < size1; this_char++)
../inputs/grep1.dat:2413:61461:            printchar (string1[this_char]);
../inputs/grep1.dat:2414:61505:
../inputs/grep1.dat:2415:61506:          where = string2;    
../inputs/grep1.dat:2416:61537:        }
../inputs/grep1.dat:2417:61547:
../inputs/grep1.dat:2418:61548:      for (this_char = where - string2; this_char < size2; this_char++)
../inputs/grep1.dat:2419:61620:        printchar (string2[this_char]);
../inputs/grep1.dat:2420:61660:    }
../inputs/grep1.dat:2421:61666:}
../inputs/grep1.dat:2422:61668:
../inputs/grep1.dat:2423:61669:#else /* not DEBUG */
../inputs/grep1.dat:2424:61691:
../inputs/grep1.dat:2425:61692:#undef assert
../inputs/grep1.dat:2426:61706:#define assert(e)
../inputs/grep1.dat:2427:61724:
../inputs/grep1.dat:2428:61725:#define DEBUG_STATEMENT(e)
../inputs/grep1.dat:2429:61752:#define DEBUG_PRINT1(x)
../inputs/grep1.dat:2430:61776:#define DEBUG_PRINT2(x1, x2)
../inputs/grep1.dat:2431:61805:#define DEBUG_PRINT3(x1, x2, x3)
../inputs/grep1.dat:2432:61838:#define DEBUG_PRINT4(x1, x2, x3, x4)
../inputs/grep1.dat:2433:61875:#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e)
../inputs/grep1.dat:2434:61921:#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)
../inputs/grep1.dat:2435:61976:
../inputs/grep1.dat:2436:61977:#endif /* not DEBUG */
../inputs/grep1.dat:2437:62000:
../inputs/grep1.dat:2438:62002:/* Set by `re_set_syntax' to the current regexp syntax to recognize.  Can
../inputs/grep1.dat:2439:62076:   also be assigned to arbitrarily: each pattern buffer stores its own
../inputs/grep1.dat:2440:62147:   syntax, so it can be changed between regex compilations.  */
../inputs/grep1.dat:2441:62211:reg_syntax_t re_syntax_options = RE_SYNTAX_EMACS;
../inputs/grep1.dat:2442:62261:
../inputs/grep1.dat:2443:62262:
../inputs/grep1.dat:2444:62263:/* Specify the precise syntax of regexps for compilation.  This provides
../inputs/grep1.dat:2445:62336:   for compatibility for various utilities which historically have
../inputs/grep1.dat:2446:62403:   different, incompatible syntaxes.
../inputs/grep1.dat:2447:62440:
../inputs/grep1.dat:2448:62441:   The argument SYNTAX is a bit mask comprised of the various bits
../inputs/grep1.dat:2449:62508:   defined in regex.h.  We return the old syntax.  */
../inputs/grep1.dat:2450:62562:
../inputs/grep1.dat:2451:62563:reg_syntax_t
../inputs/grep1.dat:2452:62576:re_set_syntax (syntax)
../inputs/grep1.dat:2453:62599:    reg_syntax_t syntax;
../inputs/grep1.dat:2454:62624:{
../inputs/grep1.dat:2455:62626:  reg_syntax_t ret = re_syntax_options;
../inputs/grep1.dat:2456:62666:  
../inputs/grep1.dat:2457:62669:  re_syntax_options = syntax;
../inputs/grep1.dat:2458:62699:  return ret;
../inputs/grep1.dat:2459:62713:}
../inputs/grep1.dat:2460:62715:
../inputs/grep1.dat:2461:62717:/* This table gives an error message for each of the error codes listed
../inputs/grep1.dat:2462:62789:   in regex.h.  Obviously the order here has to be same as there.  */
../inputs/grep1.dat:2463:62859:
../inputs/grep1.dat:2464:62860:static const char *re_error_msg[] =
../inputs/grep1.dat:2465:62896:  { NULL,					/* REG_NOERROR */
../inputs/grep1.dat:2466:62928:    "No match",					/* REG_NOMATCH */
../inputs/grep1.dat:2467:62966:    "Invalid regular expression",		/* REG_BADPAT */
../inputs/grep1.dat:2468:63018:    "Invalid collation character",		/* REG_ECOLLATE */
../inputs/grep1.dat:2469:63073:    "Invalid character class name",		/* REG_ECTYPE */
../inputs/grep1.dat:2470:63127:    "Trailing backslash",			/* REG_EESCAPE */
../inputs/grep1.dat:2471:63173:    "Invalid back reference",			/* REG_ESUBREG */
../inputs/grep1.dat:2472:63223:    "Unmatched [ or [^",			/* REG_EBRACK */
../inputs/grep1.dat:2473:63267:    "Unmatched ( or \\(",			/* REG_EPAREN */
../inputs/grep1.dat:2474:63312:    "Unmatched \\{",				/* REG_EBRACE */
../inputs/grep1.dat:2475:63353:    "Invalid content of \\{\\}",		/* REG_BADBR */
../inputs/grep1.dat:2476:63403:    "Invalid range end",			/* REG_ERANGE */
../inputs/grep1.dat:2477:63447:    "Memory exhausted",				/* REG_ESPACE */
../inputs/grep1.dat:2478:63491:    "Invalid preceding regular expression",	/* REG_BADRPT */
../inputs/grep1.dat:2479:63552:    "Premature end of regular expression",	/* REG_EEND */
../inputs/grep1.dat:2480:63610:    "Regular expression too big",		/* REG_ESIZE */
../inputs/grep1.dat:2481:63661:    "Unmatched ) or \\)",			/* REG_ERPAREN */
../inputs/grep1.dat:2482:63707:  };
../inputs/grep1.dat:2483:63712:
../inputs/grep1.dat:2484:63714:/* Subroutine declarations and macros for regex_compile.  */
../inputs/grep1.dat:2485:63775:
../inputs/grep1.dat:2486:63776:static void store_op1 (), store_op2 ();
../inputs/grep1.dat:2487:63816:static void insert_op1 (), insert_op2 ();
../inputs/grep1.dat:2488:63858:static boolean at_begline_loc_p (), at_endline_loc_p ();
../inputs/grep1.dat:2489:63915:static boolean group_in_compile_stack ();
../inputs/grep1.dat:2490:63957:static reg_errcode_t compile_range ();
../inputs/grep1.dat:2491:63996:
../inputs/grep1.dat:2492:63997:/* Fetch the next character in the uncompiled pattern---translating it 
../inputs/grep1.dat:2493:64069:   if necessary.  Also cast from a signed character in the constant
../inputs/grep1.dat:2494:64137:   string passed to us by the user to an unsigned char that we can use
../inputs/grep1.dat:2495:64208:   as an array index (in, e.g., `translate').  */
../inputs/grep1.dat:2496:64258:#define PATFETCH(c)							\
../inputs/grep1.dat:2497:64286:  do {if (p == pend) return REG_EEND;					\
../inputs/grep1.dat:2498:64330:    c = (unsigned char) *p++;						\
../inputs/grep1.dat:2499:64367:    if (translate) c = translate[c]; 					\
../inputs/grep1.dat:2500:64411:  } while (0)
../inputs/grep1.dat:2501:64425:
../inputs/grep1.dat:2502:64426:/* Fetch the next character in the uncompiled pattern, with no
../inputs/grep1.dat:2503:64489:   translation.  */
../inputs/grep1.dat:2504:64509:#define PATFETCH_RAW(c)							\
../inputs/grep1.dat:2505:64541:  do {if (p == pend) return REG_EEND;					\
../inputs/grep1.dat:2506:64585:    c = (unsigned char) *p++; 						\
../inputs/grep1.dat:2507:64623:  } while (0)
../inputs/grep1.dat:2508:64637:
../inputs/grep1.dat:2509:64638:/* Go backwards one character in the pattern.  */
../inputs/grep1.dat:2510:64688:#define PATUNFETCH p--
../inputs/grep1.dat:2511:64711:
../inputs/grep1.dat:2512:64712:
../inputs/grep1.dat:2513:64713:/* If `translate' is non-null, return translate[D], else just D.  We
../inputs/grep1.dat:2514:64782:   cast the subscript to translate because some data is declared as
../inputs/grep1.dat:2515:64850:   `char *', to avoid warnings when a string constant is passed.  But
../inputs/grep1.dat:2516:64920:   when we use a character as a subscript we must make it unsigned.  */
../inputs/grep1.dat:2517:64992:#define TRANSLATE(d) (translate ? translate[(unsigned char) (d)] : (d))
../inputs/grep1.dat:2518:65064:
../inputs/grep1.dat:2519:65065:
../inputs/grep1.dat:2520:65066:/* Macros for outputting the compiled pattern into `buffer'.  */
../inputs/grep1.dat:2521:65131:
../inputs/grep1.dat:2522:65132:/* If the buffer isn't allocated when it comes in, use this.  */
../inputs/grep1.dat:2523:65197:#define INIT_BUF_SIZE  32
../inputs/grep1.dat:2524:65223:
../inputs/grep1.dat:2525:65224:/* Make sure we have at least N more bytes of space in buffer.  */
../inputs/grep1.dat:2526:65291:#define GET_BUFFER_SPACE(n)						\
../inputs/grep1.dat:2527:65326:    while (b - bufp->buffer + (n) > bufp->allocated)			\
../inputs/grep1.dat:2528:65383:      EXTEND_BUFFER ()
../inputs/grep1.dat:2529:65406:
../inputs/grep1.dat:2530:65407:/* Make sure we have one more byte of buffer space and then add C to it.  */
../inputs/grep1.dat:2531:65484:#define BUF_PUSH(c)							\
../inputs/grep1.dat:2532:65512:  do {									\
../inputs/grep1.dat:2533:65529:    GET_BUFFER_SPACE (1);						\
../inputs/grep1.dat:2534:65562:    *b++ = (unsigned char) (c);						\
../inputs/grep1.dat:2535:65601:  } while (0)
../inputs/grep1.dat:2536:65615:
../inputs/grep1.dat:2537:65616:
../inputs/grep1.dat:2538:65617:/* Ensure we have two more bytes of buffer space and then append C1 and C2.  */
../inputs/grep1.dat:2539:65697:#define BUF_PUSH_2(c1, c2)						\
../inputs/grep1.dat:2540:65731:  do {									\
../inputs/grep1.dat:2541:65748:    GET_BUFFER_SPACE (2);						\
../inputs/grep1.dat:2542:65781:    *b++ = (unsigned char) (c1);					\
../inputs/grep1.dat:2543:65820:    *b++ = (unsigned char) (c2);					\
../inputs/grep1.dat:2544:65859:  } while (0)
../inputs/grep1.dat:2545:65873:
../inputs/grep1.dat:2546:65874:
../inputs/grep1.dat:2547:65875:/* As with BUF_PUSH_2, except for three bytes.  */
../inputs/grep1.dat:2548:65926:#define BUF_PUSH_3(c1, c2, c3)						\
../inputs/grep1.dat:2549:65964:  do {									\
../inputs/grep1.dat:2550:65981:    GET_BUFFER_SPACE (3);						\
../inputs/grep1.dat:2551:66014:    *b++ = (unsigned char) (c1);					\
../inputs/grep1.dat:2552:66053:    *b++ = (unsigned char) (c2);					\
../inputs/grep1.dat:2553:66092:    *b++ = (unsigned char) (c3);					\
../inputs/grep1.dat:2554:66131:  } while (0)
../inputs/grep1.dat:2555:66145:
../inputs/grep1.dat:2556:66146:
../inputs/grep1.dat:2557:66147:/* Store a jump with opcode OP at LOC to location TO.  We store a
../inputs/grep1.dat:2558:66213:   relative address offset by the three bytes the jump itself occupies.  */
../inputs/grep1.dat:2559:66289:#define STORE_JUMP(op, loc, to) \
../inputs/grep1.dat:2560:66323:  store_op1 (op, loc, (to) - (loc) - 3)
../inputs/grep1.dat:2561:66363:
../inputs/grep1.dat:2562:66364:/* Likewise, for a two-argument jump.  */
../inputs/grep1.dat:2563:66406:#define STORE_JUMP2(op, loc, to, arg) \
../inputs/grep1.dat:2564:66446:  store_op2 (op, loc, (to) - (loc) - 3, arg)
../inputs/grep1.dat:2565:66491:
../inputs/grep1.dat:2566:66492:/* Like `STORE_JUMP', but for inserting.  Assume `b' is the buffer end.  */
../inputs/grep1.dat:2567:66568:#define INSERT_JUMP(op, loc, to) \
../inputs/grep1.dat:2568:66603:  insert_op1 (op, loc, (to) - (loc) - 3, b)
../inputs/grep1.dat:2569:66647:
../inputs/grep1.dat:2570:66648:/* Like `STORE_JUMP2', but for inserting.  Assume `b' is the buffer end.  */
../inputs/grep1.dat:2571:66725:#define INSERT_JUMP2(op, loc, to, arg) \
../inputs/grep1.dat:2572:66766:  insert_op2 (op, loc, (to) - (loc) - 3, arg, b)
../inputs/grep1.dat:2573:66815:
../inputs/grep1.dat:2574:66816:
../inputs/grep1.dat:2575:66817:/* This is not an arbitrary limit: the arguments which represent offsets
../inputs/grep1.dat:2576:66890:   into the pattern are two bytes long.  So if 2^16 bytes turns out to
../inputs/grep1.dat:2577:66961:   be too small, many things would have to change.  */
../inputs/grep1.dat:2578:67016:#define MAX_BUF_SIZE (1L << 16)
../inputs/grep1.dat:2579:67048:
../inputs/grep1.dat:2580:67049:
../inputs/grep1.dat:2581:67050:/* Extend the buffer by twice its current size via realloc and
../inputs/grep1.dat:2582:67113:   reset the pointers that pointed into the old block to point to the
../inputs/grep1.dat:2583:67183:   correct places in the new one.  If extending the buffer results in it
../inputs/grep1.dat:2584:67256:   being larger than MAX_BUF_SIZE, then flag memory exhausted.  */
../inputs/grep1.dat:2585:67323:#define EXTEND_BUFFER()							\
../inputs/grep1.dat:2586:67355:  do { 									\
../inputs/grep1.dat:2587:67373:    unsigned char *old_buffer = bufp->buffer;				\
../inputs/grep1.dat:2588:67424:    if (bufp->allocated == MAX_BUF_SIZE) 				\
../inputs/grep1.dat:2589:67471:      return REG_ESIZE;							\
../inputs/grep1.dat:2590:67503:    bufp->allocated <<= 1;						\
../inputs/grep1.dat:2591:67537:    if (bufp->allocated > MAX_BUF_SIZE)					\
../inputs/grep1.dat:2592:67583:      bufp->allocated = MAX_BUF_SIZE; 					\
../inputs/grep1.dat:2593:67628:    bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated);\
../inputs/grep1.dat:2594:67707:    if (bufp->buffer == NULL)						\
../inputs/grep1.dat:2595:67744:      return REG_ESPACE;						\
../inputs/grep1.dat:2596:67776:    /* If the buffer moved, move all the pointers into it.  */		\
../inputs/grep1.dat:2597:67842:    if (old_buffer != bufp->buffer)					\
../inputs/grep1.dat:2598:67884:      {									\
../inputs/grep1.dat:2599:67902:        b = (b - old_buffer) + bufp->buffer;				\
../inputs/grep1.dat:2600:67952:        begalt = (begalt - old_buffer) + bufp->buffer;			\
../inputs/grep1.dat:2601:68011:        if (fixup_alt_jump)						\
../inputs/grep1.dat:2602:68046:          fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;\
../inputs/grep1.dat:2603:68120:        if (laststart)							\
../inputs/grep1.dat:2604:68151:          laststart = (laststart - old_buffer) + bufp->buffer;		\
../inputs/grep1.dat:2605:68217:        if (pending_exact)						\
../inputs/grep1.dat:2606:68251:          pending_exact = (pending_exact - old_buffer) + bufp->buffer;	\
../inputs/grep1.dat:2607:68324:      }									\
../inputs/grep1.dat:2608:68342:  } while (0)
../inputs/grep1.dat:2609:68356:
../inputs/grep1.dat:2610:68357:
../inputs/grep1.dat:2611:68358:/* Since we have one byte reserved for the register number argument to
../inputs/grep1.dat:2612:68429:   {start,stop}_memory, the maximum number of groups we can report
../inputs/grep1.dat:2613:68496:   things about is what fits in that byte.  */
../inputs/grep1.dat:2614:68543:#define MAX_REGNUM 255
../inputs/grep1.dat:2615:68566:
../inputs/grep1.dat:2616:68567:/* But patterns can have more than `MAX_REGNUM' registers.  We just
../inputs/grep1.dat:2617:68635:   ignore the excess.  */
../inputs/grep1.dat:2618:68661:typedef unsigned regnum_t;
../inputs/grep1.dat:2619:68688:
../inputs/grep1.dat:2620:68689:
../inputs/grep1.dat:2621:68690:/* Macros for the compile stack.  */
../inputs/grep1.dat:2622:68727:
../inputs/grep1.dat:2623:68728:/* Since offsets can go either forwards or backwards, this type needs to
../inputs/grep1.dat:2624:68801:   be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
../inputs/grep1.dat:2625:68877:typedef int pattern_offset_t;
../inputs/grep1.dat:2626:68907:
../inputs/grep1.dat:2627:68908:typedef struct
../inputs/grep1.dat:2628:68923:{
../inputs/grep1.dat:2629:68925:  pattern_offset_t begalt_offset;
../inputs/grep1.dat:2630:68959:  pattern_offset_t fixup_alt_jump;
../inputs/grep1.dat:2631:68994:  pattern_offset_t inner_group_offset;
../inputs/grep1.dat:2632:69033:  pattern_offset_t laststart_offset;  
../inputs/grep1.dat:2633:69072:  regnum_t regnum;
../inputs/grep1.dat:2634:69091:} compile_stack_elt_t;
../inputs/grep1.dat:2635:69114:
../inputs/grep1.dat:2636:69115:
../inputs/grep1.dat:2637:69116:typedef struct
../inputs/grep1.dat:2638:69131:{
../inputs/grep1.dat:2639:69133:  compile_stack_elt_t *stack;
../inputs/grep1.dat:2640:69163:  unsigned size;
../inputs/grep1.dat:2641:69180:  unsigned avail;			/* Offset of next open position.  */
../inputs/grep1.dat:2642:69237:} compile_stack_type;
../inputs/grep1.dat:2643:69259:
../inputs/grep1.dat:2644:69260:
../inputs/grep1.dat:2645:69261:#define INIT_COMPILE_STACK_SIZE 32
../inputs/grep1.dat:2646:69296:
../inputs/grep1.dat:2647:69297:#define COMPILE_STACK_EMPTY  (compile_stack.avail == 0)
../inputs/grep1.dat:2648:69353:#define COMPILE_STACK_FULL  (compile_stack.avail == compile_stack.size)
../inputs/grep1.dat:2649:69425:
../inputs/grep1.dat:2650:69426:/* The next available element.  */
../inputs/grep1.dat:2651:69461:#define COMPILE_STACK_TOP (compile_stack.stack[compile_stack.avail])
../inputs/grep1.dat:2652:69530:
../inputs/grep1.dat:2653:69531:
../inputs/grep1.dat:2654:69532:/* Set the bit for character C in a list.  */
../inputs/grep1.dat:2655:69578:#define SET_LIST_BIT(c)                               \
../inputs/grep1.dat:2656:69634:  (b[((unsigned char) (c)) / BYTEWIDTH]               \
../inputs/grep1.dat:2657:69690:   |= 1 << (((unsigned char) c) % BYTEWIDTH))
../inputs/grep1.dat:2658:69736:
../inputs/grep1.dat:2659:69737:
../inputs/grep1.dat:2660:69738:/* Get the next unsigned number in the uncompiled pattern.  */
../inputs/grep1.dat:2661:69801:#define GET_UNSIGNED_NUMBER(num) 					\
../inputs/grep1.dat:2662:69841:  { if (p != pend)							\
../inputs/grep1.dat:2663:69868:     {									\
../inputs/grep1.dat:2664:69885:       PATFETCH (c); 							\
../inputs/grep1.dat:2665:69915:       while (ISDIGIT (c)) 						\
../inputs/grep1.dat:2666:69950:         { 								\
../inputs/grep1.dat:2667:69971:           if (num < 0)							\
../inputs/grep1.dat:2668:70003:              num = 0;							\
../inputs/grep1.dat:2669:70034:           num = num * 10 + c - '0'; 					\
../inputs/grep1.dat:2670:70078:           if (p == pend) 						\
../inputs/grep1.dat:2671:70112:              break; 							\
../inputs/grep1.dat:2672:70142:           PATFETCH (c);						\
../inputs/grep1.dat:2673:70174:         } 								\
../inputs/grep1.dat:2674:70195:       } 								\
../inputs/grep1.dat:2675:70214:    }		
../inputs/grep1.dat:2676:70222:
../inputs/grep1.dat:2677:70223:#define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */
../inputs/grep1.dat:2678:70281:
../inputs/grep1.dat:2679:70282:#define IS_CHAR_CLASS(string)						\
../inputs/grep1.dat:2680:70319:   (STREQ (string, "alpha") || STREQ (string, "upper")			\
../inputs/grep1.dat:2681:70378:    || STREQ (string, "lower") || STREQ (string, "digit")		\
../inputs/grep1.dat:2682:70439:    || STREQ (string, "alnum") || STREQ (string, "xdigit")		\
../inputs/grep1.dat:2683:70501:    || STREQ (string, "space") || STREQ (string, "print")		\
../inputs/grep1.dat:2684:70562:    || STREQ (string, "punct") || STREQ (string, "graph")		\
../inputs/grep1.dat:2685:70623:    || STREQ (string, "cntrl") || STREQ (string, "blank"))
../inputs/grep1.dat:2686:70682:
../inputs/grep1.dat:2687:70684:/* `regex_compile' compiles PATTERN (of length SIZE) according to SYNTAX.
../inputs/grep1.dat:2688:70758:   Returns one of error codes defined in `regex.h', or zero for success.
../inputs/grep1.dat:2689:70831:
../inputs/grep1.dat:2690:70832:   Assumes the `allocated' (and perhaps `buffer') and `translate'
../inputs/grep1.dat:2691:70898:   fields are set in BUFP on entry.
../inputs/grep1.dat:2692:70934:
../inputs/grep1.dat:2693:70935:   If it succeeds, results are put in BUFP (if it returns an error, the
../inputs/grep1.dat:2694:71007:   contents of BUFP are undefined):
../inputs/grep1.dat:2695:71043:     `buffer' is the compiled pattern;
../inputs/grep1.dat:2696:71082:     `syntax' is set to SYNTAX;
../inputs/grep1.dat:2697:71114:     `used' is set to the length of the compiled pattern;
../inputs/grep1.dat:2698:71172:     `fastmap_accurate' is zero;
../inputs/grep1.dat:2699:71205:     `re_nsub' is the number of subexpressions in PATTERN;
../inputs/grep1.dat:2700:71264:     `not_bol' and `not_eol' are zero;
../inputs/grep1.dat:2701:71303:   
../inputs/grep1.dat:2702:71307:   The `fastmap' and `newline_anchor' fields are neither
../inputs/grep1.dat:2703:71364:   examined nor set.  */
../inputs/grep1.dat:2704:71389:
../inputs/grep1.dat:2705:71390:static reg_errcode_t
../inputs/grep1.dat:2706:71411:regex_compile (pattern, size, syntax, bufp)
../inputs/grep1.dat:2707:71455:     const char *pattern;
../inputs/grep1.dat:2708:71481:     int size;
../inputs/grep1.dat:2709:71496:     reg_syntax_t syntax;
../inputs/grep1.dat:2710:71522:     struct re_pattern_buffer *bufp;
../inputs/grep1.dat:2711:71559:{
../inputs/grep1.dat:2712:71561:  /* We fetch characters from PATTERN here.  Even though PATTERN is
../inputs/grep1.dat:2713:71629:     `char *' (i.e., signed), we declare these variables as unsigned, so
../inputs/grep1.dat:2714:71702:     they can be reliably used as array indices.  */
../inputs/grep1.dat:2715:71755:  register unsigned char c, c1;
../inputs/grep1.dat:2716:71787:  
../inputs/grep1.dat:2717:71790:  /* A random tempory spot in PATTERN.  */
../inputs/grep1.dat:2718:71833:  const char *p1;
../inputs/grep1.dat:2719:71851:
../inputs/grep1.dat:2720:71852:  /* Points to the end of the buffer, where we should append.  */
../inputs/grep1.dat:2721:71918:  register unsigned char *b;
../inputs/grep1.dat:2722:71947:  
../inputs/grep1.dat:2723:71950:  /* Keeps track of unclosed groups.  */
../inputs/grep1.dat:2724:71991:  compile_stack_type compile_stack;
../inputs/grep1.dat:2725:72027:
../inputs/grep1.dat:2726:72028:  /* Points to the current (ending) position in the pattern.  */
../inputs/grep1.dat:2727:72093:  const char *p = pattern;
../inputs/grep1.dat:2728:72120:  const char *pend = pattern + size;
../inputs/grep1.dat:2729:72157:  
../inputs/grep1.dat:2730:72160:  /* How to translate the characters in the pattern.  */
../inputs/grep1.dat:2731:72217:  char *translate = bufp->translate;
../inputs/grep1.dat:2732:72254:
../inputs/grep1.dat:2733:72255:  /* Address of the count-byte of the most recently inserted `exactn'
../inputs/grep1.dat:2734:72325:     command.  This makes it possible to tell if a new exact-match
../inputs/grep1.dat:2735:72392:     character can be added to that command or if the character requires
../inputs/grep1.dat:2736:72465:     a new `exactn' command.  */
../inputs/grep1.dat:2737:72498:  unsigned char *pending_exact = 0;
../inputs/grep1.dat:2738:72534:
../inputs/grep1.dat:2739:72535:  /* Address of start of the most recently finished expression.
../inputs/grep1.dat:2740:72599:     This tells, e.g., postfix * where to find the start of its
../inputs/grep1.dat:2741:72663:     operand.  Reset at the beginning of groups and alternatives.  */
../inputs/grep1.dat:2742:72733:  unsigned char *laststart = 0;
../inputs/grep1.dat:2743:72765:
../inputs/grep1.dat:2744:72766:  /* Address of beginning of regexp, or inside of last group.  */
../inputs/grep1.dat:2745:72832:  unsigned char *begalt;
../inputs/grep1.dat:2746:72857:
../inputs/grep1.dat:2747:72858:  /* Place in the uncompiled pattern (i.e., the {) to
../inputs/grep1.dat:2748:72912:     which to go back if the interval is invalid.  */
../inputs/grep1.dat:2749:72966:  const char *beg_interval;
../inputs/grep1.dat:2750:72994:                
../inputs/grep1.dat:2751:73011:  /* Address of the place where a forward jump should go to the end of
../inputs/grep1.dat:2752:73082:     the containing expression.  Each alternative of an `or' -- except the
../inputs/grep1.dat:2753:73157:     last -- ends with a forward jump of this sort.  */
../inputs/grep1.dat:2754:73213:  unsigned char *fixup_alt_jump = 0;
../inputs/grep1.dat:2755:73250:
../inputs/grep1.dat:2756:73251:  /* Counts open-groups as they are encountered.  Remembered for the
../inputs/grep1.dat:2757:73320:     matching close-group on the compile stack, so the same register
../inputs/grep1.dat:2758:73389:     number is put in the stop_memory as the start_memory.  */
../inputs/grep1.dat:2759:73452:  regnum_t regnum = 0;
../inputs/grep1.dat:2760:73475:
../inputs/grep1.dat:2761:73476:#ifdef DEBUG
../inputs/grep1.dat:2762:73489:  DEBUG_PRINT1 ("\nCompiling pattern: ");
../inputs/grep1.dat:2763:73531:  if (debug)
../inputs/grep1.dat:2764:73544:    {
../inputs/grep1.dat:2765:73550:      unsigned debug_count;
../inputs/grep1.dat:2766:73578:      
../inputs/grep1.dat:2767:73585:      for (debug_count = 0; debug_count < size; debug_count++)
../inputs/grep1.dat:2768:73648:        printchar (pattern[debug_count]);
../inputs/grep1.dat:2769:73690:      putchar ('\n');
../inputs/grep1.dat:2770:73712:    }
../inputs/grep1.dat:2771:73718:#endif /* DEBUG */
../inputs/grep1.dat:2772:73737:
../inputs/grep1.dat:2773:73738:  /* Initialize the compile stack.  */
../inputs/grep1.dat:2774:73777:  compile_stack.stack = TALLOC (INIT_COMPILE_STACK_SIZE, compile_stack_elt_t);
../inputs/grep1.dat:2775:73856:  if (compile_stack.stack == NULL)
../inputs/grep1.dat:2776:73891:    return REG_ESPACE;
../inputs/grep1.dat:2777:73914:
../inputs/grep1.dat:2778:73915:  compile_stack.size = INIT_COMPILE_STACK_SIZE;
../inputs/grep1.dat:2779:73963:  compile_stack.avail = 0;
../inputs/grep1.dat:2780:73990:
../inputs/grep1.dat:2781:73991:  /* Initialize the pattern buffer.  */
../inputs/grep1.dat:2782:74031:  bufp->syntax = syntax;
../inputs/grep1.dat:2783:74056:  bufp->fastmap_accurate = 0;
../inputs/grep1.dat:2784:74086:  bufp->not_bol = bufp->not_eol = 0;
../inputs/grep1.dat:2785:74123:
../inputs/grep1.dat:2786:74124:  /* Set `used' to zero, so that if we return an error, the pattern
../inputs/grep1.dat:2787:74192:     printer (for debugging) will think there's no pattern.  We reset it
../inputs/grep1.dat:2788:74265:     at the end.  */
../inputs/grep1.dat:2789:74286:  bufp->used = 0;
../inputs/grep1.dat:2790:74304:  
../inputs/grep1.dat:2791:74307:  /* Always count groups, whether or not bufp->no_sub is set.  */
../inputs/grep1.dat:2792:74373:  bufp->re_nsub = 0;				
../inputs/grep1.dat:2793:74398:
../inputs/grep1.dat:2794:74399:#if !defined (emacs) && !defined (SYNTAX_TABLE)
../inputs/grep1.dat:2795:74447:  /* Initialize the syntax table.  */
../inputs/grep1.dat:2796:74485:   init_syntax_once ();
../inputs/grep1.dat:2797:74509:#endif
../inputs/grep1.dat:2798:74516:
../inputs/grep1.dat:2799:74517:  if (bufp->allocated == 0)
../inputs/grep1.dat:2800:74545:    {
../inputs/grep1.dat:2801:74551:      if (bufp->buffer)
../inputs/grep1.dat:2802:74575:	{ /* If zero allocated, but buffer is non-null, try to realloc
../inputs/grep1.dat:2803:74639:             enough space.  This loses if buffer's address is bogus, but
../inputs/grep1.dat:2804:74712:             that is the user's responsibility.  */
../inputs/grep1.dat:2805:74764:          RETALLOC (bufp->buffer, INIT_BUF_SIZE, unsigned char);
../inputs/grep1.dat:2806:74829:        }
../inputs/grep1.dat:2807:74839:      else
../inputs/grep1.dat:2808:74850:        { /* Caller did not allocate a buffer.  Do it for them.  */
../inputs/grep1.dat:2809:74918:          bufp->buffer = TALLOC (INIT_BUF_SIZE, unsigned char);
../inputs/grep1.dat:2810:74982:        }
../inputs/grep1.dat:2811:74992:      if (!bufp->buffer) return REG_ESPACE;
../inputs/grep1.dat:2812:75036:
../inputs/grep1.dat:2813:75037:      bufp->allocated = INIT_BUF_SIZE;
../inputs/grep1.dat:2814:75076:    }
../inputs/grep1.dat:2815:75082:
../inputs/grep1.dat:2816:75083:  begalt = b = bufp->buffer;
../inputs/grep1.dat:2817:75112:
../inputs/grep1.dat:2818:75113:  /* Loop through the uncompiled pattern until we're at the end.  */
../inputs/grep1.dat:2819:75182:  while (p != pend)
../inputs/grep1.dat:2820:75202:    {
../inputs/grep1.dat:2821:75208:      PATFETCH (c);
../inputs/grep1.dat:2822:75228:
../inputs/grep1.dat:2823:75229:      switch (c)
../inputs/grep1.dat:2824:75246:        {
../inputs/grep1.dat:2825:75256:        case '^':
../inputs/grep1.dat:2826:75274:          {
../inputs/grep1.dat:2827:75286:            if (   /* If at start of pattern, it's an operator.  */
../inputs/grep1.dat:2828:75354:                   p == pattern + 1
../inputs/grep1.dat:2829:75390:                   /* If context independent, it's an operator.  */
../inputs/grep1.dat:2830:75458:                || syntax & RE_CONTEXT_INDEP_ANCHORS
../inputs/grep1.dat:2831:75511:                   /* Otherwise, depends on what's come before.  */
../inputs/grep1.dat:2832:75579:                || at_begline_loc_p (pattern, p, syntax))
../inputs/grep1.dat:2833:75637:              BUF_PUSH (begline);
../inputs/grep1.dat:2834:75671:            else
../inputs/grep1.dat:2835:75688:              goto normal_char;
../inputs/grep1.dat:2836:75720:          }
../inputs/grep1.dat:2837:75732:          break;
../inputs/grep1.dat:2838:75749:
../inputs/grep1.dat:2839:75750:
../inputs/grep1.dat:2840:75751:        case '$':
../inputs/grep1.dat:2841:75769:          {
../inputs/grep1.dat:2842:75781:            if (   /* If at end of pattern, it's an operator.  */
../inputs/grep1.dat:2843:75847:                   p == pend 
../inputs/grep1.dat:2844:75877:                   /* If context independent, it's an operator.  */
../inputs/grep1.dat:2845:75945:                || syntax & RE_CONTEXT_INDEP_ANCHORS
../inputs/grep1.dat:2846:75998:                   /* Otherwise, depends on what's next.  */
../inputs/grep1.dat:2847:76059:                || at_endline_loc_p (p, pend, syntax))
../inputs/grep1.dat:2848:76114:               BUF_PUSH (endline);
../inputs/grep1.dat:2849:76149:             else
../inputs/grep1.dat:2850:76167:               goto normal_char;
../inputs/grep1.dat:2851:76200:           }
../inputs/grep1.dat:2852:76213:           break;
../inputs/grep1.dat:2853:76231:
../inputs/grep1.dat:2854:76232:
../inputs/grep1.dat:2855:76233:	case '+':
../inputs/grep1.dat:2856:76244:        case '?':
../inputs/grep1.dat:2857:76262:          if ((syntax & RE_BK_PLUS_QM)
../inputs/grep1.dat:2858:76301:              || (syntax & RE_LIMITED_OPS))
../inputs/grep1.dat:2859:76345:            goto normal_char;
../inputs/grep1.dat:2860:76375:        handle_plus:
../inputs/grep1.dat:2861:76396:        case '*':
../inputs/grep1.dat:2862:76414:          /* If there is no previous pattern... */
../inputs/grep1.dat:2863:76465:          if (!laststart)
../inputs/grep1.dat:2864:76491:            {
../inputs/grep1.dat:2865:76505:              if (syntax & RE_CONTEXT_INVALID_OPS)
../inputs/grep1.dat:2866:76556:                return REG_BADRPT;
../inputs/grep1.dat:2867:76591:              else if (!(syntax & RE_CONTEXT_INDEP_OPS))
../inputs/grep1.dat:2868:76648:                goto normal_char;
../inputs/grep1.dat:2869:76682:            }
../inputs/grep1.dat:2870:76696:
../inputs/grep1.dat:2871:76697:          {
../inputs/grep1.dat:2872:76709:            /* Are we optimizing this jump?  */
../inputs/grep1.dat:2873:76757:            boolean keep_string_p = false;
../inputs/grep1.dat:2874:76800:            
../inputs/grep1.dat:2875:76813:            /* 1 means zero (many) matches is allowed.  */
../inputs/grep1.dat:2876:76872:            char zero_times_ok = 0, many_times_ok = 0;
../inputs/grep1.dat:2877:76927:
../inputs/grep1.dat:2878:76928:            /* If there is a sequence of repetition chars, collapse it
../inputs/grep1.dat:2879:76999:               down to just one (the right one).  We can't combine
../inputs/grep1.dat:2880:77066:               interval operators with these because of, e.g., `a{2}*',
../inputs/grep1.dat:2881:77138:               which should only match an even number of `a's.  */
../inputs/grep1.dat:2882:77205:
../inputs/grep1.dat:2883:77206:            for (;;)
../inputs/grep1.dat:2884:77227:              {
../inputs/grep1.dat:2885:77243:                zero_times_ok |= c != '+';
../inputs/grep1.dat:2886:77286:                many_times_ok |= c != '?';
../inputs/grep1.dat:2887:77329:
../inputs/grep1.dat:2888:77330:                if (p == pend)
../inputs/grep1.dat:2889:77361:                  break;
../inputs/grep1.dat:2890:77386:
../inputs/grep1.dat:2891:77387:                PATFETCH (c);
../inputs/grep1.dat:2892:77417:
../inputs/grep1.dat:2893:77418:                if (c == '*'
../inputs/grep1.dat:2894:77447:                    || (!(syntax & RE_BK_PLUS_QM) && (c == '+' || c == '?')))
../inputs/grep1.dat:2895:77525:                  ;
../inputs/grep1.dat:2896:77545:
../inputs/grep1.dat:2897:77546:                else if (syntax & RE_BK_PLUS_QM  &&  c == '\\')
../inputs/grep1.dat:2898:77610:                  {
../inputs/grep1.dat:2899:77630:                    if (p == pend) return REG_EESCAPE;
../inputs/grep1.dat:2900:77685:
../inputs/grep1.dat:2901:77686:                    PATFETCH (c1);
../inputs/grep1.dat:2902:77721:                    if (!(c1 == '+' || c1 == '?'))
../inputs/grep1.dat:2903:77772:                      {
../inputs/grep1.dat:2904:77796:                        PATUNFETCH;
../inputs/grep1.dat:2905:77832:                        PATUNFETCH;
../inputs/grep1.dat:2906:77868:                        break;
../inputs/grep1.dat:2907:77899:                      }
../inputs/grep1.dat:2908:77923:
../inputs/grep1.dat:2909:77924:                    c = c1;
../inputs/grep1.dat:2910:77952:                  }
../inputs/grep1.dat:2911:77972:                else
../inputs/grep1.dat:2912:77993:                  {
../inputs/grep1.dat:2913:78013:                    PATUNFETCH;
../inputs/grep1.dat:2914:78045:                    break;
../inputs/grep1.dat:2915:78072:                  }
../inputs/grep1.dat:2916:78092:
../inputs/grep1.dat:2917:78093:                /* If we get here, we found another repeat character.  */
../inputs/grep1.dat:2918:78167:               }
../inputs/grep1.dat:2919:78184:
../inputs/grep1.dat:2920:78185:            /* Star, etc. applied to an empty pattern is equivalent
../inputs/grep1.dat:2921:78253:               to an empty pattern.  */
../inputs/grep1.dat:2922:78293:            if (!laststart)  
../inputs/grep1.dat:2923:78323:              break;
../inputs/grep1.dat:2924:78344:
../inputs/grep1.dat:2925:78345:            /* Now we know whether or not zero matches is allowed
../inputs/grep1.dat:2926:78411:               and also whether or not two or more matches is allowed.  */
../inputs/grep1.dat:2927:78486:            if (many_times_ok)
../inputs/grep1.dat:2928:78517:              { /* More than one repetition is allowed, so put in at the
../inputs/grep1.dat:2929:78590:                   end a backward relative jump from `b' to before the next
../inputs/grep1.dat:2930:78666:                   jump we're going to put in below (which jumps from
../inputs/grep1.dat:2931:78736:                   laststart to after this jump).  
../inputs/grep1.dat:2932:78788:
../inputs/grep1.dat:2933:78789:                   But if we are at the `*' in the exact sequence `.*\n',
../inputs/grep1.dat:2934:78863:                   insert an unconditional jump backwards to the .,
../inputs/grep1.dat:2935:78931:                   instead of the beginning of the loop.  This way we only
../inputs/grep1.dat:2936:79006:                   push a failure point once, instead of every time
../inputs/grep1.dat:2937:79074:                   through the loop.  */
../inputs/grep1.dat:2938:79115:                assert (p - 1 > pattern);
../inputs/grep1.dat:2939:79157:
../inputs/grep1.dat:2940:79158:                /* Allocate the space for the jump.  */
../inputs/grep1.dat:2941:79214:                GET_BUFFER_SPACE (3);
../inputs/grep1.dat:2942:79252:
../inputs/grep1.dat:2943:79253:                /* We know we are not at the first character of the pattern,
../inputs/grep1.dat:2944:79330:                   because laststart was nonzero.  And we've already
../inputs/grep1.dat:2945:79399:                   incremented `p', by the way, to be the character after
../inputs/grep1.dat:2946:79473:                   the `*'.  Do we have to do something analogous here
../inputs/grep1.dat:2947:79544:                   for null bytes, because of RE_DOT_NOT_NULL?  */
../inputs/grep1.dat:2948:79611:                if (TRANSLATE (*(p - 2)) == TRANSLATE ('.')
../inputs/grep1.dat:2949:79671:		    && zero_times_ok
../inputs/grep1.dat:2950:79694:                    && p < pend && TRANSLATE (*p) == TRANSLATE ('\n')
../inputs/grep1.dat:2951:79764:                    && !(syntax & RE_DOT_NEWLINE))
../inputs/grep1.dat:2952:79815:                  { /* We have .*\n.  */
../inputs/grep1.dat:2953:79856:                    STORE_JUMP (jump, b, laststart);
../inputs/grep1.dat:2954:79909:                    keep_string_p = true;
../inputs/grep1.dat:2955:79951:                  }
../inputs/grep1.dat:2956:79971:                else
../inputs/grep1.dat:2957:79992:                  /* Anything else.  */
../inputs/grep1.dat:2958:80032:                  STORE_JUMP (maybe_pop_jump, b, laststart - 3);
../inputs/grep1.dat:2959:80097:
../inputs/grep1.dat:2960:80098:                /* We've added more stuff to the buffer.  */
../inputs/grep1.dat:2961:80159:                b += 3;
../inputs/grep1.dat:2962:80183:              }
../inputs/grep1.dat:2963:80199:
../inputs/grep1.dat:2964:80200:            /* On failure, jump from laststart to b + 3, which will be the
../inputs/grep1.dat:2965:80275:               end of the buffer after this jump is inserted.  */
../inputs/grep1.dat:2966:80341:            GET_BUFFER_SPACE (3);
../inputs/grep1.dat:2967:80375:            INSERT_JUMP (keep_string_p ? on_failure_keep_string_jump
../inputs/grep1.dat:2968:80444:                                       : on_failure_jump,
../inputs/grep1.dat:2969:80502:                         laststart, b + 3);
../inputs/grep1.dat:2970:80546:            pending_exact = 0;
../inputs/grep1.dat:2971:80577:            b += 3;
../inputs/grep1.dat:2972:80597:
../inputs/grep1.dat:2973:80598:            if (!zero_times_ok)
../inputs/grep1.dat:2974:80630:              {
../inputs/grep1.dat:2975:80646:                /* At least one repetition is required, so insert a
../inputs/grep1.dat:2976:80714:                   `dummy_failure_jump' before the initial
../inputs/grep1.dat:2977:80773:                   `on_failure_jump' instruction of the loop. This
../inputs/grep1.dat:2978:80840:                   effects a skip over that instruction the first time
../inputs/grep1.dat:2979:80911:                   we hit that loop.  */
../inputs/grep1.dat:2980:80952:                GET_BUFFER_SPACE (3);
../inputs/grep1.dat:2981:80990:                INSERT_JUMP (dummy_failure_jump, laststart, laststart + 6);
../inputs/grep1.dat:2982:81066:                b += 3;
../inputs/grep1.dat:2983:81090:              }
../inputs/grep1.dat:2984:81106:            }
../inputs/grep1.dat:2985:81120:	  break;
../inputs/grep1.dat:2986:81130:
../inputs/grep1.dat:2987:81131:
../inputs/grep1.dat:2988:81132:	case '.':
../inputs/grep1.dat:2989:81143:          laststart = b;
../inputs/grep1.dat:2990:81168:          BUF_PUSH (anychar);
../inputs/grep1.dat:2991:81198:          break;
../inputs/grep1.dat:2992:81215:
../inputs/grep1.dat:2993:81216:
../inputs/grep1.dat:2994:81217:        case '[':
../inputs/grep1.dat:2995:81235:          {
../inputs/grep1.dat:2996:81247:            boolean had_char_class = false;
../inputs/grep1.dat:2997:81291:
../inputs/grep1.dat:2998:81292:            if (p == pend) return REG_EBRACK;
../inputs/grep1.dat:2999:81338:
../inputs/grep1.dat:3000:81339:            /* Ensure that we have enough space to push a charset: the
../inputs/grep1.dat:3001:81410:               opcode, the length count, and the bitset; 34 bytes in all.  */
../inputs/grep1.dat:3002:81488:	    GET_BUFFER_SPACE (34);
../inputs/grep1.dat:3003:81516:
../inputs/grep1.dat:3004:81517:            laststart = b;
../inputs/grep1.dat:3005:81544:
../inputs/grep1.dat:3006:81545:            /* We test `*p == '^' twice, instead of using an if
../inputs/grep1.dat:3007:81609:               statement, so we only need one BUF_PUSH.  */
../inputs/grep1.dat:3008:81669:            BUF_PUSH (*p == '^' ? charset_not : charset); 
../inputs/grep1.dat:3009:81728:            if (*p == '^')
../inputs/grep1.dat:3010:81755:              p++;
../inputs/grep1.dat:3011:81774:
../inputs/grep1.dat:3012:81775:            /* Remember the first position in the bracket expression.  */
../inputs/grep1.dat:3013:81849:            p1 = p;
../inputs/grep1.dat:3014:81869:
../inputs/grep1.dat:3015:81870:            /* Push the number of bytes in the bitmap.  */
../inputs/grep1.dat:3016:81929:            BUF_PUSH ((1 << BYTEWIDTH) / BYTEWIDTH);
../inputs/grep1.dat:3017:81982:
../inputs/grep1.dat:3018:81983:            /* Clear the whole map.  */
../inputs/grep1.dat:3019:82023:            bzero (b, (1 << BYTEWIDTH) / BYTEWIDTH);
../inputs/grep1.dat:3020:82076:
../inputs/grep1.dat:3021:82077:            /* charset_not matches newline according to a syntax bit.  */
../inputs/grep1.dat:3022:82151:            if ((re_opcode_t) b[-2] == charset_not
../inputs/grep1.dat:3023:82202:                && (syntax & RE_HAT_LISTS_NOT_NEWLINE))
../inputs/grep1.dat:3024:82258:              SET_LIST_BIT ('\n');
../inputs/grep1.dat:3025:82293:
../inputs/grep1.dat:3026:82294:            /* Read in characters and ranges, setting map bits.  */
../inputs/grep1.dat:3027:82362:            for (;;)
../inputs/grep1.dat:3028:82383:              {
../inputs/grep1.dat:3029:82399:                if (p == pend) return REG_EBRACK;
../inputs/grep1.dat:3030:82449:
../inputs/grep1.dat:3031:82450:                PATFETCH (c);
../inputs/grep1.dat:3032:82480:
../inputs/grep1.dat:3033:82481:                /* \ might escape characters inside [...] and [^...].  */
../inputs/grep1.dat:3034:82555:                if ((syntax & RE_BACKSLASH_ESCAPE_IN_LISTS) && c == '\\')
../inputs/grep1.dat:3035:82629:                  {
../inputs/grep1.dat:3036:82649:                    if (p == pend) return REG_EESCAPE;
../inputs/grep1.dat:3037:82704:
../inputs/grep1.dat:3038:82705:                    PATFETCH (c1);
../inputs/grep1.dat:3039:82740:                    SET_LIST_BIT (c1);
../inputs/grep1.dat:3040:82779:                    continue;
../inputs/grep1.dat:3041:82809:                  }
../inputs/grep1.dat:3042:82829:
../inputs/grep1.dat:3043:82830:                /* Could be the end of the bracket expression.  If it's
../inputs/grep1.dat:3044:82902:                   not (i.e., when the bracket expression is `[]' so
../inputs/grep1.dat:3045:82971:                   far), the ']' character bit gets set way below.  */
../inputs/grep1.dat:3046:83042:                if (c == ']' && p != p1 + 1)
../inputs/grep1.dat:3047:83087:                  break;
../inputs/grep1.dat:3048:83112:
../inputs/grep1.dat:3049:83113:                /* Look ahead to see if it's a range when the last thing
../inputs/grep1.dat:3050:83186:                   was a character class.  */
../inputs/grep1.dat:3051:83232:                if (had_char_class && c == '-' && *p != ']')
../inputs/grep1.dat:3052:83293:                  return REG_ERANGE;
../inputs/grep1.dat:3053:83330:
../inputs/grep1.dat:3054:83331:                /* Look ahead to see if it's a range when the last thing
../inputs/grep1.dat:3055:83404:                   was a character: if this is a hyphen not at the
../inputs/grep1.dat:3056:83471:                   beginning or the end of a list, then it's the range
../inputs/grep1.dat:3057:83542:                   operator.  */
../inputs/grep1.dat:3058:83575:                if (c == '-' 
../inputs/grep1.dat:3059:83605:                    && !(p - 2 >= pattern && p[-2] == '[') 
../inputs/grep1.dat:3060:83665:                    && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^')
../inputs/grep1.dat:3061:83740:                    && *p != ']')
../inputs/grep1.dat:3062:83774:                  {
../inputs/grep1.dat:3063:83794:                    reg_errcode_t ret
../inputs/grep1.dat:3064:83832:                      = compile_range (&p, pend, translate, syntax, b);
../inputs/grep1.dat:3065:83904:                    if (ret != REG_NOERROR) return ret;
../inputs/grep1.dat:3066:83960:                  }
../inputs/grep1.dat:3067:83980:
../inputs/grep1.dat:3068:83981:                else if (p[0] == '-' && p[1] != ']')
../inputs/grep1.dat:3069:84034:                  { /* This handles ranges made up of characters only.  */
../inputs/grep1.dat:3070:84109:                    reg_errcode_t ret;
../inputs/grep1.dat:3071:84148:
../inputs/grep1.dat:3072:84149:		    /* Move past the `-'.  */
../inputs/grep1.dat:3073:84181:                    PATFETCH (c1);
../inputs/grep1.dat:3074:84216:                    
../inputs/grep1.dat:3075:84237:                    ret = compile_range (&p, pend, translate, syntax, b);
../inputs/grep1.dat:3076:84311:                    if (ret != REG_NOERROR) return ret;
../inputs/grep1.dat:3077:84367:                  }
../inputs/grep1.dat:3078:84387:
../inputs/grep1.dat:3079:84388:                /* See if we're at the beginning of a possible character
../inputs/grep1.dat:3080:84461:                   class.  */
../inputs/grep1.dat:3081:84491:
../inputs/grep1.dat:3082:84492:                else if (syntax & RE_CHAR_CLASSES && c == '[' && *p == ':')
../inputs/grep1.dat:3083:84568:                  { /* Leave room for the null.  */
../inputs/grep1.dat:3084:84620:                    char str[CHAR_CLASS_MAX_LENGTH + 1];
../inputs/grep1.dat:3085:84677:
../inputs/grep1.dat:3086:84678:                    PATFETCH (c);
../inputs/grep1.dat:3087:84712:                    c1 = 0;
../inputs/grep1.dat:3088:84740:
../inputs/grep1.dat:3089:84741:                    /* If pattern is `[[:'.  */
../inputs/grep1.dat:3090:84789:                    if (p == pend) return REG_EBRACK;
../inputs/grep1.dat:3091:84843:
../inputs/grep1.dat:3092:84844:                    for (;;)
../inputs/grep1.dat:3093:84873:                      {
../inputs/grep1.dat:3094:84897:                        PATFETCH (c);
../inputs/grep1.dat:3095:84935:                        if (c == ':' || c == ']' || p == pend
../inputs/grep1.dat:3096:84997:                            || c1 == CHAR_CLASS_MAX_LENGTH)
../inputs/grep1.dat:3097:85057:                          break;
../inputs/grep1.dat:3098:85090:                        str[c1++] = c;
../inputs/grep1.dat:3099:85129:                      }
../inputs/grep1.dat:3100:85153:                    str[c1] = '\0';
../inputs/grep1.dat:3101:85189:
../inputs/grep1.dat:3102:85190:                    /* If isn't a word bracketed by `[:' and:`]':
../inputs/grep1.dat:3103:85256:                       undo the ending character, the letters, and leave 
../inputs/grep1.dat:3104:85330:                       the leading `:' and `[' (but set bits for them).  */
../inputs/grep1.dat:3105:85406:                    if (c == ':' && *p == ']')
../inputs/grep1.dat:3106:85453:                      {
../inputs/grep1.dat:3107:85477:                        int ch;
../inputs/grep1.dat:3108:85509:                        boolean is_alnum = STREQ (str, "alnum");
../inputs/grep1.dat:3109:85574:                        boolean is_alpha = STREQ (str, "alpha");
../inputs/grep1.dat:3110:85639:                        boolean is_blank = STREQ (str, "blank");
../inputs/grep1.dat:3111:85704:                        boolean is_cntrl = STREQ (str, "cntrl");
../inputs/grep1.dat:3112:85769:                        boolean is_digit = STREQ (str, "digit");
../inputs/grep1.dat:3113:85834:                        boolean is_graph = STREQ (str, "graph");
../inputs/grep1.dat:3114:85899:                        boolean is_lower = STREQ (str, "lower");
../inputs/grep1.dat:3115:85964:                        boolean is_print = STREQ (str, "print");
../inputs/grep1.dat:3116:86029:                        boolean is_punct = STREQ (str, "punct");
../inputs/grep1.dat:3117:86094:                        boolean is_space = STREQ (str, "space");
../inputs/grep1.dat:3118:86159:                        boolean is_upper = STREQ (str, "upper");
../inputs/grep1.dat:3119:86224:                        boolean is_xdigit = STREQ (str, "xdigit");
../inputs/grep1.dat:3120:86291:                        
../inputs/grep1.dat:3121:86316:                        if (!IS_CHAR_CLASS (str)) return REG_ECTYPE;
../inputs/grep1.dat:3122:86385:
../inputs/grep1.dat:3123:86386:                        /* Throw away the ] at the end of the character
../inputs/grep1.dat:3124:86458:                           class.  */
../inputs/grep1.dat:3125:86496:                        PATFETCH (c);					
../inputs/grep1.dat:3126:86539:
../inputs/grep1.dat:3127:86540:                        if (p == pend) return REG_EBRACK;
../inputs/grep1.dat:3128:86598:
../inputs/grep1.dat:3129:86599:                        for (ch = 0; ch < 1 << BYTEWIDTH; ch++)
../inputs/grep1.dat:3130:86663:                          {
../inputs/grep1.dat:3131:86691:                            if (   (is_alnum  && ISALNUM (ch))
../inputs/grep1.dat:3132:86754:                                || (is_alpha  && ISALPHA (ch))
../inputs/grep1.dat:3133:86817:                                || (is_blank  && ISBLANK (ch))
../inputs/grep1.dat:3134:86880:                                || (is_cntrl  && ISCNTRL (ch))
../inputs/grep1.dat:3135:86943:                                || (is_digit  && ISDIGIT (ch))
../inputs/grep1.dat:3136:87006:                                || (is_graph  && ISGRAPH (ch))
../inputs/grep1.dat:3137:87069:                                || (is_lower  && ISLOWER (ch))
../inputs/grep1.dat:3138:87132:                                || (is_print  && ISPRINT (ch))
../inputs/grep1.dat:3139:87195:                                || (is_punct  && ISPUNCT (ch))
../inputs/grep1.dat:3140:87258:                                || (is_space  && ISSPACE (ch))
../inputs/grep1.dat:3141:87321:                                || (is_upper  && ISUPPER (ch))
../inputs/grep1.dat:3142:87384:                                || (is_xdigit && ISXDIGIT (ch)))
../inputs/grep1.dat:3143:87449:                            SET_LIST_BIT (ch);
../inputs/grep1.dat:3144:87496:                          }
../inputs/grep1.dat:3145:87524:                        had_char_class = true;
../inputs/grep1.dat:3146:87571:                      }
../inputs/grep1.dat:3147:87595:                    else
../inputs/grep1.dat:3148:87620:                      {
../inputs/grep1.dat:3149:87644:                        c1++;
../inputs/grep1.dat:3150:87674:                        while (c1--)    
../inputs/grep1.dat:3151:87715:                          PATUNFETCH;
../inputs/grep1.dat:3152:87753:                        SET_LIST_BIT ('[');
../inputs/grep1.dat:3153:87797:                        SET_LIST_BIT (':');
../inputs/grep1.dat:3154:87841:                        had_char_class = false;
../inputs/grep1.dat:3155:87889:                      }
../inputs/grep1.dat:3156:87913:                  }
../inputs/grep1.dat:3157:87933:                else
../inputs/grep1.dat:3158:87954:                  {
../inputs/grep1.dat:3159:87974:                    had_char_class = false;
../inputs/grep1.dat:3160:88018:                    SET_LIST_BIT (c);
../inputs/grep1.dat:3161:88056:                  }
../inputs/grep1.dat:3162:88076:              }
../inputs/grep1.dat:3163:88092:
../inputs/grep1.dat:3164:88093:            /* Discard any (non)matching list bytes that are all 0 at the
../inputs/grep1.dat:3165:88167:               end of the map.  Decrease the map-length byte too.  */
../inputs/grep1.dat:3166:88237:            while ((int) b[-1] > 0 && b[b[-1] - 1] == 0) 
../inputs/grep1.dat:3167:88295:              b[-1]--; 
../inputs/grep1.dat:3168:88319:            b += b[-1];
../inputs/grep1.dat:3169:88343:          }
../inputs/grep1.dat:3170:88355:          break;
../inputs/grep1.dat:3171:88372:
../inputs/grep1.dat:3172:88373:
../inputs/grep1.dat:3173:88374:	case '(':
../inputs/grep1.dat:3174:88385:          if (syntax & RE_NO_BK_PARENS)
../inputs/grep1.dat:3175:88425:            goto handle_open;
../inputs/grep1.dat:3176:88455:          else
../inputs/grep1.dat:3177:88470:            goto normal_char;
../inputs/grep1.dat:3178:88500:
../inputs/grep1.dat:3179:88501:
../inputs/grep1.dat:3180:88502:        case ')':
../inputs/grep1.dat:3181:88520:          if (syntax & RE_NO_BK_PARENS)
../inputs/grep1.dat:3182:88560:            goto handle_close;
../inputs/grep1.dat:3183:88591:          else
../inputs/grep1.dat:3184:88606:            goto normal_char;
../inputs/grep1.dat:3185:88636:
../inputs/grep1.dat:3186:88637:
../inputs/grep1.dat:3187:88638:        case '\n':
../inputs/grep1.dat:3188:88657:          if (syntax & RE_NEWLINE_ALT)
../inputs/grep1.dat:3189:88696:            goto handle_alt;
../inputs/grep1.dat:3190:88725:          else
../inputs/grep1.dat:3191:88740:            goto normal_char;
../inputs/grep1.dat:3192:88770:
../inputs/grep1.dat:3193:88771:
../inputs/grep1.dat:3194:88772:	case '|':
../inputs/grep1.dat:3195:88783:          if (syntax & RE_NO_BK_VBAR)
../inputs/grep1.dat:3196:88821:            goto handle_alt;
../inputs/grep1.dat:3197:88850:          else
../inputs/grep1.dat:3198:88865:            goto normal_char;
../inputs/grep1.dat:3199:88895:
../inputs/grep1.dat:3200:88896:
../inputs/grep1.dat:3201:88897:        case '{':
../inputs/grep1.dat:3202:88915:           if (syntax & RE_INTERVALS && syntax & RE_NO_BK_BRACES)
../inputs/grep1.dat:3203:88981:             goto handle_interval;
../inputs/grep1.dat:3204:89016:           else
../inputs/grep1.dat:3205:89032:             goto normal_char;
../inputs/grep1.dat:3206:89063:
../inputs/grep1.dat:3207:89064:
../inputs/grep1.dat:3208:89065:        case '\\':
../inputs/grep1.dat:3209:89084:          if (p == pend) return REG_EESCAPE;
../inputs/grep1.dat:3210:89129:
../inputs/grep1.dat:3211:89130:          /* Do not translate the character after the \, so that we can
../inputs/grep1.dat:3212:89202:             distinguish, e.g., \B from \b, even if we normally would
../inputs/grep1.dat:3213:89272:             translate, e.g., B to b.  */
../inputs/grep1.dat:3214:89314:          PATFETCH_RAW (c);
../inputs/grep1.dat:3215:89342:
../inputs/grep1.dat:3216:89343:          switch (c)
../inputs/grep1.dat:3217:89364:            {
../inputs/grep1.dat:3218:89378:            case '(':
../inputs/grep1.dat:3219:89400:              if (syntax & RE_NO_BK_PARENS)
../inputs/grep1.dat:3220:89444:                goto normal_backslash;
../inputs/grep1.dat:3221:89483:
../inputs/grep1.dat:3222:89484:            handle_open:
../inputs/grep1.dat:3223:89509:              bufp->re_nsub++;
../inputs/grep1.dat:3224:89540:              regnum++;
../inputs/grep1.dat:3225:89564:
../inputs/grep1.dat:3226:89565:              if (COMPILE_STACK_FULL)
../inputs/grep1.dat:3227:89603:                { 
../inputs/grep1.dat:3228:89622:                  RETALLOC (compile_stack.stack, compile_stack.size << 1,
../inputs/grep1.dat:3229:89696:                            compile_stack_elt_t);
../inputs/grep1.dat:3230:89746:                  if (compile_stack.stack == NULL) return REG_ESPACE;
../inputs/grep1.dat:3231:89816:
../inputs/grep1.dat:3232:89817:                  compile_stack.size <<= 1;
../inputs/grep1.dat:3233:89861:                }
../inputs/grep1.dat:3234:89879:
../inputs/grep1.dat:3235:89880:              /* These are the values to restore when we hit end of this
../inputs/grep1.dat:3236:89953:                 group.  They are all relative offsets, so that if the
../inputs/grep1.dat:3237:90024:                 whole pattern moves because of realloc, they will still
../inputs/grep1.dat:3238:90097:                 be valid.  */
../inputs/grep1.dat:3239:90128:              COMPILE_STACK_TOP.begalt_offset = begalt - bufp->buffer;
../inputs/grep1.dat:3240:90199:              COMPILE_STACK_TOP.fixup_alt_jump 
../inputs/grep1.dat:3241:90247:                = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
../inputs/grep1.dat:3242:90321:              COMPILE_STACK_TOP.laststart_offset = b - bufp->buffer;
../inputs/grep1.dat:3243:90390:              COMPILE_STACK_TOP.regnum = regnum;
../inputs/grep1.dat:3244:90439:
../inputs/grep1.dat:3245:90440:              /* We will eventually replace the 0 with the number of
../inputs/grep1.dat:3246:90509:                 groups inner to this one.  But do not push a
../inputs/grep1.dat:3247:90571:                 start_memory for groups beyond the last one we can
../inputs/grep1.dat:3248:90639:                 represent in the compiled pattern.  */
../inputs/grep1.dat:3249:90695:              if (regnum <= MAX_REGNUM)
../inputs/grep1.dat:3250:90735:                {
../inputs/grep1.dat:3251:90753:                  COMPILE_STACK_TOP.inner_group_offset = b - bufp->buffer + 2;
../inputs/grep1.dat:3252:90832:                  BUF_PUSH_3 (start_memory, regnum, 0);
../inputs/grep1.dat:3253:90888:                }
../inputs/grep1.dat:3254:90906:                
../inputs/grep1.dat:3255:90923:              compile_stack.avail++;
../inputs/grep1.dat:3256:90960:
../inputs/grep1.dat:3257:90961:              fixup_alt_jump = 0;
../inputs/grep1.dat:3258:90995:              laststart = 0;
../inputs/grep1.dat:3259:91024:              begalt = b;
../inputs/grep1.dat:3260:91050:	      /* If we've reached MAX_REGNUM groups, then this open
../inputs/grep1.dat:3261:91111:		 won't actually generate any code, so we'll have to
../inputs/grep1.dat:3262:91165:		 clear pending_exact explicitly.  */
../inputs/grep1.dat:3263:91204:	      pending_exact = 0;
../inputs/grep1.dat:3264:91230:              break;
../inputs/grep1.dat:3265:91251:
../inputs/grep1.dat:3266:91252:
../inputs/grep1.dat:3267:91253:            case ')':
../inputs/grep1.dat:3268:91275:              if (syntax & RE_NO_BK_PARENS) goto normal_backslash;
../inputs/grep1.dat:3269:91342:
../inputs/grep1.dat:3270:91343:              if (COMPILE_STACK_EMPTY)
../inputs/grep1.dat:3271:91382:                if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
../inputs/grep1.dat:3272:91441:                  goto normal_backslash;
../inputs/grep1.dat:3273:91482:                else
../inputs/grep1.dat:3274:91503:                  return REG_ERPAREN;
../inputs/grep1.dat:3275:91541:
../inputs/grep1.dat:3276:91542:            handle_close:
../inputs/grep1.dat:3277:91568:              if (fixup_alt_jump)
../inputs/grep1.dat:3278:91602:                { /* Push a dummy failure point at the end of the
../inputs/grep1.dat:3279:91668:                     alternative for a possible future
../inputs/grep1.dat:3280:91723:                     `pop_failure_jump' to pop.  See comments at
../inputs/grep1.dat:3281:91788:                     `push_dummy_failure' in `re_match_2'.  */
../inputs/grep1.dat:3282:91851:                  BUF_PUSH (push_dummy_failure);
../inputs/grep1.dat:3283:91900:                  
../inputs/grep1.dat:3284:91919:                  /* We allocated space for this jump when we assigned
../inputs/grep1.dat:3285:91990:                     to `fixup_alt_jump', in the `handle_alt' case below.  */
../inputs/grep1.dat:3286:92068:                  STORE_JUMP (jump_past_alt, fixup_alt_jump, b - 1);
../inputs/grep1.dat:3287:92137:                }
../inputs/grep1.dat:3288:92155:
../inputs/grep1.dat:3289:92156:              /* See similar code for backslashed left paren above.  */
../inputs/grep1.dat:3290:92228:              if (COMPILE_STACK_EMPTY)
../inputs/grep1.dat:3291:92267:                if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
../inputs/grep1.dat:3292:92326:                  goto normal_char;
../inputs/grep1.dat:3293:92362:                else
../inputs/grep1.dat:3294:92383:                  return REG_ERPAREN;
../inputs/grep1.dat:3295:92421:
../inputs/grep1.dat:3296:92422:              /* Since we just checked for an empty stack above, this
../inputs/grep1.dat:3297:92492:                 ``can't happen''.  */
../inputs/grep1.dat:3298:92531:              assert (compile_stack.avail != 0);
../inputs/grep1.dat:3299:92580:              {
../inputs/grep1.dat:3300:92596:                /* We don't just want to restore into `regnum', because
../inputs/grep1.dat:3301:92668:                   later groups should continue to be numbered higher,
../inputs/grep1.dat:3302:92739:                   as in `(ab)c(de)' -- the second group is #2.  */
../inputs/grep1.dat:3303:92807:                regnum_t this_group_regnum;
../inputs/grep1.dat:3304:92851:
../inputs/grep1.dat:3305:92852:                compile_stack.avail--;		
../inputs/grep1.dat:3306:92893:                begalt = bufp->buffer + COMPILE_STACK_TOP.begalt_offset;
../inputs/grep1.dat:3307:92966:                fixup_alt_jump
../inputs/grep1.dat:3308:92997:                  = COMPILE_STACK_TOP.fixup_alt_jump
../inputs/grep1.dat:3309:93050:                    ? bufp->buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1 
../inputs/grep1.dat:3310:93125:                    : 0;
../inputs/grep1.dat:3311:93150:                laststart = bufp->buffer + COMPILE_STACK_TOP.laststart_offset;
../inputs/grep1.dat:3312:93229:                this_group_regnum = COMPILE_STACK_TOP.regnum;
../inputs/grep1.dat:3313:93291:		/* If we've reached MAX_REGNUM groups, then this open
../inputs/grep1.dat:3314:93347:		   won't actually generate any code, so we'll have to
../inputs/grep1.dat:3315:93403:		   clear pending_exact explicitly.  */
../inputs/grep1.dat:3316:93444:		pending_exact = 0;
../inputs/grep1.dat:3317:93465:
../inputs/grep1.dat:3318:93466:                /* We're at the end of the group, so now we know how many
../inputs/grep1.dat:3319:93540:                   groups were inside this one.  */
../inputs/grep1.dat:3320:93592:                if (this_group_regnum <= MAX_REGNUM)
../inputs/grep1.dat:3321:93645:                  {
../inputs/grep1.dat:3322:93665:                    unsigned char *inner_group_loc
../inputs/grep1.dat:3323:93716:                      = bufp->buffer + COMPILE_STACK_TOP.inner_group_offset;
../inputs/grep1.dat:3324:93793:                    
../inputs/grep1.dat:3325:93814:                    *inner_group_loc = regnum - this_group_regnum;
../inputs/grep1.dat:3326:93881:                    BUF_PUSH_3 (stop_memory, this_group_regnum,
../inputs/grep1.dat:3327:93945:                                regnum - this_group_regnum);
../inputs/grep1.dat:3328:94006:                  }
../inputs/grep1.dat:3329:94026:              }
../inputs/grep1.dat:3330:94042:              break;
../inputs/grep1.dat:3331:94063:
../inputs/grep1.dat:3332:94064:
../inputs/grep1.dat:3333:94065:            case '|':					/* `\|'.  */
../inputs/grep1.dat:3334:94104:              if (syntax & RE_LIMITED_OPS || syntax & RE_NO_BK_VBAR)
../inputs/grep1.dat:3335:94173:                goto normal_backslash;
../inputs/grep1.dat:3336:94212:            handle_alt:
../inputs/grep1.dat:3337:94236:              if (syntax & RE_LIMITED_OPS)
../inputs/grep1.dat:3338:94279:                goto normal_char;
../inputs/grep1.dat:3339:94313:
../inputs/grep1.dat:3340:94314:              /* Insert before the previous alternative a jump which
../inputs/grep1.dat:3341:94383:                 jumps to this alternative if the former fails.  */
../inputs/grep1.dat:3342:94451:              GET_BUFFER_SPACE (3);
../inputs/grep1.dat:3343:94487:              INSERT_JUMP (on_failure_jump, begalt, b + 6);
../inputs/grep1.dat:3344:94547:              pending_exact = 0;
../inputs/grep1.dat:3345:94580:              b += 3;
../inputs/grep1.dat:3346:94602:
../inputs/grep1.dat:3347:94603:              /* The alternative before this one has a jump after it
../inputs/grep1.dat:3348:94672:                 which gets executed if it gets matched.  Adjust that
../inputs/grep1.dat:3349:94742:                 jump so it will jump to this alternative's analogous
../inputs/grep1.dat:3350:94812:                 jump (put in below, which in turn will jump to the next
../inputs/grep1.dat:3351:94885:                 (if any) alternative's such jump, etc.).  The last such
../inputs/grep1.dat:3352:94958:                 jump jumps to the correct final destination.  A picture:
../inputs/grep1.dat:3353:95032:                          _____ _____ 
../inputs/grep1.dat:3354:95071:                          |   | |   |   
../inputs/grep1.dat:3355:95112:                          |   v |   v 
../inputs/grep1.dat:3356:95151:                         a | b   | c   
../inputs/grep1.dat:3357:95191:
../inputs/grep1.dat:3358:95192:                 If we are at `b', then fixup_alt_jump right now points to a
../inputs/grep1.dat:3359:95269:                 three-byte space after `a'.  We'll put in the jump, set
../inputs/grep1.dat:3360:95342:                 fixup_alt_jump to right after `b', and leave behind three
../inputs/grep1.dat:3361:95417:                 bytes which we'll fill in when we get to after `c'.  */
../inputs/grep1.dat:3362:95490:
../inputs/grep1.dat:3363:95491:              if (fixup_alt_jump)
../inputs/grep1.dat:3364:95525:                STORE_JUMP (jump_past_alt, fixup_alt_jump, b);
../inputs/grep1.dat:3365:95588:
../inputs/grep1.dat:3366:95589:              /* Mark and leave space for a jump after this alternative,
../inputs/grep1.dat:3367:95662:                 to be filled in later either by next alternative or
../inputs/grep1.dat:3368:95731:                 when know we're at the end of a series of alternatives.  */
../inputs/grep1.dat:3369:95808:              fixup_alt_jump = b;
../inputs/grep1.dat:3370:95842:              GET_BUFFER_SPACE (3);
../inputs/grep1.dat:3371:95878:              b += 3;
../inputs/grep1.dat:3372:95900:
../inputs/grep1.dat:3373:95901:              laststart = 0;
../inputs/grep1.dat:3374:95930:              begalt = b;
../inputs/grep1.dat:3375:95956:              break;
../inputs/grep1.dat:3376:95977:
../inputs/grep1.dat:3377:95978:
../inputs/grep1.dat:3378:95979:            case '{': 
../inputs/grep1.dat:3379:96002:              /* If \{ is a literal.  */
../inputs/grep1.dat:3380:96043:              if (!(syntax & RE_INTERVALS)
../inputs/grep1.dat:3381:96086:                     /* If we're at `\{' and it's not the open-interval 
../inputs/grep1.dat:3382:96159:                        operator.  */
../inputs/grep1.dat:3383:96197:                  || ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))
../inputs/grep1.dat:3384:96274:                  || (p - 2 == pattern  &&  p == pend))
../inputs/grep1.dat:3385:96330:                goto normal_backslash;
../inputs/grep1.dat:3386:96369:
../inputs/grep1.dat:3387:96370:            handle_interval:
../inputs/grep1.dat:3388:96399:              {
../inputs/grep1.dat:3389:96415:                /* If got here, then the syntax allows intervals.  */
../inputs/grep1.dat:3390:96485:
../inputs/grep1.dat:3391:96486:                /* At least (most) this many matches must be made.  */
../inputs/grep1.dat:3392:96557:                int lower_bound = -1, upper_bound = -1;
../inputs/grep1.dat:3393:96613:
../inputs/grep1.dat:3394:96614:                beg_interval = p - 1;
../inputs/grep1.dat:3395:96652:
../inputs/grep1.dat:3396:96653:                if (p == pend)
../inputs/grep1.dat:3397:96684:                  {
../inputs/grep1.dat:3398:96704:                    if (syntax & RE_NO_BK_BRACES)
../inputs/grep1.dat:3399:96754:                      goto unfetch_interval;
../inputs/grep1.dat:3400:96799:                    else
../inputs/grep1.dat:3401:96824:                      return REG_EBRACE;
../inputs/grep1.dat:3402:96865:                  }
../inputs/grep1.dat:3403:96885:
../inputs/grep1.dat:3404:96886:                GET_UNSIGNED_NUMBER (lower_bound);
../inputs/grep1.dat:3405:96937:
../inputs/grep1.dat:3406:96938:                if (c == ',')
../inputs/grep1.dat:3407:96968:                  {
../inputs/grep1.dat:3408:96988:                    GET_UNSIGNED_NUMBER (upper_bound);
../inputs/grep1.dat:3409:97043:                    if (upper_bound < 0) upper_bound = RE_DUP_MAX;
../inputs/grep1.dat:3410:97110:                  }
../inputs/grep1.dat:3411:97130:                else
../inputs/grep1.dat:3412:97151:                  /* Interval such as `{1}' => match exactly once. */
../inputs/grep1.dat:3413:97221:                  upper_bound = lower_bound;
../inputs/grep1.dat:3414:97266:
../inputs/grep1.dat:3415:97267:                if (lower_bound < 0 || upper_bound > RE_DUP_MAX
../inputs/grep1.dat:3416:97331:                    || lower_bound > upper_bound)
../inputs/grep1.dat:3417:97381:                  {
../inputs/grep1.dat:3418:97401:                    if (syntax & RE_NO_BK_BRACES)
../inputs/grep1.dat:3419:97451:                      goto unfetch_interval;
../inputs/grep1.dat:3420:97496:                    else 
../inputs/grep1.dat:3421:97522:                      return REG_BADBR;
../inputs/grep1.dat:3422:97562:                  }
../inputs/grep1.dat:3423:97582:
../inputs/grep1.dat:3424:97583:                if (!(syntax & RE_NO_BK_BRACES)) 
../inputs/grep1.dat:3425:97633:                  {
../inputs/grep1.dat:3426:97653:                    if (c != '\\') return REG_EBRACE;
../inputs/grep1.dat:3427:97707:
../inputs/grep1.dat:3428:97708:                    PATFETCH (c);
../inputs/grep1.dat:3429:97742:                  }
../inputs/grep1.dat:3430:97762:
../inputs/grep1.dat:3431:97763:                if (c != '}')
../inputs/grep1.dat:3432:97793:                  {
../inputs/grep1.dat:3433:97813:                    if (syntax & RE_NO_BK_BRACES)
../inputs/grep1.dat:3434:97863:                      goto unfetch_interval;
../inputs/grep1.dat:3435:97908:                    else 
../inputs/grep1.dat:3436:97934:                      return REG_BADBR;
../inputs/grep1.dat:3437:97974:                  }
../inputs/grep1.dat:3438:97994:
../inputs/grep1.dat:3439:97995:                /* We just parsed a valid interval.  */
../inputs/grep1.dat:3440:98051:
../inputs/grep1.dat:3441:98052:                /* If it's invalid to have no preceding re.  */
../inputs/grep1.dat:3442:98116:                if (!laststart)
../inputs/grep1.dat:3443:98148:                  {
../inputs/grep1.dat:3444:98168:                    if (syntax & RE_CONTEXT_INVALID_OPS)
../inputs/grep1.dat:3445:98225:                      return REG_BADRPT;
../inputs/grep1.dat:3446:98266:                    else if (syntax & RE_CONTEXT_INDEP_OPS)
../inputs/grep1.dat:3447:98326:                      laststart = b;
../inputs/grep1.dat:3448:98363:                    else
../inputs/grep1.dat:3449:98388:                      goto unfetch_interval;
../inputs/grep1.dat:3450:98433:                  }
../inputs/grep1.dat:3451:98453:
../inputs/grep1.dat:3452:98454:                /* If the upper bound is zero, don't want to succeed at
../inputs/grep1.dat:3453:98526:                   all; jump from `laststart' to `b + 3', which will be
../inputs/grep1.dat:3454:98598:                   the end of the buffer after we insert the jump.  */
../inputs/grep1.dat:3455:98669:                 if (upper_bound == 0)
../inputs/grep1.dat:3456:98708:                   {
../inputs/grep1.dat:3457:98729:                     GET_BUFFER_SPACE (3);
../inputs/grep1.dat:3458:98772:                     INSERT_JUMP (jump, laststart, b + 3);
../inputs/grep1.dat:3459:98831:                     b += 3;
../inputs/grep1.dat:3460:98860:                   }
../inputs/grep1.dat:3461:98881:
../inputs/grep1.dat:3462:98882:                 /* Otherwise, we have a nontrivial interval.  When
../inputs/grep1.dat:3463:98950:                    we're all done, the pattern will look like:
../inputs/grep1.dat:3464:99014:                      set_number_at <jump count> <upper bound>
../inputs/grep1.dat:3465:99077:                      set_number_at <succeed_n count> <lower bound>
../inputs/grep1.dat:3466:99145:                      succeed_n <after jump addr> <succed_n count>
../inputs/grep1.dat:3467:99212:                      <body of loop>
../inputs/grep1.dat:3468:99249:                      jump_n <succeed_n addr> <jump count>
../inputs/grep1.dat:3469:99308:                    (The upper bound and `jump_n' are omitted if
../inputs/grep1.dat:3470:99373:                    `upper_bound' is 1, though.)  */
../inputs/grep1.dat:3471:99426:                 else 
../inputs/grep1.dat:3472:99449:                   { /* If the upper bound is > 1, we need to insert
../inputs/grep1.dat:3473:99518:                        more at the end of the loop.  */
../inputs/grep1.dat:3474:99575:                     unsigned nbytes = 10 + (upper_bound > 1) * 10;
../inputs/grep1.dat:3475:99643:
../inputs/grep1.dat:3476:99644:                     GET_BUFFER_SPACE (nbytes);
../inputs/grep1.dat:3477:99692:
../inputs/grep1.dat:3478:99693:                     /* Initialize lower bound of the `succeed_n', even
../inputs/grep1.dat:3479:99765:                        though it will be set during matching by its
../inputs/grep1.dat:3480:99834:                        attendant `set_number_at' (inserted next),
../inputs/grep1.dat:3481:99901:                        because `re_compile_fastmap' needs to know.
../inputs/grep1.dat:3482:99969:                        Jump to the `jump_n' we might insert below.  */
../inputs/grep1.dat:3483:100041:                     INSERT_JUMP2 (succeed_n, laststart,
../inputs/grep1.dat:3484:100098:                                   b + 5 + (upper_bound > 1) * 5,
../inputs/grep1.dat:3485:100164:                                   lower_bound);
../inputs/grep1.dat:3486:100213:                     b += 5;
../inputs/grep1.dat:3487:100242:
../inputs/grep1.dat:3488:100243:                     /* Code to initialize the lower bound.  Insert 
../inputs/grep1.dat:3489:100312:                        before the `succeed_n'.  The `5' is the last two
../inputs/grep1.dat:3490:100385:                        bytes of this `set_number_at', plus 3 bytes of
../inputs/grep1.dat:3491:100456:                        the following `succeed_n'.  */
../inputs/grep1.dat:3492:100511:                     insert_op2 (set_number_at, laststart, 5, lower_bound, b);
../inputs/grep1.dat:3493:100590:                     b += 5;
../inputs/grep1.dat:3494:100619:
../inputs/grep1.dat:3495:100620:                     if (upper_bound > 1)
../inputs/grep1.dat:3496:100662:                       { /* More than one repetition is allowed, so
../inputs/grep1.dat:3497:100730:                            append a backward jump to the `succeed_n'
../inputs/grep1.dat:3498:100800:                            that starts this interval.
../inputs/grep1.dat:3499:100855:                            
../inputs/grep1.dat:3500:100884:                            When we've reached this during matching,
../inputs/grep1.dat:3501:100953:                            we'll have matched the interval once, so
../inputs/grep1.dat:3502:101022:                            jump back only `upper_bound - 1' times.  */
../inputs/grep1.dat:3503:101094:                         STORE_JUMP2 (jump_n, b, laststart + 5,
../inputs/grep1.dat:3504:101158:                                      upper_bound - 1);
../inputs/grep1.dat:3505:101214:                         b += 5;
../inputs/grep1.dat:3506:101247:
../inputs/grep1.dat:3507:101248:                         /* The location we want to set is the second
../inputs/grep1.dat:3508:101318:                            parameter of the `jump_n'; that is `b-2' as
../inputs/grep1.dat:3509:101390:                            an absolute address.  `laststart' will be
../inputs/grep1.dat:3510:101460:                            the `set_number_at' we're about to insert;
../inputs/grep1.dat:3511:101531:                            `laststart+3' the number to set, the source
../inputs/grep1.dat:3512:101603:                            for the relative address.  But we are
../inputs/grep1.dat:3513:101669:                            inserting into the middle of the pattern --
../inputs/grep1.dat:3514:101741:                            so everything is getting moved up by 5.
../inputs/grep1.dat:3515:101809:                            Conclusion: (b - 2) - (laststart + 3) + 5,
../inputs/grep1.dat:3516:101880:                            i.e., b - laststart.
../inputs/grep1.dat:3517:101929:                            
../inputs/grep1.dat:3518:101958:                            We insert this at the beginning of the loop
../inputs/grep1.dat:3519:102030:                            so that if we fail during matching, we'll
../inputs/grep1.dat:3520:102100:                            reinitialize the bounds.  */
../inputs/grep1.dat:3521:102157:                         insert_op2 (set_number_at, laststart, b - laststart,
../inputs/grep1.dat:3522:102235:                                     upper_bound - 1, b);
../inputs/grep1.dat:3523:102293:                         b += 5;
../inputs/grep1.dat:3524:102326:                       }
../inputs/grep1.dat:3525:102351:                   }
../inputs/grep1.dat:3526:102372:                pending_exact = 0;
../inputs/grep1.dat:3527:102407:                beg_interval = NULL;
../inputs/grep1.dat:3528:102444:              }
../inputs/grep1.dat:3529:102460:              break;
../inputs/grep1.dat:3530:102481:
../inputs/grep1.dat:3531:102482:            unfetch_interval:
../inputs/grep1.dat:3532:102512:              /* If an invalid interval, match the characters as literals.  */
../inputs/grep1.dat:3533:102591:               assert (beg_interval);
../inputs/grep1.dat:3534:102629:               p = beg_interval;
../inputs/grep1.dat:3535:102662:               beg_interval = NULL;
../inputs/grep1.dat:3536:102698:
../inputs/grep1.dat:3537:102699:               /* normal_char and normal_backslash need `c'.  */
../inputs/grep1.dat:3538:102764:               PATFETCH (c);	
../inputs/grep1.dat:3539:102794:
../inputs/grep1.dat:3540:102795:               if (!(syntax & RE_NO_BK_BRACES))
../inputs/grep1.dat:3541:102843:                 {
../inputs/grep1.dat:3542:102862:                   if (p > pattern  &&  p[-1] == '\\')
../inputs/grep1.dat:3543:102917:                     goto normal_backslash;
../inputs/grep1.dat:3544:102961:                 }
../inputs/grep1.dat:3545:102980:               goto normal_char;
../inputs/grep1.dat:3546:103013:
../inputs/grep1.dat:3547:103014:#ifdef emacs
../inputs/grep1.dat:3548:103027:            /* There is no way to specify the before_dot and after_dot
../inputs/grep1.dat:3549:103098:               operators.  rms says this is ok.  --karl  */
../inputs/grep1.dat:3550:103158:            case '=':
../inputs/grep1.dat:3551:103180:              BUF_PUSH (at_dot);
../inputs/grep1.dat:3552:103213:              break;
../inputs/grep1.dat:3553:103234:
../inputs/grep1.dat:3554:103235:            case 's':	
../inputs/grep1.dat:3555:103258:              laststart = b;
../inputs/grep1.dat:3556:103287:              PATFETCH (c);
../inputs/grep1.dat:3557:103315:              BUF_PUSH_2 (syntaxspec, syntax_spec_code[c]);
../inputs/grep1.dat:3558:103375:              break;
../inputs/grep1.dat:3559:103396:
../inputs/grep1.dat:3560:103397:            case 'S':
../inputs/grep1.dat:3561:103419:              laststart = b;
../inputs/grep1.dat:3562:103448:              PATFETCH (c);
../inputs/grep1.dat:3563:103476:              BUF_PUSH_2 (notsyntaxspec, syntax_spec_code[c]);
../inputs/grep1.dat:3564:103539:              break;
../inputs/grep1.dat:3565:103560:#endif /* emacs */
../inputs/grep1.dat:3566:103579:
../inputs/grep1.dat:3567:103580:
../inputs/grep1.dat:3568:103581:            case 'w':
../inputs/grep1.dat:3569:103603:              laststart = b;
../inputs/grep1.dat:3570:103632:              BUF_PUSH (wordchar);
../inputs/grep1.dat:3571:103667:              break;
../inputs/grep1.dat:3572:103688:
../inputs/grep1.dat:3573:103689:
../inputs/grep1.dat:3574:103690:            case 'W':
../inputs/grep1.dat:3575:103712:              laststart = b;
../inputs/grep1.dat:3576:103741:              BUF_PUSH (notwordchar);
../inputs/grep1.dat:3577:103779:              break;
../inputs/grep1.dat:3578:103800:
../inputs/grep1.dat:3579:103801:
../inputs/grep1.dat:3580:103802:            case '<':
../inputs/grep1.dat:3581:103824:              BUF_PUSH (wordbeg);
../inputs/grep1.dat:3582:103858:              break;
../inputs/grep1.dat:3583:103879:
../inputs/grep1.dat:3584:103880:            case '>':
../inputs/grep1.dat:3585:103902:              BUF_PUSH (wordend);
../inputs/grep1.dat:3586:103936:              break;
../inputs/grep1.dat:3587:103957:
../inputs/grep1.dat:3588:103958:            case 'b':
../inputs/grep1.dat:3589:103980:              BUF_PUSH (wordbound);
../inputs/grep1.dat:3590:104016:              break;
../inputs/grep1.dat:3591:104037:
../inputs/grep1.dat:3592:104038:            case 'B':
../inputs/grep1.dat:3593:104060:              BUF_PUSH (notwordbound);
../inputs/grep1.dat:3594:104099:              break;
../inputs/grep1.dat:3595:104120:
../inputs/grep1.dat:3596:104121:            case '`':
../inputs/grep1.dat:3597:104143:              BUF_PUSH (begbuf);
../inputs/grep1.dat:3598:104176:              break;
../inputs/grep1.dat:3599:104197:
../inputs/grep1.dat:3600:104198:            case '\'':
../inputs/grep1.dat:3601:104221:              BUF_PUSH (endbuf);
../inputs/grep1.dat:3602:104254:              break;
../inputs/grep1.dat:3603:104275:
../inputs/grep1.dat:3604:104276:            case '1': case '2': case '3': case '4': case '5':
../inputs/grep1.dat:3605:104338:            case '6': case '7': case '8': case '9':
../inputs/grep1.dat:3606:104390:              if (syntax & RE_NO_BK_REFS)
../inputs/grep1.dat:3607:104432:                goto normal_char;
../inputs/grep1.dat:3608:104466:
../inputs/grep1.dat:3609:104467:              c1 = c - '0';
../inputs/grep1.dat:3610:104495:
../inputs/grep1.dat:3611:104496:              if (c1 > regnum)
../inputs/grep1.dat:3612:104527:                return REG_ESUBREG;
../inputs/grep1.dat:3613:104563:
../inputs/grep1.dat:3614:104564:              /* Can't back reference to a subexpression if inside of it.  */
../inputs/grep1.dat:3615:104642:              if (group_in_compile_stack (compile_stack, c1))
../inputs/grep1.dat:3616:104704:                goto normal_char;
../inputs/grep1.dat:3617:104738:
../inputs/grep1.dat:3618:104739:              laststart = b;
../inputs/grep1.dat:3619:104768:              BUF_PUSH_2 (duplicate, c1);
../inputs/grep1.dat:3620:104810:              break;
../inputs/grep1.dat:3621:104831:
../inputs/grep1.dat:3622:104832:
../inputs/grep1.dat:3623:104833:            case '+':
../inputs/grep1.dat:3624:104855:            case '?':
../inputs/grep1.dat:3625:104877:              if (syntax & RE_BK_PLUS_QM)
../inputs/grep1.dat:3626:104919:                goto handle_plus;
../inputs/grep1.dat:3627:104953:              else
../inputs/grep1.dat:3628:104972:                goto normal_backslash;
../inputs/grep1.dat:3629:105011:
../inputs/grep1.dat:3630:105012:            default:
../inputs/grep1.dat:3631:105033:            normal_backslash:
../inputs/grep1.dat:3632:105063:              /* You might think it would be useful for \ to mean
../inputs/grep1.dat:3633:105129:                 not to translate; but if we don't translate it
../inputs/grep1.dat:3634:105193:                 it will never match anything.  */
../inputs/grep1.dat:3635:105244:              c = TRANSLATE (c);
../inputs/grep1.dat:3636:105277:              goto normal_char;
../inputs/grep1.dat:3637:105309:            }
../inputs/grep1.dat:3638:105323:          break;
../inputs/grep1.dat:3639:105340:
../inputs/grep1.dat:3640:105341:
../inputs/grep1.dat:3641:105342:	default:
../inputs/grep1.dat:3642:105352:        /* Expects the character in `c'.  */
../inputs/grep1.dat:3643:105397:	normal_char:
../inputs/grep1.dat:3644:105411:	      /* If no exactn currently being built.  */
../inputs/grep1.dat:3645:105461:          if (!pending_exact 
../inputs/grep1.dat:3646:105491:
../inputs/grep1.dat:3647:105492:              /* If last exactn not at current position.  */
../inputs/grep1.dat:3648:105553:              || pending_exact + *pending_exact + 1 != b
../inputs/grep1.dat:3649:105610:              
../inputs/grep1.dat:3650:105625:              /* We have only one byte following the exactn for the count.  */
../inputs/grep1.dat:3651:105704:	      || *pending_exact == (1 << BYTEWIDTH) - 1
../inputs/grep1.dat:3652:105753:
../inputs/grep1.dat:3653:105754:              /* If followed by a repetition operator.  */
../inputs/grep1.dat:3654:105813:              || *p == '*' || *p == '^'
../inputs/grep1.dat:3655:105853:	      || ((syntax & RE_BK_PLUS_QM)
../inputs/grep1.dat:3656:105889:		  ? *p == '\\' && (p[1] == '+' || p[1] == '?')
../inputs/grep1.dat:3657:105938:		  : (*p == '+' || *p == '?'))
../inputs/grep1.dat:3658:105970:	      || ((syntax & RE_INTERVALS)
../inputs/grep1.dat:3659:106005:                  && ((syntax & RE_NO_BK_BRACES)
../inputs/grep1.dat:3660:106054:		      ? *p == '{'
../inputs/grep1.dat:3661:106074:                      : (p[0] == '\\' && p[1] == '{'))))
../inputs/grep1.dat:3662:106131:	    {
../inputs/grep1.dat:3663:106138:	      /* Start building a new exactn.  */
../inputs/grep1.dat:3664:106181:              
../inputs/grep1.dat:3665:106196:              laststart = b;
../inputs/grep1.dat:3666:106225:
../inputs/grep1.dat:3667:106226:	      BUF_PUSH_2 (exactn, 0);
../inputs/grep1.dat:3668:106257:	      pending_exact = b - 1;
../inputs/grep1.dat:3669:106287:            }
../inputs/grep1.dat:3670:106301:            
../inputs/grep1.dat:3671:106314:	  BUF_PUSH (c);
../inputs/grep1.dat:3672:106331:          (*pending_exact)++;
../inputs/grep1.dat:3673:106361:	  break;
../inputs/grep1.dat:3674:106371:        } /* switch (c) */
../inputs/grep1.dat:3675:106398:    } /* while p != pend */
../inputs/grep1.dat:3676:106426:
../inputs/grep1.dat:3677:106427:  
../inputs/grep1.dat:3678:106430:  /* Through the pattern now.  */
../inputs/grep1.dat:3679:106464:  
../inputs/grep1.dat:3680:106467:  if (fixup_alt_jump)
../inputs/grep1.dat:3681:106489:    STORE_JUMP (jump_past_alt, fixup_alt_jump, b);
../inputs/grep1.dat:3682:106540:
../inputs/grep1.dat:3683:106541:  if (!COMPILE_STACK_EMPTY) 
../inputs/grep1.dat:3684:106570:    return REG_EPAREN;
../inputs/grep1.dat:3685:106593:
../inputs/grep1.dat:3686:106594:  free (compile_stack.stack);
../inputs/grep1.dat:3687:106624:
../inputs/grep1.dat:3688:106625:  /* We have succeeded; set the length of the buffer.  */
../inputs/grep1.dat:3689:106683:  bufp->used = b - bufp->buffer;
../inputs/grep1.dat:3690:106716:
../inputs/grep1.dat:3691:106717:#ifdef DEBUG
../inputs/grep1.dat:3692:106730:  if (debug)
../inputs/grep1.dat:3693:106743:    {
../inputs/grep1.dat:3694:106749:      DEBUG_PRINT1 ("\nCompiled pattern: \n");
../inputs/grep1.dat:3695:106796:      print_compiled_pattern (bufp);
../inputs/grep1.dat:3696:106833:    }
../inputs/grep1.dat:3697:106839:#endif /* DEBUG */
../inputs/grep1.dat:3698:106858:
../inputs/grep1.dat:3699:106859:  return REG_NOERROR;
../inputs/grep1.dat:3700:106881:} /* regex_compile */
../inputs/grep1.dat:3701:106903:
../inputs/grep1.dat:3702:106905:/* Subroutines for `regex_compile'.  */
../inputs/grep1.dat:3703:106945:
../inputs/grep1.dat:3704:106946:/* Store OP at LOC followed by two-byte integer parameter ARG.  */
../inputs/grep1.dat:3705:107013:
../inputs/grep1.dat:3706:107014:static void
../inputs/grep1.dat:3707:107026:store_op1 (op, loc, arg)
../inputs/grep1.dat:3708:107051:    re_opcode_t op;
../inputs/grep1.dat:3709:107071:    unsigned char *loc;
../inputs/grep1.dat:3710:107095:    int arg;
../inputs/grep1.dat:3711:107108:{
../inputs/grep1.dat:3712:107110:  *loc = (unsigned char) op;
../inputs/grep1.dat:3713:107139:  STORE_NUMBER (loc + 1, arg);
../inputs/grep1.dat:3714:107170:}
../inputs/grep1.dat:3715:107172:
../inputs/grep1.dat:3716:107173:
../inputs/grep1.dat:3717:107174:/* Like `store_op1', but" for 'two two-byte parameters ARG1 and ARG2.  */
../inputs/grep1.dat:3718:107248:
../inputs/grep1.dat:3719:107249:static void
../inputs/grep1.dat:3720:107261:store_op2 (op, loc, arg1, arg2)
../inputs/grep1.dat:3721:107293:    re_opcode_t op;
../inputs/grep1.dat:3722:107313:    unsigned char *loc;
../inputs/grep1.dat:3723:107337:    int arg1, arg2;
../inputs/grep1.dat:3724:107357:{
../inputs/grep1.dat:3725:107359:  *loc = (unsigned char) op;
../inputs/grep1.dat:3726:107388:  STORE_NUMBER (loc + 1, arg1);
../inputs/grep1.dat:3727:107420:  STORE_NUMBER (loc + 3, arg2);
../inputs/grep1.dat:3728:107452:}
../inputs/grep1.dat:3729:107454:
../inputs/grep1.dat:3730:107455:
../inputs/grep1.dat:3731:107456:/* Copy the bytes from LOC to END to open up three bytes of space at LOC
../inputs/grep1.dat:3732:107529:   for OP followed by two-byte integer parameter ARG.  */
../inputs/grep1.dat:3733:107587:
../inputs/grep1.dat:3734:107588:static void
../inputs/grep1.dat:3735:107600:insert_op1 (op, loc, arg, end)
../inputs/grep1.dat:3736:107631:    re_opcode_t op;
../inputs/grep1.dat:3737:107651:    unsigned char *loc;
../inputs/grep1.dat:3738:107675:    int arg;
../inputs/grep1.dat:3739:107688:    unsigned char *end;    
../inputs/grep1.dat:3740:107716:{
../inputs/grep1.dat:3741:107718:  register unsigned char *pfrom = end;
../inputs/grep1.dat:3742:107757:  register unsigned char *pto = end + 3;
../inputs/grep1.dat:3743:107798:
../inputs/grep1.dat:3744:107799:  while (pfrom != loc)
../inputs/grep1.dat:3745:107822:    *--pto = *--pfrom;
../inputs/grep1.dat:3746:107845:    
../inputs/grep1.dat:3747:107850:  store_op1 (op, loc, arg);
../inputs/grep1.dat:3748:107878:}
../inputs/grep1.dat:3749:107880:
../inputs/grep1.dat:3750:107881:
../inputs/grep1.dat:3751:107882:/* Like `insert_op1', but for two two-byte parameters ARG1 and ARG2.  */
../inputs/grep1.dat:3752:107955:
../inputs/grep1.dat:3753:107956:static void
../inputs/grep1.dat:3754:107968:insert_op2 (op, loc, arg1, arg2, end)
../inputs/grep1.dat:3755:108006:    re_opcode_t op;
../inputs/grep1.dat:3756:108026:    unsigned char *loc;
../inputs/grep1.dat:3757:108050:    int arg1, arg2;
../inputs/grep1.dat:3758:108070:    unsigned char *end;    
../inputs/grep1.dat:3759:108098:{
../inputs/grep1.dat:3760:108100:  register unsigned char *pfrom = end;
../inputs/grep1.dat:3761:108139:  register unsigned char *pto = end + 5;
../inputs/grep1.dat:3762:108180:
../inputs/grep1.dat:3763:108181:  while (pfrom != loc)
../inputs/grep1.dat:3764:108204:    *--pto = *--pfrom;
../inputs/grep1.dat:3765:108227:    
../inputs/grep1.dat:3766:108232:  store_op2 (op, loc, arg1, arg2);
../inputs/grep1.dat:3767:108267:}
../inputs/grep1.dat:3768:108269:
../inputs/grep1.dat:3769:108270:
../inputs/grep1.dat:3770:108271:/* P points to just after a ^ in PATTERN.  Return true if that ^ comes
../inputs/grep1.dat:3771:108342:   after an alternative or a begin-subexpression.  We assume there is at
../inputs/grep1.dat:3772:108415:   least one character before the ^.  */
../inputs/grep1.dat:3773:108456:
../inputs/grep1.dat:3774:108457:static boolean
../inputs/grep1.dat:3775:108472:at_begline_loc_p (pattern, p, syntax)
../inputs/grep1.dat:3776:108510:    const char *pattern, *p;
../inputs/grep1.dat:3777:108539:    reg_syntax_t syntax;
../inputs/grep1.dat:3778:108564:{
../inputs/grep1.dat:3779:108566:  const char *prev = p - 2;
../inputs/grep1.dat:3780:108594:  boolean prev_prev_backslash = prev > pattern && prev[-1] == '\\';
../inputs/grep1.dat:3781:108662:  
../inputs/grep1.dat:3782:108665:  return
../inputs/grep1.dat:3783:108674:       /* After a subexpression?  */
../inputs/grep1.dat:3784:108711:       (*prev == '(' && (syntax & RE_NO_BK_PARENS || prev_prev_backslash))
../inputs/grep1.dat:3785:108786:       /* After an alternative?  */
../inputs/grep1.dat:3786:108822:    || (*prev == '|' && (syntax & RE_NO_BK_VBAR || prev_prev_backslash));
../inputs/grep1.dat:3787:108896:}
../inputs/grep1.dat:3788:108898:
../inputs/grep1.dat:3789:108899:
../inputs/grep1.dat:3790:108900:/* The dual of at_begline_loc_p.  This one is for $.  We assume there is
../inputs/grep1.dat:3791:108973:   at least one character after the $, i.e., `P < PEND'.  */
../inputs/grep1.dat:3792:109034:
../inputs/grep1.dat:3793:109035:static boolean
../inputs/grep1.dat:3794:109050:at_endline_loc_p (p, pend, syntax)
../inputs/grep1.dat:3795:109085:    const char *p, *pend;
../inputs/grep1.dat:3796:109111:    int syntax;
../inputs/grep1.dat:3797:109127:{
../inputs/grep1.dat:3798:109129:  const char *next = p;
../inputs/grep1.dat:3799:109153:  boolean next_backslash = *next == '\\';
../inputs/grep1.dat:3800:109195:  const char *next_next = p + 1 < pend ? p + 1 : NULL;
../inputs/grep1.dat:3801:109250:  
../inputs/grep1.dat:3802:109253:  return
../inputs/grep1.dat:3803:109262:       /* Before a subexpression?  */
../inputs/grep1.dat:3804:109300:       (syntax & RE_NO_BK_PARENS ? *next == ')'
../inputs/grep1.dat:3805:109348:        : next_backslash && next_next && *next_next == ')')
../inputs/grep1.dat:3806:109408:       /* Before an alternative?  */
../inputs/grep1.dat:3807:109445:    || (syntax & RE_NO_BK_VBAR ? *next == '|'
../inputs/grep1.dat:3808:109491:        : next_backslash && next_next && *next_next == '|');
../inputs/grep1.dat:3809:109552:}
../inputs/grep1.dat:3810:109554:
../inputs/grep1.dat:3811:109555:
../inputs/grep1.dat:3812:109556:/* Returns true if REGNUM is in one of COMPILE_STACK's elements and 
../inputs/grep1.dat:3813:109625:   false if it's not.  */
../inputs/grep1.dat:3814:109651:
../inputs/grep1.dat:3815:109652:static boolean
../inputs/grep1.dat:3816:109667:group_in_compile_stack (compile_stack, regnum)
../inputs/grep1.dat:3817:109714:    compile_stack_type compile_stack;
../inputs/grep1.dat:3818:109752:    regnum_t regnum;
../inputs/grep1.dat:3819:109773:{
../inputs/grep1.dat:3820:109775:  int this_element;
../inputs/grep1.dat:3821:109795:
../inputs/grep1.dat:3822:109796:  for (this_element = compile_stack.avail - 1;  
../inputs/grep1.dat:3823:109845:       this_element >= 0; 
../inputs/grep1.dat:3824:109872:       this_element--)
../inputs/grep1.dat:3825:109895:    if (compile_stack.stack[this_element].regnum == regnum)
../inputs/grep1.dat:3826:109955:      return true;
../inputs/grep1.dat:3827:109974:
../inputs/grep1.dat:3828:109975:  return false;
../inputs/grep1.dat:3829:109991:}
../inputs/grep1.dat:3830:109993:
../inputs/grep1.dat:3831:109994:
../inputs/grep1.dat:3832:109995:/* Read the ending character of a range (in a bracket expression) from the
../inputs/grep1.dat:3833:110070:   uncompiled pattern *P_PTR (which ends at PEND).  We assume the
../inputs/grep1.dat:3834:110136:   starting character is in `P[-2]'.  (`P[-1]' is the character `-'.)
../inputs/grep1.dat:3835:110206:   Then we set the translation of all bits between the starting and
../inputs/grep1.dat:3836:110274:   ending characters (inclusive) in the compiled pattern B.
../inputs/grep1.dat:3837:110334:   
../inputs/grep1.dat:3838:110338:   Return an error code.
../inputs/grep1.dat:3839:110363:   
../inputs/grep1.dat:3840:110367:   We use these short variable names so we can use the same macros as
../inputs/grep1.dat:3841:110437:   `regex_compile' itself.  */
../inputs/grep1.dat:3842:110468:
../inputs/grep1.dat:3843:110469:static reg_errcode_t
../inputs/grep1.dat:3844:110490:compile_range (p_ptr, pend, translate, syntax, b)
../inputs/grep1.dat:3845:110540:    const char **p_ptr, *pend;
../inputs/grep1.dat:3846:110571:    char *translate;
../inputs/grep1.dat:3847:110592:    reg_syntax_t syntax;
../inputs/grep1.dat:3848:110617:    unsigned char *b;
../inputs/grep1.dat:3849:110639:{
../inputs/grep1.dat:3850:110641:  unsigned this_char;
../inputs/grep1.dat:3851:110663:
../inputs/grep1.dat:3852:110664:  const char *p = *p_ptr;
../inputs/grep1.dat:3853:110690:  int range_start, range_end;
../inputs/grep1.dat:3854:110720:  
../inputs/grep1.dat:3855:110723:  if (p == pend)
../inputs/grep1.dat:3856:110740:    return REG_ERANGE;
../inputs/grep1.dat:3857:110763:
../inputs/grep1.dat:3858:110764:  /* Even though the pattern is a signed `char *', we need to fetch
../inputs/grep1.dat:3859:110832:     with unsigned char *'s; if the high bit of the pattern character
../inputs/grep1.dat:3860:110902:     is set, the range endpoints will be negative if we fetch using a
../inputs/grep1.dat:3861:110972:     signed char *.
../inputs/grep1.dat:3862:110992:
../inputs/grep1.dat:3863:110993:     We also want to fetch the endpoints without translating them; the 
../inputs/grep1.dat:3864:111065:     appropriate translation is done in the bit-setting loop below.  */
../inputs/grep1.dat:3865:111137:  range_start = ((unsigned char *) p)[-2];
../inputs/grep1.dat:3866:111180:  range_end   = ((unsigned char *) p)[0];
../inputs/grep1.dat:3867:111222:
../inputs/grep1.dat:3868:111223:  /* Have to increment the pointer into the pattern string, so the
../inputs/grep1.dat:3869:111290:     caller isn't still at the ending character.  */
../inputs/grep1.dat:3870:111343:  (*p_ptr)++;
../inputs/grep1.dat:3871:111357:
../inputs/grep1.dat:3872:111358:  /* If the start is after the end, the range is empty.  */
../inputs/grep1.dat:3873:111418:  if (range_start > range_end)
../inputs/grep1.dat:3874:111449:    return syntax & RE_NO_EMPTY_RANGES ? REG_ERANGE : REG_NOERROR;
../inputs/grep1.dat:3875:111516:
../inputs/grep1.dat:3876:111517:  /* Here we see why `this_char' has to be larger than an `unsigned
../inputs/grep1.dat:3877:111585:     char' -- the range is inclusive, so if `range_end' == 0xff
../inputs/grep1.dat:3878:111649:     (assuming 8-bit characters), we would otherwise go into an infinite
../inputs/grep1.dat:3879:111722:     loop, since all characters <= 0xff.  */
../inputs/grep1.dat:3880:111767:  for (this_char = range_start; this_char <= range_end; this_char++)
../inputs/grep1.dat:3881:111836:    {
../inputs/grep1.dat:3882:111842:      SET_LIST_BIT (TRANSLATE (this_char));
../inputs/grep1.dat:3883:111886:    }
../inputs/grep1.dat:3884:111892:  
../inputs/grep1.dat:3885:111895:  return REG_NOERROR;
../inputs/grep1.dat:3886:111917:}
../inputs/grep1.dat:3887:111919:
../inputs/grep1.dat:3888:111921:/* Failure stack declarations and macros; both re_compile_fastmap and
../inputs/grep1.dat:3889:111991:   re_match_2 use a failure stack.  These have to be macros because of
../inputs/grep1.dat:3890:112062:   REGEX_ALLOCATE.  */
../inputs/grep1.dat:3891:112085:   
../inputs/grep1.dat:3892:112089:
../inputs/grep1.dat:3893:112090:/* Number of failure points for which to initially allocate space
../inputs/grep1.dat:3894:112156:   when matching.  If this number is exceeded, we allocate more
../inputs/grep1.dat:3895:112220:   space, so it is not a hard limit.  */
../inputs/grep1.dat:3896:112261:#ifndef INIT_FAILURE_ALLOC
../inputs/grep1.dat:3897:112288:#define INIT_FAILURE_ALLOC 5
../inputs/grep1.dat:3898:112317:#endif
../inputs/grep1.dat:3899:112324:
../inputs/grep1.dat:3900:112325:/* Roughly the maximum number of failure points on the stack.  Would be
../inputs/grep1.dat:3901:112397:   exactly that if always used MAX_FAILURE_SPACE each time we failed.
../inputs/grep1.dat:3902:112467:   This is a variable only so users of regex can assign to it; we never
../inputs/grep1.dat:3903:112539:   change it ourselves.  */
../inputs/grep1.dat:3904:112567:int re_max_failures = 2000;
../inputs/grep1.dat:3905:112595:
../inputs/grep1.dat:3906:112596:typedef const unsigned char *fail_stack_elt_t;
../inputs/grep1.dat:3907:112643:
../inputs/grep1.dat:3908:112644:typedef struct
../inputs/grep1.dat:3909:112659:{
../inputs/grep1.dat:3910:112661:  fail_stack_elt_t *stack;
../inputs/grep1.dat:3911:112688:  unsigned size;
../inputs/grep1.dat:3912:112705:  unsigned avail;			/* Offset of next open position.  */
../inputs/grep1.dat:3913:112762:} fail_stack_type;
../inputs/grep1.dat:3914:112781:
../inputs/grep1.dat:3915:112782:#define FAIL_STACK_EMPTY()     (fail_stack.avail == 0)
../inputs/grep1.dat:3916:112837:#define FAIL_STACK_PTR_EMPTY() (fail_stack_ptr->avail == 0)
../inputs/grep1.dat:3917:112897:#define FAIL_STACK_FULL()      (fail_stack.avail == fail_stack.size)
../inputs/grep1.dat:3918:112966:#define FAIL_STACK_TOP()       (fail_stack.stack[fail_stack.avail])
../inputs/grep1.dat:3919:113034:
../inputs/grep1.dat:3920:113035:
../inputs/grep1.dat:3921:113036:/* Initialize `fail_stack'.  Do `return -2' if the alloc fails.  */
../inputs/grep1.dat:3922:113104:
../inputs/grep1.dat:3923:113105:#define INIT_FAIL_STACK()						\
../inputs/grep1.dat:3924:113138:  do {									\
../inputs/grep1.dat:3925:113155:    fail_stack.stack = (fail_stack_elt_t *)				\
../inputs/grep1.dat:3926:113204:      REGEX_ALLOCATE (INIT_FAILURE_ALLOC * sizeof (fail_stack_elt_t));	\
../inputs/grep1.dat:3927:113277:									\
../inputs/grep1.dat:3928:113288:    if (fail_stack.stack == NULL)					\
../inputs/grep1.dat:3929:113328:      return -2;							\
../inputs/grep1.dat:3930:113353:									\
../inputs/grep1.dat:3931:113364:    fail_stack.size = INIT_FAILURE_ALLOC;				\
../inputs/grep1.dat:3932:113411:    fail_stack.avail = 0;						\
../inputs/grep1.dat:3933:113444:  } while (0)
../inputs/grep1.dat:3934:113458:
../inputs/grep1.dat:3935:113459:
../inputs/grep1.dat:3936:113460:/* Double the size of FAIL_STACK, up to approximately `re_max_failures' items.
../inputs/grep1.dat:3937:113539:
../inputs/grep1.dat:3938:113540:   Return 1 if succeeds, and 0 if either ran out of memory
../inputs/grep1.dat:3939:113599:   allocating space for it or it was already too large.  
../inputs/grep1.dat:3940:113657:   
../inputs/grep1.dat:3941:113661:   REGEX_REALLOCATE requires `destination' be declared.   */
../inputs/grep1.dat:3942:113722:
../inputs/grep1.dat:3943:113723:#define DOUBLE_FAIL_STACK(fail_stack)					\
../inputs/grep1.dat:3944:113767:  ((fail_stack).size > re_max_failures * MAX_FAILURE_ITEMS		\
../inputs/grep1.dat:3945:113829:   ? 0									\
../inputs/grep1.dat:3946:113846:   : ((fail_stack).stack = (fail_stack_elt_t *)				\
../inputs/grep1.dat:3947:113899:        REGEX_REALLOCATE ((fail_stack).stack, 				\
../inputs/grep1.dat:3948:113951:          (fail_stack).size * sizeof (fail_stack_elt_t),		\
../inputs/grep1.dat:3949:114011:          ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),	\
../inputs/grep1.dat:3950:114078:									\
../inputs/grep1.dat:3951:114089:      (fail_stack).stack == NULL					\
../inputs/grep1.dat:3952:114128:      ? 0								\
../inputs/grep1.dat:3953:114147:      : ((fail_stack).size <<= 1, 					\
../inputs/grep1.dat:3954:114188:         1)))
../inputs/grep1.dat:3955:114202:
../inputs/grep1.dat:3956:114203:
../inputs/grep1.dat:3957:114204:/* Push PATTERN_OP on FAIL_STACK. 
../inputs/grep1.dat:3958:114239:
../inputs/grep1.dat:3959:114240:   Return 1 if was able to do so and 0 if ran out of memory allocating
../inputs/grep1.dat:3960:114311:   space to do so.  */
../inputs/grep1.dat:3961:114334:#define PUSH_PATTERN_OP(pattern_op, fail_stack)				\
../inputs/grep1.dat:3962:114387:  ((FAIL_STACK_FULL ()							\
../inputs/grep1.dat:3963:114418:    && !DOUBLE_FAIL_STACK (fail_stack))					\
../inputs/grep1.dat:3964:114464:    ? 0									\
../inputs/grep1.dat:3965:114482:    : ((fail_stack).stack[(fail_stack).avail++] = pattern_op,		\
../inputs/grep1.dat:3966:114547:       1))
../inputs/grep1.dat:3967:114558:
../inputs/grep1.dat:3968:114559:/* This pushes an item onto the failure stack.  Must be a four-byte
../inputs/grep1.dat:3969:114627:   value.  Assumes the variable `fail_stack'.  Probably should only
../inputs/grep1.dat:3970:114695:   be called from within `PUSH_FAILURE_POINT'.  */
../inputs/grep1.dat:3971:114746:#define PUSH_FAILURE_ITEM(item)						\
../inputs/grep1.dat:3972:114785:  fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) item
../inputs/grep1.dat:3973:114850:
../inputs/grep1.dat:3974:114851:/* The complement operation.  Assumes `fail_stack' is nonempty.  */
../inputs/grep1.dat:3975:114919:#define POP_FAILURE_ITEM() fail_stack.stack[--fail_stack.avail]
../inputs/grep1.dat:3976:114983:
../inputs/grep1.dat:3977:114984:/* Used to omit pushing failure point id's when we're not debugging.  */
../inputs/grep1.dat:3978:115057:#ifdef DEBUG
../inputs/grep1.dat:3979:115070:#define DEBUG_PUSH PUSH_FAILURE_ITEM
../inputs/grep1.dat:3980:115107:#define DEBUG_POP(item_addr) *(item_addr) = POP_FAILURE_ITEM ()
../inputs/grep1.dat:3981:115171:#else
../inputs/grep1.dat:3982:115177:#define DEBUG_PUSH(item)
../inputs/grep1.dat:3983:115202:#define DEBUG_POP(item_addr)
../inputs/grep1.dat:3984:115231:#endif
../inputs/grep1.dat:3985:115238:
../inputs/grep1.dat:3986:115239:
../inputs/grep1.dat:3987:115240:/* Push the information about the state we will need
../inputs/grep1.dat:3988:115293:   if we ever fail back to it.  
../inputs/grep1.dat:3989:115326:   
../inputs/grep1.dat:3990:115330:   Requires variables fail_stack, regstart, regend, reg_info, and
../inputs/grep1.dat:3991:115396:   num_regs be declared.  DOUBLE_FAIL_STACK requires `destination' be
../inputs/grep1.dat:3992:115466:   declared.
../inputs/grep1.dat:3993:115479:   
../inputs/grep1.dat:3994:115483:   Does `return FAILURE_CODE' if runs out of memory.  */
../inputs/grep1.dat:3995:115540:
../inputs/grep1.dat:3996:115541:#define PUSH_FAILURE_POINT(pattern_place, string_place, failure_code)	\
../inputs/grep1.dat:3997:115613:  do {									\
../inputs/grep1.dat:3998:115630:    char *destination;							\
../inputs/grep1.dat:3999:115661:    /* Must be int, so when we don't save any registers, the arithmetic	\
../inputs/grep1.dat:4000:115735:       of 0 + -1 isn't done as unsigned.  */				\
../inputs/grep1.dat:4001:115785:    int this_reg;							\
../inputs/grep1.dat:4002:115811:    									\
../inputs/grep1.dat:4003:115826:    DEBUG_STATEMENT (failure_id++);					\
../inputs/grep1.dat:4004:115868:    DEBUG_STATEMENT (nfailure_points_pushed++);				\
../inputs/grep1.dat:4005:115921:    DEBUG_PRINT2 ("\nPUSH_FAILURE_POINT #%u:\n", failure_id);		\
../inputs/grep1.dat:4006:115986:    DEBUG_PRINT2 ("  Before push, next avail: %d\n", (fail_stack).avail);\
../inputs/grep1.dat:4007:116061:    DEBUG_PRINT2 ("                     size: %d\n", (fail_stack).size);\
../inputs/grep1.dat:4008:116135:									\
../inputs/grep1.dat:4009:116146:    DEBUG_PRINT2 ("  slots needed: %d\n", NUM_FAILURE_ITEMS);		\
../inputs/grep1.dat:4010:116211:    DEBUG_PRINT2 ("     available: %d\n", REMAINING_AVAIL_SLOTS);	\
../inputs/grep1.dat:4011:116279:									\
../inputs/grep1.dat:4012:116290:    /* Ensure we have enough space allocated for what we will push.  */	\
../inputs/grep1.dat:4013:116364:    while (REMAINING_AVAIL_SLOTS < NUM_FAILURE_ITEMS)			\
../inputs/grep1.dat:4014:116422:      {									\
../inputs/grep1.dat:4015:116440:        if (!DOUBLE_FAIL_STACK (fail_stack))			\
../inputs/grep1.dat:4016:116489:          return failure_code;						\
../inputs/grep1.dat:4017:116527:									\
../inputs/grep1.dat:4018:116538:        DEBUG_PRINT2 ("\n  Doubled stack; size now: %d\n",		\
../inputs/grep1.dat:4019:116600:		       (fail_stack).size);				\
../inputs/grep1.dat:4020:116634:        DEBUG_PRINT2 ("  slots available: %d\n", REMAINING_AVAIL_SLOTS);\
../inputs/grep1.dat:4021:116708:      }									\
../inputs/grep1.dat:4022:116726:									\
../inputs/grep1.dat:4023:116737:    /* Push the info, starting with the registers.  */			\
../inputs/grep1.dat:4024:116796:    DEBUG_PRINT1 ("\n");						\
../inputs/grep1.dat:4025:116828:									\
../inputs/grep1.dat:4026:116839:    for (this_reg = lowest_active_reg; this_reg <= highest_active_reg;	\
../inputs/grep1.dat:4027:116912:         this_reg++)							\
../inputs/grep1.dat:4028:116941:      {									\
../inputs/grep1.dat:4029:116959:	DEBUG_PRINT2 ("  Pushing reg: %d\n", this_reg);			\
../inputs/grep1.dat:4030:117012:        DEBUG_STATEMENT (num_regs_pushed++);				\
../inputs/grep1.dat:4031:117062:									\
../inputs/grep1.dat:4032:117073:	DEBUG_PRINT2 ("    start: 0x%x\n", regstart[this_reg]);		\
../inputs/grep1.dat:4033:117133:        PUSH_FAILURE_ITEM (regstart[this_reg]);				\
../inputs/grep1.dat:4034:117186:                                                                        \
../inputs/grep1.dat:4035:117260:	DEBUG_PRINT2 ("    end: 0x%x\n", regend[this_reg]);		\
../inputs/grep1.dat:4036:117316:        PUSH_FAILURE_ITEM (regend[this_reg]);				\
../inputs/grep1.dat:4037:117367:									\
../inputs/grep1.dat:4038:117378:	DEBUG_PRINT2 ("    info: 0x%x\n      ", reg_info[this_reg]);	\
../inputs/grep1.dat:4039:117442:        DEBUG_PRINT2 (" match_null=%d",					\
../inputs/grep1.dat:4040:117488:                      REG_MATCH_NULL_STRING_P (reg_info[this_reg]));	\
../inputs/grep1.dat:4041:117559:        DEBUG_PRINT2 (" active=%d", IS_ACTIVE (reg_info[this_reg]));	\
../inputs/grep1.dat:4042:117630:        DEBUG_PRINT2 (" matched_something=%d",				\
../inputs/grep1.dat:4043:117682:                      MATCHED_SOMETHING (reg_info[this_reg]));		\
../inputs/grep1.dat:4044:117748:        DEBUG_PRINT2 (" ever_matched=%d",				\
../inputs/grep1.dat:4045:117795:                      EVER_MATCHED_SOMETHING (reg_info[this_reg]));	\
../inputs/grep1.dat:4046:117865:	DEBUG_PRINT1 ("\n");						\
../inputs/grep1.dat:4047:117894:        PUSH_FAILURE_ITEM (reg_info[this_reg].word);			\
../inputs/grep1.dat:4048:117951:      }									\
../inputs/grep1.dat:4049:117969:									\
../inputs/grep1.dat:4050:117980:    DEBUG_PRINT2 ("  Pushing  low active reg: %d\n", lowest_active_reg);\
../inputs/grep1.dat:4051:118054:    PUSH_FAILURE_ITEM (lowest_active_reg);				\
../inputs/grep1.dat:4052:118102:									\
../inputs/grep1.dat:4053:118113:    DEBUG_PRINT2 ("  Pushing high active reg: %d\n", highest_active_reg);\
../inputs/grep1.dat:4054:118188:    PUSH_FAILURE_ITEM (highest_active_reg);				\
../inputs/grep1.dat:4055:118237:									\
../inputs/grep1.dat:4056:118248:    DEBUG_PRINT2 ("  Pushing pattern 0x%x: ", pattern_place);		\
../inputs/grep1.dat:4057:118313:    DEBUG_PRINT_COMPILED_PATTERN (bufp, pattern_place, pend);		\
../inputs/grep1.dat:4058:118378:    PUSH_FAILURE_ITEM (pattern_place);					\
../inputs/grep1.dat:4059:118423:									\
../inputs/grep1.dat:4060:118434:    DEBUG_PRINT2 ("  Pushing string 0x%x: `", string_place);		\
../inputs/grep1.dat:4061:118498:    DEBUG_PRINT_DOUBLE_STRING (string_place, string1, size1, string2,   \
../inputs/grep1.dat:4062:118572:				 size2);				\
../inputs/grep1.dat:4063:118590:    DEBUG_PRINT1 ("'\n");						\
../inputs/grep1.dat:4064:118623:    PUSH_FAILURE_ITEM (string_place);					\
../inputs/grep1.dat:4065:118667:									\
../inputs/grep1.dat:4066:118678:    DEBUG_PRINT2 ("  Pushing failure id: %u\n", failure_id);		\
../inputs/grep1.dat:4067:118742:    DEBUG_PUSH (failure_id);						\
../inputs/grep1.dat:4068:118778:  } while (0)
../inputs/grep1.dat:4069:118792:
../inputs/grep1.dat:4070:118793:/* This is the number of items that are pushed and popped on the stack
../inputs/grep1.dat:4071:118864:   for each register.  */
../inputs/grep1.dat:4072:118890:#define NUM_REG_ITEMS  3
../inputs/grep1.dat:4073:118915:
../inputs/grep1.dat:4074:118916:/* Individual items aside from the registers.  */
../inputs/grep1.dat:4075:118966:#ifdef DEBUG
../inputs/grep1.dat:4077:119040:#else
../inputs/grep1.dat:4078:119046:#define NUM_NONREG_ITEMS 4
../inputs/grep1.dat:4079:119073:#endif
../inputs/grep1.dat:4080:119080:
../inputs/grep1.dat:4081:119081:/* We push at most this many items on the stack.  */
../inputs/grep1.dat:4082:119134:#define MAX_FAILURE_ITEMS ((num_regs - 1) * NUM_REG_ITEMS + NUM_NONREG_ITEMS)
../inputs/grep1.dat:4083:119212:
../inputs/grep1.dat:4084:119213:/* We actually push this many items.  */
../inputs/grep1.dat:4085:119254:#define NUM_FAILURE_ITEMS						\
../inputs/grep1.dat:4086:119287:  ((highest_active_reg - lowest_active_reg + 1) * NUM_REG_ITEMS 	\
../inputs/grep1.dat:4087:119354:    + NUM_NONREG_ITEMS)
../inputs/grep1.dat:4088:119378:
../inputs/grep1.dat:4089:119379:/* How many items can still be added to the stack without overflowing it.  */
../inputs/grep1.dat:4090:119457:#define REMAINING_AVAIL_SLOTS ((fail_stack).size - (fail_stack).avail)
../inputs/grep1.dat:4091:119528:
../inputs/grep1.dat:4092:119529:
../inputs/grep1.dat:4093:119530:/* Pops what PUSH_FAIL_STACK pushes.
../inputs/grep1.dat:4094:119567:
../inputs/grep1.dat:4095:119568:   We restore into the parameters, all of which should be lvalues:
../inputs/grep1.dat:4096:119635:     STR -- the saved data position.
../inputs/grep1.dat:4097:119672:     PAT -- the saved pattern position.
../inputs/grep1.dat:4098:119712:     LOW_REG, HIGH_REG -- the highest and lowest active registers.
../inputs/grep1.dat:4099:119779:     REGSTART, REGEND -- arrays of string positions.
../inputs/grep1.dat:4100:119832:     REG_INFO -- array of information about each subexpression.
../inputs/grep1.dat:4101:119896:   
../inputs/grep1.dat:4102:119900:   Also assumes the variables `fail_stack' and (if debugging), `bufp',
../inputs/grep1.dat:4103:119971:   `pend', `string1', `size1', `string2', and `size2'.  */
../inputs/grep1.dat:4104:120030:
../inputs/grep1.dat:4105:120031:#define POP_FAILURE_POINT(str, pat, low_reg, high_reg, regstart, regend, reg_info)\
../inputs/grep1.dat:4106:120115:{									\
../inputs/grep1.dat:4107:120127:  DEBUG_STATEMENT (fail_stack_elt_t failure_id;)			\
../inputs/grep1.dat:4108:120180:  int this_reg;								\
../inputs/grep1.dat:4109:120205:  const unsigned char *string_temp;					\
../inputs/grep1.dat:4110:120247:									\
../inputs/grep1.dat:4111:120258:  assert (!FAIL_STACK_EMPTY ());					\
../inputs/grep1.dat:4112:120297:									\
../inputs/grep1.dat:4113:120308:  /* Remove failure points and point to how many regs pushed.  */	\
../inputs/grep1.dat:4114:120376:  DEBUG_PRINT1 ("POP_FAILURE_POINT:\n");				\
../inputs/grep1.dat:4115:120422:  DEBUG_PRINT2 ("  Before pop, next avail: %d\n", fail_stack.avail);	\
../inputs/grep1.dat:4116:120493:  DEBUG_PRINT2 ("                    size: %d\n", fail_stack.size);	\
../inputs/grep1.dat:4117:120563:									\
../inputs/grep1.dat:4118:120574:  assert (fail_stack.avail >= NUM_NONREG_ITEMS);			\
../inputs/grep1.dat:4119:120627:									\
../inputs/grep1.dat:4120:120638:  DEBUG_POP (&failure_id);						\
../inputs/grep1.dat:4121:120672:  DEBUG_PRINT2 ("  Popping failure id: %u\n", failure_id);		\
../inputs/grep1.dat:4122:120734:									\
../inputs/grep1.dat:4123:120745:  /* If the saved string location is NULL, it came from an		\
../inputs/grep1.dat:4124:120807:     on_failure_keep_string_jump opcode, and we want to throw away the	\
../inputs/grep1.dat:4125:120880:     saved NULL, thus retaining our current position in the string.  */	\
../inputs/grep1.dat:4126:120954:  string_temp = POP_FAILURE_ITEM ();					\
../inputs/grep1.dat:4127:120997:  if (string_temp != NULL)						\
../inputs/grep1.dat:4128:121031:    str = (const char *) string_temp;					\
../inputs/grep1.dat:4129:121075:									\
../inputs/grep1.dat:4130:121086:  DEBUG_PRINT2 ("  Popping string 0x%x: `", str);			\
../inputs/grep1.dat:4131:121140:  DEBUG_PRINT_DOUBLE_STRING (str, string1, size1, string2, size2);	\
../inputs/grep1.dat:4132:121209:  DEBUG_PRINT1 ("'\n");							\
../inputs/grep1.dat:4133:121241:									\
../inputs/grep1.dat:4134:121252:  pat = (unsigned char *) POP_FAILURE_ITEM ();				\
../inputs/grep1.dat:4135:121304:  DEBUG_PRINT2 ("  Popping pattern 0x%x: ", pat);			\
../inputs/grep1.dat:4136:121358:  DEBUG_PRINT_COMPILED_PATTERN (bufp, pat, pend);			\
../inputs/grep1.dat:4137:121412:									\
../inputs/grep1.dat:4138:121423:  /* Restore register info.  */						\
../inputs/grep1.dat:4139:121462:  high_reg = (unsigned) POP_FAILURE_ITEM ();				\
../inputs/grep1.dat:4140:121512:  DEBUG_PRINT2 ("  Popping high active reg: %d\n", high_reg);		\
../inputs/grep1.dat:4141:121577:									\
../inputs/grep1.dat:4142:121588:  low_reg = (unsigned) POP_FAILURE_ITEM ();				\
../inputs/grep1.dat:4143:121637:  DEBUG_PRINT2 ("  Popping  low active reg: %d\n", low_reg);		\
../inputs/grep1.dat:4144:121701:									\
../inputs/grep1.dat:4145:121712:  for (this_reg = high_reg; this_reg >= low_reg; this_reg--)		\
../inputs/grep1.dat:4146:121776:    {									\
../inputs/grep1.dat:4147:121792:      DEBUG_PRINT2 ("    Popping reg: %d\n", this_reg);			\
../inputs/grep1.dat:4148:121852:									\
../inputs/grep1.dat:4149:121863:      reg_info[this_reg].word = POP_FAILURE_ITEM ();			\
../inputs/grep1.dat:4150:121920:      DEBUG_PRINT2 ("      info: 0x%x\n", reg_info[this_reg]);		\
../inputs/grep1.dat:4151:121986:									\
../inputs/grep1.dat:4152:121997:      regend[this_reg] = (const char *) POP_FAILURE_ITEM ();		\
../inputs/grep1.dat:4153:122061:      DEBUG_PRINT2 ("      end: 0x%x\n", regend[this_reg]);		\
../inputs/grep1.dat:4154:122124:									\
../inputs/grep1.dat:4155:122135:      regstart[this_reg] = (const char *) POP_FAILURE_ITEM ();		\
../inputs/grep1.dat:4156:122201:      DEBUG_PRINT2 ("      start: 0x%x\n", regstart[this_reg]);		\
../inputs/grep1.dat:4157:122268:    }									\
../inputs/grep1.dat:4158:122284:									\
../inputs/grep1.dat:4159:122295:  DEBUG_STATEMENT (nfailure_points_popped++);				\
../inputs/grep1.dat:4160:122346:} /* POP_FAILURE_POINT */
../inputs/grep1.dat:4161:122372:
../inputs/grep1.dat:4162:122374:/* re_compile_fastmap computes a ``fastmap'' for the compiled pattern in
../inputs/grep1.dat:4163:122447:   BUFP.  A fastmap records which of the (1 << BYTEWIDTH) possible
../inputs/grep1.dat:4164:122514:   characters can start a string that matches the pattern.  This fastmap
../inputs/grep1.dat:4165:122587:   is used by re_search to skip quickly over impossible starting points.
../inputs/grep1.dat:4166:122660:
../inputs/grep1.dat:4167:122661:   The caller must supply the address of a (1 << BYTEWIDTH)-byte data
../inputs/grep1.dat:4168:122731:   area as BUFP->fastmap.
../inputs/grep1.dat:4169:122757:   
../inputs/grep1.dat:4170:122761:   We set the `fastmap', `fastmap_accurate', and `can_be_null' fields in
../inputs/grep1.dat:4171:122834:   the pattern buffer.
../inputs/grep1.dat:4172:122857:
../inputs/grep1.dat:4173:122858:   Returns 0 if we succeed, -2 if an internal error.   */
../inputs/grep1.dat:4174:122916:
../inputs/grep1.dat:4175:122917:int
../inputs/grep1.dat:4176:122921:re_compile_fastmap (bufp)
../inputs/grep1.dat:4177:122947:     struct re_pattern_buffer *bufp;
../inputs/grep1.dat:4178:122984:{
../inputs/grep1.dat:4179:122986:  int j, k;
../inputs/grep1.dat:4180:122998:  fail_stack_type fail_stack;
../inputs/grep1.dat:4181:123028:#ifndef REGEX_MALLOC
../inputs/grep1.dat:4182:123049:  char *destination;
../inputs/grep1.dat:4183:123070:#endif
../inputs/grep1.dat:4184:123077:  /* We don't push any register information onto the failure stack.  */
../inputs/grep1.dat:4185:123149:  unsigned num_regs = 0;
../inputs/grep1.dat:4186:123174:  
../inputs/grep1.dat:4187:123177:  register char *fastmap = bufp->fastmap;
../inputs/grep1.dat:4188:123219:  unsigned char *pattern = bufp->buffer;
../inputs/grep1.dat:4189:123260:  unsigned long size = bufp->used;
../inputs/grep1.dat:4190:123295:  const unsigned char *p = pattern;
../inputs/grep1.dat:4191:123331:  register unsigned char *pend = pattern + size;
../inputs/grep1.dat:4192:123380:
../inputs/grep1.dat:4193:123381:  /* Assume that each path through the pattern can be null until
../inputs/grep1.dat:4194:123446:     proven otherwise.  We set this false at the bottom of switch
../inputs/grep1.dat:4195:123512:     statement, to which we get only if a particular path doesn't
../inputs/grep1.dat:4196:123578:     match the empty string.  */
../inputs/grep1.dat:4197:123611:  boolean path_can_be_null = true;
../inputs/grep1.dat:4198:123646:
../inputs/grep1.dat:4199:123647:  /* We aren't doing a `succeed_n' to begin with.  */
../inputs/grep1.dat:4200:123701:  boolean succeed_n_p = false;
../inputs/grep1.dat:4201:123732:
../inputs/grep1.dat:4202:123733:  assert (fastmap != NULL && p != NULL);
../inputs/grep1.dat:4203:123774:  
../inputs/grep1.dat:4204:123777:  INIT_FAIL_STACK ();
../inputs/grep1.dat:4205:123799:  bzero (fastmap, 1 << BYTEWIDTH);  /* Assume nothing's valid.  */
../inputs/grep1.dat:4206:123866:  bufp->fastmap_accurate = 1;	    /* It will be when we're done.  */
../inputs/grep1.dat:4207:123935:  bufp->can_be_null = 0;
../inputs/grep1.dat:4208:123960:      
../inputs/grep1.dat:4209:123967:  while (p != pend || !FAIL_STACK_EMPTY ())
../inputs/grep1.dat:4210:124011:    {
../inputs/grep1.dat:4211:124017:      if (p == pend)
../inputs/grep1.dat:4212:124038:        {
../inputs/grep1.dat:4213:124048:          bufp->can_be_null |= path_can_be_null;
../inputs/grep1.dat:4214:124097:          
../inputs/grep1.dat:4215:124108:          /* Reset for next path.  */
../inputs/grep1.dat:4216:124146:          path_can_be_null = true;
../inputs/grep1.dat:4217:124181:          
../inputs/grep1.dat:4218:124192:          p = fail_stack.stack[--fail_stack.avail];
../inputs/grep1.dat:4219:124244:	}
../inputs/grep1.dat:4220:124247:
../inputs/grep1.dat:4221:124248:      /* We should never be about to go beyond the end of the pattern.  */
../inputs/grep1.dat:4222:124323:      assert (p < pend);
../inputs/grep1.dat:4223:124348:      
../inputs/grep1.dat:4224:124355:#ifdef SWITCH_ENUM_BUG
../inputs/grep1.dat:4225:124378:      switch ((int) ((re_opcode_t) *p++))
../inputs/grep1.dat:4226:124420:#else
../inputs/grep1.dat:4227:124426:      switch ((re_opcode_t) *p++)
../inputs/grep1.dat:4228:124460:#endif
../inputs/grep1.dat:4229:124467:	{
../inputs/grep1.dat:4230:124470:
../inputs/grep1.dat:4231:124471:        /* I guess the idea here is to simply not bother with a fastmap
../inputs/grep1.dat:4232:124543:           if a backreference is used, since it's too hard to figure out
../inputs/grep1.dat:4233:124616:           the fastmap for the corresponding group.  Setting
../inputs/grep1.dat:4234:124677:           `can_be_null' stops `re_search_2' from using the fastmap, so
../inputs/grep1.dat:4235:124749:           that is all we do.  */
../inputs/grep1.dat:4236:124783:	case duplicate:
../inputs/grep1.dat:4237:124800:	  bufp->can_be_null = 1;
../inputs/grep1.dat:4238:124826:          return 0;
../inputs/grep1.dat:4239:124846:
../inputs/grep1.dat:4240:124847:
../inputs/grep1.dat:4241:124848:      /* Following are the cases which match a character.  These end
../inputs/grep1.dat:4242:124917:         with `break'.  */
../inputs/grep1.dat:4243:124944:
../inputs/grep1.dat:4244:124945:	case exactn:
../inputs/grep1.dat:4245:124959:          fastmap[p[1]] = 1;
../inputs/grep1.dat:4246:124988:	  break;
../inputs/grep1.dat:4247:124998:
../inputs/grep1.dat:4248:124999:
../inputs/grep1.dat:4249:125000:        case charset:
../inputs/grep1.dat:4250:125022:          for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
../inputs/grep1.dat:4251:125076:	    if (p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH)))
../inputs/grep1.dat:4252:125128:              fastmap[j] = 1;
../inputs/grep1.dat:4253:125158:	  break;
../inputs/grep1.dat:4254:125168:
../inputs/grep1.dat:4255:125169:
../inputs/grep1.dat:4256:125170:	case charset_not:
../inputs/grep1.dat:4257:125189:	  /* Chars beyond end of map must be allowed.  */
../inputs/grep1.dat:4258:125240:	  for (j = *p * BYTEWIDTH; j < (1 << BYTEWIDTH); j++)
../inputs/grep1.dat:4259:125295:            fastmap[j] = 1;
../inputs/grep1.dat:4260:125323:
../inputs/grep1.dat:4261:125324:	  for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
../inputs/grep1.dat:4262:125371:	    if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))))
../inputs/grep1.dat:4263:125426:              fastmap[j] = 1;
../inputs/grep1.dat:4264:125456:          break;
../inputs/grep1.dat:4265:125473:
../inputs/grep1.dat:4266:125474:
../inputs/grep1.dat:4267:125475:	case wordchar:
../inputs/grep1.dat:4268:125491:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
../inputs/grep1.dat:4269:125533:	    if (SYNTAX (j) == Sword)
../inputs/grep1.dat:4270:125563:	      fastmap[j] = 1;
../inputs/grep1.dat:4271:125586:	  break;
../inputs/grep1.dat:4272:125596:
../inputs/grep1.dat:4273:125597:
../inputs/grep1.dat:4274:125598:	case notwordchar:
../inputs/grep1.dat:4275:125617:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
../inputs/grep1.dat:4276:125659:	    if (SYNTAX (j) != Sword)
../inputs/grep1.dat:4277:125689:	      fastmap[j] = 1;
../inputs/grep1.dat:4278:125712:	  break;
../inputs/grep1.dat:4279:125722:
../inputs/grep1.dat:4280:125723:
../inputs/grep1.dat:4281:125724:        case anychar:
../inputs/grep1.dat:4282:125746:          /* `.' matches anything ...  */
../inputs/grep1.dat:4283:125788:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
../inputs/grep1.dat:4284:125830:            fastmap[j] = 1;
../inputs/grep1.dat:4285:125858:
../inputs/grep1.dat:4286:125859:          /* ... except perhaps newline.  */
../inputs/grep1.dat:4287:125904:          if (!(bufp->syntax & RE_DOT_NEWLINE))
../inputs/grep1.dat:4288:125952:            fastmap['\n'] = 0;
../inputs/grep1.dat:4289:125983:
../inputs/grep1.dat:4290:125984:          /* Return if we have already set `can_be_null'; if we have,
../inputs/grep1.dat:4291:126054:             then the fastmap is irrelevant.  Something's wrong here.  */
../inputs/grep1.dat:4292:126128:	  else if (bufp->can_be_null)
../inputs/grep1.dat:4293:126159:	    return 0;
../inputs/grep1.dat:4294:126174:
../inputs/grep1.dat:4295:126175:          /* Otherwise, have to check alternative paths.  */
../inputs/grep1.dat:4296:126236:	  break;
../inputs/grep1.dat:4297:126246:
../inputs/grep1.dat:4298:126247:
../inputs/grep1.dat:4299:126248:#ifdef emacs
../inputs/grep1.dat:4300:126261:        case syntaxspec:
../inputs/grep1.dat:4301:126286:	  k = *p++;
../inputs/grep1.dat:4302:126299:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
../inputs/grep1.dat:4303:126341:	    if (SYNTAX (j) == (enum syntaxcode) k)
../inputs/grep1.dat:4304:126385:	      fastmap[j] = 1;
../inputs/grep1.dat:4305:126408:	  break;
../inputs/grep1.dat:4306:126418:
../inputs/grep1.dat:4307:126419:
../inputs/grep1.dat:4308:126420:	case notsyntaxspec:
../inputs/grep1.dat:4309:126441:	  k = *p++;
../inputs/grep1.dat:4310:126454:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
../inputs/grep1.dat:4311:126496:	    if (SYNTAX (j) != (enum syntaxcode) k)
../inputs/grep1.dat:4312:126540:	      fastmap[j] = 1;
../inputs/grep1.dat:4313:126563:	  break;
../inputs/grep1.dat:4314:126573:
../inputs/grep1.dat:4315:126574:
../inputs/grep1.dat:4316:126575:      /* All cases after this match the empty string.  These end with
../inputs/grep1.dat:4317:126645:         `continue'.  */
../inputs/grep1.dat:4318:126670:
../inputs/grep1.dat:4319:126671:
../inputs/grep1.dat:4320:126672:	case before_dot:
../inputs/grep1.dat:4321:126690:	case at_dot:
../inputs/grep1.dat:4322:126704:	case after_dot:
../inputs/grep1.dat:4323:126721:          continue;
../inputs/grep1.dat:4324:126741:#endif /* not emacs */
../inputs/grep1.dat:4325:126764:
../inputs/grep1.dat:4326:126765:
../inputs/grep1.dat:4327:126766:        case no_op:
../inputs/grep1.dat:4328:126786:        case begline:
../inputs/grep1.dat:4329:126808:        case endline:
../inputs/grep1.dat:4330:126830:	case begbuf:
../inputs/grep1.dat:4331:126844:	case endbuf:
../inputs/grep1.dat:4332:126858:	case wordbound:
../inputs/grep1.dat:4333:126875:	case notwordbound:
../inputs/grep1.dat:4334:126895:	case wordbeg:
../inputs/grep1.dat:4335:126910:	case wordend:
../inputs/grep1.dat:4336:126925:        case push_dummy_failure:
../inputs/grep1.dat:4337:126958:          continue;
../inputs/grep1.dat:4338:126978:
../inputs/grep1.dat:4339:126979:
../inputs/grep1.dat:4340:126980:	case jump_n:
../inputs/grep1.dat:4341:126994:        case pop_failure_jump:
../inputs/grep1.dat:4342:127025:	case maybe_pop_jump:
../inputs/grep1.dat:4343:127047:	case jump:
../inputs/grep1.dat:4344:127059:        case jump_past_alt:
../inputs/grep1.dat:4345:127087:	case dummy_failure_jump:
../inputs/grep1.dat:4346:127113:          EXTRACT_NUMBER_AND_INCR (j, p);
../inputs/grep1.dat:4347:127155:	  p += j;	
../inputs/grep1.dat:4348:127167:	  if (j > 0)
../inputs/grep1.dat:4349:127181:	    continue;
../inputs/grep1.dat:4350:127196:            
../inputs/grep1.dat:4351:127209:          /* Jump backward implies we just went through the body of a
../inputs/grep1.dat:4352:127279:             loop and matched nothing.  Opcode jumped to should be
../inputs/grep1.dat:4353:127346:             `on_failure_jump' or `succeed_n'.  Just treat it like an
../inputs/grep1.dat:4354:127416:             ordinary jump.  For a * loop, it has pushed its failure
../inputs/grep1.dat:4355:127485:             point already; if so, discard that as redundant.  */
../inputs/grep1.dat:4356:127551:          if ((re_opcode_t) *p != on_failure_jump
../inputs/grep1.dat:4357:127601:	      && (re_opcode_t) *p != succeed_n)
../inputs/grep1.dat:4358:127642:	    continue;
../inputs/grep1.dat:4359:127657:
../inputs/grep1.dat:4360:127658:          p++;
../inputs/grep1.dat:4361:127673:          EXTRACT_NUMBER_AND_INCR (j, p);
../inputs/grep1.dat:4362:127715:          p += j;		
../inputs/grep1.dat:4363:127735:	  
../inputs/grep1.dat:4364:127739:          /* If what's on the stack is where we are now, pop it.  */
../inputs/grep1.dat:4365:127808:          if (!FAIL_STACK_EMPTY () 
../inputs/grep1.dat:4366:127844:	      && fail_stack.stack[fail_stack.avail - 1] == p)
../inputs/grep1.dat:4367:127899:            fail_stack.avail--;
../inputs/grep1.dat:4368:127931:
../inputs/grep1.dat:4369:127932:          continue;
../inputs/grep1.dat:4370:127952:
../inputs/grep1.dat:4371:127953:
../inputs/grep1.dat:4372:127954:        case on_failure_jump:
../inputs/grep1.dat:4373:127984:        case on_failure_keep_string_jump:
../inputs/grep1.dat:4374:128026:	handle_on_failure_jump:
../inputs/grep1.dat:4375:128051:          EXTRACT_NUMBER_AND_INCR (j, p);
../inputs/grep1.dat:4376:128093:
../inputs/grep1.dat:4377:128094:          /* For some patterns, e.g., `(a?)?', `p+j' here points to the
../inputs/grep1.dat:4378:128166:             end of the pattern.  We don't want to push such a point,
../inputs/grep1.dat:4379:128236:             since when we restore it above, entering the switch will
../inputs/grep1.dat:4380:128306:             increment `p' past the end of the pattern.  We don't need
../inputs/grep1.dat:4381:128377:             to push such a point since we obviously won't find any more
../inputs/grep1.dat:4382:128450:             fastmap entries beyond `pend'.  Such a pattern can match
../inputs/grep1.dat:4383:128520:             the null string, though.  */
../inputs/grep1.dat:4384:128562:          if (p + j < pend)
../inputs/grep1.dat:4385:128590:            {
../inputs/grep1.dat:4386:128604:              if (!PUSH_PATTERN_OP (p + j, fail_stack))
../inputs/grep1.dat:4387:128660:                return -2;
../inputs/grep1.dat:4388:128687:            }
../inputs/grep1.dat:4389:128701:          else
../inputs/grep1.dat:4390:128716:            bufp->can_be_null = 1;
../inputs/grep1.dat:4391:128751:
../inputs/grep1.dat:4392:128752:          if (succeed_n_p)
../inputs/grep1.dat:4393:128779:            {
../inputs/grep1.dat:4394:128793:              EXTRACT_NUMBER_AND_INCR (k, p);	/* Skip the n.  */
../inputs/grep1.dat:4395:128858:              succeed_n_p = false;
../inputs/grep1.dat:4396:128893:	    }
../inputs/grep1.dat:4397:128900:
../inputs/grep1.dat:4398:128901:          continue;
../inputs/grep1.dat:4399:128921:
../inputs/grep1.dat:4400:128922:
../inputs/grep1.dat:4401:128923:	case succeed_n:
../inputs/grep1.dat:4402:128940:          /* Get to the number of times to succeed.  */
../inputs/grep1.dat:4403:128996:          p += 2;		
../inputs/grep1.dat:4404:129016:
../inputs/grep1.dat:4405:129017:          /* Increment p past the n for when k != 0.  */
../inputs/grep1.dat:4406:129074:          EXTRACT_NUMBER_AND_INCR (k, p);
../inputs/grep1.dat:4407:129116:          if (k == 0)
../inputs/grep1.dat:4408:129138:	    {
../inputs/grep1.dat:4409:129145:              p -= 4;
../inputs/grep1.dat:4410:129167:  	      succeed_n_p = true;  /* Spaghetti code alert.  */
../inputs/grep1.dat:4411:129226:              goto handle_on_failure_jump;
../inputs/grep1.dat:4412:129269:            }
../inputs/grep1.dat:4413:129283:          continue;
../inputs/grep1.dat:4414:129303:
../inputs/grep1.dat:4415:129304:
../inputs/grep1.dat:4416:129305:	case set_number_at:
../inputs/grep1.dat:4417:129326:          p += 4;
../inputs/grep1.dat:4418:129344:          continue;
../inputs/grep1.dat:4419:129364:
../inputs/grep1.dat:4420:129365:
../inputs/grep1.dat:4421:129366:	case start_memory:
../inputs/grep1.dat:4422:129386:        case stop_memory:
../inputs/grep1.dat:4423:129412:	  p += 2;
../inputs/grep1.dat:4424:129423:	  continue;
../inputs/grep1.dat:4425:129436:
../inputs/grep1.dat:4426:129437:
../inputs/grep1.dat:4427:129438:	default:
../inputs/grep1.dat:4428:129448:          abort (); /* We have listed all the cases.  */
../inputs/grep1.dat:4429:129505:        } /* switch *p++ */
../inputs/grep1.dat:4430:129533:
../inputs/grep1.dat:4431:129534:      /* Getting here means we have found the possible starting
../inputs/grep1.dat:4432:129598:         characters for one path of the pattern -- and that the empty
../inputs/grep1.dat:4433:129668:         string does not match.  We need not follow this path further.
../inputs/grep1.dat:4434:129739:         Instead, look at the next alternative (remembered on the
../inputs/grep1.dat:4435:129805:         stack), or quit if no more.  The test at the top of the loop
../inputs/grep1.dat:4436:129875:         does these things.  */
../inputs/grep1.dat:4437:129907:      path_can_be_null = false;
../inputs/grep1.dat:4438:129939:      p = pend;
../inputs/grep1.dat:4439:129955:    } /* while p */
../inputs/grep1.dat:4440:129975:
../inputs/grep1.dat:4441:129976:  /* Set `can_be_null' for the last path (also the first path, if the
../inputs/grep1.dat:4442:130046:     pattern is empty).  */
../inputs/grep1.dat:4443:130074:  bufp->can_be_null |= path_can_be_null;
../inputs/grep1.dat:4444:130115:  return 0;
../inputs/grep1.dat:4445:130127:} /* re_compile_fastmap */
../inputs/grep1.dat:4446:130154:
../inputs/grep1.dat:4447:130156:/* Set REGS to hold NUM_REGS registers, storing them in STARTS and
../inputs/grep1.dat:4448:130223:   ENDS.  Subsequent matches using PATTERN_BUFFER and REGS will use
../inputs/grep1.dat:4449:130291:   this memory for recording register information.  STARTS and ENDS
../inputs/grep1.dat:4450:130359:   must be allocated using the malloc library routine, and must each
../inputs/grep1.dat:4451:130428:   be at least NUM_REGS * sizeof (regoff_t) bytes long.
../inputs/grep1.dat:4452:130484:
../inputs/grep1.dat:4453:130485:   If NUM_REGS == 0, then subsequent matches should allocate their own
../inputs/grep1.dat:4454:130556:   register data.
../inputs/grep1.dat:4455:130574:
../inputs/grep1.dat:4456:130575:   Unless this function is called, the first search or match using
../inputs/grep1.dat:4457:130642:   PATTERN_BUFFER will allocate its own register data, without
../inputs/grep1.dat:4458:130705:   freeing the old data.  */
../inputs/grep1.dat:4459:130734:
../inputs/grep1.dat:4460:130735:void
../inputs/grep1.dat:4461:130740:re_set_registers (bufp, regs, num_regs, starts, ends)
../inputs/grep1.dat:4462:130794:    struct re_pattern_buffer *bufp;
../inputs/grep1.dat:4463:130830:    struct re_registers *regs;
../inputs/grep1.dat:4464:130861:    unsigned num_regs;
../inputs/grep1.dat:4465:130884:    regoff_t *starts, *ends;
../inputs/grep1.dat:4466:130913:{
../inputs/grep1.dat:4467:130915:  if (num_regs)
../inputs/grep1.dat:4468:130931:    {
../inputs/grep1.dat:4469:130937:      bufp->regs_allocated = REGS_REALLOCATE;
../inputs/grep1.dat:4470:130983:      regs->num_regs = num_regs;
../inputs/grep1.dat:4471:131016:      regs->start = starts;
../inputs/grep1.dat:4472:131044:      regs->end = ends;
../inputs/grep1.dat:4473:131068:    }
../inputs/grep1.dat:4474:131074:  else
../inputs/grep1.dat:4475:131081:    {
../inputs/grep1.dat:4476:131087:      bufp->regs_allocated = REGS_UNALLOCATED;
../inputs/grep1.dat:4477:131134:      regs->num_regs = 0;
../inputs/grep1.dat:4478:131160:      regs->start = regs->end = (regoff_t) 0;
../inputs/grep1.dat:4479:131206:    }
../inputs/grep1.dat:4480:131212:}
../inputs/grep1.dat:4481:131214:
../inputs/grep1.dat:4482:131216:/* Searching routines.  */
../inputs/grep1.dat:4483:131243:
../inputs/grep1.dat:4484:131244:/* Like re_search_2, below, but only one string is specified, and
../inputs/grep1.dat:4485:131310:   doesn't let you say where to stop matching. */
../inputs/grep1.dat:4486:131360:
../inputs/grep1.dat:4487:131361:int
../inputs/grep1.dat:4488:131365:re_search (bufp, string, size, startpos, range, regs)
../inputs/grep1.dat:4489:131419:     struct re_pattern_buffer *bufp;
../inputs/grep1.dat:4490:131456:     const char *string;
../inputs/grep1.dat:4491:131481:     int size, startpos, range;
../inputs/grep1.dat:4492:131513:     struct re_registers *regs;
../inputs/grep1.dat:4493:131545:{
../inputs/grep1.dat:4494:131547:  return re_search_2 (bufp, NULL, 0, string, size, startpos, range, 
../inputs/grep1.dat:4495:131616:		      regs, size);
../inputs/grep1.dat:4496:131637:}
../inputs/grep1.dat:4497:131639:
../inputs/grep1.dat:4498:131640:
../inputs/grep1.dat:4499:131641:/* Using the compiled pattern in BUFP->buffer, first tries to match the
../inputs/grep1.dat:4500:131713:   virtual concatenation of STRING1 and STRING2, starting first at index
../inputs/grep1.dat:4501:131786:   STARTPOS, then at STARTPOS + 1, and so on.
../inputs/grep1.dat:4502:131832:   
../inputs/grep1.dat:4503:131836:   STRING1 and STRING2 have length SIZE1 and SIZE2, respectively.
../inputs/grep1.dat:4504:131902:   
../inputs/grep1.dat:4505:131906:   RANGE is how far to scan while trying to match.  RANGE = 0 means try
../inputs/grep1.dat:4506:131978:   only at STARTPOS; in general, the last start tried is STARTPOS +
../inputs/grep1.dat:4507:132046:   RANGE.
../inputs/grep1.dat:4508:132056:   
../inputs/grep1.dat:4509:132060:   In REGS, return the indices of the virtual concatenation of STRING1
../inputs/grep1.dat:4510:132131:   and STRING2 that matched the entire BUFP->buffer and its contained
../inputs/grep1.dat:4511:132201:   subexpressions.
../inputs/grep1.dat:4512:132220:   
../inputs/grep1.dat:4513:132224:   Do not consider matching one past the index STOP in the virtual
../inputs/grep1.dat:4514:132291:   concatenation of STRING1 and STRING2.
../inputs/grep1.dat:4515:132332:
../inputs/grep1.dat:4516:132333:   We return either the position in the strings at which the match was
../inputs/grep1.dat:4517:132404:   found, -1 if no match, or -2 if error (such as failure
../inputs/grep1.dat:4518:132462:   stack overflow).  */
../inputs/grep1.dat:4519:132486:
../inputs/grep1.dat:4520:132487:int
../inputs/grep1.dat:4521:132491:re_search_2 (bufp, string1, size1, string2, size2, startpos, range, regs, stop)
../inputs/grep1.dat:4522:132571:     struct re_pattern_buffer *bufp;
../inputs/grep1.dat:4523:132608:     const char *string1, *string2;
../inputs/grep1.dat:4524:132644:     int size1, size2;
../inputs/grep1.dat:4525:132667:     int startpos;
../inputs/grep1.dat:4526:132686:     int range;
../inputs/grep1.dat:4527:132702:     struct re_registers *regs;
../inputs/grep1.dat:4528:132734:     int stop;
../inputs/grep1.dat:4529:132749:{
../inputs/grep1.dat:4530:132751:  int val;
../inputs/grep1.dat:4531:132762:  register char *fastmap = bufp->fastmap;
../inputs/grep1.dat:4532:132804:  register char *translate = bufp->translate;
../inputs/grep1.dat:4533:132850:  int total_size = size1 + size2;
../inputs/grep1.dat:4534:132884:  int endpos = startpos + range;
../inputs/grep1.dat:4535:132917:
../inputs/grep1.dat:4536:132918:  /* Check for out-of-range STARTPOS.  */
../inputs/grep1.dat:4537:132960:  if (startpos < 0 || startpos > total_size)
../inputs/grep1.dat:4538:133005:    return -1;
../inputs/grep1.dat:4539:133020:    
../inputs/grep1.dat:4540:133025:  /* Fix up RANGE if it might eventually take us outside
../inputs/grep1.dat:4541:133082:     the virtual concatenation of STRING1 and STRING2.  */
../inputs/grep1.dat:4542:133141:  if (endpos < -1)
../inputs/grep1.dat:4543:133160:    range = -1 - startpos;
../inputs/grep1.dat:4544:133187:  else if (endpos > total_size)
../inputs/grep1.dat:4545:133219:    range = total_size - startpos;
../inputs/grep1.dat:4546:133254:
../inputs/grep1.dat:4547:133255:  /* If the search isn't to be a backwards one, don't waste time in a
../inputs/grep1.dat:4548:133325:     search for a pattern that must be anchored.  */
../inputs/grep1.dat:4549:133378:  if (bufp->used > 0 && (re_opcode_t) bufp->buffer[0] == begbuf && range > 0)
../inputs/grep1.dat:4550:133456:    {
../inputs/grep1.dat:4551:133462:      if (startpos > 0)
../inputs/grep1.dat:4552:133486:	return -1;
../inputs/grep1.dat:4553:133498:      else
../inputs/grep1.dat:4554:133509:	range = 1;
../inputs/grep1.dat:4555:133521:    }
../inputs/grep1.dat:4556:133527:
../inputs/grep1.dat:4557:133528:  /* Update the fastmap now if not correct already.  */
../inputs/grep1.dat:4558:133584:  if (fastmap && !bufp->fastmap_accurate)
../inputs/grep1.dat:4559:133626:    if (re_compile_fastmap (bufp) == -2)
../inputs/grep1.dat:4560:133667:      return -2;
../inputs/grep1.dat:4561:133684:  
../inputs/grep1.dat:4562:133687:  /* Loop through the string, looking for a place to start matching.  */
../inputs/grep1.dat:4563:133760:  for (;;)
../inputs/grep1.dat:4564:133771:    { 
../inputs/grep1.dat:4565:133778:      /* If a fastmap is supplied, skip quickly over characters that
../inputs/grep1.dat:4566:133847:         cannot be the start of a match.  If the pattern can match the
../inputs/grep1.dat:4567:133918:         null string, however, we don't need to skip characters; we want
../inputs/grep1.dat:4568:133991:         the first null string.  */
../inputs/grep1.dat:4569:134027:      if (fastmap && startpos < total_size && !bufp->can_be_null)
../inputs/grep1.dat:4570:134093:	{
../inputs/grep1.dat:4571:134096:	  if (range > 0)	/* Searching forwards.  */
../inputs/grep1.dat:4572:134141:	    {
../inputs/grep1.dat:4573:134148:	      register const char *d;
../inputs/grep1.dat:4574:134179:	      register int lim = 0;
../inputs/grep1.dat:4575:134208:	      int irange = range;
../inputs/grep1.dat:4576:134235:
../inputs/grep1.dat:4577:134236:              if (startpos < size1 && startpos + range >= size1)
../inputs/grep1.dat:4578:134301:                lim = range - (size1 - startpos);
../inputs/grep1.dat:4579:134351:
../inputs/grep1.dat:4580:134352:	      d = (startpos >= size1 ? string2 - size1 : string1) + startpos;
../inputs/grep1.dat:4581:134423:   
../inputs/grep1.dat:4582:134427:              /* Written out as an if-else to avoid testing `translate'
../inputs/grep1.dat:4583:134499:                 inside the loop.  */
../inputs/grep1.dat:4584:134537:	      if (translate)
../inputs/grep1.dat:4585:134559:                while (range > lim
../inputs/grep1.dat:4586:134594:                       && !fastmap[(unsigned char)
../inputs/grep1.dat:4587:134645:				   translate[(unsigned char) *d++]])
../inputs/grep1.dat:4588:134686:                  range--;
../inputs/grep1.dat:4589:134713:	      else
../inputs/grep1.dat:4590:134725:                while (range > lim && !fastmap[(unsigned char) *d++])
../inputs/grep1.dat:4591:134795:                  range--;
../inputs/grep1.dat:4592:134822:
../inputs/grep1.dat:4593:134823:	      startpos += irange - range;
../inputs/grep1.dat:4594:134858:	    }
../inputs/grep1.dat:4595:134865:	  else				/* Searching backwards.  */
../inputs/grep1.dat:4596:134904:	    {
../inputs/grep1.dat:4597:134911:	      register char c = (size1 == 0 || startpos >= size1
../inputs/grep1.dat:4598:134969:                                 ? string2[startpos - size1] 
../inputs/grep1.dat:4599:135031:                                 : string1[startpos]);
../inputs/grep1.dat:4600:135086:
../inputs/grep1.dat:4601:135087:	      if (!fastmap[(unsigned char) TRANSLATE (c)])
../inputs/grep1.dat:4602:135139:		goto advance;
../inputs/grep1.dat:4603:135155:	    }
../inputs/grep1.dat:4604:135162:	}
../inputs/grep1.dat:4605:135165:
../inputs/grep1.dat:4606:135166:      /* If can't match the null string, and that's all we have left, fail.  */
../inputs/grep1.dat:4607:135246:      if (range >= 0 && startpos == total_size && fastmap
../inputs/grep1.dat:4608:135304:          && !bufp->can_be_null)
../inputs/grep1.dat:4609:135337:	return -1;
../inputs/grep1.dat:4610:135349:
../inputs/grep1.dat:4611:135350:      val = re_match_2 (bufp, string1, size1, string2, size2,
../inputs/grep1.dat:4612:135412:	                startpos, regs, stop);
../inputs/grep1.dat:4613:135452:      if (val >= 0)
../inputs/grep1.dat:4614:135472:	return startpos;
../inputs/grep1.dat:4615:135490:        
../inputs/grep1.dat:4616:135499:      if (val == -2)
../inputs/grep1.dat:4617:135520:	return -2;
../inputs/grep1.dat:4618:135532:
../inputs/grep1.dat:4619:135533:    advance:
../inputs/grep1.dat:4620:135546:      if (!range) 
../inputs/grep1.dat:4621:135565:        break;
../inputs/grep1.dat:4622:135580:      else if (range > 0) 
../inputs/grep1.dat:4623:135607:        {
../inputs/grep1.dat:4624:135617:          range--; 
../inputs/grep1.dat:4625:135637:          startpos++;
../inputs/grep1.dat:4626:135659:        }
../inputs/grep1.dat:4627:135669:      else
../inputs/grep1.dat:4628:135680:        {
../inputs/grep1.dat:4629:135690:          range++; 
../inputs/grep1.dat:4630:135710:          startpos--;
../inputs/grep1.dat:4631:135732:        }
../inputs/grep1.dat:4632:135742:    }
../inputs/grep1.dat:4633:135748:  return -1;
../inputs/grep1.dat:4634:135761:} /* re_search_2 */
../inputs/grep1.dat:4635:135781:
../inputs/grep1.dat:4636:135783:/* Declarations and macros for re_match_2.  */
../inputs/grep1.dat:4637:135830:
../inputs/grep1.dat:4638:135831:static int bcmp_translate ();
../inputs/grep1.dat:4639:135861:static boolean alt_match_null_string_p (),
../inputs/grep1.dat:4640:135904:               common_op_match_null_string_p (),
../inputs/grep1.dat:4641:135953:               group_match_null_string_p ();
../inputs/grep1.dat:4642:135998:
../inputs/grep1.dat:4643:135999:/* Structure for per-register (a.k.a. per-group) information.
../inputs/grep1.dat:4644:136061:   This must not be longer than one word, because we push this value
../inputs/grep1.dat:4645:136130:   onto the failure stack.  Other register information, such as the
../inputs/grep1.dat:4646:136198:   starting and ending positions (which are addresses), and the list of
../inputs/grep1.dat:4647:136270:   inner groups (which is a bits list) are maintained in separate
../inputs/grep1.dat:4648:136336:   variables.  
../inputs/grep1.dat:4649:136352:   
../inputs/grep1.dat:4650:136356:   We are making a (strictly speaking) nonportable assumption here: that
../inputs/grep1.dat:4651:136429:   the compiler will pack our bit fields into something that fits into
../inputs/grep1.dat:4652:136500:   the type of `word', i.e., is something that fits into one item on the
../inputs/grep1.dat:4653:136573:   failure stack.  */
../inputs/grep1.dat:4654:136595:typedef union
../inputs/grep1.dat:4655:136609:{
../inputs/grep1.dat:4656:136611:  fail_stack_elt_t word;
../inputs/grep1.dat:4657:136636:  struct
../inputs/grep1.dat:4658:136645:  {
../inputs/grep1.dat:4659:136649:      /* This field is one if this group can match the empty string,
../inputs/grep1.dat:4660:136718:         zero if not.  If not yet determined,  `MATCH_NULL_UNSET_VALUE'.  */
../inputs/grep1.dat:4661:136795:#define MATCH_NULL_UNSET_VALUE 3
../inputs/grep1.dat:4662:136828:    unsigned match_null_string_p : 2;
../inputs/grep1.dat:4663:136866:    unsigned is_active : 1;
../inputs/grep1.dat:4664:136894:    unsigned matched_something : 1;
../inputs/grep1.dat:4665:136930:    unsigned ever_matched_something : 1;
../inputs/grep1.dat:4666:136971:  } bits;
../inputs/grep1.dat:4667:136981:} register_info_type;
../inputs/grep1.dat:4668:137003:
../inputs/grep1.dat:4669:137004:#define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)
../inputs/grep1.dat:4670:137071:#define IS_ACTIVE(R)  ((R).bits.is_active)
../inputs/grep1.dat:4671:137114:#define MATCHED_SOMETHING(R)  ((R).bits.matched_something)
../inputs/grep1.dat:4672:137173:#define EVER_MATCHED_SOMETHING(R)  ((R).bits.ever_matched_something)
../inputs/grep1.dat:4673:137242:
../inputs/grep1.dat:4674:137243:
../inputs/grep1.dat:4675:137244:/* Call this when have matched a real character; it sets `matched' flags
../inputs/grep1.dat:4676:137317:   for the subexpressions which we are currently inside.  Also records
../inputs/grep1.dat:4677:137388:   that those subexprs have matched.  */
../inputs/grep1.dat:4678:137429:#define SET_REGS_MATCHED()						\
../inputs/grep1.dat:4679:137463:  do									\
../inputs/grep1.dat:4680:137478:    {									\
../inputs/grep1.dat:4681:137494:      unsigned r;							\
../inputs/grep1.dat:4682:137520:      for (r = lowest_active_reg; r <= highest_active_reg; r++)		\
../inputs/grep1.dat:4683:137587:        {								\
../inputs/grep1.dat:4684:137606:          MATCHED_SOMETHING (reg_info[r])				\
../inputs/grep1.dat:4685:137653:            = EVER_MATCHED_SOMETHING (reg_info[r])			\
../inputs/grep1.dat:4686:137708:            = 1;							\
../inputs/grep1.dat:4687:137733:        }								\
../inputs/grep1.dat:4688:137752:    }									\
../inputs/grep1.dat:4689:137768:  while (0)
../inputs/grep1.dat:4690:137780:
../inputs/grep1.dat:4691:137781:
../inputs/grep1.dat:4692:137782:/* This converts PTR, a pointer into one of the search strings `string1'
../inputs/grep1.dat:4693:137855:   and `string2' into an offset from the beginning of that string.  */
../inputs/grep1.dat:4694:137926:#define POINTER_TO_OFFSET(ptr)						\
../inputs/grep1.dat:4695:137964:  (FIRST_STRING_P (ptr) ? (ptr) - string1 : (ptr) - string2 + size1)
../inputs/grep1.dat:4696:138033:
../inputs/grep1.dat:4697:138034:/* Registers are set to a sentinel when they haven't yet matched.  */
../inputs/grep1.dat:4698:138104:#define REG_UNSET_VALUE ((char *) -1)
../inputs/grep1.dat:4699:138142:#define REG_UNSET(e) ((e) == REG_UNSET_VALUE)
../inputs/grep1.dat:4700:138188:
../inputs/grep1.dat:4701:138189:
../inputs/grep1.dat:4702:138190:/* Macros for dealing with the split strings in re_match_2.  */
../inputs/grep1.dat:4703:138254:
../inputs/grep1.dat:4704:138255:#define MATCHING_IN_FIRST_STRING  (dend == end_match_1)
../inputs/grep1.dat:4705:138311:
../inputs/grep1.dat:4706:138312:/* Call before fetching a character with *d.  This switches over to
../inputs/grep1.dat:4707:138380:   string2 if necessary.  */
../inputs/grep1.dat:4708:138409:#define PREFETCH()							\
../inputs/grep1.dat:4709:138436:  while (d == dend)						    	\
../inputs/grep1.dat:4710:138468:    {									\
../inputs/grep1.dat:4711:138484:      /* End of string2 => fail.  */					\
../inputs/grep1.dat:4712:138527:      if (dend == end_match_2) 						\
../inputs/grep1.dat:4713:138566:        goto fail;							\
../inputs/grep1.dat:4714:138593:      /* End of string1 => advance to string2.  */ 			\
../inputs/grep1.dat:4715:138649:      d = string2;						        \
../inputs/grep1.dat:4716:138683:      dend = end_match_2;						\
../inputs/grep1.dat:4717:138716:    }
../inputs/grep1.dat:4718:138722:
../inputs/grep1.dat:4719:138723:
../inputs/grep1.dat:4720:138724:/* Test if at very beginning or at very end of the virtual concatenation
../inputs/grep1.dat:4721:138797:   of `string1' and `string2'.  If only one string, it's `string2'.  */
../inputs/grep1.dat:4722:138869:#define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)
../inputs/grep1.dat:4723:138942:#define AT_STRINGS_END(d) ((d) == end2)	
../inputs/grep1.dat:4724:138983:
../inputs/grep1.dat:4725:138984:
../inputs/grep1.dat:4726:138985:/* Test if D points to a character which is word-constituent.  We have
../inputs/grep1.dat:4727:139056:   two special cases to check for: if past the end of string1, look at
../inputs/grep1.dat:4728:139127:   the first character in string2; and if before the beginning of
../inputs/grep1.dat:4729:139193:   string2, look at the last character in string1.  */
../inputs/grep1.dat:4730:139248:#define WORDCHAR_P(d)							\
../inputs/grep1.dat:4731:139278:  (SYNTAX ((d) == end1 ? *string2					\
../inputs/grep1.dat:4732:139318:           : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\
../inputs/grep1.dat:4733:139376:   == Sword)
../inputs/grep1.dat:4734:139389:
../inputs/grep1.dat:4735:139390:/* Test if the character before D and the one at D differ with respect
../inputs/grep1.dat:4736:139461:   to being word-constituent.  */
../inputs/grep1.dat:4737:139495:#define AT_WORD_BOUNDARY(d)						\
../inputs/grep1.dat:4738:139530:  (AT_STRINGS_BEG (d) || AT_STRINGS_END (d)				\
../inputs/grep1.dat:4739:139579:   || WORDCHAR_P (d - 1) != WORDCHAR_P (d))
../inputs/grep1.dat:4740:139623:
../inputs/grep1.dat:4741:139624:
../inputs/grep1.dat:4742:139625:/* Free everything we malloc.  */
../inputs/grep1.dat:4743:139659:#ifdef REGEX_MALLOC
../inputs/grep1.dat:4744:139679:#define FREE_VAR(var) if (var) free (var); var = NULL
../inputs/grep1.dat:4745:139733:#define FREE_VARIABLES()						\
../inputs/grep1.dat:4746:139765:  do {									\
../inputs/grep1.dat:4747:139782:    FREE_VAR (fail_stack.stack);					\
../inputs/grep1.dat:4748:139821:    FREE_VAR (regstart);						\
../inputs/grep1.dat:4749:139853:    FREE_VAR (regend);							\
../inputs/grep1.dat:4750:139884:    FREE_VAR (old_regstart);						\
../inputs/grep1.dat:4751:139920:    FREE_VAR (old_regend);						\
../inputs/grep1.dat:4752:139954:    FREE_VAR (best_regstart);						\
../inputs/grep1.dat:4753:139991:    FREE_VAR (best_regend);						\
../inputs/grep1.dat:4754:140026:    FREE_VAR (reg_info);						\
../inputs/grep1.dat:4755:140058:    FREE_VAR (reg_dummy);						\
../inputs/grep1.dat:4756:140091:    FREE_VAR (reg_info_dummy);						\
../inputs/grep1.dat:4757:140129:  } while (0)
../inputs/grep1.dat:4758:140143:#else /* not REGEX_MALLOC */
../inputs/grep1.dat:4759:140172:/* Some MIPS systems (at least) want this to free alloca'd storage.  */
../inputs/grep1.dat:4760:140244:#define FREE_VARIABLES() alloca (0)
../inputs/grep1.dat:4761:140280:#endif /* not REGEX_MALLOC */
../inputs/grep1.dat:4762:140310:
../inputs/grep1.dat:4763:140311:
../inputs/grep1.dat:4764:140312:/* These values must meet several constraints.  They must not be valid
../inputs/grep1.dat:4765:140383:   register values; since we have a limit of 255 registers (because
../inputs/grep1.dat:4766:140451:   we use only one byte in the pattern for the register number), we can
../inputs/grep1.dat:4767:140523:   use numbers larger than 255.  They must differ by 1, because of
../inputs/grep1.dat:4768:140590:   NUM_FAILURE_ITEMS above.  And the value for the lowest register must
../inputs/grep1.dat:4769:140662:   be larger than the value for the highest register, so we do not try
../inputs/grep1.dat:4770:140733:   to actually save any registers when none are active.  */
../inputs/grep1.dat:4771:140793:#define NO_HIGHEST_ACTIVE_REG (1 << BYTEWIDTH)
../inputs/grep1.dat:4772:140840:#define NO_LOWEST_ACTIVE_REG (NO_HIGHEST_ACTIVE_REG + 1)
../inputs/grep1.dat:4773:140897:
../inputs/grep1.dat:4774:140899:/* Matching routines.  */
../inputs/grep1.dat:4775:140925:
../inputs/grep1.dat:4776:140926:#ifndef emacs   /* Emacs never uses this.  */
../inputs/grep1.dat:4777:140972:/* re_match is like re_match_2 except it takes only a single string.  */
../inputs/grep1.dat:4778:141045:
../inputs/grep1.dat:4779:141046:int
../inputs/grep1.dat:4780:141050:re_match (bufp, string, size, pos, regs)
../inputs/grep1.dat:4781:141091:     struct re_pattern_buffer *bufp;
../inputs/grep1.dat:4782:141128:     const char *string;
../inputs/grep1.dat:4783:141153:     int size, pos;
../inputs/grep1.dat:4784:141173:     struct re_registers *regs;
../inputs/grep1.dat:4785:141205: {
../inputs/grep1.dat:4786:141208:  return re_match_2 (bufp, NULL, 0, string, size, pos, regs, size); 
../inputs/grep1.dat:4787:141277:}
../inputs/grep1.dat:4788:141279:#endif /* not emacs */
../inputs/grep1.dat:4789:141302:
../inputs/grep1.dat:4790:141303:
../inputs/grep1.dat:4791:141304:/* re_match_2 matches the compiled pattern in BUFP against the
../inputs/grep1.dat:4792:141367:   the (virtual) concatenation of STRING1 and STRING2 (of length SIZE1
../inputs/grep1.dat:4793:141438:   and SIZE2, respectively).  We start matching at POS, and stop
../inputs/grep1.dat:4794:141503:   matching at STOP.
../inputs/grep1.dat:4795:141524:   
../inputs/grep1.dat:4796:141528:   If REGS is non-null and the `no_sub' field of BUFP is nonzero, we
../inputs/grep1.dat:4797:141597:   store offsets for the substring each group matched in REGS.  See the
../inputs/grep1.dat:4798:141669:   documentation for exactly how many groups we fill.
../inputs/grep1.dat:4799:141723:
../inputs/grep1.dat:4800:141724:   We return -1 if no match, -2 if an internal error (such as the
../inputs/grep1.dat:4801:141790:   failure stack overflowing).  Otherwise, we return the length of the
../inputs/grep1.dat:4802:141861:   matched substring.  */
../inputs/grep1.dat:4803:141887:
../inputs/grep1.dat:4804:141888:int
../inputs/grep1.dat:4805:141892:re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
../inputs/grep1.dat:4806:141959:     struct re_pattern_buffer *bufp;
../inputs/grep1.dat:4807:141996:     const char *string1, *string2;
../inputs/grep1.dat:4808:142032:     int size1, size2;
../inputs/grep1.dat:4809:142055:     int pos;
../inputs/grep1.dat:4810:142069:     struct re_registers *regs;
../inputs/grep1.dat:4811:142101:     int stop;
../inputs/grep1.dat:4812:142116:{
../inputs/grep1.dat:4813:142118:  /* General temporaries.  */
../inputs/grep1.dat:4814:142148:  int mcnt;
../inputs/grep1.dat:4815:142160:  unsigned char *p1;
../inputs/grep1.dat:4816:142181:
../inputs/grep1.dat:4817:142182:  /* Just past the end of the corresponding string.  */
../inputs/grep1.dat:4818:142238:  const char *end1, *end2;
../inputs/grep1.dat:4819:142265:
../inputs/grep1.dat:4820:142266:  /* Pointers into string1 and string2, just past the last characters in
../inputs/grep1.dat:4821:142339:     each to consider matching.  */
../inputs/grep1.dat:4822:142375:  const char *end_match_1, *end_match_2;
../inputs/grep1.dat:4823:142416:
../inputs/grep1.dat:4824:142417:  /* Where we are in the data, and the end of the current string.  */
../inputs/grep1.dat:4825:142487:  const char *d, *dend;
../inputs/grep1.dat:4826:142511:  
../inputs/grep1.dat:4827:142514:  /* Where we are in the pattern, and the end of the pattern.  */
../inputs/grep1.dat:4828:142580:  unsigned char *p = bufp->buffer;
../inputs/grep1.dat:4829:142615:  register unsigned char *pend = p + bufp->used;
../inputs/grep1.dat:4830:142664:
../inputs/grep1.dat:4831:142665:  /* We use this to map every character in the string.  */
../inputs/grep1.dat:4832:142724:  char *translate = bufp->translate;
../inputs/grep1.dat:4833:142761:
../inputs/grep1.dat:4834:142762:  /* Failure point stack.  Each place that can handle a failure further
../inputs/grep1.dat:4835:142834:     down the line pushes a failure point on this stack.  It consists of
../inputs/grep1.dat:4836:142907:     restart, regend, and reg_info for all registers corresponding to
../inputs/grep1.dat:4837:142977:     the subexpressions we're currently inside, plus the number of such
../inputs/grep1.dat:4838:143049:     registers, and, finally, two char *'s.  The first char * is where
../inputs/grep1.dat:4839:143120:     to resume scanning the pattern; the second one is where to resume
../inputs/grep1.dat:4840:143191:     scanning the strings.  If the latter is zero, the failure point is
../inputs/grep1.dat:4841:143263:     a ``dummy''; if a failure happens and the failure point is a dummy,
../inputs/grep1.dat:4842:143336:     it gets discarded and the next next one is tried.  */
../inputs/grep1.dat:4843:143395:  fail_stack_type fail_stack;
../inputs/grep1.dat:4844:143425:#ifdef DEBUG
../inputs/grep1.dat:4845:143438:  static unsigned failure_id = 0;
../inputs/grep1.dat:4846:143472:  unsigned nfailure_points_pushed = 0, nfailure_points_popped = 0;
../inputs/grep1.dat:4847:143539:#endif
../inputs/grep1.dat:4848:143546:
../inputs/grep1.dat:4849:143547:  /* We fill all the registers internally, independent of what we
../inputs/grep1.dat:4851:143679:     an element for register zero.  */
../inputs/grep1.dat:4852:143718:  unsigned num_regs = bufp->re_nsub + 1;
../inputs/grep1.dat:4853:143759:  
../inputs/grep1.dat:4854:143762:  /* The currently active registers.  */
../inputs/grep1.dat:4855:143803:  unsigned lowest_active_reg = NO_LOWEST_ACTIVE_REG;
../inputs/grep1.dat:4856:143856:  unsigned highest_active_reg = NO_HIGHEST_ACTIVE_REG;
../inputs/grep1.dat:4857:143911:
../inputs/grep1.dat:4858:143912:  /* Information on the contents of registers. These are pointers into
../inputs/grep1.dat:4859:143983:     the input strings; they record just what was matched (on this
../inputs/grep1.dat:4860:144050:     attempt) by a subexpression part of the pattern, that is, the
../inputs/grep1.dat:4861:144117:     regnum-th regstart pointer points to where in the pattern we began
../inputs/grep1.dat:4862:144189:     matching and the regnum-th regend points to right after where we
../inputs/grep1.dat:4863:144259:     stopped matching the regnum-th subexpression.  (The zeroth register
../inputs/grep1.dat:4864:144332:     keeps track of what the whole pattern matches.)  */
../inputs/grep1.dat:4865:144389:  const char **regstart, **regend;
../inputs/grep1.dat:4866:144424:
../inputs/grep1.dat:4867:144425:  /* If a group that's operated upon by a repetition operator fails to
../inputs/grep1.dat:4868:144496:     match anything, then the register for its start will need to be
../inputs/grep1.dat:4869:144565:     restored because it will have been set to wherever in the string we
../inputs/grep1.dat:4870:144638:     are when we last see its open-group operator.  Similarly for a
../inputs/grep1.dat:4871:144706:     register's end.  */
../inputs/grep1.dat:4872:144731:  const char **old_regstart, **old_regend;
../inputs/grep1.dat:4873:144774:
../inputs/grep1.dat:4874:144775:  /* The is_active field of reg_info helps us keep track of which (possibly
../inputs/grep1.dat:4875:144851:     nested) subexpressions we are currently in. The matched_something
../inputs/grep1.dat:4876:144922:     field of reg_info[reg_num] helps us tell whether or not we have
../inputs/grep1.dat:4877:144991:     matched any of the pattern so far this time through the reg_num-th
../inputs/grep1.dat:4878:145063:     subexpression.  These two fields get reset each time through any
../inputs/grep1.dat:4879:145133:     loop their register is in.  */
../inputs/grep1.dat:4880:145169:  register_info_type *reg_info; 
../inputs/grep1.dat:4881:145202:
../inputs/grep1.dat:4882:145203:  /* The following record the register info as found in the above
../inputs/grep1.dat:4883:145269:     variables when we find a match better than any we've seen before. 
../inputs/grep1.dat:4884:145341:     This happens as we backtrack through the failure points, which in
../inputs/grep1.dat:4885:145412:     turn happens only if we have not yet matched the entire string. */
../inputs/grep1.dat:4886:145484:  unsigned best_regs_set = false;
../inputs/grep1.dat:4887:145518:  const char **best_regstart, **best_regend;
../inputs/grep1.dat:4888:145563:  
../inputs/grep1.dat:4889:145566:  /* Logically, this is `best_regend[0]'.  But we don't want to have to
../inputs/grep1.dat:4890:145638:     allocate space for that if we're not allocating space for anything
../inputs/grep1.dat:4891:145710:     else (see below).  Also, we never need info about register 0 for
../inputs/grep1.dat:4892:145780:     any of the other register vectors, and it seems rather a kludge to
../inputs/grep1.dat:4893:145852:     treat `best_regend' differently than the rest.  So we keep track of
../inputs/grep1.dat:4894:145925:     the end of the best match so far in a separate variable.  We
../inputs/grep1.dat:4895:145991:     initialize this to NULL so that when we backtrack the first time
../inputs/grep1.dat:4896:146061:     and need to test it, it's not garbage.  */
../inputs/grep1.dat:4897:146109:  const char *match_end = NULL;
../inputs/grep1.dat:4898:146141:
../inputs/grep1.dat:4899:146142:  /* Used when we pop values we don't care about.  */
../inputs/grep1.dat:4900:146196:  const char **reg_dummy;
../inputs/grep1.dat:4901:146222:  register_info_type *reg_info_dummy;
../inputs/grep1.dat:4902:146260:
../inputs/grep1.dat:4903:146261:#ifdef DEBUG
../inputs/grep1.dat:4904:146274:  /* Counts the total number of registers pushed.  */
../inputs/grep1.dat:4905:146328:  unsigned num_regs_pushed = 0; 	
../inputs/grep1.dat:4906:146362:#endif
../inputs/grep1.dat:4907:146369:
../inputs/grep1.dat:4908:146370:  DEBUG_PRINT1 ("\n\nEntering re_match_2.\n");
../inputs/grep1.dat:4909:146417:  
../inputs/grep1.dat:4910:146420:  INIT_FAIL_STACK ();
../inputs/grep1.dat:4911:146442:  
../inputs/grep1.dat:4912:146445:  /* Do not bother to initialize all the register variables if there are
../inputs/grep1.dat:4913:146518:     no groups in the pattern, as it takes a fair amount of time.  If
../inputs/grep1.dat:4915:146654:     pattern), even though we never use it, since it simplifies the
../inputs/grep1.dat:4916:146722:     array indexing.  We should fix this.  */
../inputs/grep1.dat:4917:146768:  if (bufp->re_nsub)
../inputs/grep1.dat:4918:146789:    {
../inputs/grep1.dat:4919:146795:      regstart = REGEX_TALLOC (num_regs, const char *);
../inputs/grep1.dat:4920:146851:      regend = REGEX_TALLOC (num_regs, const char *);
../inputs/grep1.dat:4921:146905:      old_regstart = REGEX_TALLOC (num_regs, const char *);
../inputs/grep1.dat:4922:146965:      old_regend = REGEX_TALLOC (num_regs, const char *);
../inputs/grep1.dat:4923:147023:      best_regstart = REGEX_TALLOC (num_regs, const char *);
../inputs/grep1.dat:4924:147084:      best_regend = REGEX_TALLOC (num_regs, const char *);
../inputs/grep1.dat:4925:147143:      reg_info = REGEX_TALLOC (num_regs, register_info_type);
../inputs/grep1.dat:4926:147205:      reg_dummy = REGEX_TALLOC (num_regs, const char *);
../inputs/grep1.dat:4927:147262:      reg_info_dummy = REGEX_TALLOC (num_regs, register_info_type);
../inputs/grep1.dat:4928:147330:
../inputs/grep1.dat:4929:147331:      if (!(regstart && regend && old_regstart && old_regend && reg_info 
../inputs/grep1.dat:4930:147405:            && best_regstart && best_regend && reg_dummy && reg_info_dummy)) 
../inputs/grep1.dat:4931:147483:        {
../inputs/grep1.dat:4932:147493:          FREE_VARIABLES ();
../inputs/grep1.dat:4933:147522:          return -2;
../inputs/grep1.dat:4934:147543:        }
../inputs/grep1.dat:4935:147553:    }
../inputs/grep1.dat:4936:147559:#ifdef REGEX_MALLOC
../inputs/grep1.dat:4937:147579:  else
../inputs/grep1.dat:4938:147586:    {
../inputs/grep1.dat:4939:147592:      /* We must initialize all our variables to NULL, so that
../inputs/grep1.dat:4940:147655:         `FREE_VARIABLES' doesn't try to free them.  */
../inputs/grep1.dat:4941:147711:      regstart = regend = old_regstart = old_regend = best_regstart
../inputs/grep1.dat:4942:147779:        = best_regend = reg_dummy = NULL;
../inputs/grep1.dat:4943:147821:      reg_info = reg_info_dummy = (register_info_type *) NULL;
../inputs/grep1.dat:4944:147884:    }
../inputs/grep1.dat:4945:147890:#endif /* REGEX_MALLOC */
../inputs/grep1.dat:4946:147916:
../inputs/grep1.dat:4947:147917:  /* The starting position is bogus.  */
../inputs/grep1.dat:4948:147958:  if (pos < 0 || pos > size1 + size2)
../inputs/grep1.dat:4949:147996:    {
../inputs/grep1.dat:4950:148002:      FREE_VARIABLES ();
../inputs/grep1.dat:4951:148027:      return -1;
../inputs/grep1.dat:4952:148044:    }
../inputs/grep1.dat:4953:148050:    
../inputs/grep1.dat:4954:148055:  /* Initialize subexpression text positions to -1 to mark ones that no
../inputs/grep1.dat:4955:148127:     start_memory/stop_memory has been seen for. Also initialize the
../inputs/grep1.dat:4956:148196:     register information struct.  */
../inputs/grep1.dat:4957:148234:  for (mcnt = 1; mcnt < num_regs; mcnt++)
../inputs/grep1.dat:4958:148276:    {
../inputs/grep1.dat:4959:148282:      regstart[mcnt] = regend[mcnt] 
../inputs/grep1.dat:4960:148319:        = old_regstart[mcnt] = old_regend[mcnt] = REG_UNSET_VALUE;
../inputs/grep1.dat:4961:148386:        
../inputs/grep1.dat:4962:148395:      REG_MATCH_NULL_STRING_P (reg_info[mcnt]) = MATCH_NULL_UNSET_VALUE;
../inputs/grep1.dat:4963:148468:      IS_ACTIVE (reg_info[mcnt]) = 0;
../inputs/grep1.dat:4964:148506:      MATCHED_SOMETHING (reg_info[mcnt]) = 0;
../inputs/grep1.dat:4965:148552:      EVER_MATCHED_SOMETHING (reg_info[mcnt]) = 0;
../inputs/grep1.dat:4966:148603:    }
../inputs/grep1.dat:4967:148609:  
../inputs/grep1.dat:4968:148612:  /* We move `string1' into `string2' if the latter's empty -- but not if
../inputs/grep1.dat:4969:148686:     `string1' is null.  */
../inputs/grep1.dat:4970:148714:  if (size2 == 0 && string1 != NULL)
../inputs/grep1.dat:4971:148751:    {
../inputs/grep1.dat:4972:148757:      string2 = string1;
../inputs/grep1.dat:4973:148782:      size2 = size1;
../inputs/grep1.dat:4974:148803:      string1 = 0;
../inputs/grep1.dat:4975:148822:      size1 = 0;
../inputs/grep1.dat:4976:148839:    }
../inputs/grep1.dat:4977:148845:  end1 = string1 + size1;
../inputs/grep1.dat:4978:148871:  end2 = string2 + size2;
../inputs/grep1.dat:4979:148897:
../inputs/grep1.dat:4980:148898:  /* Compute where to stop matching, within the two strings.  */
../inputs/grep1.dat:4981:148963:  if (stop <= size1)
../inputs/grep1.dat:4982:148984:    {
../inputs/grep1.dat:4983:148990:      end_match_1 = string1 + stop;
../inputs/grep1.dat:4984:149026:      end_match_2 = string2;
../inputs/grep1.dat:4985:149055:    }
../inputs/grep1.dat:4986:149061:  else
../inputs/grep1.dat:4987:149068:    {
../inputs/grep1.dat:4988:149074:      end_match_1 = end1;
../inputs/grep1.dat:4989:149100:      end_match_2 = string2 + stop - size1;
../inputs/grep1.dat:4990:149144:    }
../inputs/grep1.dat:4991:149150:
../inputs/grep1.dat:4992:149151:  /* `p' scans through the pattern as `d' scans through the data. 
../inputs/grep1.dat:4993:149218:     `dend' is the end of the input string that `d' points within.  `d'
../inputs/grep1.dat:4994:149290:     is advanced into the following input string whenever necessary, but
../inputs/grep1.dat:4995:149363:     this happens before fetching; therefore, at the beginning of the
../inputs/grep1.dat:4996:149433:     loop, `d' can be pointing at the end of a string, but it cannot
../inputs/grep1.dat:4997:149502:     equal `string2'.  */
../inputs/grep1.dat:4998:149528:  if (size1 > 0 && pos <= size1)
../inputs/grep1.dat:4999:149561:    {
../inputs/grep1.dat:5000:149567:      d = string1 + pos;
../inputs/grep1.dat:5001:149592:      dend = end_match_1;
../inputs/grep1.dat:5002:149618:    }
../inputs/grep1.dat:5003:149624:  else
../inputs/grep1.dat:5004:149631:    {
../inputs/grep1.dat:5005:149637:      d = string2 + pos - size1;
../inputs/grep1.dat:5006:149670:      dend = end_match_2;
../inputs/grep1.dat:5007:149696:    }
../inputs/grep1.dat:5008:149702:
../inputs/grep1.dat:5009:149703:  DEBUG_PRINT1 ("The compiled pattern is: ");
../inputs/grep1.dat:5010:149749:  DEBUG_PRINT_COMPILED_PATTERN (bufp, p, pend);
../inputs/grep1.dat:5011:149797:  DEBUG_PRINT1 ("The string to match is: `");
../inputs/grep1.dat:5012:149843:  DEBUG_PRINT_DOUBLE_STRING (d, string1, size1, string2, size2);
../inputs/grep1.dat:5013:149908:  DEBUG_PRINT1 ("'\n");
../inputs/grep1.dat:5014:149932:  
../inputs/grep1.dat:5015:149935:  /* This loops over pattern commands.  It exits by returning from the
../inputs/grep1.dat:5016:150006:     function if the match is complete, or it drops through if the match
../inputs/grep1.dat:5017:150079:     fails at this starting point in the input data.  */
../inputs/grep1.dat:5018:150136:  for (;;)
../inputs/grep1.dat:5019:150147:    {
../inputs/grep1.dat:5020:150153:      DEBUG_PRINT2 ("\n0x%x: ", p);
../inputs/grep1.dat:5021:150189:
../inputs/grep1.dat:5022:150190:      if (p == pend)
../inputs/grep1.dat:5023:150211:	{ /* End of pattern means we might have succeeded.  */
../inputs/grep1.dat:5024:150267:          DEBUG_PRINT1 ("end of pattern ... ");
../inputs/grep1.dat:5025:150315:          
../inputs/grep1.dat:5026:150326:	  /* If we haven't matched the entire string, and we want the
../inputs/grep1.dat:5027:150389:             longest match, try backtracking.  */
../inputs/grep1.dat:5028:150439:          if (d != end_match_2)
../inputs/grep1.dat:5029:150471:	    {
../inputs/grep1.dat:5030:150478:              DEBUG_PRINT1 ("backtracking.\n");
../inputs/grep1.dat:5031:150526:              
../inputs/grep1.dat:5032:150541:              if (!FAIL_STACK_EMPTY ())
../inputs/grep1.dat:5033:150581:                { /* More failure points to try.  */
../inputs/grep1.dat:5034:150634:                  boolean same_str_p = (FIRST_STRING_P (match_end) 
../inputs/grep1.dat:5035:150702:	        	                == MATCHING_IN_FIRST_STRING);
../inputs/grep1.dat:5036:150758:
../inputs/grep1.dat:5037:150759:                  /* If exceeds best match so far, save it.  */
../inputs/grep1.dat:5038:150823:                  if (!best_regs_set
../inputs/grep1.dat:5039:150860:                      || (same_str_p && d > match_end)
../inputs/grep1.dat:5040:150915:                      || (!same_str_p && !MATCHING_IN_FIRST_STRING))
../inputs/grep1.dat:5041:150984:                    {
../inputs/grep1.dat:5042:151006:                      best_regs_set = true;
../inputs/grep1.dat:5043:151050:                      match_end = d;
../inputs/grep1.dat:5044:151087:                      
../inputs/grep1.dat:5045:151110:                      DEBUG_PRINT1 ("\nSAVING match as best so far.\n");
../inputs/grep1.dat:5046:151183:                      
../inputs/grep1.dat:5047:151206:                      for (mcnt = 1; mcnt < num_regs; mcnt++)
../inputs/grep1.dat:5048:151268:                        {
../inputs/grep1.dat:5049:151294:                          best_regstart[mcnt] = regstart[mcnt];
../inputs/grep1.dat:5050:151358:                          best_regend[mcnt] = regend[mcnt];
../inputs/grep1.dat:5051:151418:                        }
../inputs/grep1.dat:5052:151444:                    }
../inputs/grep1.dat:5053:151466:                  goto fail;	       
../inputs/grep1.dat:5054:151503:                }
../inputs/grep1.dat:5055:151521:
../inputs/grep1.dat:5056:151522:              /* If no failure points, don't restore garbage.  */
../inputs/grep1.dat:5057:151588:              else if (best_regs_set)   
../inputs/grep1.dat:5058:151629:                {
../inputs/grep1.dat:5059:151647:  	        restore_best_regs:
../inputs/grep1.dat:5060:151677:                  /* Restore best match.  It may happen that `dend ==
../inputs/grep1.dat:5061:151747:                     end_match_1' while the restored d is in string2.
../inputs/grep1.dat:5062:151817:                     For example, the pattern `x.*y.*z' against the
../inputs/grep1.dat:5063:151885:                     strings `x-' and `y-z-', if the two strings are
../inputs/grep1.dat:5064:151954:                     not consecutive in memory.  */
../inputs/grep1.dat:5065:152006:                  DEBUG_PRINT1 ("Restoring best registers.\n");
../inputs/grep1.dat:5066:152070:                  
../inputs/grep1.dat:5067:152089:                  d = match_end;
../inputs/grep1.dat:5068:152122:                  dend = ((d >= string1 && d <= end1)
../inputs/grep1.dat:5069:152176:		           ? end_match_1 : end_match_2);
../inputs/grep1.dat:5070:152219:
../inputs/grep1.dat:5071:152220:		  for (mcnt = 1; mcnt < num_regs; mcnt++)
../inputs/grep1.dat:5072:152264:		    {
../inputs/grep1.dat:5073:152272:		      regstart[mcnt] = best_regstart[mcnt];
../inputs/grep1.dat:5074:152318:		      regend[mcnt] = best_regend[mcnt];
../inputs/grep1.dat:5075:152360:		    }
../inputs/grep1.dat:5076:152368:                }
../inputs/grep1.dat:5077:152386:            } /* d != end_match_2 */
../inputs/grep1.dat:5078:152423:
../inputs/grep1.dat:5079:152424:          DEBUG_PRINT1 ("Accepting match.\n");
../inputs/grep1.dat:5080:152471:
../inputs/grep1.dat:5081:152472:          /* If caller wants register contents data back, do it.  */
../inputs/grep1.dat:5082:152541:          if (regs && !bufp->no_sub)
../inputs/grep1.dat:5083:152578:	    {
../inputs/grep1.dat:5084:152585:              /* Have the register data arrays been allocated?  */
../inputs/grep1.dat:5085:152652:              if (bufp->regs_allocated == REGS_UNALLOCATED)
../inputs/grep1.dat:5086:152712:                { /* No.  So allocate them with malloc.  We need one
../inputs/grep1.dat:5087:152781:                     extra element beyond `num_regs' for the `-1' marker
../inputs/grep1.dat:5088:152854:                     GNU code uses.  */
../inputs/grep1.dat:5089:152894:                  regs->num_regs = MAX (RE_NREGS, num_regs + 1);
../inputs/grep1.dat:5090:152959:                  regs->start = TALLOC (regs->num_regs, regoff_t);
../inputs/grep1.dat:5091:153026:                  regs->end = TALLOC (regs->num_regs, regoff_t);
../inputs/grep1.dat:5092:153091:                  if (regs->start == NULL || regs->end == NULL)
../inputs/grep1.dat:5093:153155:                    return -2;
../inputs/grep1.dat:5094:153186:                  bufp->regs_allocated = REGS_REALLOCATE;
../inputs/grep1.dat:5095:153244:                }
../inputs/grep1.dat:5096:153262:              else if (bufp->regs_allocated == REGS_REALLOCATE)
../inputs/grep1.dat:5097:153326:                { /* Yes.  If we need more elements than were already
../inputs/grep1.dat:5098:153396:                     allocated, reallocate them.  If we need fewer, just
../inputs/grep1.dat:5099:153469:                     leave it alone.  */
../inputs/grep1.dat:5100:153510:                  if (regs->num_regs < num_regs + 1)
../inputs/grep1.dat:5101:153563:                    {
../inputs/grep1.dat:5102:153585:                      regs->num_regs = num_regs + 1;
../inputs/grep1.dat:5103:153638:                      RETALLOC (regs->start, regs->num_regs, regoff_t);
../inputs/grep1.dat:5104:153710:                      RETALLOC (regs->end, regs->num_regs, regoff_t);
../inputs/grep1.dat:5105:153780:                      if (regs->start == NULL || regs->end == NULL)
../inputs/grep1.dat:5106:153848:                        return -2;
../inputs/grep1.dat:5107:153883:                    }
../inputs/grep1.dat:5108:153905:                }
../inputs/grep1.dat:5109:153923:              else
../inputs/grep1.dat:5110:153942:		{
../inputs/grep1.dat:5111:153946:		  /* These braces fend off a "empty body in an else-statement"
../inputs/grep1.dat:5112:154011:		     warning under GCC when assert expands to nothing.  */
../inputs/grep1.dat:5113:154072:		  assert (bufp->regs_allocated == REGS_FIXED);
../inputs/grep1.dat:5114:154121:		}
../inputs/grep1.dat:5115:154125:
../inputs/grep1.dat:5116:154126:              /* Convert the pointer data in `regstart' and `regend' to
../inputs/grep1.dat:5117:154198:                 indices.  Register zero has to be set differently,
../inputs/grep1.dat:5118:154266:                 since we haven't kept track of any info for it.  */
../inputs/grep1.dat:5119:154335:              if (regs->num_regs > 0)
../inputs/grep1.dat:5120:154373:                {
../inputs/grep1.dat:5121:154391:                  regs->start[0] = pos;
../inputs/grep1.dat:5122:154431:                  regs->end[0] = (MATCHING_IN_FIRST_STRING ? d - string1
../inputs/grep1.dat:5123:154504:			          : d - string2 + size1);
../inputs/grep1.dat:5124:154541:                }
../inputs/grep1.dat:5125:154559:              
../inputs/grep1.dat:5126:154574:              /* Go through the first `min (num_regs, regs->num_regs)'
../inputs/grep1.dat:5127:154645:                 registers, since that is all we initialized.  */
../inputs/grep1.dat:5128:154711:	      for (mcnt = 1; mcnt < MIN (num_regs, regs->num_regs); mcnt++)
../inputs/grep1.dat:5129:154780:		{
../inputs/grep1.dat:5130:154784:                  if (REG_UNSET (regstart[mcnt]) || REG_UNSET (regend[mcnt]))
../inputs/grep1.dat:5131:154862:                    regs->start[mcnt] = regs->end[mcnt] = -1;
../inputs/grep1.dat:5132:154924:                  else
../inputs/grep1.dat:5133:154947:                    {
../inputs/grep1.dat:5134:154969:		      regs->start[mcnt] = POINTER_TO_OFFSET (regstart[mcnt]);
../inputs/grep1.dat:5135:155033:                      regs->end[mcnt] = POINTER_TO_OFFSET (regend[mcnt]);
../inputs/grep1.dat:5136:155107:                    }
../inputs/grep1.dat:5137:155129:		}
../inputs/grep1.dat:5138:155133:              
../inputs/grep1.dat:5139:155148:              /* If the regs structure we return has more elements than
../inputs/grep1.dat:5140:155220:                 were in the pattern, set the extra elements to -1.  If
../inputs/grep1.dat:5141:155292:                 we (re)allocated the registers, this is the case,
../inputs/grep1.dat:5142:155359:                 because we always allocate enough to have at least one
../inputs/grep1.dat:5143:155431:                 -1 at the end.  */
../inputs/grep1.dat:5144:155467:              for (mcnt = num_regs; mcnt < regs->num_regs; mcnt++)
../inputs/grep1.dat:5145:155534:                regs->start[mcnt] = regs->end[mcnt] = -1;
../inputs/grep1.dat:5146:155592:	    } /* regs && !bufp->no_sub */
../inputs/grep1.dat:5147:155627:
../inputs/grep1.dat:5148:155628:          FREE_VARIABLES ();
../inputs/grep1.dat:5149:155657:          DEBUG_PRINT4 ("%u failure points pushed, %u popped (%u remain).\n",
../inputs/grep1.dat:5150:155735:                        nfailure_points_pushed, nfailure_points_popped,
../inputs/grep1.dat:5151:155807:                        nfailure_points_pushed - nfailure_points_popped);
../inputs/grep1.dat:5152:155881:          DEBUG_PRINT2 ("%u registers pushed.\n", num_regs_pushed);
../inputs/grep1.dat:5153:155949:
../inputs/grep1.dat:5154:155950:          mcnt = d - pos - (MATCHING_IN_FIRST_STRING 
../inputs/grep1.dat:5155:156004:			    ? string1 
../inputs/grep1.dat:5156:156022:			    : string2 - size1);
../inputs/grep1.dat:5157:156049:
../inputs/grep1.dat:5158:156050:          DEBUG_PRINT2 ("Returning %d from re_match_2.\n", mcnt);
../inputs/grep1.dat:5159:156116:
../inputs/grep1.dat:5160:156117:          return mcnt;
../inputs/grep1.dat:5161:156140:        }
../inputs/grep1.dat:5162:156150:
../inputs/grep1.dat:5163:156151:      /* Otherwise match next pattern command.  */
../inputs/grep1.dat:5164:156202:#ifdef SWITCH_ENUM_BUG
../inputs/grep1.dat:5165:156225:      switch ((int) ((re_opcode_t) *p++))
../inputs/grep1.dat:5166:156267:#else
../inputs/grep1.dat:5167:156273:      switch ((re_opcode_t) *p++)
../inputs/grep1.dat:5168:156307:#endif
../inputs/grep1.dat:5169:156314:	{
../inputs/grep1.dat:5170:156317:        /* Ignore these.  Used to ignore the n of succeed_n's which
../inputs/grep1.dat:5171:156385:           currently have n == 0.  */
../inputs/grep1.dat:5172:156423:        case no_op:
../inputs/grep1.dat:5173:156443:          DEBUG_PRINT1 ("EXECUTING no_op.\n");
../inputs/grep1.dat:5174:156490:          break;
../inputs/grep1.dat:5175:156507:
../inputs/grep1.dat:5176:156508:
../inputs/grep1.dat:5177:156509:        /* Match the next n pattern characters exactly.  The following
../inputs/grep1.dat:5178:156580:           byte in the pattern defines n, and the n bytes after that
../inputs/grep1.dat:5179:156649:           are the characters to match.  */
../inputs/grep1.dat:5180:156693:	case exactn:
../inputs/grep1.dat:5181:156707:	  mcnt = *p++;
../inputs/grep1.dat:5182:156723:          DEBUG_PRINT2 ("EXECUTING exactn %d.\n", mcnt);
../inputs/grep1.dat:5183:156780:
../inputs/grep1.dat:5184:156781:          /* This is written out as an if-else so we don't waste time
../inputs/grep1.dat:5185:156851:             testing `translate' inside the loop.  */
../inputs/grep1.dat:5186:156905:          if (translate)
../inputs/grep1.dat:5187:156930:	    {
../inputs/grep1.dat:5188:156937:	      do
../inputs/grep1.dat:5189:156947:		{
../inputs/grep1.dat:5190:156951:		  PREFETCH ();
../inputs/grep1.dat:5191:156968:		  if (translate[(unsigned char) *d++] != (char) *p++)
../inputs/grep1.dat:5192:157024:                    goto fail;
../inputs/grep1.dat:5193:157055:		}
../inputs/grep1.dat:5194:157059:	      while (--mcnt);
../inputs/grep1.dat:5195:157082:	    }
../inputs/grep1.dat:5196:157089:	  else
../inputs/grep1.dat:5197:157097:	    {
../inputs/grep1.dat:5198:157104:	      do
../inputs/grep1.dat:5199:157114:		{
../inputs/grep1.dat:5200:157118:		  PREFETCH ();
../inputs/grep1.dat:5201:157135:		  if (*d++ != (char) *p++) goto fail;
../inputs/grep1.dat:5202:157175:		}
../inputs/grep1.dat:5203:157179:	      while (--mcnt);
../inputs/grep1.dat:5204:157202:	    }
../inputs/grep1.dat:5205:157209:	  SET_REGS_MATCHED ();
../inputs/grep1.dat:5206:157233:          break;
../inputs/grep1.dat:5207:157250:
../inputs/grep1.dat:5208:157251:
../inputs/grep1.dat:5209:157252:        /* Match any character except possibly a newline or a null.  */
../inputs/grep1.dat:5210:157324:	case anychar:
../inputs/grep1.dat:5211:157339:          DEBUG_PRINT1 ("EXECUTING anychar.\n");
../inputs/grep1.dat:5212:157388:
../inputs/grep1.dat:5213:157389:          PREFETCH ();
../inputs/grep1.dat:5214:157412:
../inputs/grep1.dat:5215:157413:          if ((!(bufp->syntax & RE_DOT_NEWLINE) && TRANSLATE (*d) == '\n')
../inputs/grep1.dat:5216:157488:              || (bufp->syntax & RE_DOT_NOT_NULL && TRANSLATE (*d) == '\000'))
../inputs/grep1.dat:5217:157567:	    goto fail;
../inputs/grep1.dat:5218:157583:
../inputs/grep1.dat:5219:157584:          SET_REGS_MATCHED ();
../inputs/grep1.dat:5220:157615:          DEBUG_PRINT2 ("  Matched `%d'.\n", *d);
../inputs/grep1.dat:5221:157665:          d++;
../inputs/grep1.dat:5222:157680:	  break;
../inputs/grep1.dat:5223:157690:
../inputs/grep1.dat:5224:157691:
../inputs/grep1.dat:5225:157692:	case charset:
../inputs/grep1.dat:5226:157707:	case charset_not:
../inputs/grep1.dat:5227:157726:	  {
../inputs/grep1.dat:5228:157731:	    register unsigned char c;
../inputs/grep1.dat:5229:157762:	    boolean not = (re_opcode_t) *(p - 1) == charset_not;
../inputs/grep1.dat:5230:157820:
../inputs/grep1.dat:5231:157821:            DEBUG_PRINT2 ("EXECUTING charset%s.\n", not ? "_not" : "");
../inputs/grep1.dat:5232:157893:
../inputs/grep1.dat:5233:157894:	    PREFETCH ();
../inputs/grep1.dat:5234:157912:	    c = TRANSLATE (*d); /* The character to match.  */
../inputs/grep1.dat:5235:157968:
../inputs/grep1.dat:5236:157969:            /* Cast to `unsigned' instead of `unsigned char' in case the
../inputs/grep1.dat:5237:158042:               bit list is a full 32 bytes long.  */
../inputs/grep1.dat:5238:158095:	    if (c < (unsigned) (*p * BYTEWIDTH)
../inputs/grep1.dat:5239:158136:		&& p[1 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
../inputs/grep1.dat:5240:158188:	      not = !not;
../inputs/grep1.dat:5241:158207:
../inputs/grep1.dat:5242:158208:	    p += 1 + *p;
../inputs/grep1.dat:5243:158226:
../inputs/grep1.dat:5244:158227:	    if (!not) goto fail;
../inputs/grep1.dat:5245:158253:            
../inputs/grep1.dat:5246:158266:	    SET_REGS_MATCHED ();
../inputs/grep1.dat:5247:158292:            d++;
../inputs/grep1.dat:5248:158309:	    break;
../inputs/grep1.dat:5249:158321:	  }
../inputs/grep1.dat:5250:158326:
../inputs/grep1.dat:5251:158327:
../inputs/grep1.dat:5252:158328:        /* The beginning of a group is represented by start_memory.
../inputs/grep1.dat:5253:158396:           The arguments are the register number in the next byte, and the
../inputs/grep1.dat:5254:158471:           number of groups inner to this one in the next.  The text
../inputs/grep1.dat:5255:158540:           matched within the group is recorded (in the internal
../inputs/grep1.dat:5256:158605:           registers data structure) under the register number.  */
../inputs/grep1.dat:5257:158673:        case start_memory:
../inputs/grep1.dat:5258:158700:	  DEBUG_PRINT3 ("EXECUTING start_memory %d (%d):\n", *p, p[1]);
../inputs/grep1.dat:5259:158765:
../inputs/grep1.dat:5260:158766:          /* Find out if this group can match the empty string.  */
../inputs/grep1.dat:5261:158834:	  p1 = p;		/* To send to group_match_null_string_p.  */
../inputs/grep1.dat:5262:158891:          
../inputs/grep1.dat:5263:158902:          if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)
../inputs/grep1.dat:5264:158982:            REG_MATCH_NULL_STRING_P (reg_info[*p]) 
../inputs/grep1.dat:5265:159034:              = group_match_null_string_p (&p1, pend, reg_info);
../inputs/grep1.dat:5266:159099:
../inputs/grep1.dat:5267:159100:          /* Save the position in the string where we were the last time
../inputs/grep1.dat:5268:159173:             we were at this open-group operator in case the group is
../inputs/grep1.dat:5269:159243:             operated upon by a repetition operator, e.g., with `(a*)*b'
../inputs/grep1.dat:5270:159316:             against `ab'; then we want to ignore where we are now in
../inputs/grep1.dat:5271:159386:             the string in case this attempt to match fails.  */
../inputs/grep1.dat:5272:159451:          old_regstart[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
../inputs/grep1.dat:5273:159519:                             ? REG_UNSET (regstart[*p]) ? d : regstart[*p]
../inputs/grep1.dat:5274:159594:                             : regstart[*p];
../inputs/grep1.dat:5275:159639:	  DEBUG_PRINT2 ("  old_regstart: %d\n", 
../inputs/grep1.dat:5276:159681:			 POINTER_TO_OFFSET (old_regstart[*p]));
../inputs/grep1.dat:5277:159724:
../inputs/grep1.dat:5278:159725:          regstart[*p] = d;
../inputs/grep1.dat:5279:159753:	  DEBUG_PRINT2 ("  regstart: %d\n", POINTER_TO_OFFSET (regstart[*p]));
../inputs/grep1.dat:5280:159825:
../inputs/grep1.dat:5281:159826:          IS_ACTIVE (reg_info[*p]) = 1;
../inputs/grep1.dat:5282:159866:          MATCHED_SOMETHING (reg_info[*p]) = 0;
../inputs/grep1.dat:5283:159914:          
../inputs/grep1.dat:5284:159925:          /* This is the new highest active register.  */
../inputs/grep1.dat:5285:159983:          highest_active_reg = *p;
../inputs/grep1.dat:5286:160018:          
../inputs/grep1.dat:5287:160029:          /* If nothing was active before, this is the new lowest active
../inputs/grep1.dat:5288:160102:             register.  */
../inputs/grep1.dat:5289:160129:          if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
../inputs/grep1.dat:5290:160186:            lowest_active_reg = *p;
../inputs/grep1.dat:5291:160222:
../inputs/grep1.dat:5292:160223:          /* Move past the register number and inner group count.  */
../inputs/grep1.dat:5293:160293:          p += 2;
../inputs/grep1.dat:5294:160311:          break;
../inputs/grep1.dat:5295:160328:
../inputs/grep1.dat:5296:160329:
../inputs/grep1.dat:5297:160330:        /* The stop_memory opcode represents the end of a group.  Its
../inputs/grep1.dat:5298:160400:           arguments are the same as start_memory's: the register
../inputs/grep1.dat:5299:160466:           number, and the number of inner groups.  */
../inputs/grep1.dat:5300:160521:	case stop_memory:
../inputs/grep1.dat:5301:160540:	  DEBUG_PRINT3 ("EXECUTING stop_memory %d (%d):\n", *p, p[1]);
../inputs/grep1.dat:5302:160604:             
../inputs/grep1.dat:5303:160618:          /* We need to save the string position the last time we were at
../inputs/grep1.dat:5304:160692:             this close-group operator in case the group is operated
../inputs/grep1.dat:5305:160761:             upon by a repetition operator, e.g., with `((a*)*(b*)*)*'
../inputs/grep1.dat:5306:160832:             against `aba'; then we want to ignore where we are now in
../inputs/grep1.dat:5307:160903:             the string in case this attempt to match fails.  */
../inputs/grep1.dat:5308:160968:          old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
../inputs/grep1.dat:5309:161034:                           ? REG_UNSET (regend[*p]) ? d : regend[*p]
../inputs/grep1.dat:5310:161103:			   : regend[*p];
../inputs/grep1.dat:5311:161123:	  DEBUG_PRINT2 ("      old_regend: %d\n", 
../inputs/grep1.dat:5312:161167:			 POINTER_TO_OFFSET (old_regend[*p]));
../inputs/grep1.dat:5313:161208:
../inputs/grep1.dat:5314:161209:          regend[*p] = d;
../inputs/grep1.dat:5315:161235:	  DEBUG_PRINT2 ("      regend: %d\n", POINTER_TO_OFFSET (regend[*p]));
../inputs/grep1.dat:5316:161307:
../inputs/grep1.dat:5317:161308:          /* This register isn't active anymore.  */
../inputs/grep1.dat:5318:161361:          IS_ACTIVE (reg_info[*p]) = 0;
../inputs/grep1.dat:5319:161401:          
../inputs/grep1.dat:5320:161412:          /* If this was the only register active, nothing is active
../inputs/grep1.dat:5321:161481:             anymore.  */
../inputs/grep1.dat:5322:161507:          if (lowest_active_reg == highest_active_reg)
../inputs/grep1.dat:5323:161562:            {
../inputs/grep1.dat:5324:161576:              lowest_active_reg = NO_LOWEST_ACTIVE_REG;
../inputs/grep1.dat:5325:161632:              highest_active_reg = NO_HIGHEST_ACTIVE_REG;
../inputs/grep1.dat:5326:161690:            }
../inputs/grep1.dat:5327:161704:          else
../inputs/grep1.dat:5328:161719:            { /* We must scan for the new highest active register, since
../inputs/grep1.dat:5329:161792:                 it isn't necessarily one less than now: consider
../inputs/grep1.dat:5330:161858:                 (a(b)c(d(e)f)g).  When group 3 ends, after the f), the
../inputs/grep1.dat:5331:161930:                 new highest active register is 1.  */
../inputs/grep1.dat:5332:161985:              unsigned char r = *p - 1;
../inputs/grep1.dat:5333:162025:              while (r > 0 && !IS_ACTIVE (reg_info[r]))
../inputs/grep1.dat:5334:162081:                r--;
../inputs/grep1.dat:5335:162102:              
../inputs/grep1.dat:5336:162117:              /* If we end up at register zero, that means that we saved
../inputs/grep1.dat:5337:162190:                 the registers as the result of an `on_failure_jump', not
../inputs/grep1.dat:5338:162264:                 a `start_memory', and we jumped to past the innermost
../inputs/grep1.dat:5339:162335:                 `stop_memory'.  For example, in ((.)*) we save
../inputs/grep1.dat:5340:162399:                 registers 1 and 2 as a result of the *, but when we pop
../inputs/grep1.dat:5341:162472:                 back to the second ), we are at the stop_memory 1.
../inputs/grep1.dat:5342:162540:                 Thus, nothing is active.  */
../inputs/grep1.dat:5343:162586:	      if (r == 0)
../inputs/grep1.dat:5344:162605:                {
../inputs/grep1.dat:5345:162623:                  lowest_active_reg = NO_LOWEST_ACTIVE_REG;
../inputs/grep1.dat:5346:162683:                  highest_active_reg = NO_HIGHEST_ACTIVE_REG;
../inputs/grep1.dat:5347:162745:                }
../inputs/grep1.dat:5348:162763:              else
../inputs/grep1.dat:5349:162782:                highest_active_reg = r;
../inputs/grep1.dat:5350:162822:            }
../inputs/grep1.dat:5351:162836:          
../inputs/grep1.dat:5352:162847:          /* If just failed to match something this time around with a
../inputs/grep1.dat:5353:162918:             group that's operated on by a repetition operator, try to
../inputs/grep1.dat:5354:162989:             force exit from the ``loop'', and restore the register
../inputs/grep1.dat:5355:163057:             information for this group that we had before trying this
../inputs/grep1.dat:5356:163128:             last match.  */
../inputs/grep1.dat:5357:163157:          if ((!MATCHED_SOMETHING (reg_info[*p])
../inputs/grep1.dat:5358:163206:               || (re_opcode_t) p[-3] == start_memory)
../inputs/grep1.dat:5359:163261:	      && (p + 2) < pend)              
../inputs/grep1.dat:5360:163301:            {
../inputs/grep1.dat:5361:163315:              boolean is_a_jump_n = false;
../inputs/grep1.dat:5362:163358:              
../inputs/grep1.dat:5363:163373:              p1 = p + 2;
../inputs/grep1.dat:5364:163399:              mcnt = 0;
../inputs/grep1.dat:5365:163423:              switch ((re_opcode_t) *p1++)
../inputs/grep1.dat:5366:163466:                {
../inputs/grep1.dat:5367:163484:                  case jump_n:
../inputs/grep1.dat:5368:163515:		    is_a_jump_n = true;
../inputs/grep1.dat:5369:163541:                  case pop_failure_jump:
../inputs/grep1.dat:5370:163582:		  case maybe_pop_jump:
../inputs/grep1.dat:5371:163607:		  case jump:
../inputs/grep1.dat:5372:163622:		  case dummy_failure_jump:
../inputs/grep1.dat:5373:163651:                    EXTRACT_NUMBER_AND_INCR (mcnt, p1);
../inputs/grep1.dat:5374:163707:		    if (is_a_jump_n)
../inputs/grep1.dat:5375:163730:		      p1 += 2;
../inputs/grep1.dat:5376:163747:                    break;
../inputs/grep1.dat:5377:163774:                  
../inputs/grep1.dat:5378:163793:                  default:
../inputs/grep1.dat:5379:163820:                    /* do nothing */ ;
../inputs/grep1.dat:5380:163859:                }
../inputs/grep1.dat:5381:163877:	      p1 += mcnt;
../inputs/grep1.dat:5382:163896:        
../inputs/grep1.dat:5383:163905:              /* If the next operation is a jump backwards in the pattern
../inputs/grep1.dat:5384:163979:	         to an on_failure_jump right before the start_memory
../inputs/grep1.dat:5385:164041:                 corresponding to this stop_memory, exit from the loop
../inputs/grep1.dat:5386:164112:                 by forcing a failure after pushing on the stack the
../inputs/grep1.dat:5387:164181:                 on_failure_jump's jump in the pattern, and d.  */
../inputs/grep1.dat:5388:164248:              if (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump
../inputs/grep1.dat:5389:164315:                  && (re_opcode_t) p1[3] == start_memory && p1[4] == *p)
../inputs/grep1.dat:5390:164388:		{
../inputs/grep1.dat:5391:164392:                  /* If this group ever matched anything, then restore
../inputs/grep1.dat:5392:164463:                     what its registers were before trying this last
../inputs/grep1.dat:5393:164532:                     failed match, e.g., with `(a*)*b' against `ab' for
../inputs/grep1.dat:5394:164604:                     regstart[1], and, e.g., with `((a*)*(b*)*)*'
../inputs/grep1.dat:5395:164670:                     against `aba' for regend[3].
../inputs/grep1.dat:5396:164720:                     
../inputs/grep1.dat:5397:164742:                     Also restore the registers for inner groups for,
../inputs/grep1.dat:5398:164812:                     e.g., `((a*)(b*))*' against `aba' (register 3 would
../inputs/grep1.dat:5399:164885:                     otherwise get trashed).  */
../inputs/grep1.dat:5400:164934:                     
../inputs/grep1.dat:5401:164956:                  if (EVER_MATCHED_SOMETHING (reg_info[*p]))
../inputs/grep1.dat:5402:165017:		    {
../inputs/grep1.dat:5403:165025:		      unsigned r; 
../inputs/grep1.dat:5404:165046:        
../inputs/grep1.dat:5405:165055:                      EVER_MATCHED_SOMETHING (reg_info[*p]) = 0;
../inputs/grep1.dat:5406:165120:                      
../inputs/grep1.dat:5407:165143:		      /* Restore this and inner groups' (if any) registers.  */
../inputs/grep1.dat:5408:165209:                      for (r = *p; r < *p + *(p + 1); r++)
../inputs/grep1.dat:5409:165268:                        {
../inputs/grep1.dat:5410:165294:                          regstart[r] = old_regstart[r];
../inputs/grep1.dat:5411:165351:
../inputs/grep1.dat:5412:165352:                          /* xx why this test?  */
../inputs/grep1.dat:5413:165403:                          if ((int) old_regend[r] >= (int) regstart[r])
../inputs/grep1.dat:5414:165475:                            regend[r] = old_regend[r];
../inputs/grep1.dat:5415:165530:                        }     
../inputs/grep1.dat:5416:165561:                    }
../inputs/grep1.dat:5417:165583:		  p1++;
../inputs/grep1.dat:5418:165593:                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
../inputs/grep1.dat:5419:165647:                  PUSH_FAILURE_POINT (p1 + mcnt, d, -2);
../inputs/grep1.dat:5420:165704:
../inputs/grep1.dat:5421:165705:                  goto fail;
../inputs/grep1.dat:5422:165734:                }
../inputs/grep1.dat:5423:165752:            }
../inputs/grep1.dat:5424:165766:          
../inputs/grep1.dat:5425:165777:          /* Move past the register number and the inner group count.  */
../inputs/grep1.dat:5426:165851:          p += 2;
../inputs/grep1.dat:5427:165869:          break;
../inputs/grep1.dat:5428:165886:
../inputs/grep1.dat:5429:165887:
../inputs/grep1.dat:5430:165888:	/* \<digit> has been turned into a `duplicate' command which is
../inputs/grep1.dat:5431:165953:           followed by the numeric value of <digit> as the register number.  */
../inputs/grep1.dat:5432:166033:        case duplicate:
../inputs/grep1.dat:5433:166057:	  {
../inputs/grep1.dat:5434:166062:	    register const char *d2, *dend2;
../inputs/grep1.dat:5435:166100:	    int regno = *p++;   /* Get which register to match against.  */
../inputs/grep1.dat:5436:166169:	    DEBUG_PRINT2 ("EXECUTING duplicate %d.\n", regno);
../inputs/grep1.dat:5437:166225:
../inputs/grep1.dat:5438:166226:	    /* Can't back reference a group which we've never matched.  */
../inputs/grep1.dat:5439:166294:            if (REG_UNSET (regstart[regno]) || REG_UNSET (regend[regno]))
../inputs/grep1.dat:5440:166368:              goto fail;
../inputs/grep1.dat:5441:166393:              
../inputs/grep1.dat:5442:166408:            /* Where in input to try to start matching.  */
../inputs/grep1.dat:5443:166468:            d2 = regstart[regno];
../inputs/grep1.dat:5444:166502:            
../inputs/grep1.dat:5445:166515:            /* Where to stop matching; if both the place to start and
../inputs/grep1.dat:5446:166585:               the place to stop matching are in the same string, then
../inputs/grep1.dat:5447:166656:               set to the place to stop, otherwise, for now have to use
../inputs/grep1.dat:5448:166728:               the end of the first string.  */
../inputs/grep1.dat:5449:166776:
../inputs/grep1.dat:5450:166777:            dend2 = ((FIRST_STRING_P (regstart[regno]) 
../inputs/grep1.dat:5451:166833:		      == FIRST_STRING_P (regend[regno]))
../inputs/grep1.dat:5452:166876:		     ? regend[regno] : end_match_1);
../inputs/grep1.dat:5453:166915:	    for (;;)
../inputs/grep1.dat:5454:166929:	      {
../inputs/grep1.dat:5455:166938:		/* If necessary, advance to next segment in register
../inputs/grep1.dat:5456:166993:                   contents.  */
../inputs/grep1.dat:5457:167026:		while (d2 == dend2)
../inputs/grep1.dat:5458:167048:		  {
../inputs/grep1.dat:5459:167054:		    if (dend2 == end_match_2) break;
../inputs/grep1.dat:5460:167093:		    if (dend2 == regend[regno]) break;
../inputs/grep1.dat:5461:167134:
../inputs/grep1.dat:5462:167135:                    /* End of string1 => advance to string2. */
../inputs/grep1.dat:5463:167199:                    d2 = string2;
../inputs/grep1.dat:5464:167233:                    dend2 = regend[regno];
../inputs/grep1.dat:5465:167276:		  }
../inputs/grep1.dat:5466:167282:		/* At end of register contents => success */
../inputs/grep1.dat:5467:167329:		if (d2 == dend2) break;
../inputs/grep1.dat:5468:167355:
../inputs/grep1.dat:5469:167356:		/* If necessary, advance to next segment in data.  */
../inputs/grep1.dat:5470:167412:		PREFETCH ();
../inputs/grep1.dat:5471:167427:
../inputs/grep1.dat:5472:167428:		/* How many characters left in this segment to match.  */
../inputs/grep1.dat:5473:167488:		mcnt = dend - d;
../inputs/grep1.dat:5474:167507:                
../inputs/grep1.dat:5475:167524:		/* Want how many consecutive characters we can match in
../inputs/grep1.dat:5476:167582:                   one shot, so, if necessary, adjust the count.  */
../inputs/grep1.dat:5477:167651:                if (mcnt > dend2 - d2)
../inputs/grep1.dat:5478:167690:		  mcnt = dend2 - d2;
../inputs/grep1.dat:5479:167713:                  
../inputs/grep1.dat:5480:167732:		/* Compare that many; failure if mismatch, else move
../inputs/grep1.dat:5481:167787:                   past them.  */
../inputs/grep1.dat:5482:167821:		if (translate 
../inputs/grep1.dat:5483:167838:                    ? bcmp_translate (d, d2, mcnt, translate) 
../inputs/grep1.dat:5484:167901:                    : bcmp (d, d2, mcnt))
../inputs/grep1.dat:5485:167943:		  goto fail;
../inputs/grep1.dat:5486:167958:		d += mcnt, d2 += mcnt;
../inputs/grep1.dat:5487:167983:	      }
../inputs/grep1.dat:5488:167992:	  }
../inputs/grep1.dat:5489:167997:	  break;
../inputs/grep1.dat:5490:168007:
../inputs/grep1.dat:5491:168008:
../inputs/grep1.dat:5492:168009:        /* begline matches the empty string at the beginning of the string
../inputs/grep1.dat:5493:168084:           (unless `not_bol' is set in `bufp'), and, if
../inputs/grep1.dat:5494:168140:           `newline_anchor' is set, after newlines.  */
../inputs/grep1.dat:5495:168196:	case begline:
../inputs/grep1.dat:5496:168211:          DEBUG_PRINT1 ("EXECUTING begline.\n");
../inputs/grep1.dat:5497:168260:          
../inputs/grep1.dat:5498:168271:          if (AT_STRINGS_BEG (d))
../inputs/grep1.dat:5499:168305:            {
../inputs/grep1.dat:5500:168319:              if (!bufp->not_bol) break;
../inputs/grep1.dat:5501:168360:            }
../inputs/grep1.dat:5502:168374:          else if (d[-1] == '\n' && bufp->newline_anchor)
../inputs/grep1.dat:5503:168432:            {
../inputs/grep1.dat:5504:168446:              break;
../inputs/grep1.dat:5505:168467:            }
../inputs/grep1.dat:5506:168481:          /* In all other cases, we fail.  */
../inputs/grep1.dat:5507:168527:          goto fail;
../inputs/grep1.dat:5508:168548:
../inputs/grep1.dat:5509:168549:
../inputs/grep1.dat:5510:168550:        /* endline is the dual of begline.  */
../inputs/grep1.dat:5511:168597:	case endline:
../inputs/grep1.dat:5512:168612:          DEBUG_PRINT1 ("EXECUTING endline.\n");
../inputs/grep1.dat:5513:168661:
../inputs/grep1.dat:5514:168662:          if (AT_STRINGS_END (d))
../inputs/grep1.dat:5515:168696:            {
../inputs/grep1.dat:5516:168710:              if (!bufp->not_eol) break;
../inputs/grep1.dat:5517:168751:            }
../inputs/grep1.dat:5518:168765:          
../inputs/grep1.dat:5519:168776:          /* We have to ``prefetch'' the next character.  */
../inputs/grep1.dat:5520:168837:          else if ((d == end1 ? *string2 : *d) == '\n'
../inputs/grep1.dat:5521:168892:                   && bufp->newline_anchor)
../inputs/grep1.dat:5522:168936:            {
../inputs/grep1.dat:5523:168950:              break;
../inputs/grep1.dat:5524:168971:            }
../inputs/grep1.dat:5525:168985:          goto fail;
../inputs/grep1.dat:5526:169006:
../inputs/grep1.dat:5527:169007:
../inputs/grep1.dat:5528:169008:	/* Match at the very beginning of the data.  */
../inputs/grep1.dat:5529:169057:        case begbuf:
../inputs/grep1.dat:5530:169078:          DEBUG_PRINT1 ("EXECUTING begbuf.\n");
../inputs/grep1.dat:5531:169126:          if (AT_STRINGS_BEG (d))
../inputs/grep1.dat:5532:169160:            break;
../inputs/grep1.dat:5533:169179:          goto fail;
../inputs/grep1.dat:5534:169200:
../inputs/grep1.dat:5535:169201:
../inputs/grep1.dat:5536:169202:	/* Match at the very end of the data.  */
../inputs/grep1.dat:5537:169245:        case endbuf:
../inputs/grep1.dat:5538:169266:          DEBUG_PRINT1 ("EXECUTING endbuf.\n");
../inputs/grep1.dat:5539:169314:	  if (AT_STRINGS_END (d))
../inputs/grep1.dat:5540:169341:	    break;
../inputs/grep1.dat:5541:169353:          goto fail;
../inputs/grep1.dat:5542:169374:
../inputs/grep1.dat:5543:169375:
../inputs/grep1.dat:5544:169376:        /* on_failure_keep_string_jump is used to optimize `.*\n'.  It
../inputs/grep1.dat:5545:169447:           pushes NULL as the value for the string on the stack.  Then
../inputs/grep1.dat:5546:169518:           `pop_failure_point' will keep the current value for the
../inputs/grep1.dat:5547:169585:           string, instead of restoring it.  To see why, consider
../inputs/grep1.dat:5548:169651:           matching `foo\nbar' against `.*\n'.  The .* matches the foo;
../inputs/grep1.dat:5549:169723:           then the . fails against the \n.  But the next thing we want
../inputs/grep1.dat:5550:169795:           to do is match the \n against the \n; if we restored the
../inputs/grep1.dat:5551:169863:           string value, we would be back at the foo.
../inputs/grep1.dat:5552:169917:           
../inputs/grep1.dat:5553:169929:           Because this is used only in specific cases, we don't need to
../inputs/grep1.dat:5554:170002:           check all the things that `on_failure_jump' does, to make
../inputs/grep1.dat:5555:170071:           sure the right things get saved on the stack.  Hence we don't
../inputs/grep1.dat:5556:170144:           share its code.  The only reason to push anything on the
../inputs/grep1.dat:5557:170212:           stack at all is that otherwise we would have to change
../inputs/grep1.dat:5558:170278:           `anychar's code to do something besides goto fail in this
../inputs/grep1.dat:5559:170347:           case; that seems worse than this.  */
../inputs/grep1.dat:5560:170396:        case on_failure_keep_string_jump:
../inputs/grep1.dat:5561:170438:          DEBUG_PRINT1 ("EXECUTING on_failure_keep_string_jump");
../inputs/grep1.dat:5562:170504:          
../inputs/grep1.dat:5563:170515:          EXTRACT_NUMBER_AND_INCR (mcnt, p);
../inputs/grep1.dat:5564:170560:          DEBUG_PRINT3 (" %d (to 0x%x):\n", mcnt, p + mcnt);
../inputs/grep1.dat:5565:170621:
../inputs/grep1.dat:5566:170622:          PUSH_FAILURE_POINT (p + mcnt, NULL, -2);
../inputs/grep1.dat:5567:170673:          break;
../inputs/grep1.dat:5568:170690:
../inputs/grep1.dat:5569:170691:
../inputs/grep1.dat:5570:170692:	/* Uses of on_failure_jump:
../inputs/grep1.dat:5571:170721:        
../inputs/grep1.dat:5572:170730:           Each alternative starts with an on_failure_jump that points
../inputs/grep1.dat:5573:170801:           to the beginning of the next alternative.  Each alternative
../inputs/grep1.dat:5574:170872:           except the last ends with a jump that in effect jumps past
../inputs/grep1.dat:5575:170942:           the rest of the alternatives.  (They really jump to the
../inputs/grep1.dat:5576:171009:           ending jump of the following alternative, because tensioning
../inputs/grep1.dat:5577:171081:           these jumps is a hassle.)
../inputs/grep1.dat:5578:171118:
../inputs/grep1.dat:5579:171119:           Repeats start with an on_failure_jump that points past both
../inputs/grep1.dat:5580:171190:           the repetition text and either the following jump or
../inputs/grep1.dat:5581:171254:           pop_failure_jump back to this on_failure_jump.  */
../inputs/grep1.dat:5582:171316:	case on_failure_jump:
../inputs/grep1.dat:5583:171339:        on_failure:
../inputs/grep1.dat:5584:171359:          DEBUG_PRINT1 ("EXECUTING on_failure_jump");
../inputs/grep1.dat:5585:171413:
../inputs/grep1.dat:5586:171414:          EXTRACT_NUMBER_AND_INCR (mcnt, p);
../inputs/grep1.dat:5587:171459:          DEBUG_PRINT3 (" %d (to 0x%x)", mcnt, p + mcnt);
../inputs/grep1.dat:5588:171517:
../inputs/grep1.dat:5589:171518:          /* If this on_failure_jump comes right before a group (i.e.,
../inputs/grep1.dat:5590:171589:             the original * applied to a group), save the information
../inputs/grep1.dat:5591:171659:             for that group and all inner ones, so that if we fail back
../inputs/grep1.dat:5592:171731:             to this point, the group's information will be correct.
../inputs/grep1.dat:5593:171800:             For example, in \(a*\)*\1, we need the preceding group,
../inputs/grep1.dat:5594:171869:             and in \(\(a*\)b*\)\2, we need the inner group.  */
../inputs/grep1.dat:5595:171934:
../inputs/grep1.dat:5596:171935:          /* We can't use `p' to check ahead because we push
../inputs/grep1.dat:5597:171996:             a failure point to `p + mcnt' after we do this.  */
../inputs/grep1.dat:5598:172061:          p1 = p;
../inputs/grep1.dat:5599:172079:
../inputs/grep1.dat:5600:172080:          /* We need to skip no_op's before we look for the
../inputs/grep1.dat:5601:172140:             start_memory in case this on_failure_jump is happening as
../inputs/grep1.dat:5602:172211:             the result of a completed succeed_n, as in \(a\)\{1,3\}b\1
../inputs/grep1.dat:5603:172283:             against aba.  */
../inputs/grep1.dat:5604:172313:          while (p1 < pend && (re_opcode_t) *p1 == no_op)
../inputs/grep1.dat:5605:172371:            p1++;
../inputs/grep1.dat:5606:172389:
../inputs/grep1.dat:5607:172390:          if (p1 < pend && (re_opcode_t) *p1 == start_memory)
../inputs/grep1.dat:5608:172452:            {
../inputs/grep1.dat:5609:172466:              /* We have a new highest active register now.  This will
../inputs/grep1.dat:5610:172537:                 get reset at the start_memory we are about to get to,
../inputs/grep1.dat:5611:172608:                 but we will have saved all the registers relevant to
../inputs/grep1.dat:5612:172678:                 this repetition op, as described above.  */
../inputs/grep1.dat:5613:172739:              highest_active_reg = *(p1 + 1) + *(p1 + 2);
../inputs/grep1.dat:5614:172797:              if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
../inputs/grep1.dat:5615:172858:                lowest_active_reg = *(p1 + 1);
../inputs/grep1.dat:5616:172905:            }
../inputs/grep1.dat:5617:172919:
../inputs/grep1.dat:5618:172920:          DEBUG_PRINT1 (":\n");
../inputs/grep1.dat:5619:172952:          PUSH_FAILURE_POINT (p + mcnt, d, -2);
../inputs/grep1.dat:5620:173000:          break;
../inputs/grep1.dat:5621:173017:
../inputs/grep1.dat:5622:173018:
../inputs/grep1.dat:5623:173019:        /* A smart repeat ends with `maybe_pop_jump'.
../inputs/grep1.dat:5624:173073:	   We change it to either `pop_failure_jump' or `jump'.  */
../inputs/grep1.dat:5625:173134:        case maybe_pop_jump:
../inputs/grep1.dat:5626:173163:          EXTRACT_NUMBER_AND_INCR (mcnt, p);
../inputs/grep1.dat:5627:173208:          DEBUG_PRINT2 ("EXECUTING maybe_pop_jump %d.\n", mcnt);
../inputs/grep1.dat:5628:173273:          {
../inputs/grep1.dat:5629:173285:	    register unsigned char *p2 = p;
../inputs/grep1.dat:5630:173322:
../inputs/grep1.dat:5631:173323:            /* Compare the beginning of the repeat with what in the
../inputs/grep1.dat:5632:173391:               pattern follows its end. If we can establish that there
../inputs/grep1.dat:5633:173462:               is nothing that they would both match, i.e., that we
../inputs/grep1.dat:5634:173530:               would have to backtrack because of (as in, e.g., `a*a')
../inputs/grep1.dat:5635:173601:               then we can change to pop_failure_jump, because we'll
../inputs/grep1.dat:5636:173670:               never have to backtrack.
../inputs/grep1.dat:5637:173710:               
../inputs/grep1.dat:5638:173726:               This is not true in the case of alternatives: in
../inputs/grep1.dat:5639:173790:               `(a|ab)*' we do need to backtrack to the `ab' alternative
../inputs/grep1.dat:5640:173863:               (e.g., if the string was `ab').  But instead of trying to
../inputs/grep1.dat:5641:173936:               detect that here, the alternative has put on a dummy
../inputs/grep1.dat:5642:174004:               failure point which is what we will end up popping.  */
../inputs/grep1.dat:5643:174075:
../inputs/grep1.dat:5644:174076:	    /* Skip over open/close-group commands.  */
../inputs/grep1.dat:5645:174125:	    while (p2 + 2 < pend
../inputs/grep1.dat:5646:174151:		   && ((re_opcode_t) *p2 == stop_memory
../inputs/grep1.dat:5647:174193:		       || (re_opcode_t) *p2 == start_memory))
../inputs/grep1.dat:5648:174241:	      p2 += 3;			/* Skip over args, too.  */
../inputs/grep1.dat:5649:174287:
../inputs/grep1.dat:5650:174288:            /* If we're at the end of the pattern, we can change.  */
../inputs/grep1.dat:5651:174358:            if (p2 == pend)
../inputs/grep1.dat:5652:174386:	      {
../inputs/grep1.dat:5653:174395:		/* Consider what happens when matching ":\(.*\)"
../inputs/grep1.dat:5654:174446:		   against ":/".  I don't really understand this code
../inputs/grep1.dat:5655:174502:		   yet.  */
../inputs/grep1.dat:5656:174516:  	        p[-3] = (unsigned char) pop_failure_jump;
../inputs/grep1.dat:5657:174569:                DEBUG_PRINT1
../inputs/grep1.dat:5658:174598:                  ("  End of pattern: change to `pop_failure_jump'.\n");
../inputs/grep1.dat:5659:174671:              }
../inputs/grep1.dat:5660:174687:
../inputs/grep1.dat:5661:174688:            else if ((re_opcode_t) *p2 == exactn
../inputs/grep1.dat:5662:174737:		     || (bufp->newline_anchor && (re_opcode_t) *p2 == endline))
../inputs/grep1.dat:5663:174803:	      {
../inputs/grep1.dat:5664:174812:		register unsigned char c
../inputs/grep1.dat:5665:174839:                  = *p2 == (unsigned char) endline ? '\n' : p2[2];
../inputs/grep1.dat:5666:174906:		p1 = p + mcnt;
../inputs/grep1.dat:5667:174923:
../inputs/grep1.dat:5668:174924:                /* p1[0] ... p1[2] are the `on_failure_jump' corresponding
../inputs/grep1.dat:5669:174999:                   to the `maybe_finalize_jump' of this case.  Examine what 
../inputs/grep1.dat:5670:175076:                   follows.  */
../inputs/grep1.dat:5671:175108:                if ((re_opcode_t) p1[3] == exactn && p1[5] != c)
../inputs/grep1.dat:5672:175173:                  {
../inputs/grep1.dat:5673:175193:  		    p[-3] = (unsigned char) pop_failure_jump;
../inputs/grep1.dat:5674:175243:                    DEBUG_PRINT3 ("  %c != %c => pop_failure_jump.\n",
../inputs/grep1.dat:5675:175314:                                  c, p1[5]);
../inputs/grep1.dat:5676:175359:                  }
../inputs/grep1.dat:5677:175379:                  
../inputs/grep1.dat:5678:175398:		else if ((re_opcode_t) p1[3] == charset
../inputs/grep1.dat:5679:175440:			 || (re_opcode_t) p1[3] == charset_not)
../inputs/grep1.dat:5680:175483:		  {
../inputs/grep1.dat:5681:175489:		    int not = (re_opcode_t) p1[3] == charset_not;
../inputs/grep1.dat:5682:175541:                    
../inputs/grep1.dat:5683:175562:		    if (c < (unsigned char) (p1[4] * BYTEWIDTH)
../inputs/grep1.dat:5684:175612:			&& p1[5 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
../inputs/grep1.dat:5685:175666:		      not = !not;
../inputs/grep1.dat:5686:175686:
../inputs/grep1.dat:5687:175687:                    /* `not' is equal to 1 if c would match, which means
../inputs/grep1.dat:5688:175760:                        that we can't change to pop_failure_jump.  */
../inputs/grep1.dat:5689:175830:		    if (!not)
../inputs/grep1.dat:5690:175846:                      {
../inputs/grep1.dat:5691:175870:  		        p[-3] = (unsigned char) pop_failure_jump;
../inputs/grep1.dat:5692:175924:                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
../inputs/grep1.dat:5693:176000:                      }
../inputs/grep1.dat:5694:176024:		  }
../inputs/grep1.dat:5695:176030:	      }
../inputs/grep1.dat:5696:176039:	  }
../inputs/grep1.dat:5697:176044:	  p -= 2;		/* Point at relative address again.  */
../inputs/grep1.dat:5698:176096:	  if ((re_opcode_t) p[-1] != pop_failure_jump)
../inputs/grep1.dat:5699:176144:	    {
../inputs/grep1.dat:5700:176151:	      p[-1] = (unsigned char) jump;
../inputs/grep1.dat:5701:176188:              DEBUG_PRINT1 ("  Match => jump.\n");
../inputs/grep1.dat:5702:176239:	      goto unconditional_jump;
../inputs/grep1.dat:5703:176271:	    }
../inputs/grep1.dat:5704:176278:        /* Note fall through.  */
../inputs/grep1.dat:5705:176312:
../inputs/grep1.dat:5706:176313:
../inputs/grep1.dat:5707:176314:	/* The end of a simple repeat has a pop_failure_jump back to
../inputs/grep1.dat:5708:176376:           its matching on_failure_jump, where the latter will push a
../inputs/grep1.dat:5709:176446:           failure point.  The pop_failure_jump takes off failure
../inputs/grep1.dat:5710:176512:           points put on by this pop_failure_jump's matching
../inputs/grep1.dat:5711:176573:           on_failure_jump; we got through the pattern to here from the
../inputs/grep1.dat:5712:176645:           matching on_failure_jump, so didn't fail.  */
../inputs/grep1.dat:5713:176702:        case pop_failure_jump:
../inputs/grep1.dat:5714:176733:          {
../inputs/grep1.dat:5715:176745:            /* We need to pass separate storage for the lowest and
../inputs/grep1.dat:5716:176812:               highest registers, even though we don't care about the
../inputs/grep1.dat:5717:176882:               actual values.  Otherwise, we will restore only one
../inputs/grep1.dat:5718:176949:               register from the stack, since lowest will == highest in
../inputs/grep1.dat:5719:177021:               `pop_failure_point'.  */
../inputs/grep1.dat:5720:177061:            unsigned dummy_low_reg, dummy_high_reg;
../inputs/grep1.dat:5721:177113:            unsigned char *pdummy;
../inputs/grep1.dat:5722:177148:            const char *sdummy;
../inputs/grep1.dat:5723:177180:
../inputs/grep1.dat:5724:177181:            DEBUG_PRINT1 ("EXECUTING pop_failure_jump.\n");
../inputs/grep1.dat:5725:177241:            POP_FAILURE_POINT (sdummy, pdummy,
../inputs/grep1.dat:5726:177288:                               dummy_low_reg, dummy_high_reg,
../inputs/grep1.dat:5727:177350:                               reg_dummy, reg_dummy, reg_info_dummy);
../inputs/grep1.dat:5728:177420:          }
../inputs/grep1.dat:5729:177432:          /* Note fall through.  */
../inputs/grep1.dat:5730:177468:
../inputs/grep1.dat:5731:177469:          
../inputs/grep1.dat:5732:177480:        /* Unconditionally jump (without popping any failure points).  */
../inputs/grep1.dat:5733:177554:        case jump:
../inputs/grep1.dat:5734:177573:	unconditional_jump:
../inputs/grep1.dat:5735:177594:	  EXTRACT_NUMBER_AND_INCR (mcnt, p);	/* Get the amount to jump.  */
../inputs/grep1.dat:5736:177663:          DEBUG_PRINT2 ("EXECUTING jump %d ", mcnt);
../inputs/grep1.dat:5737:177716:	  p += mcnt;				/* Do the jump.  */
../inputs/grep1.dat:5738:177753:          DEBUG_PRINT2 ("(to 0x%x).\n", p);
../inputs/grep1.dat:5739:177797:	  break;
../inputs/grep1.dat:5740:177807:
../inputs/grep1.dat:5741:177808:	
../inputs/grep1.dat:5742:177810:        /* We need this opcode so we can detect where alternatives end
../inputs/grep1.dat:5743:177881:           in `group_match_null_string_p' et al.  */
../inputs/grep1.dat:5744:177934:        case jump_past_alt:
../inputs/grep1.dat:5745:177962:          DEBUG_PRINT1 ("EXECUTING jump_past_alt.\n");
../inputs/grep1.dat:5746:178017:          goto unconditional_jump;
../inputs/grep1.dat:5747:178052:
../inputs/grep1.dat:5748:178053:
../inputs/grep1.dat:5749:178054:        /* Normally, the on_failure_jump pushes a failure point, which
../inputs/grep1.dat:5750:178125:           then gets popped at pop_failure_jump.  We will end up at
../inputs/grep1.dat:5751:178193:           pop_failure_jump, also, and with a pattern of, say, `a+', we
../inputs/grep1.dat:5752:178265:           are skipping over the on_failure_jump, so we have to push
../inputs/grep1.dat:5753:178334:           something meaningless for pop_failure_jump to pop.  */
../inputs/grep1.dat:5754:178400:        case dummy_failure_jump:
../inputs/grep1.dat:5755:178433:          DEBUG_PRINT1 ("EXECUTING dummy_failure_jump.\n");
../inputs/grep1.dat:5756:178493:          /* It doesn't matter what we push for the string here.  What
../inputs/grep1.dat:5757:178564:             the code at `fail' tests is the value for the pattern.  */
../inputs/grep1.dat:5758:178636:          PUSH_FAILURE_POINT (0, 0, -2);
../inputs/grep1.dat:5759:178677:          goto unconditional_jump;
../inputs/grep1.dat:5760:178712:
../inputs/grep1.dat:5761:178713:
../inputs/grep1.dat:5762:178714:        /* At the end of an alternative, we need to push a dummy failure
../inputs/grep1.dat:5763:178787:           point in case we are followed by a `pop_failure_jump', because
../inputs/grep1.dat:5764:178861:           we don't want the failure point for the alternative to be
../inputs/grep1.dat:5765:178930:           popped.  For example, matching `(a|ab)*' against `aab'
../inputs/grep1.dat:5766:178996:           requires that we match the `ab' alternative.  */
../inputs/grep1.dat:5767:179056:        case push_dummy_failure:
../inputs/grep1.dat:5768:179089:          DEBUG_PRINT1 ("EXECUTING push_dummy_failure.\n");
../inputs/grep1.dat:5769:179149:          /* See comments just above at `dummy_failure_jump' about the
../inputs/grep1.dat:5770:179220:             two zeroes.  */
../inputs/grep1.dat:5771:179249:          PUSH_FAILURE_POINT (0, 0, -2);
../inputs/grep1.dat:5772:179290:          break;
../inputs/grep1.dat:5773:179307:
../inputs/grep1.dat:5774:179308:        /* Have to succeed matching what follows at least n times.
../inputs/grep1.dat:5775:179375:           After that, handle like `on_failure_jump'.  */
../inputs/grep1.dat:5776:179433:        case succeed_n: 
../inputs/grep1.dat:5777:179458:          EXTRACT_NUMBER (mcnt, p + 2);
../inputs/grep1.dat:5778:179498:          DEBUG_PRINT2 ("EXECUTING succeed_n %d.\n", mcnt);
../inputs/grep1.dat:5779:179558:
../inputs/grep1.dat:5780:179559:          assert (mcnt >= 0);
../inputs/grep1.dat:5781:179589:          /* Originally, this is how many times we HAVE to succeed.  */
../inputs/grep1.dat:5782:179661:          if (mcnt > 0)
../inputs/grep1.dat:5783:179685:            {
../inputs/grep1.dat:5784:179699:               mcnt--;
../inputs/grep1.dat:5785:179722:	       p += 2;
../inputs/grep1.dat:5786:179738:               STORE_NUMBER_AND_INCR (p, mcnt);
../inputs/grep1.dat:5787:179786:               DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p, mcnt);
../inputs/grep1.dat:5788:179852:            }
../inputs/grep1.dat:5789:179866:	  else if (mcnt == 0)
../inputs/grep1.dat:5790:179889:            {
../inputs/grep1.dat:5791:179903:              DEBUG_PRINT2 ("  Setting two bytes from 0x%x to no_op.\n", p+2);
../inputs/grep1.dat:5792:179982:	      p[2] = (unsigned char) no_op;
../inputs/grep1.dat:5793:180019:              p[3] = (unsigned char) no_op;
../inputs/grep1.dat:5794:180063:              goto on_failure;
../inputs/grep1.dat:5795:180094:            }
../inputs/grep1.dat:5796:180108:          break;
../inputs/grep1.dat:5797:180125:        
../inputs/grep1.dat:5798:180134:        case jump_n: 
../inputs/grep1.dat:5799:180156:          EXTRACT_NUMBER (mcnt, p + 2);
../inputs/grep1.dat:5800:180196:          DEBUG_PRINT2 ("EXECUTING jump_n %d.\n", mcnt);
../inputs/grep1.dat:5801:180253:
../inputs/grep1.dat:5802:180254:          /* Originally, this is how many times we CAN jump.  */
../inputs/grep1.dat:5803:180319:          if (mcnt)
../inputs/grep1.dat:5804:180339:            {
../inputs/grep1.dat:5805:180353:               mcnt--;
../inputs/grep1.dat:5806:180376:               STORE_NUMBER (p + 2, mcnt);
../inputs/grep1.dat:5807:180419:	       goto unconditional_jump;	     
../inputs/grep1.dat:5808:180458:            }
../inputs/grep1.dat:5809:180472:          /* If don't have to jump any more, skip over the rest of command.  */
../inputs/grep1.dat:5810:180552:	  else      
../inputs/grep1.dat:5811:180566:	    p += 4;		     
../inputs/grep1.dat:5812:180586:          break;
../inputs/grep1.dat:5813:180603:        
../inputs/grep1.dat:5814:180612:	case set_number_at:
../inputs/grep1.dat:5815:180633:	  {
../inputs/grep1.dat:5816:180638:            DEBUG_PRINT1 ("EXECUTING set_number_at.\n");
../inputs/grep1.dat:5817:180695:
../inputs/grep1.dat:5818:180696:            EXTRACT_NUMBER_AND_INCR (mcnt, p);
../inputs/grep1.dat:5819:180743:            p1 = p + mcnt;
../inputs/grep1.dat:5820:180770:            EXTRACT_NUMBER_AND_INCR (mcnt, p);
../inputs/grep1.dat:5821:180817:            DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p1, mcnt);
../inputs/grep1.dat:5822:180881:	    STORE_NUMBER (p1, mcnt);
../inputs/grep1.dat:5823:180911:            break;
../inputs/grep1.dat:5824:180930:          }
../inputs/grep1.dat:5825:180942:
../inputs/grep1.dat:5826:180943:        case wordbound:
../inputs/grep1.dat:5827:180967:          DEBUG_PRINT1 ("EXECUTING wordbound.\n");
../inputs/grep1.dat:5828:181018:          if (AT_WORD_BOUNDARY (d))
../inputs/grep1.dat:5829:181054:	    break;
../inputs/grep1.dat:5830:181066:          goto fail;
../inputs/grep1.dat:5831:181087:
../inputs/grep1.dat:5832:181088:	case notwordbound:
../inputs/grep1.dat:5833:181108:          DEBUG_PRINT1 ("EXECUTING notwordbound.\n");
../inputs/grep1.dat:5834:181162:	  if (AT_WORD_BOUNDARY (d))
../inputs/grep1.dat:5835:181191:	    goto fail;
../inputs/grep1.dat:5836:181207:          break;
../inputs/grep1.dat:5837:181224:
../inputs/grep1.dat:5838:181225:	case wordbeg:
../inputs/grep1.dat:5839:181240:          DEBUG_PRINT1 ("EXECUTING wordbeg.\n");
../inputs/grep1.dat:5840:181289:	  if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))
../inputs/grep1.dat:5841:181359:	    break;
../inputs/grep1.dat:5842:181371:          goto fail;
../inputs/grep1.dat:5843:181392:
../inputs/grep1.dat:5844:181393:	case wordend:
../inputs/grep1.dat:5845:181408:          DEBUG_PRINT1 ("EXECUTING wordend.\n");
../inputs/grep1.dat:5846:181457:	  if (!AT_STRINGS_BEG (d) && WORDCHAR_P (d - 1)
../inputs/grep1.dat:5847:181506:              && (!WORDCHAR_P (d) || AT_STRINGS_END (d)))
../inputs/grep1.dat:5848:181564:	    break;
../inputs/grep1.dat:5849:181576:          goto fail;
../inputs/grep1.dat:5850:181597:
../inputs/grep1.dat:5851:181598:#ifdef emacs
../inputs/grep1.dat:5852:181611:#ifdef emacs19
../inputs/grep1.dat:5853:181626:  	case before_dot:
../inputs/grep1.dat:5854:181646:          DEBUG_PRINT1 ("EXECUTING before_dot.\n");
../inputs/grep1.dat:5855:181698: 	  if (PTR_CHAR_POS ((unsigned char *) d) >= point)
../inputs/grep1.dat:5856:181751:  	    goto fail;
../inputs/grep1.dat:5857:181769:  	  break;
../inputs/grep1.dat:5858:181781:  
../inputs/grep1.dat:5859:181784:  	case at_dot:
../inputs/grep1.dat:5860:181800:          DEBUG_PRINT1 ("EXECUTING at_dot.\n");
../inputs/grep1.dat:5861:181848: 	  if (PTR_CHAR_POS ((unsigned char *) d) != point)
../inputs/grep1.dat:5862:181901:  	    goto fail;
../inputs/grep1.dat:5863:181919:  	  break;
../inputs/grep1.dat:5864:181931:  
../inputs/grep1.dat:5865:181934:  	case after_dot:
../inputs/grep1.dat:5866:181953:          DEBUG_PRINT1 ("EXECUTING after_dot.\n");
../inputs/grep1.dat:5867:182004:          if (PTR_CHAR_POS ((unsigned char *) d) <= point)
../inputs/grep1.dat:5868:182063:  	    goto fail;
../inputs/grep1.dat:5869:182081:  	  break;
../inputs/grep1.dat:5870:182093:#else /* not emacs19 */
../inputs/grep1.dat:5871:182117:	case at_dot:
../inputs/grep1.dat:5872:182131:          DEBUG_PRINT1 ("EXECUTING at_dot.\n");
../inputs/grep1.dat:5873:182179:	  if (PTR_CHAR_POS ((unsigned char *) d) + 1 != point)
../inputs/grep1.dat:5874:182235:	    goto fail;
../inputs/grep1.dat:5875:182251:	  break;
../inputs/grep1.dat:5876:182261:#endif /* not emacs19 */
../inputs/grep1.dat:5877:182286:
../inputs/grep1.dat:5878:182287:	case syntaxspec:
../inputs/grep1.dat:5879:182305:          DEBUG_PRINT2 ("EXECUTING syntaxspec %d.\n", mcnt);
../inputs/grep1.dat:5880:182366:	  mcnt = *p++;
../inputs/grep1.dat:5881:182382:	  goto matchsyntax;
../inputs/grep1.dat:5882:182403:
../inputs/grep1.dat:5883:182404:        case wordchar:
../inputs/grep1.dat:5884:182427:          DEBUG_PRINT1 ("EXECUTING Emacs wordchar.\n");
../inputs/grep1.dat:5885:182483:	  mcnt = (int) Sword;
../inputs/grep1.dat:5886:182506:        matchsyntax:
../inputs/grep1.dat:5887:182527:	  PREFETCH ();
../inputs/grep1.dat:5888:182543:	  if (SYNTAX (*d++) != (enum syntaxcode) mcnt)
../inputs/grep1.dat:5889:182591:            goto fail;
../inputs/grep1.dat:5890:182614:          SET_REGS_MATCHED ();
../inputs/grep1.dat:5891:182645:	  break;
../inputs/grep1.dat:5892:182655:
../inputs/grep1.dat:5893:182656:	case notsyntaxspec:
../inputs/grep1.dat:5894:182677:          DEBUG_PRINT2 ("EXECUTING notsyntaxspec %d.\n", mcnt);
../inputs/grep1.dat:5895:182741:	  mcnt = *p++;
../inputs/grep1.dat:5896:182757:	  goto matchnotsyntax;
../inputs/grep1.dat:5897:182781:
../inputs/grep1.dat:5898:182782:        case notwordchar:
../inputs/grep1.dat:5899:182808:          DEBUG_PRINT1 ("EXECUTING Emacs notwordchar.\n");
../inputs/grep1.dat:5900:182867:	  mcnt = (int) Sword;
../inputs/grep1.dat:5901:182890:        matchnotsyntax:
../inputs/grep1.dat:5902:182914:	  PREFETCH ();
../inputs/grep1.dat:5903:182930:	  if (SYNTAX (*d++) == (enum syntaxcode) mcnt)
../inputs/grep1.dat:5904:182978:            goto fail;
../inputs/grep1.dat:5905:183001:	  SET_REGS_MATCHED ();
../inputs/grep1.dat:5906:183025:          break;
../inputs/grep1.dat:5907:183042:
../inputs/grep1.dat:5908:183043:#else /* not emacs */
../inputs/grep1.dat:5909:183065:	case wordchar:
../inputs/grep1.dat:5910:183081:          DEBUG_PRINT1 ("EXECUTING non-Emacs wordchar.\n");
../inputs/grep1.dat:5911:183141:	  PREFETCH ();
../inputs/grep1.dat:5912:183157:          if (!WORDCHAR_P (d))
../inputs/grep1.dat:5913:183188:            goto fail;
../inputs/grep1.dat:5914:183211:	  SET_REGS_MATCHED ();
../inputs/grep1.dat:5915:183235:          d++;
../inputs/grep1.dat:5916:183250:	  break;
../inputs/grep1.dat:5917:183260:	  
../inputs/grep1.dat:5918:183264:	case notwordchar:
../inputs/grep1.dat:5919:183283:          DEBUG_PRINT1 ("EXECUTING non-Emacs notwordchar.\n");
../inputs/grep1.dat:5920:183346:	  PREFETCH ();
../inputs/grep1.dat:5921:183362:	  if (WORDCHAR_P (d))
../inputs/grep1.dat:5922:183385:            goto fail;
../inputs/grep1.dat:5923:183408:          SET_REGS_MATCHED ();
../inputs/grep1.dat:5924:183439:          d++;
../inputs/grep1.dat:5925:183454:	  break;
../inputs/grep1.dat:5926:183464:#endif /* not emacs */
../inputs/grep1.dat:5927:183487:          
../inputs/grep1.dat:5928:183498:        default:
../inputs/grep1.dat:5929:183515:          abort ();
../inputs/grep1.dat:5930:183535:	}
../inputs/grep1.dat:5931:183538:      continue;  /* Successfully executed one pattern command; keep going.  */
../inputs/grep1.dat:5932:183617:
../inputs/grep1.dat:5933:183618:
../inputs/grep1.dat:5934:183619:    /* We goto here if a matching operation fails. */
../inputs/grep1.dat:5935:183673:    fail:
../inputs/grep1.dat:5936:183683:      if (!FAIL_STACK_EMPTY ())
../inputs/grep1.dat:5937:183715:	{ /* A restart point is known.  Restore to that state.  */
../inputs/grep1.dat:5938:183775:          DEBUG_PRINT1 ("\nFAIL:\n");
../inputs/grep1.dat:5939:183813:          POP_FAILURE_POINT (d, p,
../inputs/grep1.dat:5940:183848:                             lowest_active_reg, highest_active_reg,
../inputs/grep1.dat:5941:183916:                             regstart, regend, reg_info);
../inputs/grep1.dat:5942:183974:
../inputs/grep1.dat:5943:183975:          /* If this failure point is a dummy, try the next one.  */
../inputs/grep1.dat:5944:184044:          if (!p)
../inputs/grep1.dat:5945:184062:	    goto fail;
../inputs/grep1.dat:5946:184078:
../inputs/grep1.dat:5947:184079:          /* If we failed to the end of the pattern, don't examine *p.  */
../inputs/grep1.dat:5948:184154:	  assert (p <= pend);
../inputs/grep1.dat:5949:184177:          if (p < pend)
../inputs/grep1.dat:5950:184201:            {
../inputs/grep1.dat:5951:184215:              boolean is_a_jump_n = false;
../inputs/grep1.dat:5952:184258:              
../inputs/grep1.dat:5953:184273:              /* If failed to a backwards jump that's part of a repetition
../inputs/grep1.dat:5954:184348:                 loop, need to pop this failure point and use the next one.  */
../inputs/grep1.dat:5955:184428:              switch ((re_opcode_t) *p)
../inputs/grep1.dat:5956:184468:                {
../inputs/grep1.dat:5957:184486:                case jump_n:
../inputs/grep1.dat:5958:184515:                  is_a_jump_n = true;
../inputs/grep1.dat:5959:184553:                case maybe_pop_jump:
../inputs/grep1.dat:5960:184590:                case pop_failure_jump:
../inputs/grep1.dat:5961:184629:                case jump:
../inputs/grep1.dat:5962:184656:                  p1 = p + 1;
../inputs/grep1.dat:5963:184686:                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
../inputs/grep1.dat:5964:184740:                  p1 += mcnt;	
../inputs/grep1.dat:5965:184771:
../inputs/grep1.dat:5966:184772:                  if ((is_a_jump_n && (re_opcode_t) *p1 == succeed_n)
../inputs/grep1.dat:5967:184842:                      || (!is_a_jump_n
../inputs/grep1.dat:5968:184881:                          && (re_opcode_t) *p1 == on_failure_jump))
../inputs/grep1.dat:5969:184949:                    goto fail;
../inputs/grep1.dat:5970:184980:                  break;
../inputs/grep1.dat:5971:185005:                default:
../inputs/grep1.dat:5972:185030:                  /* do nothing */ ;
../inputs/grep1.dat:5973:185067:                }
../inputs/grep1.dat:5974:185085:            }
../inputs/grep1.dat:5975:185099:
../inputs/grep1.dat:5976:185100:          if (d >= string1 && d <= end1)
../inputs/grep1.dat:5977:185141:	    dend = end_match_1;
../inputs/grep1.dat:5978:185166:        }
../inputs/grep1.dat:5979:185176:      else
../inputs/grep1.dat:5980:185187:        break;   /* Matching at this starting point really fails.  */
../inputs/grep1.dat:5981:185257:    } /* for (;;) */
../inputs/grep1.dat:5982:185278:
../inputs/grep1.dat:5983:185279:  if (best_regs_set)
../inputs/grep1.dat:5984:185300:    goto restore_best_regs;
../inputs/grep1.dat:5985:185328:
../inputs/grep1.dat:5986:185329:  FREE_VARIABLES ();
../inputs/grep1.dat:5987:185350:
../inputs/grep1.dat:5988:185351:  return -1;         			/* Failure to match.  */
../inputs/grep1.dat:5989:185400:} /* re_match_2 */
../inputs/grep1.dat:5990:185419:
../inputs/grep1.dat:5991:185421:/* Subroutine definitions for re_match_2.  */
../inputs/grep1.dat:5992:185467:
../inputs/grep1.dat:5993:185468:
../inputs/grep1.dat:5994:185469:/* We are passed P pointing to a register number after a start_memory.
../inputs/grep1.dat:5995:185540:   
../inputs/grep1.dat:5996:185544:   Return true if the pattern up to the corresponding stop_memory can
../inputs/grep1.dat:5997:185614:   match the empty string, and false otherwise.
../inputs/grep1.dat:5998:185662:   
../inputs/grep1.dat:5999:185666:   If we find the matching stop_memory, sets P to point to one past its number.
../inputs/grep1.dat:6000:185746:   Otherwise, sets P to an undefined byte less than or equal to END.
../inputs/grep1.dat:6001:185815:
../inputs/grep1.dat:6002:185816:   We don't handle duplicates properly (yet).  */
../inputs/grep1.dat:6003:185866:
../inputs/grep1.dat:6004:185867:static boolean
../inputs/grep1.dat:6005:185882:group_match_null_string_p (p, end, reg_info)
../inputs/grep1.dat:6006:185927:    unsigned char **p, *end;
../inputs/grep1.dat:6007:185956:    register_info_type *reg_info;
../inputs/grep1.dat:6008:185990:{
../inputs/grep1.dat:6009:185992:  int mcnt;
../inputs/grep1.dat:6010:186004:  /* Point to after the args to the start_memory.  */
../inputs/grep1.dat:6011:186058:  unsigned char *p1 = *p + 2;
../inputs/grep1.dat:6012:186088:  
../inputs/grep1.dat:6013:186091:  while (p1 < end)
../inputs/grep1.dat:6014:186110:    {
../inputs/grep1.dat:6015:186116:      /* Skip over opcodes that can match nothing, and return true or
../inputs/grep1.dat:6016:186186:	 false, as appropriate, when we get to one that can't, or to the
../inputs/grep1.dat:6017:186252:         matching stop_memory.  */
../inputs/grep1.dat:6018:186287:      
../inputs/grep1.dat:6019:186294:      switch ((re_opcode_t) *p1)
../inputs/grep1.dat:6020:186327:        {
../inputs/grep1.dat:6021:186337:        /* Could be either a loop or a series of alternatives.  */
../inputs/grep1.dat:6022:186404:        case on_failure_jump:
../inputs/grep1.dat:6023:186434:          p1++;
../inputs/grep1.dat:6024:186450:          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
../inputs/grep1.dat:6025:186496:          
../inputs/grep1.dat:6026:186507:          /* If the next operation is not a jump backwards in the
../inputs/grep1.dat:6027:186573:	     pattern.  */
../inputs/grep1.dat:6028:186592:
../inputs/grep1.dat:6029:186593:	  if (mcnt >= 0)
../inputs/grep1.dat:6030:186611:	    {
../inputs/grep1.dat:6031:186618:              /* Go through the on_failure_jumps of the alternatives,
../inputs/grep1.dat:6032:186688:                 seeing if any of the alternatives cannot match nothing.
../inputs/grep1.dat:6033:186761:                 The last alternative starts with only a jump,
../inputs/grep1.dat:6034:186824:                 whereas the rest start with on_failure_jump and end
../inputs/grep1.dat:6035:186893:                 with a jump, e.g., here is the pattern for `a|b|c':
../inputs/grep1.dat:6036:186962:
../inputs/grep1.dat:6037:186963:                 /on_failure_jump/0/6/exactn/1/a/jump_past_alt/0/6
../inputs/grep1.dat:6038:187030:                 /on_failure_jump/0/6/exactn/1/b/jump_past_alt/0/3
../inputs/grep1.dat:6039:187097:                 /exactn/1/c						
../inputs/grep1.dat:6040:187132:
../inputs/grep1.dat:6041:187133:                 So, we have to first go through the first (n-1)
../inputs/grep1.dat:6042:187198:                 alternatives and then deal with the last one separately.  */
../inputs/grep1.dat:6043:187276:
../inputs/grep1.dat:6044:187277:
../inputs/grep1.dat:6045:187278:              /* Deal with the first (n-1) alternatives, which start
../inputs/grep1.dat:6046:187347:                 with an on_failure_jump (see above) that jumps to right
../inputs/grep1.dat:6047:187420:                 past a jump_past_alt.  */
../inputs/grep1.dat:6048:187463:
../inputs/grep1.dat:6049:187464:              while ((re_opcode_t) p1[mcnt-3] == jump_past_alt)
../inputs/grep1.dat:6050:187528:                {
../inputs/grep1.dat:6051:187546:                  /* `mcnt' holds how many bytes long the alternative
../inputs/grep1.dat:6052:187616:                     is, including the ending `jump_past_alt' and
../inputs/grep1.dat:6053:187682:                     its number.  */
../inputs/grep1.dat:6054:187719:
../inputs/grep1.dat:6055:187720:                  if (!alt_match_null_string_p (p1, p1 + mcnt - 3, 
../inputs/grep1.dat:6056:187788:				                      reg_info))
../inputs/grep1.dat:6057:187825:                    return false;
../inputs/grep1.dat:6058:187859:
../inputs/grep1.dat:6059:187860:                  /* Move to right after this alternative, including the
../inputs/grep1.dat:6060:187933:		     jump_past_alt.  */
../inputs/grep1.dat:6061:187959:                  p1 += mcnt;	
../inputs/grep1.dat:6062:187990:
../inputs/grep1.dat:6063:187991:                  /* Break if it's the beginning of an n-th alternative
../inputs/grep1.dat:6064:188063:                     that doesn't begin with an on_failure_jump.  */
../inputs/grep1.dat:6065:188132:                  if ((re_opcode_t) *p1 != on_failure_jump)
../inputs/grep1.dat:6066:188192:                    break;
../inputs/grep1.dat:6067:188219:		
../inputs/grep1.dat:6068:188222:		  /* Still have to check that it's not an n-th
../inputs/grep1.dat:6069:188271:		     alternative that starts with an on_failure_jump.  */
../inputs/grep1.dat:6070:188331:		  p1++;
../inputs/grep1.dat:6071:188341:                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
../inputs/grep1.dat:6072:188395:                  if ((re_opcode_t) p1[mcnt-3] != jump_past_alt)
../inputs/grep1.dat:6073:188460:                    {
../inputs/grep1.dat:6074:188482:		      /* Get to the beginning of the n-th alternative.  */
../inputs/grep1.dat:6075:188543:                      p1 -= 3;
../inputs/grep1.dat:6076:188574:                      break;
../inputs/grep1.dat:6077:188603:                    }
../inputs/grep1.dat:6078:188625:                }
../inputs/grep1.dat:6079:188643:
../inputs/grep1.dat:6080:188644:              /* Deal with the last alternative: go back and get number
../inputs/grep1.dat:6081:188716:                 of the `jump_past_alt' just before it.  `mcnt' contains
../inputs/grep1.dat:6082:188789:                 the length of the alternative.  */
../inputs/grep1.dat:6083:188841:              EXTRACT_NUMBER (mcnt, p1 - 2);
../inputs/grep1.dat:6084:188886:
../inputs/grep1.dat:6085:188887:              if (!alt_match_null_string_p (p1, p1 + mcnt, reg_info))
../inputs/grep1.dat:6086:188957:                return false;
../inputs/grep1.dat:6087:188987:
../inputs/grep1.dat:6088:188988:              p1 += mcnt;	/* Get past the n-th alternative.  */
../inputs/grep1.dat:6089:189052:            } /* if mcnt > 0 */
../inputs/grep1.dat:6090:189084:          break;
../inputs/grep1.dat:6091:189101:
../inputs/grep1.dat:6092:189102:          
../inputs/grep1.dat:6093:189113:        case stop_memory:
../inputs/grep1.dat:6094:189139:	  assert (p1[1] == **p);
../inputs/grep1.dat:6095:189165:          *p = p1 + 2;
../inputs/grep1.dat:6096:189188:          return true;
../inputs/grep1.dat:6097:189211:
../inputs/grep1.dat:6098:189212:        
../inputs/grep1.dat:6099:189221:        default: 
../inputs/grep1.dat:6100:189239:          if (!common_op_match_null_string_p (&p1, end, reg_info))
../inputs/grep1.dat:6101:189306:            return false;
../inputs/grep1.dat:6102:189332:        }
../inputs/grep1.dat:6103:189342:    } /* while p1 < end */
../inputs/grep1.dat:6104:189369:
../inputs/grep1.dat:6105:189370:  return false;
../inputs/grep1.dat:6106:189386:} /* group_match_null_string_p */
../inputs/grep1.dat:6107:189420:
../inputs/grep1.dat:6108:189421:
../inputs/grep1.dat:6109:189422:/* Similar to group_match_null_string_p, but doesn't deal with alternatives:
../inputs/grep1.dat:6110:189499:   It expects P to be the first byte of a single alternative and END one
../inputs/grep1.dat:6111:189572:   byte past the last. The alternative can contain groups.  */
../inputs/grep1.dat:6112:189635:   
../inputs/grep1.dat:6113:189639:static boolean
../inputs/grep1.dat:6114:189654:alt_match_null_string_p (p, end, reg_info)
../inputs/grep1.dat:6115:189697:    unsigned char *p, *end;
../inputs/grep1.dat:6116:189725:    register_info_type *reg_info;
../inputs/grep1.dat:6117:189759:{
../inputs/grep1.dat:6118:189761:  int mcnt;
../inputs/grep1.dat:6119:189773:  unsigned char *p1 = p;
../inputs/grep1.dat:6120:189798:  
../inputs/grep1.dat:6121:189801:  while (p1 < end)
../inputs/grep1.dat:6122:189820:    {
../inputs/grep1.dat:6123:189826:      /* Skip over opcodes that can match nothing, and break when we get 
../inputs/grep1.dat:6124:189900:         to one that can't.  */
../inputs/grep1.dat:6125:189932:      
../inputs/grep1.dat:6126:189939:      switch ((re_opcode_t) *p1)
../inputs/grep1.dat:6127:189972:        {
../inputs/grep1.dat:6128:189982:	/* It's a loop.  */
../inputs/grep1.dat:6129:190003:        case on_failure_jump:
../inputs/grep1.dat:6130:190033:          p1++;
../inputs/grep1.dat:6131:190049:          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
../inputs/grep1.dat:6132:190095:          p1 += mcnt;
../inputs/grep1.dat:6133:190117:          break;
../inputs/grep1.dat:6134:190134:          
../inputs/grep1.dat:6135:190145:	default: 
../inputs/grep1.dat:6136:190156:          if (!common_op_match_null_string_p (&p1, end, reg_info))
../inputs/grep1.dat:6137:190223:            return false;
../inputs/grep1.dat:6138:190249:        }
../inputs/grep1.dat:6139:190259:    }  /* while p1 < end */
../inputs/grep1.dat:6140:190287:
../inputs/grep1.dat:6141:190288:  return true;
../inputs/grep1.dat:6142:190303:} /* alt_match_null_string_p */
../inputs/grep1.dat:6143:190335:
../inputs/grep1.dat:6144:190336:
../inputs/grep1.dat:6145:190337:/* Deals with the ops common to group_match_null_string_p and
../inputs/grep1.dat:6146:190399:   alt_match_null_string_p.  
../inputs/grep1.dat:6147:190429:   
../inputs/grep1.dat:6148:190433:   Sets P to one after the op and its arguments, if any.  */
../inputs/grep1.dat:6149:190494:
../inputs/grep1.dat:6150:190495:static boolean
../inputs/grep1.dat:6151:190510:common_op_match_null_string_p (p, end, reg_info)
../inputs/grep1.dat:6152:190559:    unsigned char **p, *end;
../inputs/grep1.dat:6153:190588:    register_info_type *reg_info;
../inputs/grep1.dat:6154:190622:{
../inputs/grep1.dat:6155:190624:  int mcnt;
../inputs/grep1.dat:6156:190636:  boolean ret;
../inputs/grep1.dat:6157:190651:  int reg_no;
../inputs/grep1.dat:6158:190665:  unsigned char *p1 = *p;
../inputs/grep1.dat:6159:190691:
../inputs/grep1.dat:6160:190692:  switch ((re_opcode_t) *p1++)
../inputs/grep1.dat:6161:190723:    {
../inputs/grep1.dat:6162:190729:    case no_op:
../inputs/grep1.dat:6163:190745:    case begline:
../inputs/grep1.dat:6164:190763:    case endline:
../inputs/grep1.dat:6165:190781:    case begbuf:
../inputs/grep1.dat:6166:190798:    case endbuf:
../inputs/grep1.dat:6167:190815:    case wordbeg:
../inputs/grep1.dat:6168:190833:    case wordend:
../inputs/grep1.dat:6169:190851:    case wordbound:
../inputs/grep1.dat:6170:190871:    case notwordbound:
../inputs/grep1.dat:6171:190894:#ifdef emacs
../inputs/grep1.dat:6172:190907:    case before_dot:
../inputs/grep1.dat:6173:190928:    case at_dot:
../inputs/grep1.dat:6174:190945:    case after_dot:
../inputs/grep1.dat:6175:190965:#endif
../inputs/grep1.dat:6176:190972:      break;
../inputs/grep1.dat:6177:190985:
../inputs/grep1.dat:6178:190986:    case start_memory:
../inputs/grep1.dat:6179:191009:      reg_no = *p1;
../inputs/grep1.dat:6180:191029:      assert (reg_no > 0 && reg_no <= MAX_REGNUM);
../inputs/grep1.dat:6181:191080:      ret = group_match_null_string_p (&p1, end, reg_info);
../inputs/grep1.dat:6182:191140:      
../inputs/grep1.dat:6183:191147:      /* Have to set this here in case we're checking a group which
../inputs/grep1.dat:6184:191215:         contains a group and a back reference to it.  */
../inputs/grep1.dat:6185:191273:
../inputs/grep1.dat:6186:191274:      if (REG_MATCH_NULL_STRING_P (reg_info[reg_no]) == MATCH_NULL_UNSET_VALUE)
../inputs/grep1.dat:6187:191354:        REG_MATCH_NULL_STRING_P (reg_info[reg_no]) = ret;
../inputs/grep1.dat:6188:191412:
../inputs/grep1.dat:6189:191413:      if (!ret)
../inputs/grep1.dat:6190:191429:        return false;
../inputs/grep1.dat:6191:191451:      break;
../inputs/grep1.dat:6192:191464:          
../inputs/grep1.dat:6193:191475:    /* If this is an optimized succeed_n for zero times, make the jump.  */
../inputs/grep1.dat:6194:191551:    case jump:
../inputs/grep1.dat:6195:191566:      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
../inputs/grep1.dat:6196:191608:      if (mcnt >= 0)
../inputs/grep1.dat:6197:191629:        p1 += mcnt;
../inputs/grep1.dat:6198:191649:      else
../inputs/grep1.dat:6199:191660:        return false;
../inputs/grep1.dat:6200:191682:      break;
../inputs/grep1.dat:6201:191695:
../inputs/grep1.dat:6202:191696:    case succeed_n:
../inputs/grep1.dat:6203:191716:      /* Get to the number of times to succeed.  */
../inputs/grep1.dat:6204:191768:      p1 += 2;		
../inputs/grep1.dat:6205:191785:      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
../inputs/grep1.dat:6206:191827:
../inputs/grep1.dat:6207:191828:      if (mcnt == 0)
../inputs/grep1.dat:6208:191849:        {
../inputs/grep1.dat:6209:191859:          p1 -= 4;
../inputs/grep1.dat:6210:191878:          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
../inputs/grep1.dat:6211:191924:          p1 += mcnt;
../inputs/grep1.dat:6212:191946:        }
../inputs/grep1.dat:6213:191956:      else
../inputs/grep1.dat:6214:191967:        return false;
../inputs/grep1.dat:6215:191989:      break;
../inputs/grep1.dat:6216:192002:
../inputs/grep1.dat:6217:192003:    case duplicate: 
../inputs/grep1.dat:6218:192024:      if (!REG_MATCH_NULL_STRING_P (reg_info[*p1]))
../inputs/grep1.dat:6219:192076:        return false;
../inputs/grep1.dat:6220:192098:      break;
../inputs/grep1.dat:6221:192111:
../inputs/grep1.dat:6222:192112:    case set_number_at:
../inputs/grep1.dat:6223:192136:      p1 += 4;
../inputs/grep1.dat:6224:192151:
../inputs/grep1.dat:6225:192152:    default:
../inputs/grep1.dat:6226:192165:      /* All other opcodes mean we cannot match the empty string.  */
../inputs/grep1.dat:6227:192235:      return false;
../inputs/grep1.dat:6228:192255:  }
../inputs/grep1.dat:6229:192259:
../inputs/grep1.dat:6230:192260:  *p = p1;
../inputs/grep1.dat:6231:192271:  return true;
../inputs/grep1.dat:6232:192286:} /* common_op_match_null_string_p */
../inputs/grep1.dat:6233:192324:
../inputs/grep1.dat:6234:192325:
../inputs/grep1.dat:6235:192326:/* Return zero if TRANSLATE[S1] and TRANSLATE[S2] are identical for LEN
../inputs/grep1.dat:6236:192398:   bytes; nonzero otherwise.  */
../inputs/grep1.dat:6237:192431:   
../inputs/grep1.dat:6238:192435:static int
../inputs/grep1.dat:6239:192446:bcmp_translate (s1, s2, len, translate)
../inputs/grep1.dat:6240:192486:     unsigned char *s1, *s2;
../inputs/grep1.dat:6241:192515:     register int len;
../inputs/grep1.dat:6242:192538:     char *translate;
../inputs/grep1.dat:6243:192560:{
../inputs/grep1.dat:6244:192562:  register unsigned char *p1 = s1, *p2 = s2;
../inputs/grep1.dat:6245:192607:  while (len)
../inputs/grep1.dat:6246:192621:    {
../inputs/grep1.dat:6247:192627:      if (translate[*p1++] != translate[*p2++]) return 1;
../inputs/grep1.dat:6248:192685:      len--;
../inputs/grep1.dat:6249:192698:    }
../inputs/grep1.dat:6250:192704:  return 0;
../inputs/grep1.dat:6251:192716:}
../inputs/grep1.dat:6252:192718:
../inputs/grep1.dat:6253:192720:/* Entry points for GNU code.  */
../inputs/grep1.dat:6254:192754:
../inputs/grep1.dat:6255:192755:/* re_compile_pattern is the GNU regular expression compiler: it
../inputs/grep1.dat:6256:192820:   compiles PATTERN (of length SIZE) and puts the result in BUFP.
../inputs/grep1.dat:6257:192886:   Returns 0 if the pattern was valid, otherwise an error string.
../inputs/grep1.dat:6258:192952:   
../inputs/grep1.dat:6259:192956:   Assumes the `allocated' (and perhaps `buffer') and `translate' fields
../inputs/grep1.dat:6260:193029:   are set in BUFP on entry.
../inputs/grep1.dat:6261:193058:   
../inputs/grep1.dat:6262:193062:   We call regex_compile to do the actual compilation.  */
../inputs/grep1.dat:6263:193121:
../inputs/grep1.dat:6264:193122:const char *
../inputs/grep1.dat:6265:193135:re_compile_pattern (pattern, length, bufp)
../inputs/grep1.dat:6266:193178:     const char *pattern;
../inputs/grep1.dat:6267:193204:     int length;
../inputs/grep1.dat:6268:193221:     struct re_pattern_buffer *bufp;
../inputs/grep1.dat:6269:193258:{
../inputs/grep1.dat:6270:193260:  reg_errcode_t ret;
../inputs/grep1.dat:6271:193281:  
../inputs/grep1.dat:6272:193284:  /* GNU code is written to assume at least RE_NREGS registers will be set
../inputs/grep1.dat:6273:193359:     (and at least one extra will be -1).  */
../inputs/grep1.dat:6274:193405:  bufp->regs_allocated = REGS_UNALLOCATED;
../inputs/grep1.dat:6275:193448:  
../inputs/grep1.dat:6276:193451:  /* And GNU code determines whether or not to get register information
../inputs/grep1.dat:6277:193523:     by passing null for the REGS argument to re_match, etc., not by
../inputs/grep1.dat:6278:193592:     setting no_sub.  */
../inputs/grep1.dat:6279:193617:  bufp->no_sub = 0;
../inputs/grep1.dat:6280:193637:  
../inputs/grep1.dat:6281:193640:  /* Match anchors at newline.  */
../inputs/grep1.dat:6282:193675:  bufp->newline_anchor = 1;
../inputs/grep1.dat:6283:193703:  
../inputs/grep1.dat:6284:193706:  ret = regex_compile (pattern, length, re_syntax_options, bufp);
../inputs/grep1.dat:6285:193772:
../inputs/grep1.dat:6286:193773:  return re_error_msg[(int) ret];
../inputs/grep1.dat:6287:193807:}     
../inputs/grep1.dat:6288:193814:
../inputs/grep1.dat:6289:193816:/* Entry points compatible with 4.2 BSD regex library.  We don't define
../inputs/grep1.dat:6290:193888:   them if this is an Emacs or POSIX compilation.  */
../inputs/grep1.dat:6291:193942:
../inputs/grep1.dat:6292:193943:#if !defined (emacs) && !defined (_POSIX_SOURCE)
../inputs/grep1.dat:6293:193992:
../inputs/grep1.dat:6294:193993:/* BSD has one and only one pattern buffer.  */
../inputs/grep1.dat:6295:194041:static struct re_pattern_buffer re_comp_buf;
../inputs/grep1.dat:6296:194086:
../inputs/grep1.dat:6297:194087:char *
../inputs/grep1.dat:6298:194094:re_comp (s)
../inputs/grep1.dat:6299:194106:    const char *s;
../inputs/grep1.dat:6300:194125:{
../inputs/grep1.dat:6301:194127:  reg_errcode_t ret;
../inputs/grep1.dat:6302:194148:  
../inputs/grep1.dat:6303:194151:  if (!s)
../inputs/grep1.dat:6304:194161:    {
../inputs/grep1.dat:6305:194167:      if (!re_comp_buf.buffer)
../inputs/grep1.dat:6306:194198:	return "No previous regular expression";
../inputs/grep1.dat:6307:194240:      return 0;
../inputs/grep1.dat:6308:194256:    }
../inputs/grep1.dat:6309:194262:
../inputs/grep1.dat:6310:194263:  if (!re_comp_buf.buffer)
../inputs/grep1.dat:6311:194290:    {
../inputs/grep1.dat:6312:194296:      re_comp_buf.buffer = (unsigned char *) malloc (200);
../inputs/grep1.dat:6313:194355:      if (re_comp_buf.buffer == NULL)
../inputs/grep1.dat:6314:194393:        return "Memory exhausted";
../inputs/grep1.dat:6315:194428:      re_comp_buf.allocated = 200;
../inputs/grep1.dat:6316:194463:
../inputs/grep1.dat:6317:194464:      re_comp_buf.fastmap = (char *) malloc (1 << BYTEWIDTH);
../inputs/grep1.dat:6318:194526:      if (re_comp_buf.fastmap == NULL)
../inputs/grep1.dat:6319:194565:	return "Memory exhausted";
../inputs/grep1.dat:6320:194593:    }
../inputs/grep1.dat:6321:194599:
../inputs/grep1.dat:6322:194600:  /* Since `re_exec' always passes NULL for the `regs' argument, we
../inputs/grep1.dat:6323:194668:     don't need to initialize the pattern buffer fields which affect it.  */
../inputs/grep1.dat:6324:194745:
../inputs/grep1.dat:6325:194746:  /* Match anchors at newlines.  */
../inputs/grep1.dat:6326:194782:  re_comp_buf.newline_anchor = 1;
../inputs/grep1.dat:6327:194816:
../inputs/grep1.dat:6328:194817:  ret = regex_compile (s, strlen (s), re_syntax_options, &re_comp_buf);
../inputs/grep1.dat:6329:194889:  
../inputs/grep1.dat:6330:194892:  /* Yes, we're discarding `const' here.  */
../inputs/grep1.dat:6331:194937:  return (char *) re_error_msg[(int) ret];
../inputs/grep1.dat:6332:194980:}
../inputs/grep1.dat:6333:194982:
../inputs/grep1.dat:6334:194983:
../inputs/grep1.dat:6335:194984:int
../inputs/grep1.dat:6336:194988:re_exec (s)
../inputs/grep1.dat:6337:195000:    const char *s;
../inputs/grep1.dat:6338:195019:{
../inputs/grep1.dat:6339:195021:  const int len = strlen (s);
../inputs/grep1.dat:6340:195051:  return
../inputs/grep1.dat:6341:195060:    0 <= re_search (&re_comp_buf, s, len, 0, len, (struct re_registers *) 0);
../inputs/grep1.dat:6342:195138:}
../inputs/grep1.dat:6343:195140:#endif /* not emacs and not _POSIX_SOURCE */
../inputs/grep1.dat:6344:195185:
../inputs/grep1.dat:6345:195187:/* POSIX.2 functions.  Don't define these for Emacs.  */
../inputs/grep1.dat:6346:195244:
../inputs/grep1.dat:6347:195245:#ifndef emacs
../inputs/grep1.dat:6348:195259:
../inputs/grep1.dat:6349:195260:/* regcomp takes a regular expression as a string and compiles it.
../inputs/grep1.dat:6350:195327:
../inputs/grep1.dat:6351:195328:   PREG is a regex_t *.  We do not expect any fields to be initialized,
../inputs/grep1.dat:6352:195400:   since POSIX says we shouldn't.  Thus, we set
../inputs/grep1.dat:6353:195448:
../inputs/grep1.dat:6354:195449:     `buffer' to the compiled pattern;
../inputs/grep1.dat:6355:195488:     `used' to the length of the compiled pattern;
../inputs/grep1.dat:6356:195539:     `syntax' to RE_SYNTAX_POSIX_EXTENDED if the
../inputs/grep1.dat:6357:195588:       REG_EXTENDED bit in CFLAGS is set; otherwise, to
../inputs/grep1.dat:6358:195644:       RE_SYNTAX_POSIX_BASIC;
../inputs/grep1.dat:6359:195674:     `newline_anchor' to REG_NEWLINE being set in CFLAGS;
../inputs/grep1.dat:6360:195732:     `fastmap' and `fastmap_accurate' to zero;
../inputs/grep1.dat:6361:195779:     `re_nsub' to the number of subexpressions in PATTERN.
../inputs/grep1.dat:6362:195838:
../inputs/grep1.dat:6363:195839:   PATTERN is the address of the pattern string.
../inputs/grep1.dat:6364:195888:
../inputs/grep1.dat:6365:195889:   CFLAGS is a series of bits which affect compilation.
../inputs/grep1.dat:6366:195945:
../inputs/grep1.dat:6367:195946:     If REG_EXTENDED is set, we use POSIX extended syntax; otherwise, we
../inputs/grep1.dat:6368:196019:     use POSIX basic syntax.
../inputs/grep1.dat:6369:196048:
../inputs/grep1.dat:6370:196049:     If REG_NEWLINE is set, then . and [^...] don't match newline.
../inputs/grep1.dat:6371:196116:     Also, regexec will try a match beginning after every newline.
../inputs/grep1.dat:6372:196183:
../inputs/grep1.dat:6373:196184:     If REG_ICASE is set, then we considers upper- and lowercase
../inputs/grep1.dat:6374:196249:     versions of letters to be equivalent when matching.
../inputs/grep1.dat:6375:196306:
../inputs/grep1.dat:6376:196307:     If REG_NOSUB is set, then when PREG is passed to regexec, that
../inputs/grep1.dat:6377:196375:     routine will report only success or failure, and nothing about the
../inputs/grep1.dat:6378:196447:     registers.
../inputs/grep1.dat:6379:196463:
../inputs/grep1.dat:6380:196464:   It returns 0 if it succeeds, nonzero if it doesn't.  (See regex.h for
../inputs/grep1.dat:6381:196537:   the return codes and their meanings.)  */
../inputs/grep1.dat:6382:196582:
../inputs/grep1.dat:6383:196583:int
../inputs/grep1.dat:6384:196587:regcomp (preg, pattern, cflags)
../inputs/grep1.dat:6385:196619:    regex_t *preg;
../inputs/grep1.dat:6386:196638:    const char *pattern; 
../inputs/grep1.dat:6387:196664:    int cflags;
../inputs/grep1.dat:6388:196680:{
../inputs/grep1.dat:6389:196682:  reg_errcode_t ret;
../inputs/grep1.dat:6390:196703:  unsigned syntax
../inputs/grep1.dat:6391:196721:    = (cflags & REG_EXTENDED) ?
../inputs/grep1.dat:6392:196753:      RE_SYNTAX_POSIX_EXTENDED : RE_SYNTAX_POSIX_BASIC;
../inputs/grep1.dat:6393:196809:
../inputs/grep1.dat:6394:196810:  /* regex_compile will allocate the space for the compiled pattern.  */
../inputs/grep1.dat:6395:196883:  preg->buffer = 0;
../inputs/grep1.dat:6396:196903:  preg->allocated = 0;
../inputs/grep1.dat:6397:196926:  preg->used = 0;
../inputs/grep1.dat:6398:196944:  
../inputs/grep1.dat:6399:196947:  /* Don't bother to use a fastmap when searching.  This simplifies the
../inputs/grep1.dat:6400:197019:     REG_NEWLINE case: if we used a fastmap, we'd have to put all the
../inputs/grep1.dat:6401:197089:     characters after newlines into the fastmap.  This way, we just try
../inputs/grep1.dat:6402:197161:     every character.  */
../inputs/grep1.dat:6403:197187:  preg->fastmap = 0;
../inputs/grep1.dat:6404:197208:  
../inputs/grep1.dat:6405:197211:  if (cflags & REG_ICASE)
../inputs/grep1.dat:6406:197237:    {
../inputs/grep1.dat:6407:197243:      unsigned i;
../inputs/grep1.dat:6408:197261:      
../inputs/grep1.dat:6409:197268:      preg->translate = (char *) malloc (CHAR_SET_SIZE);
../inputs/grep1.dat:6410:197325:      if (preg->translate == NULL)
../inputs/grep1.dat:6411:197360:        return (int) REG_ESPACE;
../inputs/grep1.dat:6412:197393:
../inputs/grep1.dat:6413:197394:      /* Map uppercase characters to corresponding lowercase ones.  */
../inputs/grep1.dat:6414:197465:      for (i = 0; i < CHAR_SET_SIZE; i++)
../inputs/grep1.dat:6415:197507:        preg->translate[i] = ISUPPER (i) ? tolower (i) : i;
../inputs/grep1.dat:6416:197567:    }
../inputs/grep1.dat:6417:197573:  else
../inputs/grep1.dat:6418:197580:    preg->translate = NULL;
../inputs/grep1.dat:6419:197608:
../inputs/grep1.dat:6420:197609:  /* If REG_NEWLINE is set, newlines are treated differently.  */
../inputs/grep1.dat:6421:197675:  if (cflags & REG_NEWLINE)
../inputs/grep1.dat:6422:197703:    { /* REG_NEWLINE implies neither . nor [^...] match newline.  */
../inputs/grep1.dat:6423:197772:      syntax &= ~RE_DOT_NEWLINE;
../inputs/grep1.dat:6424:197805:      syntax |= RE_HAT_LISTS_NOT_NEWLINE;
../inputs/grep1.dat:6425:197847:      /* It also changes the matching behavior.  */
../inputs/grep1.dat:6426:197899:      preg->newline_anchor = 1;
../inputs/grep1.dat:6427:197931:    }
../inputs/grep1.dat:6428:197937:  else
../inputs/grep1.dat:6429:197944:    preg->newline_anchor = 0;
../inputs/grep1.dat:6430:197974:
../inputs/grep1.dat:6431:197975:  preg->no_sub = !!(cflags & REG_NOSUB);
../inputs/grep1.dat:6432:198016:
../inputs/grep1.dat:6433:198017:  /* POSIX says a null character in the pattern terminates it, so we 
../inputs/grep1.dat:6434:198087:     can use strlen here in compiling the pattern.  */
../inputs/grep1.dat:6435:198142:  ret = regex_compile (pattern, strlen (pattern), syntax, preg);
../inputs/grep1.dat:6436:198207:  
../inputs/grep1.dat:6437:198210:  /* POSIX doesn't distinguish between an unmatched open-group and an
../inputs/grep1.dat:6438:198280:     unmatched close-group: both are REG_EPAREN.  */
../inputs/grep1.dat:6439:198333:  if (ret == REG_ERPAREN) ret = REG_EPAREN;
../inputs/grep1.dat:6440:198377:  
../inputs/grep1.dat:6441:198380:  return (int) ret;
../inputs/grep1.dat:6442:198400:}
../inputs/grep1.dat:6443:198402:
../inputs/grep1.dat:6444:198403:
../inputs/grep1.dat:6445:198404:/* regexec searches for a given pattern, specified by PREG, in the
../inputs/grep1.dat:6446:198471:   string STRING.
../inputs/grep1.dat:6447:198489:   
../inputs/grep1.dat:6448:198493:   If NMATCH is zero or REG_NOSUB was set in the cflags argument to
../inputs/grep1.dat:6449:198561:   `regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at
../inputs/grep1.dat:6450:198629:   least NMATCH elements, and we set them to the offsets of the
../inputs/grep1.dat:6451:198693:   corresponding matched substrings.
../inputs/grep1.dat:6452:198730:   
../inputs/grep1.dat:6453:198734:   EFLAGS specifies `execution flags' which affect matching: if
../inputs/grep1.dat:6454:198798:   REG_NOTBOL is set, then ^ does not match at the beginning of the
../inputs/grep1.dat:6455:198866:   string; if REG_NOTEOL is set, then $ does not match at the end.
../inputs/grep1.dat:6456:198933:   
../inputs/grep1.dat:6457:198937:   We return 0 if we find a match and REG_NOMATCH if not.  */
../inputs/grep1.dat:6458:198999:
../inputs/grep1.dat:6459:199000:int
../inputs/grep1.dat:6460:199004:regexec (preg, string, nmatch, pmatch, eflags)
../inputs/grep1.dat:6461:199051:    const regex_t *preg;
../inputs/grep1.dat:6462:199076:    const char *string; 
../inputs/grep1.dat:6463:199101:    size_t nmatch; 
../inputs/grep1.dat:6464:199121:    regmatch_t pmatch[]; 
../inputs/grep1.dat:6465:199147:    int eflags;
../inputs/grep1.dat:6466:199163:{
../inputs/grep1.dat:6467:199165:  int ret;
../inputs/grep1.dat:6468:199176:  struct re_registers regs;
../inputs/grep1.dat:6469:199204:  regex_t private_preg;
../inputs/grep1.dat:6470:199228:  int len = strlen (string);
../inputs/grep1.dat:6471:199257:  boolean want_reg_info = !preg->no_sub && nmatch > 0;
../inputs/grep1.dat:6472:199312:
../inputs/grep1.dat:6473:199313:  private_preg = *preg;
../inputs/grep1.dat:6474:199337:  
../inputs/grep1.dat:6475:199340:  private_preg.not_bol = !!(eflags & REG_NOTBOL);
../inputs/grep1.dat:6476:199390:  private_preg.not_eol = !!(eflags & REG_NOTEOL);
../inputs/grep1.dat:6477:199440:  
../inputs/grep1.dat:6478:199443:  /* The user has told us exactly how many registers to return
../inputs/grep1.dat:6479:199506:     information about, via `nmatch'.  We have to pass that on to the
../inputs/grep1.dat:6480:199576:     matching routines.  */
../inputs/grep1.dat:6481:199604:  private_preg.regs_allocated = REGS_FIXED;
../inputs/grep1.dat:6482:199648:  
../inputs/grep1.dat:6483:199651:  if (want_reg_info)
../inputs/grep1.dat:6484:199672:    {
../inputs/grep1.dat:6485:199678:      regs.num_regs = nmatch;
../inputs/grep1.dat:6486:199708:      regs.start = TALLOC (nmatch, regoff_t);
../inputs/grep1.dat:6487:199754:      regs.end = TALLOC (nmatch, regoff_t);
../inputs/grep1.dat:6488:199798:      if (regs.start == NULL || regs.end == NULL)
../inputs/grep1.dat:6489:199848:        return (int) REG_NOMATCH;
../inputs/grep1.dat:6490:199882:    }
../inputs/grep1.dat:6491:199888:
../inputs/grep1.dat:6492:199889:  /* Perform the searching operation.  */
../inputs/grep1.dat:6493:199931:  ret = re_search (&private_preg, string, len,
../inputs/grep1.dat:6494:199978:                   /* start: */ 0, /* range: */ len,
../inputs/grep1.dat:6495:200031:                   want_reg_info ? &regs : (struct re_registers *) 0);
../inputs/grep1.dat:6496:200102:  
../inputs/grep1.dat:6497:200105:  /* Copy the register information to the POSIX structure.  */
../inputs/grep1.dat:6498:200168:  if (want_reg_info)
../inputs/grep1.dat:6499:200189:    {
../inputs/grep1.dat:6500:200195:      if (ret >= 0)
../inputs/grep1.dat:6501:200215:        {
../inputs/grep1.dat:6502:200225:          unsigned r;
../inputs/grep1.dat:6503:200247:
../inputs/grep1.dat:6504:200248:          for (r = 0; r < nmatch; r++)
../inputs/grep1.dat:6505:200287:            {
../inputs/grep1.dat:6506:200301:              pmatch[r].rm_so = regs.start[r];
../inputs/grep1.dat:6507:200348:              pmatch[r].rm_eo = regs.end[r];
../inputs/grep1.dat:6508:200393:            }
../inputs/grep1.dat:6509:200407:        }
../inputs/grep1.dat:6510:200417:
../inputs/grep1.dat:6511:200418:      /* If we needed the temporary register info, free the space now.  */
../inputs/grep1.dat:6512:200493:      free (regs.start);
../inputs/grep1.dat:6513:200518:      free (regs.end);
../inputs/grep1.dat:6514:200541:    }
../inputs/grep1.dat:6515:200547:
../inputs/grep1.dat:6516:200548:  /* We want zero return to mean success, unlike `re_search'.  */
../inputs/grep1.dat:6517:200614:  return ret >= 0 ? (int) REG_NOERROR : (int) REG_NOMATCH;
../inputs/grep1.dat:6518:200673:}
../inputs/grep1.dat:6519:200675:
../inputs/grep1.dat:6520:200676:
../inputs/grep1.dat:6521:200677:/* Returns a message corresponding to an error code, ERRCODE, returned
../inputs/grep1.dat:6522:200748:   from either regcomp or regexec.   We don't use PREG here.  */
../inputs/grep1.dat:6523:200813:
../inputs/grep1.dat:6524:200814:size_t
../inputs/grep1.dat:6525:200821:regerror (errcode, preg, errbuf, errbuf_size)
../inputs/grep1.dat:6526:200867:    int errcode;
../inputs/grep1.dat:6527:200884:    const regex_t *preg;
../inputs/grep1.dat:6528:200909:    char *errbuf;
../inputs/grep1.dat:6529:200927:    size_t errbuf_size;
../inputs/grep1.dat:6530:200951:{
../inputs/grep1.dat:6531:200953:  const char *msg;
../inputs/grep1.dat:6532:200972:  size_t msg_size;
../inputs/grep1.dat:6533:200991:
../inputs/grep1.dat:6534:200992:  if (errcode < 0
../inputs/grep1.dat:6535:201010:      || errcode >= (sizeof (re_error_msg) / sizeof (re_error_msg[0])))
../inputs/grep1.dat:6536:201082:    /* Only error codes returned by the rest of the code should be passed 
../inputs/grep1.dat:6537:201157:       to this routine.  If we are given anything else, or if other regex
../inputs/grep1.dat:6538:201231:       code generates an invalid error code, then the program has a bug.
../inputs/grep1.dat:6539:201304:       Dump core so we can fix it.  */
../inputs/grep1.dat:6540:201343:    abort ();
../inputs/grep1.dat:6541:201357:
../inputs/grep1.dat:6542:201358:  msg = re_error_msg[errcode];
../inputs/grep1.dat:6543:201389:
../inputs/grep1.dat:6544:201390:  /* POSIX doesn't require that we do anything in this case, but why
../inputs/grep1.dat:6545:201459:     not be nice.  */
../inputs/grep1.dat:6546:201481:  if (! msg)
../inputs/grep1.dat:6547:201494:    msg = "Success";
../inputs/grep1.dat:6548:201515:
../inputs/grep1.dat:6550:201573:  
../inputs/grep1.dat:6551:201576:  if (errbuf_size != 0)
../inputs/grep1.dat:6552:201600:    {
../inputs/grep1.dat:6553:201606:      if (msg_size > errbuf_size)
../inputs/grep1.dat:6554:201640:        {
../inputs/grep1.dat:6555:201650:          strncpy (errbuf, msg, errbuf_size - 1);
../inputs/grep1.dat:6556:201700:          errbuf[errbuf_size - 1] = 0;
../inputs/grep1.dat:6557:201739:        }
../inputs/grep1.dat:6558:201749:      else
../inputs/grep1.dat:6559:201760:        strcpy (errbuf, msg);
../inputs/grep1.dat:6560:201790:    }
../inputs/grep1.dat:6561:201796:
../inputs/grep1.dat:6562:201797:  return msg_size;
../inputs/grep1.dat:6563:201816:}
../inputs/grep1.dat:6564:201818:
../inputs/grep1.dat:6565:201819:
../inputs/grep1.dat:6566:201820:/* Free dynamically allocated space used by PREG.  */
../inputs/grep1.dat:6567:201874:
../inputs/grep1.dat:6568:201875:void
../inputs/grep1.dat:6569:201880:regfree (preg)
../inputs/grep1.dat:6570:201895:    regex_t *preg;
../inputs/grep1.dat:6571:201914:{
../inputs/grep1.dat:6572:201916:  if (preg->buffer != NULL)
../inputs/grep1.dat:6573:201944:    free (preg->buffer);
../inputs/grep1.dat:6574:201969:  preg->buffer = NULL;
../inputs/grep1.dat:6575:201992:  
../inputs/grep1.dat:6576:201995:  preg->allocated = 0;
../inputs/grep1.dat:6577:202018:  preg->used = 0;
../inputs/grep1.dat:6578:202036:
../inputs/grep1.dat:6579:202037:  if (preg->fastmap != NULL)
../inputs/grep1.dat:6580:202066:    free (preg->fastmap);
../inputs/grep1.dat:6581:202092:  preg->fastmap = NULL;
../inputs/grep1.dat:6582:202116:  preg->fastmap_accurate = 0;
../inputs/grep1.dat:6583:202146:
../inputs/grep1.dat:6584:202147:  if (preg->translate != NULL)
../inputs/grep1.dat:6585:202178:    free (preg->translate);
../inputs/grep1.dat:6586:202206:  preg->translate = NULL;
../inputs/grep1.dat:6587:202232:}
../inputs/grep1.dat:6588:202234:
../inputs/grep1.dat:6589:202235:#endif /* not emacs  */
../inputs/grep1.dat:6590:202259:
../inputs/grep1.dat:6591:202261:/*
../inputs/grep1.dat:6592:202264:Local variables:
../inputs/grep1.dat:6593:202281:make-backup-files: t
../inputs/grep1.dat:6594:202302:version-control: t
../inputs/grep1.dat:6595:202321:trim-versions-without-asking: nil
../inputs/grep1.dat:6596:202355:End:
../inputs/grep1.dat:6597:202360:*/
../inputs/grep1.dat:6598:202363:/* dfa.c - deterministic extended regexp routines for GNU
../inputs/grep1.dat:6599:202421:   Copyright (C) 1988 Free Software Foundation, Inc.
../inputs/grep1.dat:6600:202474:
../inputs/grep1.dat:6601:202475:   This program is free software; you can redistribute it and/or modify
../inputs/grep1.dat:6602:202547:   it under the terms of the GNU General Public License as published by
../inputs/grep1.dat:6603:202619:   the Free Software Foundation; either version 2, or (at your option)
../inputs/grep1.dat:6604:202690:   any later version.
../inputs/grep1.dat:6605:202712:
../inputs/grep1.dat:6606:202713:   This program is distributed in the hope that it will be useful,
../inputs/grep1.dat:6607:202780:   but WITHOUT ANY WARRANTY; without even the implied warranty of
../inputs/grep1.dat:6608:202846:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
../inputs/grep1.dat:6609:202911:   GNU General Public License for more details.
../inputs/grep1.dat:6610:202959:
../inputs/grep1.dat:6611:202960:   You should have received a copy of the GNU General Public License
../inputs/grep1.dat:6612:203029:   along with this program; if not, write to the Free Software
../inputs/grep1.dat:6613:203092:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
../inputs/grep1.dat:6614:203157:
../inputs/grep1.dat:6615:203158:/* Written June, 1988 by Mike Haertel
../inputs/grep1.dat:6616:203196:   Modified July, 1988 by Arthur David Olson to assist BMG speedups  */
../inputs/grep1.dat:6617:203268:
../inputs/grep1.dat:6621:203342:
../inputs/grep1.dat:6622:203343:#ifdef STDC_HEADERS
../inputs/grep1.dat:6623:203363:#if flag_stdlib==0
../inputs/grep1.dat:6625:203402:#define flag_stdlib 1
../inputs/grep1.dat:6626:203424:#endif
../inputs/grep1.dat:6627:203431:#else
../inputs/grep1.dat:6628:203437:#if flag_systypes==0 
../inputs/grep1.dat:6630:203482:#define flag_systypes 1
../inputs/grep1.dat:6631:203506:#endif
../inputs/grep1.dat:6632:203513:extern char *calloc(), *malloc(), *realloc();
../inputs/grep1.dat:6633:203559:extern void free();
../inputs/grep1.dat:6634:203579:#endif
../inputs/grep1.dat:6635:203586:
../inputs/grep1.dat:6636:203587:#if defined(HAVE_STRING_H) || defined(STDC_HEADERS)
../inputs/grep1.dat:6637:203639:#if flag_string==0
../inputs/grep1.dat:6639:203678:#define flag_string 1
../inputs/grep1.dat:6640:203700:#endif
../inputs/grep1.dat:6641:203707:#undef index
../inputs/grep1.dat:6642:203720:#define index strchr
../inputs/grep1.dat:6643:203741:#else
../inputs/grep1.dat:6644:203747:#if flag_strings==0
../inputs/grep1.dat:6646:203788:#define flag_strings 1
../inputs/grep1.dat:6647:203811:#endif
../inputs/grep1.dat:6648:203818:#endif
../inputs/grep1.dat:6649:203825:
../inputs/grep1.dat:6650:203826:#ifndef isgraph
../inputs/grep1.dat:6651:203842:#define isgraph(C) (isprint(C) && !isspace(C))
../inputs/grep1.dat:6652:203889:#endif
../inputs/grep1.dat:6653:203896:
../inputs/grep1.dat:6654:203897:#undef ISALPHA
../inputs/grep1.dat:6655:203912:#undef ISUPPER
../inputs/grep1.dat:6656:203927:#undef ISLOWER
../inputs/grep1.dat:6657:203942:#undef ISDIGIT
../inputs/grep1.dat:6658:203957:#undef ISXDIGIT
../inputs/grep1.dat:6659:203973:#undef ISSPACE
../inputs/grep1.dat:6660:203988:#undef ISPUNCT
../inputs/grep1.dat:6661:204003:#undef ISALNUM
../inputs/grep1.dat:6662:204018:#undef ISPRINT
../inputs/grep1.dat:6663:204033:#undef ISGRAPH
../inputs/grep1.dat:6664:204048:#undef ISCNTRL
../inputs/grep1.dat:6665:204063:
../inputs/grep1.dat:6666:204064:
../inputs/grep1.dat:6667:204065:#ifdef isascii
../inputs/grep1.dat:6668:204080:#define ISALPHA(C) (isascii(C) && isalpha(C))
../inputs/grep1.dat:6669:204126:#define ISUPPER(C) (isascii(C) && isupper(C))
../inputs/grep1.dat:6670:204172:#define ISLOWER(C) (isascii(C) && islower(C))
../inputs/grep1.dat:6671:204218:#define ISDIGIT(C) (isascii(C) && isdigit(C))
../inputs/grep1.dat:6672:204264:#define ISXDIGIT(C) (isascii(C) && isxdigit(C))
../inputs/grep1.dat:6673:204312:#define ISSPACE(C) (isascii(C) && isspace(C))
../inputs/grep1.dat:6674:204358:#define ISPUNCT(C) (isascii(C) && ispunct(C))
../inputs/grep1.dat:6675:204404:#define ISALNUM(C) (isascii(C) && isalnum(C))
../inputs/grep1.dat:6676:204450:#define ISPRINT(C) (isascii(C) && isprint(C))
../inputs/grep1.dat:6677:204496:#define ISGRAPH(C) (isascii(C) && isgraph(C))
../inputs/grep1.dat:6678:204542:#define ISCNTRL(C) (isascii(C) && iscntrl(C))
../inputs/grep1.dat:6679:204588:#else
../inputs/grep1.dat:6680:204594:#define ISALPHA(C) isalpha(C)
../inputs/grep1.dat:6681:204624:#define ISUPPER(C) isupper(C)
../inputs/grep1.dat:6682:204654:#define ISLOWER(C) islower(C)
../inputs/grep1.dat:6683:204684:#define ISDIGIT(C) isdigit(C)
../inputs/grep1.dat:6684:204714:#define ISXDIGIT(C) isxdigit(C)
../inputs/grep1.dat:6685:204746:#define ISSPACE(C) isspace(C)
../inputs/grep1.dat:6686:204776:#define ISPUNCT(C) ispunct(C)
../inputs/grep1.dat:6687:204806:#define ISALNUM(C) isalnum(C)
../inputs/grep1.dat:6688:204836:#define ISPRINT(C) isprint(C)
../inputs/grep1.dat:6689:204866:#define ISGRAPH(C) isgraph(C)
../inputs/grep1.dat:6690:204896:#define ISCNTRL(C) iscntrl(C)
../inputs/grep1.dat:6691:204926:#endif
../inputs/grep1.dat:6692:204933:
../inputs/grep1.dat:6695:204974:
../inputs/grep1.dat:6696:204975:#if __STDC__
../inputs/grep1.dat:6697:204988:typedef void *ptr_t;
../inputs/grep1.dat:6698:205009:#else
../inputs/grep1.dat:6699:205015:typedef char *ptr_t;
../inputs/grep1.dat:6700:205036:#endif
../inputs/grep1.dat:6701:205043:
../inputs/grep1.dat:6702:205044:static void	dfamust();
../inputs/grep1.dat:6703:205067:
../inputs/grep1.dat:6704:205068:static ptr_t
../inputs/grep1.dat:6705:205081:xcalloc(n, s)
../inputs/grep1.dat:6706:205095:     int n;
../inputs/grep1.dat:6707:205107:     size_t s;
../inputs/grep1.dat:6708:205122:{
../inputs/grep1.dat:6709:205124:  ptr_t r = calloc(n, s);
../inputs/grep1.dat:6710:205150:
../inputs/grep1.dat:6711:205151:  if (!r)
../inputs/grep1.dat:6712:205161:    dfaerror("Memory exhausted");
../inputs/grep1.dat:6713:205195:  return r;
../inputs/grep1.dat:6714:205207:}
../inputs/grep1.dat:6715:205209:
../inputs/grep1.dat:6716:205210:static ptr_t
../inputs/grep1.dat:6717:205223:xmalloc_1(n)
../inputs/grep1.dat:6718:205236:     size_t n;
../inputs/grep1.dat:6719:205251:{
../inputs/grep1.dat:6720:205253:  ptr_t r = malloc(n);
../inputs/grep1.dat:6721:205276:
../inputs/grep1.dat:6722:205277:  assert(n != 0);
../inputs/grep1.dat:6723:205295:  if (!r)
../inputs/grep1.dat:6724:205305:    dfaerror("Memory exhausted");
../inputs/grep1.dat:6725:205339:  return r;
../inputs/grep1.dat:6726:205351:}
../inputs/grep1.dat:6727:205353:
../inputs/grep1.dat:6728:205354:static ptr_t
../inputs/grep1.dat:6729:205367:xrealloc_1(p, n)
../inputs/grep1.dat:6730:205384:     ptr_t p;
../inputs/grep1.dat:6731:205398:     size_t n;
../inputs/grep1.dat:6732:205413:{
../inputs/grep1.dat:6733:205415:  ptr_t r = realloc(p, n);
../inputs/grep1.dat:6734:205442:
../inputs/grep1.dat:6735:205443:  assert(n != 0);
../inputs/grep1.dat:6736:205461:  if (!r)
../inputs/grep1.dat:6737:205471:    dfaerror("Memory exhausted");
../inputs/grep1.dat:6738:205505:  return r;
../inputs/grep1.dat:6739:205517:}
../inputs/grep1.dat:6740:205519:
../inputs/grep1.dat:6741:205520:#define CALLOC(p, t, n) ((p) = (t *) xcalloc((n), sizeof (t)))
../inputs/grep1.dat:6742:205583:#define MALLOC(p, t, n) ((p) = (t *) xmalloc_1((n) * sizeof (t)))
../inputs/grep1.dat:6743:205649:#define REALLOC(p, t, n) ((p) = (t *) xrealloc_1((ptr_t) (p), (n) * sizeof (t)))
../inputs/grep1.dat:6744:205730:
../inputs/grep1.dat:6745:205731:/* Reallocate an array of type t if nalloc is too small for index. */
../inputs/grep1.dat:6746:205801:#define REALLOC_IF_NECESSARY(p, t, nalloc, index) \
../inputs/grep1.dat:6747:205853:  if ((index) >= (nalloc))			  \
../inputs/grep1.dat:6748:205886:    {						  \
../inputs/grep1.dat:6749:205901:      while ((index) >= (nalloc))		  \
../inputs/grep1.dat:6750:205940:	(nalloc) *= 2;				  \
../inputs/grep1.dat:6751:205963:      REALLOC(p, t, nalloc);			  \
../inputs/grep1.dat:6752:205998:    }
../inputs/grep1.dat:6753:206004:
../inputs/grep1.dat:6754:206005:#ifdef DEBUG
../inputs/grep1.dat:6755:206018:
../inputs/grep1.dat:6756:206019:static void
../inputs/grep1.dat:6757:206031:prtok(t)
../inputs/grep1.dat:6758:206040:     token t;
../inputs/grep1.dat:6759:206054:{
../inputs/grep1.dat:6760:206056:  char *s;
../inputs/grep1.dat:6761:206067:
../inputs/grep1.dat:6762:206068:  if (t < 0)
../inputs/grep1.dat:6763:206081:    fprintf(stderr, "END");
../inputs/grep1.dat:6764:206109:  else if (t < NOTCHAR)
../inputs/grep1.dat:6765:206133:    fprintf(stderr, "%c", t);
../inputs/grep1.dat:6766:206163:  else
../inputs/grep1.dat:6767:206170:    {
../inputs/grep1.dat:6768:206176:      switch (t)
../inputs/grep1.dat:6769:206193:	{
../inputs/grep1.dat:6770:206196:	case EMPTY: s = "EMPTY"; break;
../inputs/grep1.dat:6771:206229:	case BACKREF: s = "BACKREF"; break;
../inputs/grep1.dat:6772:206266:	case BEGLINE: s = "BEGLINE"; break;
../inputs/grep1.dat:6773:206303:	case ENDLINE: s = "ENDLINE"; break;
../inputs/grep1.dat:6774:206340:	case BEGWORD: s = "BEGWORD"; break;
../inputs/grep1.dat:6775:206377:	case ENDWORD: s = "ENDWORD"; break;
../inputs/grep1.dat:6776:206414:	case LIMWORD: s = "LIMWORD"; break;
../inputs/grep1.dat:6777:206451:	case NOTLIMWORD: s = "NOTLIMWORD"; break;
../inputs/grep1.dat:6778:206494:	case QMARK: s = "QMARK"; break;
../inputs/grep1.dat:6779:206527:	case STAR: s = "STAR"; break;
../inputs/grep1.dat:6780:206558:	case PLUS: s = "PLUS"; break;
../inputs/grep1.dat:6781:206589:	case CAT: s = "CAT"; break;
../inputs/grep1.dat:6782:206618:	case OR: s = "OR"; break;
../inputs/grep1.dat:6783:206645:	case ORTOP: s = "ORTOP"; break;
../inputs/grep1.dat:6784:206678:	case LPAREN: s = "LPAREN"; break;
../inputs/grep1.dat:6785:206713:	case RPAREN: s = "RPAREN"; break;
../inputs/grep1.dat:6786:206748:	default: s = "CSET"; break;
../inputs/grep1.dat:6787:206777:	}
../inputs/grep1.dat:6788:206780:      fprintf(stderr, "%s", s);
../inputs/grep1.dat:6789:206812:    }
../inputs/grep1.dat:6790:206818:}
../inputs/grep1.dat:6791:206820:#endif /* DEBUG */
../inputs/grep1.dat:6792:206839:
../inputs/grep1.dat:6793:206840:/* Stuff pertaining to charclasses. */
../inputs/grep1.dat:6794:206879:
../inputs/grep1.dat:6795:206880:static int
../inputs/grep1.dat:6796:206891:tstbit(b, c)
../inputs/grep1.dat:6797:206904:     int b;
../inputs/grep1.dat:6798:206916:     charclass c;
../inputs/grep1.dat:6799:206934:{
../inputs/grep1.dat:6800:206936:  return c[b / INTBITS] & 1 << b % INTBITS;
../inputs/grep1.dat:6801:206980:}
../inputs/grep1.dat:6802:206982:
../inputs/grep1.dat:6803:206983:static void
../inputs/grep1.dat:6804:206995:setbit(b, c)
../inputs/grep1.dat:6805:207008:     int b;
../inputs/grep1.dat:6806:207020:     charclass c;
../inputs/grep1.dat:6807:207038:{
../inputs/grep1.dat:6808:207040:  c[b / INTBITS] |= 1 << b % INTBITS;
../inputs/grep1.dat:6809:207078:}
../inputs/grep1.dat:6810:207080:
../inputs/grep1.dat:6811:207081:static void
../inputs/grep1.dat:6812:207093:clrbit(b, c)
../inputs/grep1.dat:6813:207106:     int b;
../inputs/grep1.dat:6814:207118:     charclass c;
../inputs/grep1.dat:6815:207136:{
../inputs/grep1.dat:6816:207138:  c[b / INTBITS] &= ~(1 << b % INTBITS);
../inputs/grep1.dat:6817:207179:}
../inputs/grep1.dat:6818:207181:
../inputs/grep1.dat:6819:207182:static void
../inputs/grep1.dat:6820:207194:copyset(src, dst)
../inputs/grep1.dat:6821:207212:     charclass src;
../inputs/grep1.dat:6822:207232:     charclass dst;
../inputs/grep1.dat:6823:207252:{
../inputs/grep1.dat:6824:207254:  int i;
../inputs/grep1.dat:6825:207263:
../inputs/grep1.dat:6826:207264:  for (i = 0; i < CHARCLASS_INTS; ++i)
../inputs/grep1.dat:6827:207303:    dst[i] = src[i];
../inputs/grep1.dat:6828:207324:}
../inputs/grep1.dat:6829:207326:
../inputs/grep1.dat:6830:207327:static void
../inputs/grep1.dat:6831:207339:zeroset(s)
../inputs/grep1.dat:6832:207350:     charclass s;
../inputs/grep1.dat:6833:207368:{
../inputs/grep1.dat:6834:207370:  int i;
../inputs/grep1.dat:6835:207379:
../inputs/grep1.dat:6836:207380:  for (i = 0; i < CHARCLASS_INTS; ++i)
../inputs/grep1.dat:6837:207419:    s[i] = 0;
../inputs/grep1.dat:6838:207433:}
../inputs/grep1.dat:6839:207435:
../inputs/grep1.dat:6840:207436:static void
../inputs/grep1.dat:6841:207448:notset(s)
../inputs/grep1.dat:6842:207458:     charclass s;
../inputs/grep1.dat:6843:207476:{
../inputs/grep1.dat:6844:207478:  int i;
../inputs/grep1.dat:6845:207487:
../inputs/grep1.dat:6846:207488:  for (i = 0; i < CHARCLASS_INTS; ++i)
../inputs/grep1.dat:6847:207527:    s[i] = ~s[i];
../inputs/grep1.dat:6848:207545:}
../inputs/grep1.dat:6849:207547:
../inputs/grep1.dat:6850:207548:static int
../inputs/grep1.dat:6851:207559:equal(s1, s2)
../inputs/grep1.dat:6852:207573:     charclass s1;
../inputs/grep1.dat:6853:207592:     charclass s2;
../inputs/grep1.dat:6854:207611:{
../inputs/grep1.dat:6855:207613:  int i;
../inputs/grep1.dat:6856:207622:
../inputs/grep1.dat:6857:207623:  for (i = 0; i < CHARCLASS_INTS; ++i)
../inputs/grep1.dat:6858:207662:    if (s1[i] != s2[i])
../inputs/grep1.dat:6859:207686:      return 0;
../inputs/grep1.dat:6860:207702:  return 1;
../inputs/grep1.dat:6861:207714:}
../inputs/grep1.dat:6862:207716:
../inputs/grep1.dat:6863:207717:/* A pointer to the current dfa is kept here during parsing. */
../inputs/grep1.dat:6864:207781:static struct dfa *dfa;
../inputs/grep1.dat:6865:207805:
../inputs/grep1.dat:6866:207806:/* Find the index of charclass s in dfa->charclasses, or allocate a new charclass. */
../inputs/grep1.dat:6867:207892:static int
../inputs/grep1.dat:6868:207903:charclass_index(s)
../inputs/grep1.dat:6869:207922:     charclass s;
../inputs/grep1.dat:6870:207940:{
../inputs/grep1.dat:6871:207942:  int i;
../inputs/grep1.dat:6872:207951:
../inputs/grep1.dat:6873:207952:  for (i = 0; i < dfa->cindex; ++i)
../inputs/grep1.dat:6874:207988:    if (equal(s, dfa->charclasses[i]))
../inputs/grep1.dat:6875:208027:      return i;
../inputs/grep1.dat:6876:208043:  REALLOC_IF_NECESSARY(dfa->charclasses, charclass, dfa->calloc, dfa->cindex);
../inputs/grep1.dat:6877:208122:  ++dfa->cindex;
../inputs/grep1.dat:6878:208139:  copyset(s, dfa->charclasses[i]);
../inputs/grep1.dat:6879:208174:  return i;
../inputs/grep1.dat:6880:208186:}
../inputs/grep1.dat:6881:208188:
../inputs/grep1.dat:6882:208189:/* Syntax bits controlling the behavior of the lexical analyzer. */
../inputs/grep1.dat:6883:208257:static int syntax_bits, syntax_bits_set;
../inputs/grep1.dat:6884:208298:
../inputs/grep1.dat:6885:208299:/* Flag for case-folding letters into sets. */
../inputs/grep1.dat:6886:208346:static int case_fold;
../inputs/grep1.dat:6887:208368:
../inputs/grep1.dat:6888:208369:/* Entry point to set syntax options. */
../inputs/grep1.dat:6889:208410:void
../inputs/grep1.dat:6890:208415:dfasyntax(bits, fold)
../inputs/grep1.dat:6891:208437:     int bits;
../inputs/grep1.dat:6892:208452:     int fold;
../inputs/grep1.dat:6893:208467:{
../inputs/grep1.dat:6894:208469:  syntax_bits_set = 1;
../inputs/grep1.dat:6895:208492:  syntax_bits = bits;
../inputs/grep1.dat:6896:208514:  case_fold = fold;
../inputs/grep1.dat:6897:208534:}
../inputs/grep1.dat:6898:208536:
../inputs/grep1.dat:6899:208537:/* Lexical analyzer.  All the dross that deals with the obnoxious
../inputs/grep1.dat:6900:208603:   GNU Regex syntax bits is located here.  The poor, suffering
../inputs/grep1.dat:6901:208666:   reader is referred to the GNU Regex documentation for the
../inputs/grep1.dat:6902:208727:   meaning of the @#%!@#%^!@ syntax bits. */
../inputs/grep1.dat:6903:208772:
../inputs/grep1.dat:6904:208773:static char *lexstart;		/* Pointer to beginning of input string. */
../inputs/grep1.dat:6905:208841:static char *lexptr;		/* Pointer to next input character. */
../inputs/grep1.dat:6906:208902:static lexleft;			/* Number of characters remaining. */
../inputs/grep1.dat:6907:208958:static token lasttok;		/* Previous token returned; initially END. */
../inputs/grep1.dat:6908:209027:static int laststart;		/* True if we're separated from beginning or (, |
../inputs/grep1.dat:6909:209100:				   only by zero-width characters. */
../inputs/grep1.dat:6910:209141:static int parens;		/* Count of outstanding left parens. */
../inputs/grep1.dat:6911:209201:static int minrep, maxrep;	/* Repeat counts for {m,n}. */
../inputs/grep1.dat:6912:209259:
../inputs/grep1.dat:6913:209260:/* Note that characters become unsigned here. */
../inputs/grep1.dat:6914:209309:#define FETCH(c, eoferr)   	      \
../inputs/grep1.dat:6915:209345:  {			   	      \
../inputs/grep1.dat:6916:209363:    if (! lexleft)	   	      \
../inputs/grep1.dat:6917:209394:      if (eoferr != 0)	   	      \
../inputs/grep1.dat:6918:209429:	dfaerror(eoferr);  	      \
../inputs/grep1.dat:6919:209458:      else		   	      \
../inputs/grep1.dat:6920:209482:	return END;	   	      \
../inputs/grep1.dat:6921:209507:    (c) = (unsigned char) *lexptr++;  \
../inputs/grep1.dat:6922:209547:    --lexleft;		   	      \
../inputs/grep1.dat:6923:209575:  }
../inputs/grep1.dat:6924:209579:
../inputs/grep1.dat:6925:209580:#define FUNC(F, P) static int F(c) int c; { return P(c); }
../inputs/grep1.dat:6926:209639:
../inputs/grep1.dat:6927:209640:FUNC(is_alpha, ISALPHA)
../inputs/grep1.dat:6928:209664:FUNC(is_upper, ISUPPER)
../inputs/grep1.dat:6929:209688:FUNC(is_lower, ISLOWER)
../inputs/grep1.dat:6930:209712:FUNC(is_digit, ISDIGIT)
../inputs/grep1.dat:6931:209736:FUNC(is_xdigit, ISXDIGIT)
../inputs/grep1.dat:6932:209762:FUNC(is_space, ISSPACE)
../inputs/grep1.dat:6933:209786:FUNC(is_punct, ISPUNCT)
../inputs/grep1.dat:6934:209810:FUNC(is_alnum, ISALNUM)
../inputs/grep1.dat:6935:209834:FUNC(is_print, ISPRINT)
../inputs/grep1.dat:6936:209858:FUNC(is_graph, ISGRAPH)
../inputs/grep1.dat:6937:209882:FUNC(is_cntrl, ISCNTRL)
../inputs/grep1.dat:6938:209906:
../inputs/grep1.dat:6939:209907:/* The following list maps the names of the Posix named character classes
../inputs/grep1.dat:6940:209981:   to predicate functions that determine whether a given character is in
../inputs/grep1.dat:6941:210054:   the class.  The leading [ has already been eaten by the lexical analyzer. */
../inputs/grep1.dat:6942:210134:static struct {
../inputs/grep1.dat:6943:210150:  char *name;
../inputs/grep1.dat:6944:210164:  int (*pred)();
../inputs/grep1.dat:6945:210181:} prednames[] = {
../inputs/grep1.dat:6946:210199:  ":alpha:]", is_alpha,
../inputs/grep1.dat:6947:210223:  ":upper:]", is_upper,
../inputs/grep1.dat:6948:210247:  ":lower:]", is_lower,
../inputs/grep1.dat:6949:210271:  ":digit:]", is_digit,
../inputs/grep1.dat:6950:210295:  ":xdigit:]", is_xdigit,
../inputs/grep1.dat:6951:210321:  ":space:]", is_space,
../inputs/grep1.dat:6952:210345:  ":punct:]", is_punct,
../inputs/grep1.dat:6953:210369:  ":alnum:]", is_alnum,
../inputs/grep1.dat:6954:210393:  ":print:]", is_print,
../inputs/grep1.dat:6955:210417:  ":graph:]", is_graph,
../inputs/grep1.dat:6956:210441:  ":cntrl:]", is_cntrl,
../inputs/grep1.dat:6957:210465:  0
../inputs/grep1.dat:6958:210469:};
../inputs/grep1.dat:6959:210472:
../inputs/grep1.dat:6960:210473:static int
../inputs/grep1.dat:6961:210484:looking_at(s)
../inputs/grep1.dat:6962:210498:     char *s;
../inputs/grep1.dat:6963:210512:{
../inputs/grep1.dat:6964:210514:  int len;
../inputs/grep1.dat:6965:210525:
../inputs/grep1.dat:6966:210526:  len = strlen(s);
../inputs/grep1.dat:6967:210545:  if (lexleft < len)
../inputs/grep1.dat:6968:210566:    return 0;
../inputs/grep1.dat:6969:210580:  return strncmp(s, lexptr, len) == 0;
../inputs/grep1.dat:6970:210619:}
../inputs/grep1.dat:6971:210621:
../inputs/grep1.dat:6972:210622:static token
../inputs/grep1.dat:6973:210635:lex()
../inputs/grep1.dat:6974:210641:{
../inputs/grep1.dat:6975:210643:  token c, c1, c2;
../inputs/grep1.dat:6976:210662:  int backslash = 0, invert;
../inputs/grep1.dat:6977:210691:  charclass ccl;
../inputs/grep1.dat:6978:210708:  int i;
../inputs/grep1.dat:6979:210717:
../inputs/grep1.dat:6980:210718:  /* Basic plan: We fetch a character.  If it's a backslash,
../inputs/grep1.dat:6981:210779:     we set the backslash flag and go through the loop again.
../inputs/grep1.dat:6982:210841:     On the plus side, this avoids having a duplicate of the
../inputs/grep1.dat:6983:210902:     main switch inside the backslash case.  On the minus side,
../inputs/grep1.dat:6984:210966:     it means that just about every case begins with
../inputs/grep1.dat:6985:211019:     "if (backslash) ...".  */
../inputs/grep1.dat:6986:211050:  for (i = 0; i < 2; ++i)
../inputs/grep1.dat:6987:211076:    {
../inputs/grep1.dat:6988:211082:      FETCH(c, 0);
../inputs/grep1.dat:6989:211101:      switch (c)
../inputs/grep1.dat:6990:211118:	{
../inputs/grep1.dat:6991:211121:	case '\\':
../inputs/grep1.dat:6992:211133:	  if (backslash)
../inputs/grep1.dat:6993:211151:	    goto normal_char;
../inputs/grep1.dat:6994:211174:	  if (lexleft == 0)
../inputs/grep1.dat:6995:211195:	    dfaerror("Unfinished \\ escape");
../inputs/grep1.dat:6996:211234:	  backslash = 1;
../inputs/grep1.dat:6997:211252:	  break;
../inputs/grep1.dat:6998:211262:
../inputs/grep1.dat:6999:211263:	case '^':
../inputs/grep1.dat:7000:211274:	  if (backslash)
../inputs/grep1.dat:7001:211292:	    goto normal_char;
../inputs/grep1.dat:7002:211315:	  if (syntax_bits & RE_CONTEXT_INDEP_ANCHORS
../inputs/grep1.dat:7003:211361:	      || lasttok == END
../inputs/grep1.dat:7004:211386:	      || lasttok == LPAREN
../inputs/grep1.dat:7005:211414:	      || lasttok == OR)
../inputs/grep1.dat:7006:211439:	    return lasttok = BEGLINE;
../inputs/grep1.dat:7007:211470:	  goto normal_char;
../inputs/grep1.dat:7008:211491:
../inputs/grep1.dat:7009:211492:	case '$':
../inputs/grep1.dat:7010:211503:	  if (backslash)
../inputs/grep1.dat:7011:211521:	    goto normal_char;
../inputs/grep1.dat:7012:211544:	  if (syntax_bits & RE_CONTEXT_INDEP_ANCHORS
../inputs/grep1.dat:7013:211590:	      || lexleft == 0
../inputs/grep1.dat:7014:211613:	      || (syntax_bits & RE_NO_BK_PARENS
../inputs/grep1.dat:7015:211654:		  ? lexleft > 0 && *lexptr == ')'
../inputs/grep1.dat:7016:211690:		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == ')')
../inputs/grep1.dat:7017:211750:	      || (syntax_bits & RE_NO_BK_VBAR
../inputs/grep1.dat:7018:211789:		  ? lexleft > 0 && *lexptr == '|'
../inputs/grep1.dat:7019:211825:		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == '|')
../inputs/grep1.dat:7020:211885:	      || ((syntax_bits & RE_NEWLINE_ALT)
../inputs/grep1.dat:7021:211927:	          && lexleft > 0 && *lexptr == '\n'))
../inputs/grep1.dat:7022:211974:	    return lasttok = ENDLINE;
../inputs/grep1.dat:7023:212005:	  goto normal_char;
../inputs/grep1.dat:7024:212026:
../inputs/grep1.dat:7025:212027:	case '1':
../inputs/grep1.dat:7026:212038:	case '2':
../inputs/grep1.dat:7027:212049:	case '3':
../inputs/grep1.dat:7028:212060:	case '4':
../inputs/grep1.dat:7029:212071:	case '5':
../inputs/grep1.dat:7030:212082:	case '6':
../inputs/grep1.dat:7031:212093:	case '7':
../inputs/grep1.dat:7032:212104:	case '8':
../inputs/grep1.dat:7033:212115:	case '9':
../inputs/grep1.dat:7034:212126:	  if (backslash && !(syntax_bits & RE_NO_BK_REFS))
../inputs/grep1.dat:7035:212178:	    {
../inputs/grep1.dat:7036:212185:	      laststart = 0;
../inputs/grep1.dat:7037:212207:	      return lasttok = BACKREF;
../inputs/grep1.dat:7038:212240:	    }
../inputs/grep1.dat:7039:212247:	  goto normal_char;
../inputs/grep1.dat:7040:212268:
../inputs/grep1.dat:7041:212269:	case '<':
../inputs/grep1.dat:7042:212280:	  if (backslash)
../inputs/grep1.dat:7043:212298:	    return lasttok = BEGWORD;
../inputs/grep1.dat:7044:212329:	  goto normal_char;
../inputs/grep1.dat:7045:212350:
../inputs/grep1.dat:7046:212351:	case '>':
../inputs/grep1.dat:7047:212362:	  if (backslash)
../inputs/grep1.dat:7048:212380:	    return lasttok = ENDWORD;
../inputs/grep1.dat:7049:212411:	  goto normal_char;
../inputs/grep1.dat:7050:212432:
../inputs/grep1.dat:7051:212433:	case 'b':
../inputs/grep1.dat:7052:212444:	  if (backslash)
../inputs/grep1.dat:7053:212462:	    return lasttok = LIMWORD;
../inputs/grep1.dat:7054:212493:	  goto normal_char;
../inputs/grep1.dat:7055:212514:
../inputs/grep1.dat:7056:212515:	case 'B':
../inputs/grep1.dat:7057:212526:	  if (backslash)
../inputs/grep1.dat:7058:212544:	    return lasttok = NOTLIMWORD;
../inputs/grep1.dat:7059:212578:	  goto normal_char;
../inputs/grep1.dat:7060:212599:
../inputs/grep1.dat:7061:212600:	case '?':
../inputs/grep1.dat:7062:212611:	  if (syntax_bits & RE_LIMITED_OPS)
../inputs/grep1.dat:7063:212648:	    goto normal_char;
../inputs/grep1.dat:7064:212671:	  if (backslash != ((syntax_bits & RE_BK_PLUS_QM) != 0))
../inputs/grep1.dat:7065:212729:	    goto normal_char;
../inputs/grep1.dat:7066:212752:	  if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)
../inputs/grep1.dat:7067:212811:	    goto normal_char;
../inputs/grep1.dat:7068:212834:	  return lasttok = QMARK;
../inputs/grep1.dat:7069:212861:
../inputs/grep1.dat:7070:212862:	case '*':
../inputs/grep1.dat:7071:212873:	  if (backslash)
../inputs/grep1.dat:7072:212891:	    goto normal_char;
../inputs/grep1.dat:7073:212914:	  if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)
../inputs/grep1.dat:7074:212973:	    goto normal_char;
../inputs/grep1.dat:7075:212996:	  return lasttok = STAR;
../inputs/grep1.dat:7076:213022:
../inputs/grep1.dat:7077:213023:	case '+':
../inputs/grep1.dat:7078:213034:	  if (syntax_bits & RE_LIMITED_OPS)
../inputs/grep1.dat:7079:213071:	    goto normal_char;
../inputs/grep1.dat:7080:213094:	  if (backslash != ((syntax_bits & RE_BK_PLUS_QM) != 0))
../inputs/grep1.dat:7081:213152:	    goto normal_char;
../inputs/grep1.dat:7082:213175:	  if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)
../inputs/grep1.dat:7083:213234:	    goto normal_char;
../inputs/grep1.dat:7084:213257:	  return lasttok = PLUS;
../inputs/grep1.dat:7085:213283:
../inputs/grep1.dat:7086:213284:	case '{':
../inputs/grep1.dat:7087:213295:	  if (!(syntax_bits & RE_INTERVALS))
../inputs/grep1.dat:7088:213333:	    goto normal_char;
../inputs/grep1.dat:7089:213356:	  if (backslash != ((syntax_bits & RE_NO_BK_BRACES) == 0))
../inputs/grep1.dat:7090:213416:	    goto normal_char;
../inputs/grep1.dat:7091:213439:	  minrep = maxrep = 0;
../inputs/grep1.dat:7092:213463:	  /* Cases:
../inputs/grep1.dat:7093:213476:	     {M} - exact count
../inputs/grep1.dat:7094:213500:	     {M,} - minimum count, maximum is infinity
../inputs/grep1.dat:7095:213548:	     {,M} - 0 through M
../inputs/grep1.dat:7096:213573:	     {M,N} - M through N */
../inputs/grep1.dat:7097:213602:	  FETCH(c, "unfinished repeat count");
../inputs/grep1.dat:7098:213642:	  if (ISDIGIT(c))
../inputs/grep1.dat:7099:213661:	    {
../inputs/grep1.dat:7100:213668:	      minrep = c - '0';
../inputs/grep1.dat:7101:213693:	      for (;;)
../inputs/grep1.dat:7102:213709:		{
../inputs/grep1.dat:7103:213713:		  FETCH(c, "unfinished repeat count");
../inputs/grep1.dat:7104:213754:		  if (!ISDIGIT(c))
../inputs/grep1.dat:7105:213775:		    break;
../inputs/grep1.dat:7106:213788:		  minrep = 10 * minrep + c - '0';
../inputs/grep1.dat:7107:213824:		}
../inputs/grep1.dat:7108:213828:	    }
../inputs/grep1.dat:7109:213835:	  else if (c != ',')
../inputs/grep1.dat:7110:213857:	    dfaerror("malformed repeat count");
../inputs/grep1.dat:7111:213898:	  if (c == ',')
../inputs/grep1.dat:7112:213915:	    for (;;)
../inputs/grep1.dat:7113:213929:	      {
../inputs/grep1.dat:7114:213938:		FETCH(c, "unfinished repeat count");
../inputs/grep1.dat:7115:213977:		if (!ISDIGIT(c))
../inputs/grep1.dat:7116:213996:		  break;
../inputs/grep1.dat:7117:214007:		maxrep = 10 * maxrep + c - '0';
../inputs/grep1.dat:7118:214041:	      }
../inputs/grep1.dat:7119:214050:	  else
../inputs/grep1.dat:7120:214058:	    maxrep = minrep;
../inputs/grep1.dat:7121:214080:	  if (!(syntax_bits & RE_NO_BK_BRACES))
../inputs/grep1.dat:7122:214121:	    {
../inputs/grep1.dat:7123:214128:	      if (c != '\\')
../inputs/grep1.dat:7124:214150:		dfaerror("malformed repeat count");
../inputs/grep1.dat:7125:214188:	      FETCH(c, "unfinished repeat count");
../inputs/grep1.dat:7126:214232:	    }
../inputs/grep1.dat:7127:214239:	  if (c != '}')
../inputs/grep1.dat:7128:214256:	    dfaerror("malformed repeat count");
../inputs/grep1.dat:7129:214297:	  laststart = 0;
../inputs/grep1.dat:7130:214315:	  return lasttok = REPMN;
../inputs/grep1.dat:7131:214342:
../inputs/grep1.dat:7132:214343:	case '|':
../inputs/grep1.dat:7133:214354:	  if (syntax_bits & RE_LIMITED_OPS)
../inputs/grep1.dat:7134:214391:	    goto normal_char;
../inputs/grep1.dat:7135:214414:	  if (backslash != ((syntax_bits & RE_NO_BK_VBAR) == 0))
../inputs/grep1.dat:7136:214472:	    goto normal_char;
../inputs/grep1.dat:7137:214495:	  laststart = 1;
../inputs/grep1.dat:7138:214513:	  return lasttok = OR;
../inputs/grep1.dat:7139:214537:
../inputs/grep1.dat:7140:214538:	case '\n':
../inputs/grep1.dat:7141:214550:	  if (syntax_bits & RE_LIMITED_OPS
../inputs/grep1.dat:7142:214586:	      || backslash
../inputs/grep1.dat:7143:214606:	      || !(syntax_bits & RE_NEWLINE_ALT))
../inputs/grep1.dat:7144:214649:	    goto normal_char;
../inputs/grep1.dat:7145:214672:	  laststart = 1;
../inputs/grep1.dat:7146:214690:	  return lasttok = OR;
../inputs/grep1.dat:7147:214714:
../inputs/grep1.dat:7148:214715:	case '(':
../inputs/grep1.dat:7149:214726:	  if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))
../inputs/grep1.dat:7150:214786:	    goto normal_char;
../inputs/grep1.dat:7151:214809:	  ++parens;
../inputs/grep1.dat:7152:214822:	  laststart = 1;
../inputs/grep1.dat:7153:214840:	  return lasttok = LPAREN;
../inputs/grep1.dat:7154:214868:
../inputs/grep1.dat:7155:214869:	case ')':
../inputs/grep1.dat:7156:214880:	  if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))
../inputs/grep1.dat:7157:214940:	    goto normal_char;
../inputs/grep1.dat:7158:214963:	  if (parens == 0 && syntax_bits & RE_UNMATCHED_RIGHT_PAREN_ORD)
../inputs/grep1.dat:7159:215029:	    goto normal_char;
../inputs/grep1.dat:7160:215052:	  --parens;
../inputs/grep1.dat:7161:215065:	  laststart = 0;
../inputs/grep1.dat:7162:215083:	  return lasttok = RPAREN;
../inputs/grep1.dat:7163:215111:
../inputs/grep1.dat:7164:215112:	case '.':
../inputs/grep1.dat:7165:215123:	  if (backslash)
../inputs/grep1.dat:7166:215141:	    goto normal_char;
../inputs/grep1.dat:7167:215164:	  zeroset(ccl);
../inputs/grep1.dat:7168:215181:	  notset(ccl);
../inputs/grep1.dat:7169:215197:	  if (!(syntax_bits & RE_DOT_NEWLINE))
../inputs/grep1.dat:7170:215237:	    clrbit('\n', ccl);
../inputs/grep1.dat:7171:215261:	  if (syntax_bits & RE_DOT_NOT_NULL)
../inputs/grep1.dat:7172:215299:	    clrbit('\0', ccl);
../inputs/grep1.dat:7173:215323:	  laststart = 0;
../inputs/grep1.dat:7174:215341:	  return lasttok = CSET + charclass_index(ccl);
../inputs/grep1.dat:7175:215390:
../inputs/grep1.dat:7176:215391:	case 'w':
../inputs/grep1.dat:7177:215402:	case 'W':
../inputs/grep1.dat:7178:215413:	  if (!backslash)
../inputs/grep1.dat:7179:215432:	    goto normal_char;
../inputs/grep1.dat:7180:215455:	  zeroset(ccl);
../inputs/grep1.dat:7181:215472:	  for (c2 = 0; c2 < NOTCHAR; ++c2)
../inputs/grep1.dat:7182:215508:	    if (ISALNUM(c2))
../inputs/grep1.dat:7183:215530:	      setbit(c2, ccl);
../inputs/grep1.dat:7184:215554:	  if (c == 'W')
../inputs/grep1.dat:7185:215571:	    notset(ccl);
../inputs/grep1.dat:7186:215589:	  laststart = 0;
../inputs/grep1.dat:7187:215607:	  return lasttok = CSET + charclass_index(ccl);
../inputs/grep1.dat:7188:215656:	
../inputs/grep1.dat:7189:215658:	case '[':
../inputs/grep1.dat:7190:215669:	  if (backslash)
../inputs/grep1.dat:7191:215687:	    goto normal_char;
../inputs/grep1.dat:7192:215710:	  zeroset(ccl);
../inputs/grep1.dat:7193:215727:	  FETCH(c, "Unbalanced [");
../inputs/grep1.dat:7194:215756:	  if (c == '^')
../inputs/grep1.dat:7195:215773:	    {
../inputs/grep1.dat:7196:215780:	      FETCH(c, "Unbalanced [");
../inputs/grep1.dat:7197:215813:	      invert = 1;
../inputs/grep1.dat:7198:215832:	    }
../inputs/grep1.dat:7199:215839:	  else
../inputs/grep1.dat:7200:215847:	    invert = 0;
../inputs/grep1.dat:7201:215864:	  do
../inputs/grep1.dat:7202:215870:	    {
../inputs/grep1.dat:7203:215877:	      /* Nobody ever said this had to be fast. :-)
../inputs/grep1.dat:7204:215929:		 Note that if we're looking at some other [:...:]
../inputs/grep1.dat:7205:215981:		 construct, we just treat it as a bunch of ordinary
../inputs/grep1.dat:7206:216035:		 characters.  We can do this because we assume
../inputs/grep1.dat:7207:216084:		 regex has checked for syntax errors before
../inputs/grep1.dat:7208:216130:		 dfa is ever called. */
../inputs/grep1.dat:7209:216156:	      if (c == '[' && (syntax_bits & RE_CHAR_CLASSES))
../inputs/grep1.dat:7210:216212:		for (c1 = 0; prednames[c1].name; ++c1)
../inputs/grep1.dat:7211:216253:		  if (looking_at(prednames[c1].name))
../inputs/grep1.dat:7212:216293:		    {
../inputs/grep1.dat:7213:216301:		      for (c2 = 0; c2 < NOTCHAR; ++c2)
../inputs/grep1.dat:7214:216342:			if ((*prednames[c1].pred)(c2))
../inputs/grep1.dat:7215:216376:			  setbit(c2, ccl);
../inputs/grep1.dat:7216:216398:		      lexptr += strlen(prednames[c1].name);
../inputs/grep1.dat:7217:216444:		      lexleft -= strlen(prednames[c1].name);
../inputs/grep1.dat:7218:216491:		      FETCH(c1, "Unbalanced [");
../inputs/grep1.dat:7219:216526:		      goto skip;
../inputs/grep1.dat:7220:216545:		    }
../inputs/grep1.dat:7221:216553:	      if (c == '\\' && (syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))
../inputs/grep1.dat:7222:216623:		FETCH(c, "Unbalanced [");
../inputs/grep1.dat:7223:216651:	      FETCH(c1, "Unbalanced [");
../inputs/grep1.dat:7224:216685:	      if (c1 == '-')
../inputs/grep1.dat:7225:216707:		{
../inputs/grep1.dat:7226:216711:		  FETCH(c2, "Unbalanced [");
../inputs/grep1.dat:7227:216742:		  if (c2 == ']')
../inputs/grep1.dat:7228:216761:		    {
../inputs/grep1.dat:7229:216769:		      /* In the case [x-], the - is an ordinary hyphen,
../inputs/grep1.dat:7230:216827:			 which is left in c1, the lookahead character. */
../inputs/grep1.dat:7231:216880:		      --lexptr;
../inputs/grep1.dat:7232:216898:		      ++lexleft;
../inputs/grep1.dat:7233:216917:		      c2 = c;
../inputs/grep1.dat:7234:216933:		    }
../inputs/grep1.dat:7235:216941:		  else
../inputs/grep1.dat:7236:216950:		    {
../inputs/grep1.dat:7237:216958:		      if (c2 == '\\'
../inputs/grep1.dat:7238:216981:			  && (syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))
../inputs/grep1.dat:7239:217035:			FETCH(c2, "Unbalanced [");
../inputs/grep1.dat:7240:217065:		      FETCH(c1, "Unbalanced [");
../inputs/grep1.dat:7241:217100:		    }
../inputs/grep1.dat:7242:217108:		}
../inputs/grep1.dat:7243:217112:	      else
../inputs/grep1.dat:7244:217124:		c2 = c;
../inputs/grep1.dat:7245:217134:	      while (c <= c2)
../inputs/grep1.dat:7246:217157:		{
../inputs/grep1.dat:7247:217161:		  setbit(c, ccl);
../inputs/grep1.dat:7248:217181:		  if (case_fold)
../inputs/grep1.dat:7249:217200:		    if (ISUPPER(c))
../inputs/grep1.dat:7250:217222:		      setbit(tolower(c), ccl);
../inputs/grep1.dat:7251:217255:		    else if (ISLOWER(c))
../inputs/grep1.dat:7252:217282:		      setbit(toupper(c), ccl);
../inputs/grep1.dat:7253:217315:		  ++c;
../inputs/grep1.dat:7254:217324:		}
../inputs/grep1.dat:7255:217328:	    skip:
../inputs/grep1.dat:7256:217339:	      ;
../inputs/grep1.dat:7257:217348:	    }
../inputs/grep1.dat:7258:217355:	  while ((c = c1) != ']');
../inputs/grep1.dat:7259:217383:	  if (invert)
../inputs/grep1.dat:7260:217398:	    {
../inputs/grep1.dat:7261:217405:	      notset(ccl);
../inputs/grep1.dat:7262:217425:	      if (syntax_bits & RE_HAT_LISTS_NOT_NEWLINE)
../inputs/grep1.dat:7263:217476:		clrbit('\n', ccl);
../inputs/grep1.dat:7264:217497:	    }
../inputs/grep1.dat:7265:217504:	  laststart = 0;
../inputs/grep1.dat:7266:217522:	  return lasttok = CSET + charclass_index(ccl);
../inputs/grep1.dat:7267:217571:
../inputs/grep1.dat:7268:217572:	default:
../inputs/grep1.dat:7269:217582:	normal_char:
../inputs/grep1.dat:7270:217596:	  laststart = 0;
../inputs/grep1.dat:7271:217614:	  if (case_fold && ISALPHA(c))
../inputs/grep1.dat:7272:217646:	    {
../inputs/grep1.dat:7273:217653:	      zeroset(ccl);
../inputs/grep1.dat:7274:217674:	      setbit(c, ccl);
../inputs/grep1.dat:7275:217697:	      if (isupper(c))
../inputs/grep1.dat:7276:217720:		setbit(tolower(c), ccl);
../inputs/grep1.dat:7277:217747:	      else
../inputs/grep1.dat:7278:217759:		setbit(toupper(c), ccl);
../inputs/grep1.dat:7279:217786:	      return lasttok = CSET + charclass_index(ccl);
../inputs/grep1.dat:7280:217839:	    }
../inputs/grep1.dat:7281:217846:	  return c;
../inputs/grep1.dat:7282:217859:	}
../inputs/grep1.dat:7283:217862:    }
../inputs/grep1.dat:7284:217868:
../inputs/grep1.dat:7285:217869:  /* The above loop should consume at most a backslash
../inputs/grep1.dat:7286:217924:     and some other character. */
../inputs/grep1.dat:7287:217958:  abort();
../inputs/grep1.dat:7288:217969:}
../inputs/grep1.dat:7289:217971:
../inputs/grep1.dat:7290:217972:/* Recursive descent parser for regular expressions. */
../inputs/grep1.dat:7291:218028:
../inputs/grep1.dat:7292:218029:static token tok;		/* Lookahead token. */
../inputs/grep1.dat:7293:218071:static depth;			/* Current depth of a hypothetical stack
../inputs/grep1.dat:7294:218128:				   holding deferred productions.  This is
../inputs/grep1.dat:7295:218174:				   used to determine the depth that will be
../inputs/grep1.dat:7296:218222:				   required of the real stack later on in
../inputs/grep1.dat:7297:218268:				   dfaanalyze(). */
../inputs/grep1.dat:7298:218292:
../inputs/grep1.dat:7299:218293:/* Add the given token to the parse tree, maintaining the depth count and
../inputs/grep1.dat:7300:218367:   updating the maximum depth if necessary. */
../inputs/grep1.dat:7301:218414:static void
../inputs/grep1.dat:7302:218426:addtok(t)
../inputs/grep1.dat:7303:218436:     token t;
../inputs/grep1.dat:7304:218450:{
../inputs/grep1.dat:7305:218452:  REALLOC_IF_NECESSARY(dfa->tokens, token, dfa->talloc, dfa->tindex);
../inputs/grep1.dat:7306:218522:  dfa->tokens[dfa->tindex++] = t;
../inputs/grep1.dat:7307:218556:
../inputs/grep1.dat:7308:218557:  switch (t)
../inputs/grep1.dat:7309:218570:    {
../inputs/grep1.dat:7310:218576:    case QMARK:
../inputs/grep1.dat:7311:218592:    case STAR:
../inputs/grep1.dat:7312:218607:    case PLUS:
../inputs/grep1.dat:7313:218622:      break;
../inputs/grep1.dat:7314:218635:
../inputs/grep1.dat:7315:218636:    case CAT:
../inputs/grep1.dat:7316:218650:    case OR:
../inputs/grep1.dat:7317:218663:    case ORTOP:
../inputs/grep1.dat:7318:218679:      --depth;
../inputs/grep1.dat:7319:218694:      break;
../inputs/grep1.dat:7320:218707:
../inputs/grep1.dat:7321:218708:    default:
../inputs/grep1.dat:7322:218721:      ++dfa->nleaves;
../inputs/grep1.dat:7323:218743:    case EMPTY:
../inputs/grep1.dat:7324:218759:      ++depth;
../inputs/grep1.dat:7325:218774:      break;
../inputs/grep1.dat:7326:218787:    }
../inputs/grep1.dat:7327:218793:  if (depth > dfa->depth)
../inputs/grep1.dat:7328:218819:    dfa->depth = depth;
../inputs/grep1.dat:7329:218843:}
../inputs/grep1.dat:7330:218845:
../inputs/grep1.dat:7331:218846:/* The grammar understood by the parser is as follows.
../inputs/grep1.dat:7332:218901:
../inputs/grep1.dat:7333:218902:   regexp:
../inputs/grep1.dat:7334:218913:     regexp OR branch
../inputs/grep1.dat:7335:218935:     branch
../inputs/grep1.dat:7336:218947:
../inputs/grep1.dat:7337:218948:   branch:
../inputs/grep1.dat:7338:218959:     branch closure
../inputs/grep1.dat:7339:218979:     closure
../inputs/grep1.dat:7340:218992:
../inputs/grep1.dat:7341:218993:   closure:
../inputs/grep1.dat:7342:219005:     closure QMARK
../inputs/grep1.dat:7343:219024:     closure STAR
../inputs/grep1.dat:7344:219042:     closure PLUS
../inputs/grep1.dat:7345:219060:     atom
../inputs/grep1.dat:7346:219070:
../inputs/grep1.dat:7347:219071:   atom:
../inputs/grep1.dat:7348:219080:     <normal character>
../inputs/grep1.dat:7349:219104:     CSET
../inputs/grep1.dat:7350:219114:     BACKREF
../inputs/grep1.dat:7351:219127:     BEGLINE
../inputs/grep1.dat:7352:219140:     ENDLINE
../inputs/grep1.dat:7353:219153:     BEGWORD
../inputs/grep1.dat:7354:219166:     ENDWORD
../inputs/grep1.dat:7355:219179:     LIMWORD
../inputs/grep1.dat:7356:219192:     NOTLIMWORD
../inputs/grep1.dat:7357:219208:     <empty>
../inputs/grep1.dat:7358:219221:
../inputs/grep1.dat:7359:219222:   The parser builds a parse tree in postfix form in an array of tokens. */
../inputs/grep1.dat:7360:219298:
../inputs/grep1.dat:7361:219299:#if __STDC__
../inputs/grep1.dat:7362:219312:static void regexp(int);
../inputs/grep1.dat:7363:219337:#else
../inputs/grep1.dat:7364:219343:static void regexp();
../inputs/grep1.dat:7365:219365:#endif
../inputs/grep1.dat:7366:219372:
../inputs/grep1.dat:7367:219373:static void
../inputs/grep1.dat:7368:219385:atom()
../inputs/grep1.dat:7369:219392:{
../inputs/grep1.dat:7370:219394:  if ((tok >= 0 && tok < NOTCHAR) || tok >= CSET || tok == BACKREF
../inputs/grep1.dat:7371:219461:      || tok == BEGLINE || tok == ENDLINE || tok == BEGWORD
../inputs/grep1.dat:7372:219521:      || tok == ENDWORD || tok == LIMWORD || tok == NOTLIMWORD)
../inputs/grep1.dat:7373:219585:    {
../inputs/grep1.dat:7374:219591:      addtok(tok);
../inputs/grep1.dat:7375:219610:      tok = lex();
../inputs/grep1.dat:7376:219629:    }
../inputs/grep1.dat:7377:219635:  else if (tok == LPAREN)
../inputs/grep1.dat:7378:219661:    {
../inputs/grep1.dat:7379:219667:      tok = lex();
../inputs/grep1.dat:7380:219686:      regexp(0);
../inputs/grep1.dat:7381:219703:      if (tok != RPAREN)
../inputs/grep1.dat:7382:219728:	dfaerror("Unbalanced (");
../inputs/grep1.dat:7383:219755:      tok = lex();
../inputs/grep1.dat:7384:219774:    }
../inputs/grep1.dat:7385:219780:  else
../inputs/grep1.dat:7386:219787:    addtok(EMPTY);
../inputs/grep1.dat:7387:219806:}
../inputs/grep1.dat:7388:219808:
../inputs/grep1.dat:7389:219809:/* Return the number of tokens in the given subexpression. */
../inputs/grep1.dat:7390:219871:static int
../inputs/grep1.dat:7391:219882:nsubtoks(tindex)
../inputs/grep1.dat:7392:219899:{
../inputs/grep1.dat:7393:219901:  int ntoks1;
../inputs/grep1.dat:7394:219915:
../inputs/grep1.dat:7395:219916:  switch (dfa->tokens[tindex - 1])
../inputs/grep1.dat:7396:219951:    {
../inputs/grep1.dat:7397:219957:    default:
../inputs/grep1.dat:7398:219970:      return 1;
../inputs/grep1.dat:7399:219986:    case QMARK:
../inputs/grep1.dat:7400:220002:    case STAR:
../inputs/grep1.dat:7401:220017:    case PLUS:
../inputs/grep1.dat:7402:220032:      return 1 + nsubtoks(tindex - 1);
../inputs/grep1.dat:7403:220071:    case CAT:
../inputs/grep1.dat:7404:220085:    case OR:
../inputs/grep1.dat:7405:220098:    case ORTOP:
../inputs/grep1.dat:7406:220114:      ntoks1 = nsubtoks(tindex - 1);
../inputs/grep1.dat:7407:220151:      return 1 + ntoks1 + nsubtoks(tindex - 1 - ntoks1);
../inputs/grep1.dat:7408:220208:    }
../inputs/grep1.dat:7409:220214:}
../inputs/grep1.dat:7410:220216:
../inputs/grep1.dat:7411:220217:/* Copy the given subexpression to the top of the tree. */
../inputs/grep1.dat:7412:220276:static void
../inputs/grep1.dat:7413:220288:copytoks(tindex, ntokens)
../inputs/grep1.dat:7414:220314:     int tindex, ntokens;
../inputs/grep1.dat:7415:220340:{
../inputs/grep1.dat:7416:220342:  int i;
../inputs/grep1.dat:7417:220351:
../inputs/grep1.dat:7418:220352:  for (i = 0; i < ntokens; ++i)
../inputs/grep1.dat:7419:220384:    addtok(dfa->tokens[tindex + i]);
../inputs/grep1.dat:7420:220421:}
../inputs/grep1.dat:7421:220423:
../inputs/grep1.dat:7422:220424:static void
../inputs/grep1.dat:7423:220436:closure()
../inputs/grep1.dat:7424:220446:{
../inputs/grep1.dat:7425:220448:  int tindex, ntokens, i;
../inputs/grep1.dat:7426:220474:
../inputs/grep1.dat:7427:220475:  atom();
../inputs/grep1.dat:7428:220485:  while (tok == QMARK || tok == STAR || tok == PLUS || tok == REPMN)
../inputs/grep1.dat:7429:220554:    if (tok == REPMN)
../inputs/grep1.dat:7430:220576:      {
../inputs/grep1.dat:7431:220584:	ntokens = nsubtoks(dfa->tindex);
../inputs/grep1.dat:7432:220618:	tindex = dfa->tindex - ntokens;
../inputs/grep1.dat:7433:220651:	if (maxrep == 0)
../inputs/grep1.dat:7434:220669:	  addtok(PLUS);
../inputs/grep1.dat:7435:220686:	if (minrep == 0)
../inputs/grep1.dat:7436:220704:	  addtok(QMARK);
../inputs/grep1.dat:7437:220722:	for (i = 1; i < minrep; ++i)
../inputs/grep1.dat:7438:220752:	  {
../inputs/grep1.dat:7439:220757:	    copytoks(tindex, ntokens);
../inputs/grep1.dat:7440:220789:	    addtok(CAT);
../inputs/grep1.dat:7441:220807:	  }
../inputs/grep1.dat:7442:220812:	for (; i < maxrep; ++i)
../inputs/grep1.dat:7443:220837:	  {
../inputs/grep1.dat:7444:220842:	    copytoks(tindex, ntokens);
../inputs/grep1.dat:7445:220874:	    addtok(QMARK);
../inputs/grep1.dat:7446:220894:	    addtok(CAT);
../inputs/grep1.dat:7447:220912:	  }
../inputs/grep1.dat:7448:220917:	tok = lex();
../inputs/grep1.dat:7449:220931:      }
../inputs/grep1.dat:7450:220939:    else
../inputs/grep1.dat:7451:220948:      {
../inputs/grep1.dat:7452:220956:	addtok(tok);
../inputs/grep1.dat:7453:220970:	tok = lex();
../inputs/grep1.dat:7454:220984:      }
../inputs/grep1.dat:7455:220992:}
../inputs/grep1.dat:7456:220994:
../inputs/grep1.dat:7457:220995:static void
../inputs/grep1.dat:7458:221007:branch()
../inputs/grep1.dat:7459:221016:{
../inputs/grep1.dat:7460:221018:  closure();
../inputs/grep1.dat:7461:221031:  while (tok != RPAREN && tok != OR && tok >= 0)
../inputs/grep1.dat:7462:221080:    {
../inputs/grep1.dat:7463:221086:      closure();
../inputs/grep1.dat:7464:221103:      addtok(CAT);
../inputs/grep1.dat:7465:221122:    }
../inputs/grep1.dat:7466:221128:}
../inputs/grep1.dat:7467:221130:
../inputs/grep1.dat:7468:221131:static void
../inputs/grep1.dat:7469:221143:regexp(toplevel)
../inputs/grep1.dat:7470:221160:     int toplevel;
../inputs/grep1.dat:7471:221179:{
../inputs/grep1.dat:7472:221181:  branch();
../inputs/grep1.dat:7473:221193:  while (tok == OR)
../inputs/grep1.dat:7474:221213:    {
../inputs/grep1.dat:7475:221219:      tok = lex();
../inputs/grep1.dat:7476:221238:      branch();
../inputs/grep1.dat:7477:221254:      if (toplevel)
../inputs/grep1.dat:7478:221274:	addtok(ORTOP);
../inputs/grep1.dat:7479:221290:      else
../inputs/grep1.dat:7480:221301:	addtok(OR);
../inputs/grep1.dat:7481:221314:    }
../inputs/grep1.dat:7482:221320:}
../inputs/grep1.dat:7483:221322:
../inputs/grep1.dat:7484:221323:/* Main entry point for the parser.  S is a string to be parsed, len is the
../inputs/grep1.dat:7486:221476:   the struct dfa to parse into. */
../inputs/grep1.dat:7487:221512:void
../inputs/grep1.dat:7488:221517:dfaparse(s, len, d)
../inputs/grep1.dat:7489:221537:     char *s;
../inputs/grep1.dat:7490:221551:     size_t len;
../inputs/grep1.dat:7491:221568:     struct dfa *d;
../inputs/grep1.dat:7492:221588:
../inputs/grep1.dat:7493:221589:{
../inputs/grep1.dat:7494:221591:  dfa = d;
../inputs/grep1.dat:7495:221602:  lexstart = lexptr = s;
../inputs/grep1.dat:7496:221627:  lexleft = len;
../inputs/grep1.dat:7497:221644:  lasttok = END;
../inputs/grep1.dat:7498:221661:  laststart = 1;
../inputs/grep1.dat:7499:221678:  parens = 0;
../inputs/grep1.dat:7500:221692:
../inputs/grep1.dat:7501:221693:  if (! syntax_bits_set)
../inputs/grep1.dat:7502:221718:    dfaerror("No syntax specified");
../inputs/grep1.dat:7503:221755:
../inputs/grep1.dat:7504:221756:  tok = lex();
../inputs/grep1.dat:7505:221771:  depth = d->depth;
../inputs/grep1.dat:7506:221791:
../inputs/grep1.dat:7507:221792:  regexp(1);
../inputs/grep1.dat:7508:221805:
../inputs/grep1.dat:7509:221806:  if (tok != END)
../inputs/grep1.dat:7510:221824:    dfaerror("Unbalanced )");
../inputs/grep1.dat:7511:221854:
../inputs/grep1.dat:7512:221855:  addtok(END - d->nregexps);
../inputs/grep1.dat:7513:221884:  addtok(CAT);
../inputs/grep1.dat:7514:221899:
../inputs/grep1.dat:7515:221900:  if (d->nregexps)
../inputs/grep1.dat:7516:221919:    addtok(ORTOP);
../inputs/grep1.dat:7517:221938:
../inputs/grep1.dat:7518:221939:  ++d->nregexps;
../inputs/grep1.dat:7519:221956:}
../inputs/grep1.dat:7520:221958:
../inputs/grep1.dat:7521:221959:/* Some primitives for operating on sets of positions. */
../inputs/grep1.dat:7522:222017:
../inputs/grep1.dat:7523:222018:/* Copy one set to another; the destination must be large enough. */
../inputs/grep1.dat:7524:222087:static void
../inputs/grep1.dat:7525:222099:copy(src, dst)
../inputs/grep1.dat:7526:222114:     position_set *src;
../inputs/grep1.dat:7527:222138:     position_set *dst;
../inputs/grep1.dat:7528:222162:{
../inputs/grep1.dat:7529:222164:  int i;
../inputs/grep1.dat:7530:222173:
../inputs/grep1.dat:7531:222174:  for (i = 0; i < src->nelem; ++i)
../inputs/grep1.dat:7532:222209:    dst->elems[i] = src->elems[i];
../inputs/grep1.dat:7533:222244:  dst->nelem = src->nelem;
../inputs/grep1.dat:7534:222271:}
../inputs/grep1.dat:7535:222273:
../inputs/grep1.dat:7536:222274:/* Insert a position in a set.  Position sets are maintained in sorted
../inputs/grep1.dat:7537:222345:   order according to index.  If position already exists in the set with
../inputs/grep1.dat:7538:222418:   the same index then their constraints are logically or'd together.
../inputs/grep1.dat:7539:222488:   S->elems must point to an array large enough to hold the resulting set. */
../inputs/grep1.dat:7540:222566:static void
../inputs/grep1.dat:7541:222578:insert(p, s)
../inputs/grep1.dat:7542:222591:     position p;
../inputs/grep1.dat:7543:222608:     position_set *s;
../inputs/grep1.dat:7544:222630:{
../inputs/grep1.dat:7545:222632:  int i;
../inputs/grep1.dat:7546:222641:  position t1, t2;
../inputs/grep1.dat:7547:222660:
../inputs/grep1.dat:7548:222661:  for (i = 0; i < s->nelem && p.index < s->elems[i].index; ++i)
../inputs/grep1.dat:7549:222725:    ;
../inputs/grep1.dat:7550:222731:  if (i < s->nelem && p.index == s->elems[i].index)
../inputs/grep1.dat:7551:222783:    s->elems[i].constraint |= p.constraint;
../inputs/grep1.dat:7552:222827:  else
../inputs/grep1.dat:7553:222834:    {
../inputs/grep1.dat:7554:222840:      t1 = p;
../inputs/grep1.dat:7555:222854:      ++s->nelem;
../inputs/grep1.dat:7556:222872:      while (i < s->nelem)
../inputs/grep1.dat:7557:222899:	{
../inputs/grep1.dat:7558:222902:	  t2 = s->elems[i];
../inputs/grep1.dat:7559:222923:	  s->elems[i++] = t1;
../inputs/grep1.dat:7560:222946:	  t1 = t2;
../inputs/grep1.dat:7561:222958:	}
../inputs/grep1.dat:7562:222961:    }
../inputs/grep1.dat:7563:222967:}
../inputs/grep1.dat:7564:222969:
../inputs/grep1.dat:7565:222970:/* Merge two sets of positions into a third.  The result is exactly as if
../inputs/grep1.dat:7566:223044:   the positions of both sets were inserted into an initially empty set. */
../inputs/grep1.dat:7567:223120:static void
../inputs/grep1.dat:7568:223132:merge(s1, s2, m)
../inputs/grep1.dat:7569:223149:     position_set *s1;
../inputs/grep1.dat:7570:223172:     position_set *s2;
../inputs/grep1.dat:7571:223195:     position_set *m;
../inputs/grep1.dat:7572:223217:{
../inputs/grep1.dat:7573:223219:  int i = 0, j = 0;
../inputs/grep1.dat:7574:223239:
../inputs/grep1.dat:7575:223240:  m->nelem = 0;
../inputs/grep1.dat:7576:223256:  while (i < s1->nelem && j < s2->nelem)
../inputs/grep1.dat:7577:223297:    if (s1->elems[i].index > s2->elems[j].index)
../inputs/grep1.dat:7578:223346:      m->elems[m->nelem++] = s1->elems[i++];
../inputs/grep1.dat:7579:223391:    else if (s1->elems[i].index < s2->elems[j].index)
../inputs/grep1.dat:7580:223445:      m->elems[m->nelem++] = s2->elems[j++];
../inputs/grep1.dat:7581:223490:    else
../inputs/grep1.dat:7582:223499:      {
../inputs/grep1.dat:7583:223507:	m->elems[m->nelem] = s1->elems[i++];
../inputs/grep1.dat:7584:223545:	m->elems[m->nelem++].constraint |= s2->elems[j++].constraint;
../inputs/grep1.dat:7585:223608:      }
../inputs/grep1.dat:7586:223616:  while (i < s1->nelem)
../inputs/grep1.dat:7587:223640:    m->elems[m->nelem++] = s1->elems[i++];
../inputs/grep1.dat:7588:223683:  while (j < s2->nelem)
../inputs/grep1.dat:7589:223707:    m->elems[m->nelem++] = s2->elems[j++];
../inputs/grep1.dat:7590:223750:}
../inputs/grep1.dat:7591:223752:
../inputs/grep1.dat:7592:223753:/* Delete a position from a set. */
../inputs/grep1.dat:7593:223789:static void
../inputs/grep1.dat:7594:223801:delete(p, s)
../inputs/grep1.dat:7595:223814:     position p;
../inputs/grep1.dat:7596:223831:     position_set *s;
../inputs/grep1.dat:7597:223853:{
../inputs/grep1.dat:7598:223855:  int i;
../inputs/grep1.dat:7599:223864:
../inputs/grep1.dat:7600:223865:  for (i = 0; i < s->nelem; ++i)
../inputs/grep1.dat:7601:223898:    if (p.index == s->elems[i].index)
../inputs/grep1.dat:7602:223936:      break;
../inputs/grep1.dat:7603:223949:  if (i < s->nelem)
../inputs/grep1.dat:7604:223969:    for (--s->nelem; i < s->nelem; ++i)
../inputs/grep1.dat:7605:224009:      s->elems[i] = s->elems[i + 1];
../inputs/grep1.dat:7606:224046:}
../inputs/grep1.dat:7607:224048:
../inputs/grep1.dat:7608:224049:/* Find the index of the state corresponding to the given position set with
../inputs/grep1.dat:7609:224125:   the given preceding context, or create a new state if there is no such
../inputs/grep1.dat:7610:224199:   state.  Newline and letter tell whether we got here on a newline or
../inputs/grep1.dat:7611:224270:   letter, respectively. */
../inputs/grep1.dat:7612:224298:static int
../inputs/grep1.dat:7613:224309:state_index(d, s, newline, letter)
../inputs/grep1.dat:7614:224344:     struct dfa *d;
../inputs/grep1.dat:7615:224364:     position_set *s;
../inputs/grep1.dat:7616:224386:     int newline;
../inputs/grep1.dat:7617:224404:     int letter;
../inputs/grep1.dat:7618:224421:{
../inputs/grep1.dat:7619:224423:  int hash = 0;
../inputs/grep1.dat:7620:224439:  int constraint;
../inputs/grep1.dat:7621:224457:  int i, j;
../inputs/grep1.dat:7622:224469:
../inputs/grep1.dat:7623:224470:  newline = newline ? 1 : 0;
../inputs/grep1.dat:7624:224499:  letter = letter ? 1 : 0;
../inputs/grep1.dat:7625:224526:
../inputs/grep1.dat:7626:224527:  for (i = 0; i < s->nelem; ++i)
../inputs/grep1.dat:7627:224560:    hash ^= s->elems[i].index + s->elems[i].constraint;
../inputs/grep1.dat:7628:224616:
../inputs/grep1.dat:7629:224617:  /* Try to find a state that exactly matches the proposed one. */
../inputs/grep1.dat:7630:224684:  for (i = 0; i < d->sindex; ++i)
../inputs/grep1.dat:7631:224718:    {
../inputs/grep1.dat:7632:224724:      if (hash != d->states[i].hash || s->nelem != d->states[i].elems.nelem
../inputs/grep1.dat:7633:224800:	  || newline != d->states[i].newline || letter != d->states[i].letter)
../inputs/grep1.dat:7634:224872:	continue;
../inputs/grep1.dat:7635:224883:      for (j = 0; j < s->nelem; ++j)
../inputs/grep1.dat:7636:224920:	if (s->elems[j].constraint
../inputs/grep1.dat:7637:224948:	    != d->states[i].elems.elems[j].constraint
../inputs/grep1.dat:7638:224995:	    || s->elems[j].index != d->states[i].elems.elems[j].index)
../inputs/grep1.dat:7639:225059:	  break;
../inputs/grep1.dat:7640:225069:      if (j == s->nelem)
../inputs/grep1.dat:7641:225094:	return i;
../inputs/grep1.dat:7642:225105:    }
../inputs/grep1.dat:7643:225111:
../inputs/grep1.dat:7644:225112:  /* We'll have to create a new state. */
../inputs/grep1.dat:7645:225154:  REALLOC_IF_NECESSARY(d->states, dfa_state, d->salloc, d->sindex);
../inputs/grep1.dat:7646:225222:  d->states[i].hash = hash;
../inputs/grep1.dat:7647:225250:  MALLOC(d->states[i].elems.elems, position, s->nelem);
../inputs/grep1.dat:7648:225306:  copy(s, &d->states[i].elems);
../inputs/grep1.dat:7649:225338:  d->states[i].newline = newline;
../inputs/grep1.dat:7650:225372:  d->states[i].letter = letter;
../inputs/grep1.dat:7651:225404:  d->states[i].backref = 0;
../inputs/grep1.dat:7652:225432:  d->states[i].constraint = 0;
../inputs/grep1.dat:7653:225463:  d->states[i].first_end = 0;
../inputs/grep1.dat:7654:225493:  for (j = 0; j < s->nelem; ++j)
../inputs/grep1.dat:7655:225526:    if (d->tokens[s->elems[j].index] < 0)
../inputs/grep1.dat:7656:225568:      {
../inputs/grep1.dat:7657:225576:	constraint = s->elems[j].constraint;
../inputs/grep1.dat:7658:225614:	if (SUCCEEDS_IN_CONTEXT(constraint, newline, 0, letter, 0)
../inputs/grep1.dat:7659:225674:	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 0, letter, 1)
../inputs/grep1.dat:7660:225737:	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 1, letter, 0)
../inputs/grep1.dat:7661:225800:	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 1, letter, 1))
../inputs/grep1.dat:7662:225864:	  d->states[i].constraint |= constraint;
../inputs/grep1.dat:7663:225906:	if (! d->states[i].first_end)
../inputs/grep1.dat:7664:225937:	  d->states[i].first_end = d->tokens[s->elems[j].index];
../inputs/grep1.dat:7665:225995:      }
../inputs/grep1.dat:7666:226003:    else if (d->tokens[s->elems[j].index] == BACKREF)
../inputs/grep1.dat:7667:226057:      {
../inputs/grep1.dat:7668:226065:	d->states[i].constraint = NO_CONSTRAINT;
../inputs/grep1.dat:7669:226107:	d->states[i].backref = 1;
../inputs/grep1.dat:7670:226134:      }
../inputs/grep1.dat:7671:226142:
../inputs/grep1.dat:7672:226143:  ++d->sindex;
../inputs/grep1.dat:7673:226158:
../inputs/grep1.dat:7674:226159:  return i;
../inputs/grep1.dat:7675:226171:}
../inputs/grep1.dat:7676:226173:
../inputs/grep1.dat:7677:226174:/* Find the epsilon closure of a set of positions.  If any position of the set
../inputs/grep1.dat:7678:226253:   contains a symbol that matches the empty string in some context, replace
../inputs/grep1.dat:7679:226329:   that position with the elements of its follow labeled with an appropriate
../inputs/grep1.dat:7680:226406:   constraint.  Repeat exhaustively until no funny positions are left.
../inputs/grep1.dat:7681:226477:   S->elems must be large enough to hold the result. */
../inputs/grep1.dat:7682:226533:void
../inputs/grep1.dat:7683:226538:epsclosure(s, d)
../inputs/grep1.dat:7684:226555:     position_set *s;
../inputs/grep1.dat:7685:226577:     struct dfa *d;
../inputs/grep1.dat:7686:226597:{
../inputs/grep1.dat:7687:226599:  int i, j;
../inputs/grep1.dat:7688:226611:  int *visited;
../inputs/grep1.dat:7689:226627:  position p, old;
../inputs/grep1.dat:7690:226646:
../inputs/grep1.dat:7691:226647:  MALLOC(visited, int, d->tindex);
../inputs/grep1.dat:7692:226682:  for (i = 0; i < d->tindex; ++i)
../inputs/grep1.dat:7693:226716:    visited[i] = 0;
../inputs/grep1.dat:7694:226736:
../inputs/grep1.dat:7695:226737:  for (i = 0; i < s->nelem; ++i)
../inputs/grep1.dat:7696:226770:    if (d->tokens[s->elems[i].index] >= NOTCHAR
../inputs/grep1.dat:7697:226818:	&& d->tokens[s->elems[i].index] != BACKREF
../inputs/grep1.dat:7698:226862:	&& d->tokens[s->elems[i].index] < CSET)
../inputs/grep1.dat:7699:226903:      {
../inputs/grep1.dat:7700:226911:	old = s->elems[i];
../inputs/grep1.dat:7701:226931:	p.constraint = old.constraint;
../inputs/grep1.dat:7702:226963:	delete(s->elems[i], s);
../inputs/grep1.dat:7703:226988:	if (visited[old.index])
../inputs/grep1.dat:7704:227013:	  {
../inputs/grep1.dat:7705:227018:	    --i;
../inputs/grep1.dat:7706:227028:	    continue;
../inputs/grep1.dat:7707:227043:	  }
../inputs/grep1.dat:7708:227048:	visited[old.index] = 1;
../inputs/grep1.dat:7709:227073:	switch (d->tokens[old.index])
../inputs/grep1.dat:7710:227104:	  {
../inputs/grep1.dat:7711:227109:	  case BEGLINE:
../inputs/grep1.dat:7712:227126:	    p.constraint &= BEGLINE_CONSTRAINT;
../inputs/grep1.dat:7713:227167:	    break;
../inputs/grep1.dat:7714:227179:	  case ENDLINE:
../inputs/grep1.dat:7715:227196:	    p.constraint &= ENDLINE_CONSTRAINT;
../inputs/grep1.dat:7716:227237:	    break;
../inputs/grep1.dat:7717:227249:	  case BEGWORD:
../inputs/grep1.dat:7718:227266:	    p.constraint &= BEGWORD_CONSTRAINT;
../inputs/grep1.dat:7719:227307:	    break;
../inputs/grep1.dat:7720:227319:	  case ENDWORD:
../inputs/grep1.dat:7721:227336:	    p.constraint &= ENDWORD_CONSTRAINT;
../inputs/grep1.dat:7722:227377:	    break;
../inputs/grep1.dat:7723:227389:	  case LIMWORD:
../inputs/grep1.dat:7724:227406:	    p.constraint &= LIMWORD_CONSTRAINT;
../inputs/grep1.dat:7725:227447:	    break;
../inputs/grep1.dat:7726:227459:	  case NOTLIMWORD:
../inputs/grep1.dat:7727:227479:	    p.constraint &= NOTLIMWORD_CONSTRAINT;
../inputs/grep1.dat:7728:227523:	    break;
../inputs/grep1.dat:7729:227535:	  default:
../inputs/grep1.dat:7730:227547:	    break;
../inputs/grep1.dat:7731:227559:	  }
../inputs/grep1.dat:7732:227564:	for (j = 0; j < d->follows[old.index].nelem; ++j)
../inputs/grep1.dat:7733:227615:	  {
../inputs/grep1.dat:7734:227620:	    p.index = d->follows[old.index].elems[j].index;
../inputs/grep1.dat:7735:227673:	    insert(p, s);
../inputs/grep1.dat:7736:227692:	  }
../inputs/grep1.dat:7737:227697:	/* Force rescan to start at the beginning. */
../inputs/grep1.dat:7738:227744:	i = -1;
../inputs/grep1.dat:7739:227753:      }
../inputs/grep1.dat:7740:227761:
../inputs/grep1.dat:7741:227762:  free(visited);
../inputs/grep1.dat:7742:227779:}
../inputs/grep1.dat:7743:227781:
../inputs/grep1.dat:7744:227782:/* Perform bottom-up analysis on the parse tree, computing various functions.
../inputs/grep1.dat:7745:227860:   Note that at this point, we're pretending constructs like \< are real
../inputs/grep1.dat:7746:227933:   characters rather than constraints on what can follow them.
../inputs/grep1.dat:7747:227996:
../inputs/grep1.dat:7748:227997:   Nullable:  A node is nullable if it is at the root of a regexp that can
../inputs/grep1.dat:7749:228072:   match the empty string.
../inputs/grep1.dat:7750:228099:   *  EMPTY leaves are nullable.
../inputs/grep1.dat:7751:228132:   * No other leaf is nullable.
../inputs/grep1.dat:7752:228164:   * A QMARK or STAR node is nullable.
../inputs/grep1.dat:7753:228203:   * A PLUS node is nullable if its argument is nullable.
../inputs/grep1.dat:7754:228261:   * A CAT node is nullable if both its arguments are nullable.
../inputs/grep1.dat:7755:228325:   * An OR node is nullable if either argument is nullable.
../inputs/grep1.dat:7756:228385:
../inputs/grep1.dat:7757:228386:   Firstpos:  The firstpos of a node is the set of positions (nonempty leaves)
../inputs/grep1.dat:7758:228465:   that could correspond to the first character of a string matching the
../inputs/grep1.dat:7759:228538:   regexp rooted at the given node.
../inputs/grep1.dat:7760:228574:   * EMPTY leaves have empty firstpos.
../inputs/grep1.dat:7761:228613:   * The firstpos of a nonempty leaf is that leaf itself.
../inputs/grep1.dat:7762:228671:   * The firstpos of a QMARK, STAR, or PLUS node is the firstpos of its
../inputs/grep1.dat:7763:228743:     argument.
../inputs/grep1.dat:7764:228758:   * The firstpos of a CAT node is the firstpos of the left argument, union
../inputs/grep1.dat:7765:228834:     the firstpos of the right if the left argument is nullable.
../inputs/grep1.dat:7766:228899:   * The firstpos of an OR node is the union of firstpos of each argument.
../inputs/grep1.dat:7767:228974:
../inputs/grep1.dat:7768:228975:   Lastpos:  The lastpos of a node is the set of positions that could
../inputs/grep1.dat:7769:229045:   correspond to the last character of a string matching the regexp at
../inputs/grep1.dat:7770:229116:   the given node.
../inputs/grep1.dat:7771:229135:   * EMPTY leaves have empty lastpos.
../inputs/grep1.dat:7772:229173:   * The lastpos of a nonempty leaf is that leaf itself.
../inputs/grep1.dat:7773:229230:   * The lastpos of a QMARK, STAR, or PLUS node is the lastpos of its
../inputs/grep1.dat:7774:229300:     argument.
../inputs/grep1.dat:7775:229315:   * The lastpos of a CAT node is the lastpos of its right argument, union
../inputs/grep1.dat:7776:229390:     the lastpos of the left if the right argument is nullable.
../inputs/grep1.dat:7777:229454:   * The lastpos of an OR node is the union of the lastpos of each argument.
../inputs/grep1.dat:7778:229531:
../inputs/grep1.dat:7779:229532:   Follow:  The follow of a position is the set of positions that could
../inputs/grep1.dat:7780:229604:   correspond to the character following a character matching the node in
../inputs/grep1.dat:7781:229678:   a string matching the regexp.  At this point we consider special symbols
../inputs/grep1.dat:7782:229754:   that match the empty string in some context to be just normal characters.
../inputs/grep1.dat:7783:229831:   Later, if we find that a special symbol is in a follow set, we will
../inputs/grep1.dat:7784:229902:   replace it with the elements of its follow, labeled with an appropriate
../inputs/grep1.dat:7785:229977:   constraint.
../inputs/grep1.dat:7786:229992:   * Every node in the firstpos of the argument of a STAR or PLUS node is in
../inputs/grep1.dat:7787:230069:     the follow of every node in the lastpos.
../inputs/grep1.dat:7788:230115:   * Every node in the firstpos of the second argument of a CAT node is in
../inputs/grep1.dat:7789:230190:     the follow of every node in the lastpos of the first argument.
../inputs/grep1.dat:7790:230258:
../inputs/grep1.dat:7791:230259:   Because of the postfix representation of the parse tree, the depth-first
../inputs/grep1.dat:7792:230335:   analysis is conveniently done by a linear scan with the aid of a stack.
../inputs/grep1.dat:7793:230410:   Sets are stored as arrays of the elements, obeying a stack-like allocation
../inputs/grep1.dat:7794:230488:   scheme; the number of elements in each set deeper in the stack can be
../inputs/grep1.dat:7795:230561:   used to determine the address of a particular set's array. */
../inputs/grep1.dat:7796:230626:void
../inputs/grep1.dat:7797:230631:dfaanalyze(d, searchflag)
../inputs/grep1.dat:7798:230657:     struct dfa *d;
../inputs/grep1.dat:7799:230677:     int searchflag;
../inputs/grep1.dat:7800:230698:{
../inputs/grep1.dat:7801:230700:  int *nullable;		/* Nullable stack. */
../inputs/grep1.dat:7802:230740:  int *nfirstpos;		/* Element count stack for firstpos sets. */
../inputs/grep1.dat:7803:230804:  position *firstpos;		/* Array where firstpos elements are stored. */
../inputs/grep1.dat:7804:230875:  int *nlastpos;		/* Element count stack for lastpos sets. */
../inputs/grep1.dat:7805:230937:  position *lastpos;		/* Array where lastpos elements are stored. */
../inputs/grep1.dat:7806:231006:  int *nalloc;			/* Sizes of arrays allocated to follow sets. */
../inputs/grep1.dat:7807:231071:  position_set tmp;		/* Temporary set for merging sets. */
../inputs/grep1.dat:7808:231130:  position_set merged;		/* Result of merging sets. */
../inputs/grep1.dat:7809:231184:  int wants_newline;		/* True if some position wants newline info. */
../inputs/grep1.dat:7810:231254:  int *o_nullable;
../inputs/grep1.dat:7811:231273:  int *o_nfirst, *o_nlast;
../inputs/grep1.dat:7812:231300:  position *o_firstpos, *o_lastpos;
../inputs/grep1.dat:7813:231336:  int i, j;
../inputs/grep1.dat:7814:231348:  position *pos;
../inputs/grep1.dat:7815:231365:
../inputs/grep1.dat:7816:231366:#ifdef DEBUG
../inputs/grep1.dat:7817:231379:  fprintf(stderr, "dfaanalyze:\n");
../inputs/grep1.dat:7818:231415:  for (i = 0; i < d->tindex; ++i)
../inputs/grep1.dat:7819:231449:    {
../inputs/grep1.dat:7820:231455:      fprintf(stderr, " %d:", i);
../inputs/grep1.dat:7821:231489:      prtok(d->tokens[i]);
../inputs/grep1.dat:7822:231516:    }
../inputs/grep1.dat:7823:231522:  putc('\n', stderr);
../inputs/grep1.dat:7824:231544:#endif
../inputs/grep1.dat:7825:231551:
../inputs/grep1.dat:7826:231552:  d->searchflag = searchflag;
../inputs/grep1.dat:7827:231582:
../inputs/grep1.dat:7828:231583:  MALLOC(nullable, int, d->depth);
../inputs/grep1.dat:7829:231618:  o_nullable = nullable;
../inputs/grep1.dat:7830:231643:  MALLOC(nfirstpos, int, d->depth);
../inputs/grep1.dat:7831:231679:  o_nfirst = nfirstpos;
../inputs/grep1.dat:7832:231703:  MALLOC(firstpos, position, d->nleaves);
../inputs/grep1.dat:7833:231745:  o_firstpos = firstpos, firstpos += d->nleaves;
../inputs/grep1.dat:7834:231794:  MALLOC(nlastpos, int, d->depth);
../inputs/grep1.dat:7835:231829:  o_nlast = nlastpos;
../inputs/grep1.dat:7836:231851:  MALLOC(lastpos, position, d->nleaves);
../inputs/grep1.dat:7837:231892:  o_lastpos = lastpos, lastpos += d->nleaves;
../inputs/grep1.dat:7838:231938:  MALLOC(nalloc, int, d->tindex);
../inputs/grep1.dat:7839:231972:  for (i = 0; i < d->tindex; ++i)
../inputs/grep1.dat:7840:232006:    nalloc[i] = 0;
../inputs/grep1.dat:7841:232025:  MALLOC(merged.elems, position, d->nleaves);
../inputs/grep1.dat:7842:232071:
../inputs/grep1.dat:7843:232072:  CALLOC(d->follows, position_set, d->tindex);
../inputs/grep1.dat:7844:232119:
../inputs/grep1.dat:7845:232120:  for (i = 0; i < d->tindex; ++i)
../inputs/grep1.dat:7846:232154:#ifdef DEBUG
../inputs/grep1.dat:7847:232167:    {				/* Nonsyntactic #ifdef goo... */
../inputs/grep1.dat:7848:232209:#endif
../inputs/grep1.dat:7849:232216:    switch (d->tokens[i])
../inputs/grep1.dat:7850:232242:      {
../inputs/grep1.dat:7851:232250:      case EMPTY:
../inputs/grep1.dat:7852:232268:	/* The empty set is nullable. */
../inputs/grep1.dat:7853:232302:	*nullable++ = 1;
../inputs/grep1.dat:7854:232320:
../inputs/grep1.dat:7855:232321:	/* The firstpos and lastpos of the empty leaf are both empty. */
../inputs/grep1.dat:7856:232387:	*nfirstpos++ = *nlastpos++ = 0;
../inputs/grep1.dat:7857:232420:	break;
../inputs/grep1.dat:7858:232428:
../inputs/grep1.dat:7859:232429:      case STAR:
../inputs/grep1.dat:7860:232446:      case PLUS:
../inputs/grep1.dat:7861:232463:	/* Every element in the firstpos of the argument is in the follow
../inputs/grep1.dat:7862:232530:	   of every element in the lastpos. */
../inputs/grep1.dat:7863:232570:	tmp.nelem = nfirstpos[-1];
../inputs/grep1.dat:7864:232598:	tmp.elems = firstpos;
../inputs/grep1.dat:7865:232621:	pos = lastpos;
../inputs/grep1.dat:7866:232637:	for (j = 0; j < nlastpos[-1]; ++j)
../inputs/grep1.dat:7867:232673:	  {
../inputs/grep1.dat:7868:232678:	    merge(&tmp, &d->follows[pos[j].index], &merged);
../inputs/grep1.dat:7869:232732:	    REALLOC_IF_NECESSARY(d->follows[pos[j].index].elems, position,
../inputs/grep1.dat:7870:232800:				 nalloc[pos[j].index], merged.nelem - 1);
../inputs/grep1.dat:7871:232846:	    copy(&merged, &d->follows[pos[j].index]);
../inputs/grep1.dat:7872:232893:	  }
../inputs/grep1.dat:7873:232898:
../inputs/grep1.dat:7874:232899:      case QMARK:
../inputs/grep1.dat:7875:232917:	/* A QMARK or STAR node is automatically nullable. */
../inputs/grep1.dat:7876:232972:	if (d->tokens[i] != PLUS)
../inputs/grep1.dat:7877:232999:	  nullable[-1] = 1;
../inputs/grep1.dat:7878:233020:	break;
../inputs/grep1.dat:7879:233028:
../inputs/grep1.dat:7880:233029:      case CAT:
../inputs/grep1.dat:7881:233045:	/* Every element in the firstpos of the second argument is in the
../inputs/grep1.dat:7882:233112:	   follow of every element in the lastpos of the first argument. */
../inputs/grep1.dat:7883:233181:	tmp.nelem = nfirstpos[-1];
../inputs/grep1.dat:7884:233209:	tmp.elems = firstpos;
../inputs/grep1.dat:7885:233232:	pos = lastpos + nlastpos[-1];
../inputs/grep1.dat:7886:233263:	for (j = 0; j < nlastpos[-2]; ++j)
../inputs/grep1.dat:7887:233299:	  {
../inputs/grep1.dat:7888:233304:	    merge(&tmp, &d->follows[pos[j].index], &merged);
../inputs/grep1.dat:7889:233358:	    REALLOC_IF_NECESSARY(d->follows[pos[j].index].elems, position,
../inputs/grep1.dat:7890:233426:				 nalloc[pos[j].index], merged.nelem - 1);
../inputs/grep1.dat:7891:233472:	    copy(&merged, &d->follows[pos[j].index]);
../inputs/grep1.dat:7892:233519:	  }
../inputs/grep1.dat:7893:233524:
../inputs/grep1.dat:7894:233525:	/* The firstpos of a CAT node is the firstpos of the first argument,
../inputs/grep1.dat:7895:233595:	   union that of the second argument if the first is nullable. */
../inputs/grep1.dat:7896:233662:	if (nullable[-2])
../inputs/grep1.dat:7897:233681:	  nfirstpos[-2] += nfirstpos[-1];
../inputs/grep1.dat:7898:233716:	else
../inputs/grep1.dat:7899:233722:	  firstpos += nfirstpos[-1];
../inputs/grep1.dat:7900:233752:	--nfirstpos;
../inputs/grep1.dat:7901:233766:
../inputs/grep1.dat:7902:233767:	/* The lastpos of a CAT node is the lastpos of the second argument,
../inputs/grep1.dat:7903:233836:	   union that of the first argument if the second is nullable. */
../inputs/grep1.dat:7904:233903:	if (nullable[-1])
../inputs/grep1.dat:7905:233922:	  nlastpos[-2] += nlastpos[-1];
../inputs/grep1.dat:7906:233955:	else
../inputs/grep1.dat:7907:233961:	  {
../inputs/grep1.dat:7908:233966:	    pos = lastpos + nlastpos[-2];
../inputs/grep1.dat:7909:234001:	    for (j = nlastpos[-1] - 1; j >= 0; --j)
../inputs/grep1.dat:7910:234046:	      pos[j] = lastpos[j];
../inputs/grep1.dat:7911:234074:	    lastpos += nlastpos[-2];
../inputs/grep1.dat:7912:234104:	    nlastpos[-2] = nlastpos[-1];
../inputs/grep1.dat:7913:234138:	  }
../inputs/grep1.dat:7914:234143:	--nlastpos;
../inputs/grep1.dat:7915:234156:
../inputs/grep1.dat:7916:234157:	/* A CAT node is nullable if both arguments are nullable. */
../inputs/grep1.dat:7917:234219:	nullable[-2] = nullable[-1] && nullable[-2];
../inputs/grep1.dat:7918:234265:	--nullable;
../inputs/grep1.dat:7919:234278:	break;
../inputs/grep1.dat:7920:234286:
../inputs/grep1.dat:7921:234287:      case OR:
../inputs/grep1.dat:7922:234302:      case ORTOP:
../inputs/grep1.dat:7923:234320:	/* The firstpos is the union of the firstpos of each argument. */
../inputs/grep1.dat:7924:234387:	nfirstpos[-2] += nfirstpos[-1];
../inputs/grep1.dat:7925:234420:	--nfirstpos;
../inputs/grep1.dat:7926:234434:
../inputs/grep1.dat:7927:234435:	/* The lastpos is the union of the lastpos of each argument. */
../inputs/grep1.dat:7928:234500:	nlastpos[-2] += nlastpos[-1];
../inputs/grep1.dat:7929:234531:	--nlastpos;
../inputs/grep1.dat:7930:234544:
../inputs/grep1.dat:7931:234545:	/* An OR node is nullable if either argument is nullable. */
../inputs/grep1.dat:7932:234607:	nullable[-2] = nullable[-1] || nullable[-2];
../inputs/grep1.dat:7933:234653:	--nullable;
../inputs/grep1.dat:7934:234666:	break;
../inputs/grep1.dat:7935:234674:
../inputs/grep1.dat:7936:234675:      default:
../inputs/grep1.dat:7937:234690:	/* Anything else is a nonempty position.  (Note that special
../inputs/grep1.dat:7938:234752:	   constructs like \< are treated as nonempty strings here;
../inputs/grep1.dat:7939:234813:	   an "epsilon closure" effectively makes them nullable later.
../inputs/grep1.dat:7940:234877:	   Backreferences have to get a real position so we can detect
../inputs/grep1.dat:7941:234941:	   transitions on them later.  But they are nullable. */
../inputs/grep1.dat:7942:234999:	*nullable++ = d->tokens[i] == BACKREF;
../inputs/grep1.dat:7943:235039:
../inputs/grep1.dat:7944:235040:	/* This position is in its own firstpos and lastpos. */
../inputs/grep1.dat:7945:235097:	*nfirstpos++ = *nlastpos++ = 1;
../inputs/grep1.dat:7946:235130:	--firstpos, --lastpos;
../inputs/grep1.dat:7947:235154:	firstpos->index = lastpos->index = i;
../inputs/grep1.dat:7948:235193:	firstpos->constraint = lastpos->constraint = NO_CONSTRAINT;
../inputs/grep1.dat:7949:235254:
../inputs/grep1.dat:7950:235255:	/* Allocate the follow set for this position. */
../inputs/grep1.dat:7951:235305:	nalloc[i] = 1;
../inputs/grep1.dat:7952:235321:	MALLOC(d->follows[i].elems, position, nalloc[i]);
../inputs/grep1.dat:7953:235372:	break;
../inputs/grep1.dat:7954:235380:      }
../inputs/grep1.dat:7955:235388:#ifdef DEBUG
../inputs/grep1.dat:7956:235401:    /* ... balance the above nonsyntactic #ifdef goo... */
../inputs/grep1.dat:7957:235460:      fprintf(stderr, "node %d:", i);
../inputs/grep1.dat:7958:235498:      prtok(d->tokens[i]);
../inputs/grep1.dat:7959:235525:      putc('\n', stderr);
../inputs/grep1.dat:7960:235551:      fprintf(stderr, nullable[-1] ? " nullable: yes\n" : " nullable: no\n");
../inputs/grep1.dat:7961:235629:      fprintf(stderr, " firstpos:");
../inputs/grep1.dat:7962:235666:      for (j = nfirstpos[-1] - 1; j >= 0; --j)
../inputs/grep1.dat:7963:235713:	{
../inputs/grep1.dat:7964:235716:	  fprintf(stderr, " %d:", firstpos[j].index);
../inputs/grep1.dat:7965:235763:	  prtok(d->tokens[firstpos[j].index]);
../inputs/grep1.dat:7966:235803:	}
../inputs/grep1.dat:7967:235806:      fprintf(stderr, "\n lastpos:");
../inputs/grep1.dat:7968:235844:      for (j = nlastpos[-1] - 1; j >= 0; --j)
../inputs/grep1.dat:7969:235890:	{
../inputs/grep1.dat:7970:235893:	  fprintf(stderr, " %d:", lastpos[j].index);
../inputs/grep1.dat:7971:235939:	  prtok(d->tokens[lastpos[j].index]);
../inputs/grep1.dat:7972:235978:	}
../inputs/grep1.dat:7973:235981:      putc('\n', stderr);
../inputs/grep1.dat:7974:236007:    }
../inputs/grep1.dat:7975:236013:#endif
../inputs/grep1.dat:7976:236020:
../inputs/grep1.dat:7977:236021:  /* For each follow set that is the follow set of a real position, replace
../inputs/grep1.dat:7978:236097:     it with its epsilon closure. */
../inputs/grep1.dat:7979:236134:  for (i = 0; i < d->tindex; ++i)
../inputs/grep1.dat:7980:236168:    if (d->tokens[i] < NOTCHAR || d->tokens[i] == BACKREF
../inputs/grep1.dat:7981:236226:	|| d->tokens[i] >= CSET)
../inputs/grep1.dat:7982:236252:      {
../inputs/grep1.dat:7983:236260:#ifdef DEBUG
../inputs/grep1.dat:7984:236273:	fprintf(stderr, "follows(%d:", i);
../inputs/grep1.dat:7985:236309:	prtok(d->tokens[i]);
../inputs/grep1.dat:7986:236331:	fprintf(stderr, "):");
../inputs/grep1.dat:7987:236355:	for (j = d->follows[i].nelem - 1; j >= 0; --j)
../inputs/grep1.dat:7988:236403:	  {
../inputs/grep1.dat:7989:236408:	    fprintf(stderr, " %d:", d->follows[i].elems[j].index);
../inputs/grep1.dat:7990:236468:	    prtok(d->tokens[d->follows[i].elems[j].index]);
../inputs/grep1.dat:7991:236521:	  }
../inputs/grep1.dat:7992:236526:	putc('\n', stderr);
../inputs/grep1.dat:7993:236547:#endif
../inputs/grep1.dat:7994:236554:	copy(&d->follows[i], &merged);
../inputs/grep1.dat:7995:236586:	epsclosure(&merged, d);
../inputs/grep1.dat:7996:236611:	if (d->follows[i].nelem < merged.nelem)
../inputs/grep1.dat:7997:236652:	  REALLOC(d->follows[i].elems, position, merged.nelem);
../inputs/grep1.dat:7998:236709:	copy(&merged, &d->follows[i]);
../inputs/grep1.dat:7999:236741:      }
../inputs/grep1.dat:8000:236749:
../inputs/grep1.dat:8001:236750:  /* Get the epsilon closure of the firstpos of the regexp.  The result will
../inputs/grep1.dat:8002:236827:     be the set of positions of state 0. */
../inputs/grep1.dat:8003:236871:  merged.nelem = 0;
../inputs/grep1.dat:8004:236891:  for (i = 0; i < nfirstpos[-1]; ++i)
../inputs/grep1.dat:8005:236929:    insert(firstpos[i], &merged);
../inputs/grep1.dat:8006:236963:  epsclosure(&merged, d);
../inputs/grep1.dat:8007:236989:
../inputs/grep1.dat:8008:236990:  /* Check if any of the positions of state 0 will want newline context. */
../inputs/grep1.dat:8009:237066:  wants_newline = 0;
../inputs/grep1.dat:8010:237087:  for (i = 0; i < merged.nelem; ++i)
../inputs/grep1.dat:8011:237124:    if (PREV_NEWLINE_DEPENDENT(merged.elems[i].constraint))
../inputs/grep1.dat:8012:237184:      wants_newline = 1;
../inputs/grep1.dat:8013:237209:
../inputs/grep1.dat:8014:237210:  /* Build the initial state. */
../inputs/grep1.dat:8015:237243:  d->salloc = 1;
../inputs/grep1.dat:8016:237260:  d->sindex = 0;
../inputs/grep1.dat:8017:237277:  MALLOC(d->states, dfa_state, d->salloc);
../inputs/grep1.dat:8018:237320:  state_index(d, &merged, wants_newline, 0);
../inputs/grep1.dat:8019:237365:
../inputs/grep1.dat:8020:237366:  free(o_nullable);
../inputs/grep1.dat:8021:237386:  free(o_nfirst);
../inputs/grep1.dat:8022:237404:  free(o_firstpos);
../inputs/grep1.dat:8023:237424:  free(o_nlast);
../inputs/grep1.dat:8024:237441:  free(o_lastpos);
../inputs/grep1.dat:8025:237460:  free(nalloc);
../inputs/grep1.dat:8026:237476:  free(merged.elems);
../inputs/grep1.dat:8027:237498:}
../inputs/grep1.dat:8028:237500:
../inputs/grep1.dat:8029:237501:/* Find, for each character, the transition out of state s of d, and store
../inputs/grep1.dat:8030:237576:   it in the appropriate slot of trans.
../inputs/grep1.dat:8031:237616:
../inputs/grep1.dat:8032:237617:   We divide the positions of s into groups (positions can appear in more
../inputs/grep1.dat:8033:237691:   than one group).  Each group is labeled with a set of characters that
../inputs/grep1.dat:8034:237764:   every position in the group matches (taking into account, if necessary,
../inputs/grep1.dat:8035:237839:   preceding context information of s).  For each group, find the union
../inputs/grep1.dat:8036:237911:   of the its elements' follows.  This set is the set of positions of the
../inputs/grep1.dat:8037:237985:   new state.  For each character in the group's label, set the transition
../inputs/grep1.dat:8038:238060:   on this character to be to a state corresponding to the set's positions,
../inputs/grep1.dat:8039:238136:   and its associated backward context information, if necessary.
../inputs/grep1.dat:8040:238202:
../inputs/grep1.dat:8042:238280:   0 in every state.
../inputs/grep1.dat:8043:238301:
../inputs/grep1.dat:8044:238302:   The collection of groups is constructed by building an equivalence-class
../inputs/grep1.dat:8045:238378:   partition of the positions of s.
../inputs/grep1.dat:8046:238414:
../inputs/grep1.dat:8047:238415:   For each position, find the set of characters C that it matches.  Eliminate
../inputs/grep1.dat:8048:238494:   any characters from C that fail on grounds of backward context.
../inputs/grep1.dat:8049:238561:
../inputs/grep1.dat:8050:238562:   Search through the groups, looking for a group whose label L has nonempty
../inputs/grep1.dat:8051:238639:   intersection with C.  If L - C is nonempty, create a new group labeled
../inputs/grep1.dat:8052:238713:   L - C and having the same positions as the current group, and set L to
../inputs/grep1.dat:8053:238787:   the intersection of L and C.  Insert the position in this group, set
../inputs/grep1.dat:8054:238859:   C = C - L, and resume scanning.
../inputs/grep1.dat:8055:238894:
../inputs/grep1.dat:8056:238895:   If after comparing with every group there are characters remaining in C,
../inputs/grep1.dat:8057:238971:   create a new group labeled with the characters of C and insert this
../inputs/grep1.dat:8058:239042:   position in that group. */
../inputs/grep1.dat:8059:239072:void
../inputs/grep1.dat:8060:239077:dfastate(s, d, trans)
../inputs/grep1.dat:8061:239099:     int s;
../inputs/grep1.dat:8062:239111:     struct dfa *d;
../inputs/grep1.dat:8063:239131:     int trans[];
../inputs/grep1.dat:8064:239149:{
../inputs/grep1.dat:8065:239151:  position_set grps[NOTCHAR];	/* As many as will ever be needed. */
../inputs/grep1.dat:8066:239219:  charclass labels[NOTCHAR];	/* Labels corresponding to the groups. */
../inputs/grep1.dat:8067:239290:  int ngrps = 0;		/* Number of groups actually used. */
../inputs/grep1.dat:8068:239346:  position pos;			/* Current position being considered. */
../inputs/grep1.dat:8069:239405:  charclass matches;		/* Set of matching characters. */
../inputs/grep1.dat:8070:239461:  int matchesf;			/* True if matches is nonempty. */
../inputs/grep1.dat:8071:239514:  charclass intersect;		/* Intersection with some label set. */
../inputs/grep1.dat:8072:239578:  int intersectf;		/* True if intersect is nonempty. */
../inputs/grep1.dat:8073:239634:  charclass leftovers;		/* Stuff in the label that didn't match. */
../inputs/grep1.dat:8074:239702:  int leftoversf;		/* True if leftovers is nonempty. */
../inputs/grep1.dat:8075:239758:  static charclass letters;	/* Set of characters considered letters. */
../inputs/grep1.dat:8076:239830:  static charclass newline;	/* Set of characters that aren't newline. */
../inputs/grep1.dat:8077:239903:  position_set follows;		/* Union of the follows of some group. */
../inputs/grep1.dat:8078:239970:  position_set tmp;		/* Temporary space for merging sets. */
../inputs/grep1.dat:8079:240031:  int state;			/* New state. */
../inputs/grep1.dat:8080:240063:  int wants_newline;		/* New state wants to know newline context. */
../inputs/grep1.dat:8081:240132:  int state_newline;		/* New state on a newline transition. */
../inputs/grep1.dat:8082:240195:  int wants_letter;		/* New state wants to know letter context. */
../inputs/grep1.dat:8083:240262:  int state_letter;		/* New state on a letter transition. */
../inputs/grep1.dat:8084:240323:  static initialized;		/* Flag for static initialization. */
../inputs/grep1.dat:8085:240384:  int i, j, k;
../inputs/grep1.dat:8086:240399:
../inputs/grep1.dat:8087:240400:  /* Initialize the set of letters, if necessary. */
../inputs/grep1.dat:8088:240453:  if (! initialized)
../inputs/grep1.dat:8089:240474:    {
../inputs/grep1.dat:8090:240480:      initialized = 1;
../inputs/grep1.dat:8091:240503:      for (i = 0; i < NOTCHAR; ++i)
../inputs/grep1.dat:8092:240539:	if (ISALNUM(i))
../inputs/grep1.dat:8093:240556:	  setbit(i, letters);
../inputs/grep1.dat:8094:240579:      setbit('\n', newline);
../inputs/grep1.dat:8095:240608:    }
../inputs/grep1.dat:8096:240614:
../inputs/grep1.dat:8097:240615:  zeroset(matches);
../inputs/grep1.dat:8098:240635:
../inputs/grep1.dat:8099:240636:  for (i = 0; i < d->states[s].elems.nelem; ++i)
../inputs/grep1.dat:8100:240685:    {
../inputs/grep1.dat:8101:240691:      pos = d->states[s].elems.elems[i];
../inputs/grep1.dat:8102:240732:      if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR)
../inputs/grep1.dat:8103:240803:	setbit(d->tokens[pos.index], matches);
../inputs/grep1.dat:8104:240843:      else if (d->tokens[pos.index] >= CSET)
../inputs/grep1.dat:8105:240888:	copyset(d->charclasses[d->tokens[pos.index] - CSET], matches);
../inputs/grep1.dat:8106:240952:      else
../inputs/grep1.dat:8107:240963:	continue;
../inputs/grep1.dat:8108:240974:
../inputs/grep1.dat:8109:240975:      /* Some characters may need to be eliminated from matches because
../inputs/grep1.dat:8110:241047:	 they fail in the current context. */
../inputs/grep1.dat:8111:241086:      if (pos.constraint != 0xFF)
../inputs/grep1.dat:8112:241120:	{
../inputs/grep1.dat:8113:241123:	  if (! MATCHES_NEWLINE_CONTEXT(pos.constraint,
../inputs/grep1.dat:8114:241172:					 d->states[s].newline, 1))
../inputs/grep1.dat:8115:241204:	    clrbit('\n', matches);
../inputs/grep1.dat:8116:241232:	  if (! MATCHES_NEWLINE_CONTEXT(pos.constraint,
../inputs/grep1.dat:8117:241281:					 d->states[s].newline, 0))
../inputs/grep1.dat:8118:241313:	    for (j = 0; j < CHARCLASS_INTS; ++j)
../inputs/grep1.dat:8119:241355:	      matches[j] &= newline[j];
../inputs/grep1.dat:8120:241388:	  if (! MATCHES_LETTER_CONTEXT(pos.constraint,
../inputs/grep1.dat:8121:241436:					d->states[s].letter, 1))
../inputs/grep1.dat:8122:241466:	    for (j = 0; j < CHARCLASS_INTS; ++j)
../inputs/grep1.dat:8123:241508:	      matches[j] &= ~letters[j];
../inputs/grep1.dat:8124:241542:	  if (! MATCHES_LETTER_CONTEXT(pos.constraint,
../inputs/grep1.dat:8125:241590:					d->states[s].letter, 0))
../inputs/grep1.dat:8126:241620:	    for (j = 0; j < CHARCLASS_INTS; ++j)
../inputs/grep1.dat:8127:241662:	      matches[j] &= letters[j];
../inputs/grep1.dat:8128:241695:
../inputs/grep1.dat:8129:241696:	  /* If there are no characters left, there's no point in going on. */
../inputs/grep1.dat:8130:241768:	  for (j = 0; j < CHARCLASS_INTS && !matches[j]; ++j)
../inputs/grep1.dat:8131:241823:	    ;
../inputs/grep1.dat:8132:241830:	  if (j == CHARCLASS_INTS)
../inputs/grep1.dat:8133:241858:	    continue;
../inputs/grep1.dat:8134:241873:	}
../inputs/grep1.dat:8135:241876:
../inputs/grep1.dat:8136:241877:      for (j = 0; j < ngrps; ++j)
../inputs/grep1.dat:8137:241911:	{
../inputs/grep1.dat:8138:241914:	  /* If matches contains a single character only, and the current
../inputs/grep1.dat:8139:241981:	     group's label doesn't contain that character, go on to the
../inputs/grep1.dat:8140:242046:	     next group. */
../inputs/grep1.dat:8141:242067:	  if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR
../inputs/grep1.dat:8142:242134:	      && !tstbit(d->tokens[pos.index], labels[j]))
../inputs/grep1.dat:8143:242186:	    continue;
../inputs/grep1.dat:8144:242201:
../inputs/grep1.dat:8145:242202:	  /* Check if this group's label has a nonempty intersection with
../inputs/grep1.dat:8146:242269:	     matches. */
../inputs/grep1.dat:8147:242287:	  intersectf = 0;
../inputs/grep1.dat:8148:242306:	  for (k = 0; k < CHARCLASS_INTS; ++k)
../inputs/grep1.dat:8149:242346:	    (intersect[k] = matches[k] & labels[j][k]) ? intersectf = 1 : 0;
../inputs/grep1.dat:8150:242416:	  if (! intersectf)
../inputs/grep1.dat:8151:242437:	    continue;
../inputs/grep1.dat:8152:242452:
../inputs/grep1.dat:8153:242453:	  /* It does; now find the set differences both ways. */
../inputs/grep1.dat:8154:242511:	  leftoversf = matchesf = 0;
../inputs/grep1.dat:8155:242541:	  for (k = 0; k < CHARCLASS_INTS; ++k)
../inputs/grep1.dat:8156:242581:	    {
../inputs/grep1.dat:8157:242588:	      /* Even an optimizing compiler can't know this for sure. */
../inputs/grep1.dat:8158:242655:	      int match = matches[k], label = labels[j][k];
../inputs/grep1.dat:8159:242708:
../inputs/grep1.dat:8160:242709:	      (leftovers[k] = ~match & label) ? leftoversf = 1 : 0;
../inputs/grep1.dat:8161:242770:	      (matches[k] = match & ~label) ? matchesf = 1 : 0;
../inputs/grep1.dat:8162:242827:	    }
../inputs/grep1.dat:8163:242834:
../inputs/grep1.dat:8164:242835:	  /* If there were leftovers, create a new group labeled with them. */
../inputs/grep1.dat:8165:242907:	  if (leftoversf)
../inputs/grep1.dat:8166:242926:	    {
../inputs/grep1.dat:8167:242933:	      copyset(leftovers, labels[ngrps]);
../inputs/grep1.dat:8168:242975:	      copyset(intersect, labels[j]);
../inputs/grep1.dat:8169:243013:	      MALLOC(grps[ngrps].elems, position, d->nleaves);
../inputs/grep1.dat:8170:243069:	      copy(&grps[j], &grps[ngrps]);
../inputs/grep1.dat:8171:243106:	      ++ngrps;
../inputs/grep1.dat:8172:243122:	    }
../inputs/grep1.dat:8173:243129:
../inputs/grep1.dat:8174:243130:	  /* Put the position in the current group.  Note that there is no
../inputs/grep1.dat:8175:243198:	     reason to call insert() here. */
../inputs/grep1.dat:8176:243237:	  grps[j].elems[grps[j].nelem++] = pos;
../inputs/grep1.dat:8177:243278:
../inputs/grep1.dat:8178:243279:	  /* If every character matching the current position has been
../inputs/grep1.dat:8179:243343:	     accounted for, we're done. */
../inputs/grep1.dat:8180:243379:	  if (! matchesf)
../inputs/grep1.dat:8181:243398:	    break;
../inputs/grep1.dat:8182:243410:	}
../inputs/grep1.dat:8183:243413:
../inputs/grep1.dat:8184:243414:      /* If we've passed the last group, and there are still characters
../inputs/grep1.dat:8185:243486:	 unaccounted for, then we'll have to create a new group. */
../inputs/grep1.dat:8186:243547:      if (j == ngrps)
../inputs/grep1.dat:8187:243569:	{
../inputs/grep1.dat:8188:243572:	  copyset(matches, labels[ngrps]);
../inputs/grep1.dat:8189:243608:	  zeroset(matches);
../inputs/grep1.dat:8190:243629:	  MALLOC(grps[ngrps].elems, position, d->nleaves);
../inputs/grep1.dat:8191:243681:	  grps[ngrps].nelem = 1;
../inputs/grep1.dat:8192:243707:	  grps[ngrps].elems[0] = pos;
../inputs/grep1.dat:8193:243738:	  ++ngrps;
../inputs/grep1.dat:8194:243750:	}
../inputs/grep1.dat:8195:243753:    }
../inputs/grep1.dat:8196:243759:
../inputs/grep1.dat:8197:243760:  MALLOC(follows.elems, position, d->nleaves);
../inputs/grep1.dat:8198:243807:  MALLOC(tmp.elems, position, d->nleaves);
../inputs/grep1.dat:8199:243850:
../inputs/grep1.dat:8200:243851:  /* If we are a searching matcher, the default transition is to a state
../inputs/grep1.dat:8201:243924:     containing the positions of state 0, otherwise the default transition
../inputs/grep1.dat:8202:243999:     is to fail miserably. */
../inputs/grep1.dat:8203:244029:  if (d->searchflag)
../inputs/grep1.dat:8204:244050:    {
../inputs/grep1.dat:8205:244056:      wants_newline = 0;
../inputs/grep1.dat:8206:244081:      wants_letter = 0;
../inputs/grep1.dat:8207:244105:      for (i = 0; i < d->states[0].elems.nelem; ++i)
../inputs/grep1.dat:8208:244158:	{
../inputs/grep1.dat:8209:244161:	  if (PREV_NEWLINE_DEPENDENT(d->states[0].elems.elems[i].constraint))
../inputs/grep1.dat:8210:244232:	    wants_newline = 1;
../inputs/grep1.dat:8211:244256:	  if (PREV_LETTER_DEPENDENT(d->states[0].elems.elems[i].constraint))
../inputs/grep1.dat:8212:244326:	    wants_letter = 1;
../inputs/grep1.dat:8213:244349:	}
../inputs/grep1.dat:8214:244352:      copy(&d->states[0].elems, &follows);
../inputs/grep1.dat:8215:244395:      state = state_index(d, &follows, 0, 0);
../inputs/grep1.dat:8216:244441:      if (wants_newline)
../inputs/grep1.dat:8217:244466:	state_newline = state_index(d, &follows, 1, 0);
../inputs/grep1.dat:8218:244515:      else
../inputs/grep1.dat:8219:244526:	state_newline = state;
../inputs/grep1.dat:8220:244550:      if (wants_letter)
../inputs/grep1.dat:8221:244574:	state_letter = state_index(d, &follows, 0, 1);
../inputs/grep1.dat:8222:244622:      else
../inputs/grep1.dat:8223:244633:	state_letter = state;
../inputs/grep1.dat:8224:244656:      for (i = 0; i < NOTCHAR; ++i)
../inputs/grep1.dat:8225:244692:	if (i == '\n')
../inputs/grep1.dat:8226:244708:	  trans[i] = state_newline;
../inputs/grep1.dat:8227:244737:	else if (ISALNUM(i))
../inputs/grep1.dat:8228:244759:	  trans[i] = state_letter;
../inputs/grep1.dat:8229:244787:	else
../inputs/grep1.dat:8230:244793:	  trans[i] = state;
../inputs/grep1.dat:8231:244814:    }
../inputs/grep1.dat:8232:244820:  else
../inputs/grep1.dat:8233:244827:    for (i = 0; i < NOTCHAR; ++i)
../inputs/grep1.dat:8234:244861:      trans[i] = -1;
../inputs/grep1.dat:8235:244882:
../inputs/grep1.dat:8236:244883:  for (i = 0; i < ngrps; ++i)
../inputs/grep1.dat:8237:244913:    {
../inputs/grep1.dat:8238:244919:      follows.nelem = 0;
../inputs/grep1.dat:8239:244944:
../inputs/grep1.dat:8240:244945:      /* Find the union of the follows of the positions of the group.
../inputs/grep1.dat:8241:245015:	 This is a hideously inefficient loop.  Fix it someday. */
../inputs/grep1.dat:8242:245075:      for (j = 0; j < grps[i].nelem; ++j)
../inputs/grep1.dat:8243:245117:	for (k = 0; k < d->follows[grps[i].elems[j].index].nelem; ++k)
../inputs/grep1.dat:8244:245181:	  insert(d->follows[grps[i].elems[j].index].elems[k], &follows);
../inputs/grep1.dat:8245:245247:
../inputs/grep1.dat:8246:245248:      /* If we are building a searching matcher, throw in the positions
../inputs/grep1.dat:8247:245320:	 of state 0 as well. */
../inputs/grep1.dat:8248:245345:      if (d->searchflag)
../inputs/grep1.dat:8249:245370:	for (j = 0; j < d->states[0].elems.nelem; ++j)
../inputs/grep1.dat:8250:245418:	  insert(d->states[0].elems.elems[j], &follows);
../inputs/grep1.dat:8251:245468:
../inputs/grep1.dat:8252:245469:      /* Find out if the new state will want any context information. */
../inputs/grep1.dat:8253:245542:      wants_newline = 0;
../inputs/grep1.dat:8254:245567:      if (tstbit('\n', labels[i]))
../inputs/grep1.dat:8255:245602:	for (j = 0; j < follows.nelem; ++j)
../inputs/grep1.dat:8256:245639:	  if (PREV_NEWLINE_DEPENDENT(follows.elems[j].constraint))
../inputs/grep1.dat:8257:245699:	    wants_newline = 1;
../inputs/grep1.dat:8258:245723:
../inputs/grep1.dat:8259:245724:      wants_letter = 0;
../inputs/grep1.dat:8260:245748:      for (j = 0; j < CHARCLASS_INTS; ++j)
../inputs/grep1.dat:8261:245791:	if (labels[i][j] & letters[j])
../inputs/grep1.dat:8262:245823:	  break;
../inputs/grep1.dat:8263:245833:      if (j < CHARCLASS_INTS)
../inputs/grep1.dat:8264:245863:	for (j = 0; j < follows.nelem; ++j)
../inputs/grep1.dat:8265:245900:	  if (PREV_LETTER_DEPENDENT(follows.elems[j].constraint))
../inputs/grep1.dat:8266:245959:	    wants_letter = 1;
../inputs/grep1.dat:8267:245982:
../inputs/grep1.dat:8268:245983:      /* Find the state(s) corresponding to the union of the follows. */
../inputs/grep1.dat:8269:246056:      state = state_index(d, &follows, 0, 0);
../inputs/grep1.dat:8270:246102:      if (wants_newline)
../inputs/grep1.dat:8271:246127:	state_newline = state_index(d, &follows, 1, 0);
../inputs/grep1.dat:8272:246176:      else
../inputs/grep1.dat:8273:246187:	state_newline = state;
../inputs/grep1.dat:8274:246211:      if (wants_letter)
../inputs/grep1.dat:8275:246235:	state_letter = state_index(d, &follows, 0, 1);
../inputs/grep1.dat:8276:246283:      else
../inputs/grep1.dat:8277:246294:	state_letter = state;
../inputs/grep1.dat:8278:246317:
../inputs/grep1.dat:8279:246318:      /* Set the transitions for each character in the current label. */
../inputs/grep1.dat:8280:246391:      for (j = 0; j < CHARCLASS_INTS; ++j)
../inputs/grep1.dat:8281:246434:	for (k = 0; k < INTBITS; ++k)
../inputs/grep1.dat:8282:246465:	  if (labels[i][j] & 1 << k)
../inputs/grep1.dat:8283:246495:	    {
../inputs/grep1.dat:8284:246502:	      int c = j * INTBITS + k;
../inputs/grep1.dat:8285:246534:
../inputs/grep1.dat:8286:246535:	      if (c == '\n')
../inputs/grep1.dat:8287:246557:		trans[c] = state_newline;
../inputs/grep1.dat:8288:246585:	      else if (ISALNUM(c))
../inputs/grep1.dat:8289:246613:		trans[c] = state_letter;
../inputs/grep1.dat:8290:246640:	      else if (c < NOTCHAR)
../inputs/grep1.dat:8291:246669:		trans[c] = state;
../inputs/grep1.dat:8292:246689:	    }
../inputs/grep1.dat:8293:246696:    }
../inputs/grep1.dat:8294:246702:
../inputs/grep1.dat:8295:246703:  for (i = 0; i < ngrps; ++i)
../inputs/grep1.dat:8296:246733:    free(grps[i].elems);
../inputs/grep1.dat:8297:246758:  free(follows.elems);
../inputs/grep1.dat:8298:246781:  free(tmp.elems);
../inputs/grep1.dat:8299:246800:}
../inputs/grep1.dat:8300:246802:
../inputs/grep1.dat:8301:246803:/* Some routines for manipulating a compiled dfa's transition tables.
../inputs/grep1.dat:8302:246873:   Each state may or may not have a transition table; if it does, and it
../inputs/grep1.dat:8303:246946:   is a non-accepting state, then d->trans[state] points to its table.
../inputs/grep1.dat:8304:247017:   If it is an accepting state then d->fails[state] points to its table.
../inputs/grep1.dat:8305:247090:   If it has no table at all, then d->trans[state] is NULL.
../inputs/grep1.dat:8306:247150:   TODO: Improve this comment, get rid of the unnecessary redundancy. */
../inputs/grep1.dat:8307:247223:
../inputs/grep1.dat:8308:247224:static void
../inputs/grep1.dat:8309:247236:build_state(s, d)
../inputs/grep1.dat:8310:247254:     int s;
../inputs/grep1.dat:8311:247266:     struct dfa *d;
../inputs/grep1.dat:8312:247286:{
../inputs/grep1.dat:8313:247288:  int *trans;			/* The new transition table. */
../inputs/grep1.dat:8314:247336:  int i;
../inputs/grep1.dat:8315:247345:
../inputs/grep1.dat:8316:247346:  /* Set an upper limit on the number of transition tables that will ever
../inputs/grep1.dat:8317:247420:     exist at once.  1024 is arbitrary.  The idea is that the frequently
../inputs/grep1.dat:8318:247493:     used transition tables will be quickly rebuilt, whereas the ones that
../inputs/grep1.dat:8319:247568:     were only needed once or twice will be cleared away. */
../inputs/grep1.dat:8320:247629:  if (d->trcount >= 1024)
../inputs/grep1.dat:8321:247655:    {
../inputs/grep1.dat:8322:247661:      for (i = 0; i < d->tralloc; ++i)
../inputs/grep1.dat:8323:247700:	if (d->trans[i])
../inputs/grep1.dat:8324:247718:	  {
../inputs/grep1.dat:8325:247723:	    free((ptr_t) d->trans[i]);
../inputs/grep1.dat:8326:247755:	    d->trans[i] = NULL;
../inputs/grep1.dat:8327:247780:	  }
../inputs/grep1.dat:8328:247785:	else if (d->fails[i])
../inputs/grep1.dat:8329:247808:	  {
../inputs/grep1.dat:8330:247813:	    free((ptr_t) d->fails[i]);
../inputs/grep1.dat:8331:247845:	    d->fails[i] = NULL;
../inputs/grep1.dat:8332:247870:	  }
../inputs/grep1.dat:8333:247875:      d->trcount = 0;
../inputs/grep1.dat:8334:247897:    }
../inputs/grep1.dat:8335:247903:
../inputs/grep1.dat:8336:247904:  ++d->trcount;
../inputs/grep1.dat:8337:247920:
../inputs/grep1.dat:8338:247921:  /* Set up the success bits for this state. */
../inputs/grep1.dat:8339:247969:  d->success[s] = 0;
../inputs/grep1.dat:8340:247990:  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 1, d->states[s].letter, 0,
../inputs/grep1.dat:8341:248064:      s, *d))
../inputs/grep1.dat:8342:248078:    d->success[s] |= 4;
../inputs/grep1.dat:8343:248102:  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 0, d->states[s].letter, 1,
../inputs/grep1.dat:8344:248176:      s, *d))
../inputs/grep1.dat:8345:248190:    d->success[s] |= 2;
../inputs/grep1.dat:8346:248214:  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 0, d->states[s].letter, 0,
../inputs/grep1.dat:8347:248288:      s, *d))
../inputs/grep1.dat:8348:248302:    d->success[s] |= 1;
../inputs/grep1.dat:8349:248326:
../inputs/grep1.dat:8350:248327:  MALLOC(trans, int, NOTCHAR);
../inputs/grep1.dat:8351:248358:  dfastate(s, d, trans);
../inputs/grep1.dat:8352:248383:
../inputs/grep1.dat:8353:248384:  /* Now go through the new transition table, and make sure that the trans
../inputs/grep1.dat:8354:248459:     and fail arrays are allocated large enough to hold a pointer for the
../inputs/grep1.dat:8355:248533:     largest state mentioned in the table. */
../inputs/grep1.dat:8356:248579:  for (i = 0; i < NOTCHAR; ++i)
../inputs/grep1.dat:8357:248611:    if (trans[i] >= d->tralloc)
../inputs/grep1.dat:8358:248643:      {
../inputs/grep1.dat:8359:248651:	int oldalloc = d->tralloc;
../inputs/grep1.dat:8360:248679:
../inputs/grep1.dat:8361:248680:	while (trans[i] >= d->tralloc)
../inputs/grep1.dat:8362:248712:	  d->tralloc *= 2;
../inputs/grep1.dat:8363:248732:	REALLOC(d->realtrans, int *, d->tralloc + 1);
../inputs/grep1.dat:8364:248779:	d->trans = d->realtrans + 1;
../inputs/grep1.dat:8365:248809:	REALLOC(d->fails, int *, d->tralloc);
../inputs/grep1.dat:8366:248848:	REALLOC(d->success, int, d->tralloc);
../inputs/grep1.dat:8367:248887:	REALLOC(d->newlines, int, d->tralloc);
../inputs/grep1.dat:8368:248927:	while (oldalloc < d->tralloc)
../inputs/grep1.dat:8369:248958:	  {
../inputs/grep1.dat:8370:248963:	    d->trans[oldalloc] = NULL;
../inputs/grep1.dat:8371:248995:	    d->fails[oldalloc++] = NULL;
../inputs/grep1.dat:8372:249029:	  }
../inputs/grep1.dat:8373:249034:      }
../inputs/grep1.dat:8374:249042:
../inputs/grep1.dat:8375:249043:  /* Keep the newline transition in a special place so we can use it as
../inputs/grep1.dat:8376:249115:     a sentinel. */
../inputs/grep1.dat:8377:249135:  d->newlines[s] = trans['\n'];
../inputs/grep1.dat:8378:249167:  trans['\n'] = -1;
../inputs/grep1.dat:8379:249187:
../inputs/grep1.dat:8380:249188:  if (ACCEPTING(s, *d))
../inputs/grep1.dat:8381:249212:    d->fails[s] = trans;
../inputs/grep1.dat:8382:249237:  else
../inputs/grep1.dat:8383:249244:    d->trans[s] = trans;
../inputs/grep1.dat:8384:249269:}
../inputs/grep1.dat:8385:249271:
../inputs/grep1.dat:8386:249272:static void
../inputs/grep1.dat:8387:249284:build_state_zero(d)
../inputs/grep1.dat:8388:249304:     struct dfa *d;
../inputs/grep1.dat:8389:249324:{
../inputs/grep1.dat:8390:249326:  d->tralloc = 1;
../inputs/grep1.dat:8391:249344:  d->trcount = 0;
../inputs/grep1.dat:8392:249362:  CALLOC(d->realtrans, int *, d->tralloc + 1);
../inputs/grep1.dat:8393:249409:  d->trans = d->realtrans + 1;
../inputs/grep1.dat:8394:249440:  CALLOC(d->fails, int *, d->tralloc);
../inputs/grep1.dat:8395:249479:  MALLOC(d->success, int, d->tralloc);
../inputs/grep1.dat:8396:249518:  MALLOC(d->newlines, int, d->tralloc);
../inputs/grep1.dat:8397:249558:  build_state(0, d);
../inputs/grep1.dat:8398:249579:}
../inputs/grep1.dat:8399:249581:
../inputs/grep1.dat:8400:249582:/* Search through a buffer looking for a match to the given struct dfa.
../inputs/grep1.dat:8401:249654:   Find the first occurrence of a string matching the regexp in the buffer,
../inputs/grep1.dat:8402:249730:   and the shortest possible version thereof.  Return a pointer to the first
../inputs/grep1.dat:8403:249807:   character after the match, or NULL if none is found.  Begin points to
../inputs/grep1.dat:8404:249880:   the beginning of the buffer, and end points to the first character after
../inputs/grep1.dat:8405:249956:   its end.  We store a newline in *end to act as a sentinel, so end had
../inputs/grep1.dat:8406:250029:   better point somewhere valid.  Newline is a flag indicating whether to
../inputs/grep1.dat:8407:250103:   allow newlines to be in the matching string.  If count is non-
../inputs/grep1.dat:8408:250169:   NULL it points to a place we're supposed to increment every time we
../inputs/grep1.dat:8409:250240:   see a newline.  Finally, if backref is non-NULL it points to a place
../inputs/grep1.dat:8410:250312:   where we're supposed to store a 1 if backreferencing happened and the
../inputs/grep1.dat:8411:250385:   match needs to be verified by a backtracking matcher.  Otherwise
../inputs/grep1.dat:8412:250453:   we store a 0 in *backref. */
../inputs/grep1.dat:8413:250485:char *
../inputs/grep1.dat:8414:250492:dfaexec(d, begin, end, newline, count, backref)
../inputs/grep1.dat:8415:250540:     struct dfa *d;
../inputs/grep1.dat:8416:250560:     char *begin;
../inputs/grep1.dat:8417:250578:     char *end;
../inputs/grep1.dat:8418:250594:     int newline;
../inputs/grep1.dat:8419:250612:     int *count;
../inputs/grep1.dat:8420:250629:     int *backref;
../inputs/grep1.dat:8421:250648:{
../inputs/grep1.dat:8422:250650:  register s, s1, tmp;		/* Current state. */
../inputs/grep1.dat:8423:250695:  register unsigned char *p;	/* Current input character. */
../inputs/grep1.dat:8424:250755:  register **trans, *t;		/* Copy of d->trans so it can be optimized
../inputs/grep1.dat:8425:250823:				   into a register. */
../inputs/grep1.dat:8426:250850:  static sbit[NOTCHAR];	/* Table for anding with d->success. */
../inputs/grep1.dat:8427:250914:  static sbit_init;
../inputs/grep1.dat:8428:250934:
../inputs/grep1.dat:8429:250935:  if (! sbit_init)
../inputs/grep1.dat:8430:250954:    {
../inputs/grep1.dat:8431:250960:      int i;
../inputs/grep1.dat:8432:250973:
../inputs/grep1.dat:8433:250974:      sbit_init = 1;
../inputs/grep1.dat:8434:250995:      for (i = 0; i < NOTCHAR; ++i)
../inputs/grep1.dat:8435:251031:	if (i == '\n')
../inputs/grep1.dat:8436:251047:	  sbit[i] = 4;
../inputs/grep1.dat:8437:251063:	else if (ISALNUM(i))
../inputs/grep1.dat:8438:251085:	  sbit[i] = 2;
../inputs/grep1.dat:8439:251101:	else
../inputs/grep1.dat:8440:251107:	  sbit[i] = 1;
../inputs/grep1.dat:8441:251123:    }
../inputs/grep1.dat:8442:251129:
../inputs/grep1.dat:8443:251130:  if (! d->tralloc)
../inputs/grep1.dat:8444:251150:    build_state_zero(d);
../inputs/grep1.dat:8445:251175:
../inputs/grep1.dat:8446:251176:  s = s1 = 0;
../inputs/grep1.dat:8447:251190:  p = (unsigned char *) begin;
../inputs/grep1.dat:8448:251221:  trans = d->trans;
../inputs/grep1.dat:8449:251241:  *end = '\n';
../inputs/grep1.dat:8450:251256:
../inputs/grep1.dat:8451:251257:  for (;;)
../inputs/grep1.dat:8452:251268:    {
../inputs/grep1.dat:8453:251274:      /* The dreaded inner loop. */
../inputs/grep1.dat:8454:251310:      if ((t = trans[s]) != 0)
../inputs/grep1.dat:8455:251341:	do
../inputs/grep1.dat:8456:251345:	  {
../inputs/grep1.dat:8457:251350:	    s1 = t[*p++];
../inputs/grep1.dat:8458:251369:	    if (! (t = trans[s1]))
../inputs/grep1.dat:8459:251397:	      goto last_was_s;
../inputs/grep1.dat:8460:251421:	    s = t[*p++];
../inputs/grep1.dat:8461:251439:	  }
../inputs/grep1.dat:8462:251444:        while ((t = trans[s]) != 0);
../inputs/grep1.dat:8463:251481:      goto last_was_s1;
../inputs/grep1.dat:8464:251505:    last_was_s:
../inputs/grep1.dat:8465:251521:      tmp = s, s = s1, s1 = tmp;
../inputs/grep1.dat:8466:251554:    last_was_s1:
../inputs/grep1.dat:8467:251571:
../inputs/grep1.dat:8468:251572:      if (s >= 0 && p <= (unsigned char *) end && d->fails[s])
../inputs/grep1.dat:8469:251635:	{
../inputs/grep1.dat:8470:251638:	  if (d->success[s] & sbit[*p])
../inputs/grep1.dat:8471:251671:	    {
../inputs/grep1.dat:8472:251678:	      if (backref)
../inputs/grep1.dat:8473:251698:		if (d->states[s].backref)
../inputs/grep1.dat:8474:251726:		  *backref = 1;
../inputs/grep1.dat:8475:251744:		else
../inputs/grep1.dat:8476:251751:		  *backref = 0;
../inputs/grep1.dat:8477:251769:	      return (char *) p;
../inputs/grep1.dat:8478:251795:	    }
../inputs/grep1.dat:8479:251802:
../inputs/grep1.dat:8480:251803:	  s1 = s;
../inputs/grep1.dat:8481:251814:	  s = d->fails[s][*p++];
../inputs/grep1.dat:8482:251840:	  continue;
../inputs/grep1.dat:8483:251853:	}
../inputs/grep1.dat:8484:251856:
../inputs/grep1.dat:8485:251857:      /* If the previous character was a newline, count it. */
../inputs/grep1.dat:8486:251920:      if (count && (char *) p <= end && p[-1] == '\n')
../inputs/grep1.dat:8487:251975:	++*count;
../inputs/grep1.dat:8488:251986:
../inputs/grep1.dat:8489:251987:      /* Check if we've run off the end of the buffer. */
../inputs/grep1.dat:8490:252045:      if ((char *) p > end)
../inputs/grep1.dat:8491:252073:	return NULL;
../inputs/grep1.dat:8492:252087:
../inputs/grep1.dat:8493:252088:      if (s >= 0)
../inputs/grep1.dat:8494:252106:	{
../inputs/grep1.dat:8495:252109:	  build_state(s, d);
../inputs/grep1.dat:8496:252131:	  trans = d->trans;
../inputs/grep1.dat:8497:252152:	  continue;
../inputs/grep1.dat:8498:252165:	}
../inputs/grep1.dat:8499:252168:
../inputs/grep1.dat:8500:252169:      if (p[-1] == '\n' && newline)
../inputs/grep1.dat:8501:252205:	{
../inputs/grep1.dat:8502:252208:	  s = d->newlines[s1];
../inputs/grep1.dat:8503:252232:	  continue;
../inputs/grep1.dat:8504:252245:	}
../inputs/grep1.dat:8505:252248:
../inputs/grep1.dat:8506:252249:      s = 0;
../inputs/grep1.dat:8507:252262:    }
../inputs/grep1.dat:8508:252268:}
../inputs/grep1.dat:8509:252270:
../inputs/grep1.dat:8510:252271:/* Initialize the components of a dfa that the other routines don't
../inputs/grep1.dat:8511:252339:   initialize for themselves. */
../inputs/grep1.dat:8512:252372:void
../inputs/grep1.dat:8513:252377:dfainit(d)
../inputs/grep1.dat:8514:252388:     struct dfa *d;
../inputs/grep1.dat:8515:252408:{
../inputs/grep1.dat:8516:252410:  d->calloc = 1;
../inputs/grep1.dat:8517:252427:  MALLOC(d->charclasses, charclass, d->calloc);
../inputs/grep1.dat:8518:252475:  d->cindex = 0;
../inputs/grep1.dat:8519:252492:
../inputs/grep1.dat:8520:252493:  d->talloc = 1;
../inputs/grep1.dat:8521:252510:  MALLOC(d->tokens, token, d->talloc);
../inputs/grep1.dat:8522:252549:  d->tindex = d->depth = d->nleaves = d->nregexps = 0;
../inputs/grep1.dat:8523:252604:
../inputs/grep1.dat:8524:252605:  d->searchflag = 0;
../inputs/grep1.dat:8525:252626:  d->tralloc = 0;
../inputs/grep1.dat:8526:252644:
../inputs/grep1.dat:8527:252645:  d->musts = 0;
../inputs/grep1.dat:8528:252661:}
../inputs/grep1.dat:8529:252663:
../inputs/grep1.dat:8530:252664:/* Parse and analyze a single string of the given length. */
../inputs/grep1.dat:8531:252725:void
../inputs/grep1.dat:8532:252730:dfacomp(s, len, d, searchflag)
../inputs/grep1.dat:8533:252761:     char *s;
../inputs/grep1.dat:8534:252775:     size_t len;
../inputs/grep1.dat:8535:252792:     struct dfa *d;
../inputs/grep1.dat:8536:252812:     int searchflag;
../inputs/grep1.dat:8537:252833:{
../inputs/grep1.dat:8538:252835:  if (case_fold)	/* dummy folding in service of dfamust() */
../inputs/grep1.dat:8539:252896:    {
../inputs/grep1.dat:8540:252902:      char *copy;
../inputs/grep1.dat:8541:252920:      int i;
../inputs/grep1.dat:8542:252933:
../inputs/grep1.dat:8543:252934:      copy = malloc(len);
../inputs/grep1.dat:8544:252960:      if (!copy)
../inputs/grep1.dat:8545:252977:	dfaerror("out of memory");
../inputs/grep1.dat:8546:253005:      
../inputs/grep1.dat:8547:253012:      /* This is a kludge. */
../inputs/grep1.dat:8548:253042:      case_fold = 0;
../inputs/grep1.dat:8549:253063:      for (i = 0; i < len; ++i)
../inputs/grep1.dat:8550:253095:	if (ISUPPER(s[i]))
../inputs/grep1.dat:8551:253115:	  copy[i] = tolower(s[i]);
../inputs/grep1.dat:8552:253143:	else
../inputs/grep1.dat:8553:253149:	  copy[i] = s[i];
../inputs/grep1.dat:8554:253168:
../inputs/grep1.dat:8555:253169:      dfainit(d);
../inputs/grep1.dat:8556:253187:      dfaparse(copy, len, d);
../inputs/grep1.dat:8557:253217:      free(copy);
../inputs/grep1.dat:8558:253235:      dfamust(d);
../inputs/grep1.dat:8559:253253:      d->cindex = d->tindex = d->depth = d->nleaves = d->nregexps = 0;
../inputs/grep1.dat:8560:253324:      case_fold = 1;
../inputs/grep1.dat:8561:253345:      dfaparse(s, len, d);
../inputs/grep1.dat:8562:253372:      dfaanalyze(d, searchflag);
../inputs/grep1.dat:8563:253405:    }
../inputs/grep1.dat:8564:253411:  else
../inputs/grep1.dat:8565:253418:    {
../inputs/grep1.dat:8566:253424:        dfainit(d);
../inputs/grep1.dat:8567:253444:        dfaparse(s, len, d);
../inputs/grep1.dat:8568:253473:	dfamust(d);
../inputs/grep1.dat:8569:253486:        dfaanalyze(d, searchflag);
../inputs/grep1.dat:8570:253521:    }
../inputs/grep1.dat:8571:253527:}
../inputs/grep1.dat:8572:253529:
../inputs/grep1.dat:8573:253530:/* Free the storage held by the components of a dfa. */
../inputs/grep1.dat:8574:253586:void
../inputs/grep1.dat:8575:253591:dfafree(d)
../inputs/grep1.dat:8576:253602:     struct dfa *d;
../inputs/grep1.dat:8577:253622:{
../inputs/grep1.dat:8578:253624:  int i;
../inputs/grep1.dat:8579:253633:  struct dfamust *dm, *ndm;
../inputs/grep1.dat:8580:253661:
../inputs/grep1.dat:8581:253662:  free((ptr_t) d->charclasses);
../inputs/grep1.dat:8582:253694:  free((ptr_t) d->tokens);
../inputs/grep1.dat:8583:253721:  for (i = 0; i < d->sindex; ++i)
../inputs/grep1.dat:8584:253755:    free((ptr_t) d->states[i].elems.elems);
../inputs/grep1.dat:8585:253799:  free((ptr_t) d->states);
../inputs/grep1.dat:8586:253826:  for (i = 0; i < d->tindex; ++i)
../inputs/grep1.dat:8587:253860:    if (d->follows[i].elems)
../inputs/grep1.dat:8588:253889:      free((ptr_t) d->follows[i].elems);
../inputs/grep1.dat:8589:253930:  free((ptr_t) d->follows);
../inputs/grep1.dat:8590:253958:  for (i = 0; i < d->tralloc; ++i)
../inputs/grep1.dat:8591:253993:    if (d->trans[i])
../inputs/grep1.dat:8592:254014:      free((ptr_t) d->trans[i]);
../inputs/grep1.dat:8593:254047:    else if (d->fails[i])
../inputs/grep1.dat:8594:254073:      free((ptr_t) d->fails[i]);
../inputs/grep1.dat:8595:254106:  free((ptr_t) d->realtrans);
../inputs/grep1.dat:8596:254136:  free((ptr_t) d->fails);
../inputs/grep1.dat:8597:254162:  free((ptr_t) d->newlines);
../inputs/grep1.dat:8598:254191:  for (dm = d->musts; dm; dm = ndm)
../inputs/grep1.dat:8599:254227:    {
../inputs/grep1.dat:8600:254233:      ndm = dm->next;
../inputs/grep1.dat:8601:254255:      free(dm->must);
../inputs/grep1.dat:8602:254277:      free((ptr_t) dm);
../inputs/grep1.dat:8603:254301:    }
../inputs/grep1.dat:8604:254307:}
../inputs/grep1.dat:8605:254309:
../inputs/grep1.dat:8606:254310:/* Having found the postfix representation of the regular expression,
../inputs/grep1.dat:8607:254380:   try to find a long sequence of characters that must appear in any line
../inputs/grep1.dat:8608:254454:   containing the r.e.
../inputs/grep1.dat:8609:254477:   Finding a "longest" sequence is beyond the scope here;
../inputs/grep1.dat:8610:254535:   we take an easy way out and hope for the best.
../inputs/grep1.dat:8611:254585:   (Take "(ab|a)b"--please.)
../inputs/grep1.dat:8612:254614:
../inputs/grep1.dat:8613:254615:   We do a bottom-up calculation of sequences of characters that must appear
../inputs/grep1.dat:8614:254692:   in matches of r.e.'s represented by trees rooted at the nodes of the postfix
../inputs/grep1.dat:8615:254772:   representation:
../inputs/grep1.dat:8616:254791:	sequences that must appear at the left of the match ("left")
../inputs/grep1.dat:8617:254853:	sequences that must appear at the right of the match ("right")
../inputs/grep1.dat:8618:254917:	lists of sequences that must appear somewhere in the match ("in")
../inputs/grep1.dat:8619:254984:	sequences that must constitute the match ("is")
../inputs/grep1.dat:8620:255033:
../inputs/grep1.dat:8621:255034:   When we get to the root of the tree, we use one of the longest of its
../inputs/grep1.dat:8622:255107:   calculated "in" sequences as our answer.  The sequence we find is returned in
../inputs/grep1.dat:8623:255188:   d->must (where "d" is the single argument passed to "dfamust");
../inputs/grep1.dat:8624:255255:   the length of the sequence is returned in d->mustn.
../inputs/grep1.dat:8625:255310:
../inputs/grep1.dat:8626:255311:   The sequences calculated for the various types of node (in pseudo ANSI c)
../inputs/grep1.dat:8627:255388:   are shown below.  "p" is the operand of unary operators (and the left-hand
../inputs/grep1.dat:8628:255466:   operand of binary operators); "q" is the right-hand operand of binary
../inputs/grep1.dat:8629:255539:   operators.
../inputs/grep1.dat:8630:255553:
../inputs/grep1.dat:8631:255554:   "ZERO" means "a zero-length sequence" below.
../inputs/grep1.dat:8632:255602:
../inputs/grep1.dat:8633:255603:	Type	left		right		is		in
../inputs/grep1.dat:8634:255629:	----	----		-----		--		--
../inputs/grep1.dat:8635:255655:	char c	# c		# c		# c		# c
../inputs/grep1.dat:8636:255682:	
../inputs/grep1.dat:8637:255684:	CSET	ZERO		ZERO		ZERO		ZERO
../inputs/grep1.dat:8638:255713:	
../inputs/grep1.dat:8639:255715:	STAR	ZERO		ZERO		ZERO		ZERO
../inputs/grep1.dat:8640:255744:
../inputs/grep1.dat:8641:255745:	QMARK	ZERO		ZERO		ZERO		ZERO
../inputs/grep1.dat:8642:255775:
../inputs/grep1.dat:8643:255776:	PLUS	p->left		p->right	ZERO		p->in
../inputs/grep1.dat:8644:255812:
../inputs/grep1.dat:8645:255813:	CAT	(p->is==ZERO)?	(q->is==ZERO)?	(p->is!=ZERO &&	p->in plus
../inputs/grep1.dat:8646:255875:		p->left :	q->right :	q->is!=ZERO) ?	q->in plus
../inputs/grep1.dat:8647:255924:		p->is##q->left	p->right##q->is	p->is##q->is :	p->right##q->left
../inputs/grep1.dat:8648:255990:						ZERO
../inputs/grep1.dat:8649:256001:					
../inputs/grep1.dat:8650:256007:	OR	longest common	longest common	(do p->is and	substrings common to
../inputs/grep1.dat:8651:256076:		leading		trailing	q->is have same	p->in and q->in
../inputs/grep1.dat:8652:256128:		(sub)sequence	(sub)sequence	length and	
../inputs/grep1.dat:8653:256170:		of p->left	of p->right	content) ?	
../inputs/grep1.dat:8654:256207:		and q->left	and q->right	p->is : NULL	
../inputs/grep1.dat:8655:256248:
../inputs/grep1.dat:8656:256249:   If there's anything else we recognize in the tree, all four sequences get set
../inputs/grep1.dat:8657:256330:   to zero-length sequences.  If there's something we don't recognize in the tree,
../inputs/grep1.dat:8658:256413:   we just return a zero-length sequence.
../inputs/grep1.dat:8659:256455:
../inputs/grep1.dat:8660:256456:   Break ties in favor of infrequent letters (choosing 'zzz' in preference to
../inputs/grep1.dat:8661:256534:   'aaa')?
../inputs/grep1.dat:8662:256545:
../inputs/grep1.dat:8663:256546:   And. . .is it here or someplace that we might ponder "optimizations" such as
../inputs/grep1.dat:8664:256626:	egrep 'psi|epsilon'	->	egrep 'psi'
../inputs/grep1.dat:8665:256662:	egrep 'pepsi|epsilon'	->	egrep 'epsi'
../inputs/grep1.dat:8666:256701:					(Yes, we now find "epsi" as a "string
../inputs/grep1.dat:8667:256744:					that must occur", but we might also
../inputs/grep1.dat:8668:256785:					simplify the *entire* r.e. being sought)
../inputs/grep1.dat:8669:256831:	grep '[c]'		->	grep 'c'
../inputs/grep1.dat:8670:256856:	grep '(ab|a)b'		->	grep 'ab'
../inputs/grep1.dat:8671:256886:	grep 'ab*'		->	grep 'a'
../inputs/grep1.dat:8672:256911:	grep 'a*b'		->	grep 'b'
../inputs/grep1.dat:8673:256936:
../inputs/grep1.dat:8674:256937:   There are several issues:
../inputs/grep1.dat:8675:256966:
../inputs/grep1.dat:8676:256967:   Is optimization easy (enough)?
../inputs/grep1.dat:8677:257001:
../inputs/grep1.dat:8678:257002:   Does optimization actually accomplish anything,
../inputs/grep1.dat:8679:257053:   or is the automaton you get from "psi|epsilon" (for example)
../inputs/grep1.dat:8680:257117:   the same as the one you get from "psi" (for example)?
../inputs/grep1.dat:8681:257174:  
../inputs/grep1.dat:8682:257177:   Are optimizable r.e.'s likely to be used in real-life situations
../inputs/grep1.dat:8683:257245:   (something like 'ab*' is probably unlikely; something like is
../inputs/grep1.dat:8684:257310:   'psi|epsilon' is likelier)? */
../inputs/grep1.dat:8685:257344:
../inputs/grep1.dat:8686:257345:static char *
../inputs/grep1.dat:8687:257359:icatalloc(old, new)
../inputs/grep1.dat:8688:257379:     char *old;
../inputs/grep1.dat:8689:257395:     char *new;
../inputs/grep1.dat:8690:257411:{
../inputs/grep1.dat:8691:257413:  char *result;
../inputs/grep1.dat:8692:257429:  int oldsize, newsize;
../inputs/grep1.dat:8693:257453:
../inputs/grep1.dat:8694:257454:  newsize = (new == NULL) ? 0 : strlen(new);
../inputs/grep1.dat:8695:257499:  if (old == NULL)
../inputs/grep1.dat:8696:257518:    oldsize = 0;
../inputs/grep1.dat:8697:257535:  else if (newsize == 0)
../inputs/grep1.dat:8698:257560:    return old;
../inputs/grep1.dat:8699:257576:  else	oldsize = strlen(old);
../inputs/grep1.dat:8700:257606:  if (old == NULL)
../inputs/grep1.dat:8701:257625:    result = (char *) malloc(newsize + 1);
../inputs/grep1.dat:8702:257668:  else
../inputs/grep1.dat:8703:257675:    result = (char *) realloc((void *) old, oldsize + newsize + 1);
../inputs/grep1.dat:8704:257743:  if (result != NULL && new != NULL)
../inputs/grep1.dat:8705:257780:    (void) strcpy(result + oldsize, new);
../inputs/grep1.dat:8706:257822:  return result;
../inputs/grep1.dat:8707:257839:}
../inputs/grep1.dat:8708:257841:
../inputs/grep1.dat:8709:257842:static char *
../inputs/grep1.dat:8710:257856:icpyalloc(string)
../inputs/grep1.dat:8711:257874:     char *string;
../inputs/grep1.dat:8712:257893:{
../inputs/grep1.dat:8713:257895:  return icatalloc((char *) NULL, string);
../inputs/grep1.dat:8714:257938:}
../inputs/grep1.dat:8715:257940:
../inputs/grep1.dat:8716:257941:static char *
../inputs/grep1.dat:8717:257955:istrstr(lookin, lookfor)
../inputs/grep1.dat:8718:257980:     char *lookin;
../inputs/grep1.dat:8719:257999:     char *lookfor;
../inputs/grep1.dat:8720:258019:{
../inputs/grep1.dat:8721:258021:  char *cp;
../inputs/grep1.dat:8722:258033:  int len;
../inputs/grep1.dat:8723:258044:
../inputs/grep1.dat:8724:258045:  len = strlen(lookfor);
../inputs/grep1.dat:8725:258070:  for (cp = lookin; *cp != '\0'; ++cp)
../inputs/grep1.dat:8726:258109:    if (strncmp(cp, lookfor, len) == 0)
../inputs/grep1.dat:8727:258149:      return cp;
../inputs/grep1.dat:8728:258166:  return NULL;
../inputs/grep1.dat:8729:258181:}
../inputs/grep1.dat:8730:258183:
../inputs/grep1.dat:8731:258184:static void
../inputs/grep1.dat:8732:258196:ifree(cp)
../inputs/grep1.dat:8733:258206:     char *cp;
../inputs/grep1.dat:8734:258221:{
../inputs/grep1.dat:8735:258223:  if (cp != NULL)
../inputs/grep1.dat:8736:258241:    free(cp);
../inputs/grep1.dat:8737:258255:}
../inputs/grep1.dat:8738:258257:
../inputs/grep1.dat:8739:258258:static void
../inputs/grep1.dat:8740:258270:freelist(cpp)
../inputs/grep1.dat:8741:258284:     char **cpp;
../inputs/grep1.dat:8742:258301:{
../inputs/grep1.dat:8743:258303:  int i;
../inputs/grep1.dat:8744:258312:
../inputs/grep1.dat:8745:258313:  if (cpp == NULL)
../inputs/grep1.dat:8746:258332:    return;
../inputs/grep1.dat:8747:258344:  for (i = 0; cpp[i] != NULL; ++i)
../inputs/grep1.dat:8748:258379:    {
../inputs/grep1.dat:8749:258385:      free(cpp[i]);
../inputs/grep1.dat:8750:258405:      cpp[i] = NULL;
../inputs/grep1.dat:8751:258426:    }
../inputs/grep1.dat:8752:258432:}
../inputs/grep1.dat:8753:258434:
../inputs/grep1.dat:8754:258435:static char **
../inputs/grep1.dat:8755:258450:enlist(cpp, new, len)
../inputs/grep1.dat:8756:258472:     char **cpp;
../inputs/grep1.dat:8757:258489:     char *new;
../inputs/grep1.dat:8758:258505:     int len;
../inputs/grep1.dat:8759:258519:{
../inputs/grep1.dat:8760:258521:  int i, j;
../inputs/grep1.dat:8761:258533:
../inputs/grep1.dat:8762:258534:  if (cpp == NULL)
../inputs/grep1.dat:8763:258553:    return NULL;
../inputs/grep1.dat:8764:258570:  if ((new = icpyalloc(new)) == NULL)
../inputs/grep1.dat:8765:258608:    {
../inputs/grep1.dat:8766:258614:      freelist(cpp);
../inputs/grep1.dat:8767:258635:      return NULL;
../inputs/grep1.dat:8768:258654:    }
../inputs/grep1.dat:8769:258660:  new[len] = '\0';
../inputs/grep1.dat:8770:258679:  /* Is there already something in the list that's new (or longer)? */
../inputs/grep1.dat:8771:258750:  for (i = 0; cpp[i] != NULL; ++i)
../inputs/grep1.dat:8772:258785:    if (istrstr(cpp[i], new) != NULL)
../inputs/grep1.dat:8773:258823:      {
../inputs/grep1.dat:8774:258831:	free(new);
../inputs/grep1.dat:8775:258843:	return cpp;
../inputs/grep1.dat:8776:258856:      }
../inputs/grep1.dat:8777:258864:  /* Eliminate any obsoleted strings. */
../inputs/grep1.dat:8778:258905:  j = 0;
../inputs/grep1.dat:8779:258914:  while (cpp[j] != NULL)
../inputs/grep1.dat:8780:258939:    if (istrstr(new, cpp[j]) == NULL)
../inputs/grep1.dat:8781:258977:      ++j;
../inputs/grep1.dat:8782:258988:    else
../inputs/grep1.dat:8783:258997:      {
../inputs/grep1.dat:8784:259005:	free(cpp[j]);
../inputs/grep1.dat:8785:259020:	if (--i == j)
../inputs/grep1.dat:8786:259035:	  break;
../inputs/grep1.dat:8787:259045:	cpp[j] = cpp[i];
../inputs/grep1.dat:8788:259063:	cpp[i] = NULL;
../inputs/grep1.dat:8789:259079:      }
../inputs/grep1.dat:8790:259087:  /* Add the new string. */
../inputs/grep1.dat:8791:259115:  cpp = (char **) realloc((char *) cpp, (i + 2) * sizeof *cpp);
../inputs/grep1.dat:8792:259179:  if (cpp == NULL)
../inputs/grep1.dat:8793:259198:    return NULL;
../inputs/grep1.dat:8794:259215:  cpp[i] = new;
../inputs/grep1.dat:8795:259231:  cpp[i + 1] = NULL;
../inputs/grep1.dat:8796:259252:  return cpp;
../inputs/grep1.dat:8797:259266:}
../inputs/grep1.dat:8798:259268:
../inputs/grep1.dat:8799:259269:/* Given pointers to two strings, return a pointer to an allocated
../inputs/grep1.dat:8800:259336:   list of their distinct common substrings. Return NULL if something
../inputs/grep1.dat:8801:259406:   seems wild. */
../inputs/grep1.dat:8802:259424:static char **
../inputs/grep1.dat:8803:259439:comsubs(left, right)
../inputs/grep1.dat:8804:259460:     char *left;
../inputs/grep1.dat:8805:259477:     char *right;
../inputs/grep1.dat:8806:259495:{
../inputs/grep1.dat:8807:259497:  char **cpp;
../inputs/grep1.dat:8808:259511:  char *lcp;
../inputs/grep1.dat:8809:259524:  char *rcp;
../inputs/grep1.dat:8810:259537:  int i, len;
../inputs/grep1.dat:8811:259551:
../inputs/grep1.dat:8812:259552:  if (left == NULL || right == NULL)
../inputs/grep1.dat:8813:259589:    return NULL;
../inputs/grep1.dat:8814:259606:  cpp = (char **) malloc(sizeof *cpp);
../inputs/grep1.dat:8815:259645:  if (cpp == NULL)
../inputs/grep1.dat:8816:259664:    return NULL;
../inputs/grep1.dat:8817:259681:  cpp[0] = NULL;
../inputs/grep1.dat:8818:259698:  for (lcp = left; *lcp != '\0'; ++lcp)
../inputs/grep1.dat:8819:259738:    {
../inputs/grep1.dat:8820:259744:      len = 0;
../inputs/grep1.dat:8821:259759:      rcp = index(right, *lcp);
../inputs/grep1.dat:8822:259791:      while (rcp != NULL)
../inputs/grep1.dat:8823:259817:	{
../inputs/grep1.dat:8824:259820:	  for (i = 1; lcp[i] != '\0' && lcp[i] == rcp[i]; ++i)
../inputs/grep1.dat:8825:259876:	    ;
../inputs/grep1.dat:8826:259883:	  if (i > len)
../inputs/grep1.dat:8827:259899:	    len = i;
../inputs/grep1.dat:8828:259913:	  rcp = index(rcp + 1, *lcp);
../inputs/grep1.dat:8829:259944:	}
../inputs/grep1.dat:8830:259947:      if (len == 0)
../inputs/grep1.dat:8831:259967:	continue;
../inputs/grep1.dat:8832:259978:      if ((cpp = enlist(cpp, lcp, len)) == NULL)
../inputs/grep1.dat:8833:260027:	break;
../inputs/grep1.dat:8834:260035:    }
../inputs/grep1.dat:8835:260041:  return cpp;
../inputs/grep1.dat:8836:260055:}
../inputs/grep1.dat:8837:260057:
../inputs/grep1.dat:8838:260058:static char **
../inputs/grep1.dat:8839:260073:addlists(old, new)
../inputs/grep1.dat:8840:260092:char **old;
../inputs/grep1.dat:8841:260104:char **new;
../inputs/grep1.dat:8842:260116:{
../inputs/grep1.dat:8843:260118:  int i;
../inputs/grep1.dat:8844:260127:
../inputs/grep1.dat:8845:260128:  if (old == NULL || new == NULL)
../inputs/grep1.dat:8846:260162:    return NULL;
../inputs/grep1.dat:8847:260179:  for (i = 0; new[i] != NULL; ++i)
../inputs/grep1.dat:8848:260214:    {
../inputs/grep1.dat:8849:260220:      old = enlist(old, new[i], strlen(new[i]));
../inputs/grep1.dat:8850:260269:      if (old == NULL)
../inputs/grep1.dat:8851:260292:	break;
../inputs/grep1.dat:8852:260300:    }
../inputs/grep1.dat:8853:260306:  return old;
../inputs/grep1.dat:8854:260320:}
../inputs/grep1.dat:8855:260322:
../inputs/grep1.dat:8856:260323:/* Given two lists of substrings, return a new list giving substrings
../inputs/grep1.dat:8857:260393:   common to both. */
../inputs/grep1.dat:8858:260415:static char **
../inputs/grep1.dat:8859:260430:inboth(left, right)
../inputs/grep1.dat:8860:260450:     char **left;
../inputs/grep1.dat:8861:260468:     char **right;
../inputs/grep1.dat:8862:260487:{
../inputs/grep1.dat:8863:260489:  char **both;
../inputs/grep1.dat:8864:260504:  char **temp;
../inputs/grep1.dat:8865:260519:  int lnum, rnum;
../inputs/grep1.dat:8866:260537:
../inputs/grep1.dat:8867:260538:  if (left == NULL || right == NULL)
../inputs/grep1.dat:8868:260575:    return NULL;
../inputs/grep1.dat:8869:260592:  both = (char **) malloc(sizeof *both);
../inputs/grep1.dat:8870:260633:  if (both == NULL)
../inputs/grep1.dat:8871:260653:    return NULL;
../inputs/grep1.dat:8872:260670:  both[0] = NULL;
../inputs/grep1.dat:8873:260688:  for (lnum = 0; left[lnum] != NULL; ++lnum)
../inputs/grep1.dat:8874:260733:    {
../inputs/grep1.dat:8875:260739:      for (rnum = 0; right[rnum] != NULL; ++rnum)
../inputs/grep1.dat:8876:260789:	{
../inputs/grep1.dat:8877:260792:	  temp = comsubs(left[lnum], right[rnum]);
../inputs/grep1.dat:8878:260836:	  if (temp == NULL)
../inputs/grep1.dat:8879:260857:	    {
../inputs/grep1.dat:8880:260864:	      freelist(both);
../inputs/grep1.dat:8881:260887:	      return NULL;
../inputs/grep1.dat:8882:260907:	    }
../inputs/grep1.dat:8883:260914:	  both = addlists(both, temp);
../inputs/grep1.dat:8884:260946:	  freelist(temp);
../inputs/grep1.dat:8885:260965:	  if (both == NULL)
../inputs/grep1.dat:8886:260986:	    return NULL;
../inputs/grep1.dat:8887:261004:	}
../inputs/grep1.dat:8888:261007:    }
../inputs/grep1.dat:8889:261013:  return both;
../inputs/grep1.dat:8890:261028:}
../inputs/grep1.dat:8891:261030:
../inputs/grep1.dat:8892:261031:typedef struct
../inputs/grep1.dat:8893:261046:{
../inputs/grep1.dat:8894:261048:  char **in;
../inputs/grep1.dat:8895:261061:  char *left;
../inputs/grep1.dat:8896:261075:  char *right;
../inputs/grep1.dat:8897:261090:  char *is;
../inputs/grep1.dat:8898:261102:} must;
../inputs/grep1.dat:8899:261110:
../inputs/grep1.dat:8900:261111:static void
../inputs/grep1.dat:8901:261123:resetmust(mp)
../inputs/grep1.dat:8902:261137:must *mp;
../inputs/grep1.dat:8903:261147:{
../inputs/grep1.dat:8904:261149:  mp->left[0] = mp->right[0] = mp->is[0] = '\0';
../inputs/grep1.dat:8905:261198:  freelist(mp->in);
../inputs/grep1.dat:8906:261218:}
../inputs/grep1.dat:8907:261220:
../inputs/grep1.dat:8908:261221:static void
../inputs/grep1.dat:8909:261233:dfamust(dfa)
../inputs/grep1.dat:8910:261246:struct dfa *dfa;
../inputs/grep1.dat:8911:261263:{
../inputs/grep1.dat:8912:261265:  must *musts;
../inputs/grep1.dat:8913:261280:  must *mp;
../inputs/grep1.dat:8914:261292:  char *result;
../inputs/grep1.dat:8915:261308:  int ri;
../inputs/grep1.dat:8916:261318:  int i;
../inputs/grep1.dat:8917:261327:  int exact;
../inputs/grep1.dat:8918:261340:  token t;
../inputs/grep1.dat:8919:261351:  static must must0;
../inputs/grep1.dat:8920:261372:  struct dfamust *dm;
../inputs/grep1.dat:8921:261394:
../inputs/grep1.dat:8922:261395:  result = "";
../inputs/grep1.dat:8923:261410:  exact = 0;
../inputs/grep1.dat:8924:261423:  musts = (must *) malloc((dfa->tindex + 1) * sizeof *musts);
../inputs/grep1.dat:8925:261485:  if (musts == NULL)
../inputs/grep1.dat:8926:261506:    return;
../inputs/grep1.dat:8927:261518:  mp = musts;
../inputs/grep1.dat:8928:261532:  for (i = 0; i <= dfa->tindex; ++i)
../inputs/grep1.dat:8929:261569:    mp[i] = must0;
../inputs/grep1.dat:8930:261588:  for (i = 0; i <= dfa->tindex; ++i)
../inputs/grep1.dat:8931:261625:    {
../inputs/grep1.dat:8932:261631:      mp[i].in = (char **) malloc(sizeof *mp[i].in);
../inputs/grep1.dat:8933:261684:      mp[i].left = malloc(2);
../inputs/grep1.dat:8934:261714:      mp[i].right = malloc(2);
../inputs/grep1.dat:8935:261745:      mp[i].is = malloc(2);
../inputs/grep1.dat:8936:261773:      if (mp[i].in == NULL || mp[i].left == NULL ||
../inputs/grep1.dat:8937:261825:	  mp[i].right == NULL || mp[i].is == NULL)
../inputs/grep1.dat:8938:261869:	goto done;
../inputs/grep1.dat:8939:261881:      mp[i].left[0] = mp[i].right[0] = mp[i].is[0] = '\0';
../inputs/grep1.dat:8940:261940:      mp[i].in[0] = NULL;
../inputs/grep1.dat:8941:261966:    }
../inputs/grep1.dat:8942:261972:#ifdef DEBUG
../inputs/grep1.dat:8943:261985:  fprintf(stderr, "dfamust:\n");
../inputs/grep1.dat:8944:262018:  for (i = 0; i < dfa->tindex; ++i)
../inputs/grep1.dat:8945:262054:    {
../inputs/grep1.dat:8946:262060:      fprintf(stderr, " %d:", i);
../inputs/grep1.dat:8947:262094:      prtok(dfa->tokens[i]);
../inputs/grep1.dat:8948:262123:    }
../inputs/grep1.dat:8949:262129:  putc('\n', stderr);
../inputs/grep1.dat:8950:262151:#endif
../inputs/grep1.dat:8951:262158:  for (ri = 0; ri < dfa->tindex; ++ri)
../inputs/grep1.dat:8952:262197:    {
../inputs/grep1.dat:8953:262203:      switch (t = dfa->tokens[ri])
../inputs/grep1.dat:8954:262238:	{
../inputs/grep1.dat:8955:262241:	case LPAREN:
../inputs/grep1.dat:8956:262255:	case RPAREN:
../inputs/grep1.dat:8957:262269:	  goto done;		/* "cannot happen" */
../inputs/grep1.dat:8958:262306:	case EMPTY:
../inputs/grep1.dat:8959:262319:	case BEGLINE:
../inputs/grep1.dat:8960:262334:	case ENDLINE:
../inputs/grep1.dat:8961:262349:	case BEGWORD:
../inputs/grep1.dat:8962:262364:	case ENDWORD:
../inputs/grep1.dat:8963:262379:	case LIMWORD:
../inputs/grep1.dat:8964:262394:	case NOTLIMWORD:
../inputs/grep1.dat:8965:262412:	case BACKREF:
../inputs/grep1.dat:8966:262427:	  resetmust(mp);
../inputs/grep1.dat:8967:262445:	  break;
../inputs/grep1.dat:8968:262455:	case STAR:
../inputs/grep1.dat:8969:262467:	case QMARK:
../inputs/grep1.dat:8970:262480:	  if (mp <= musts)
../inputs/grep1.dat:8971:262500:	    goto done;		/* "cannot happen" */
../inputs/grep1.dat:8972:262539:	  --mp;
../inputs/grep1.dat:8973:262548:	  resetmust(mp);
../inputs/grep1.dat:8974:262566:	  break;
../inputs/grep1.dat:8975:262576:	case OR:
../inputs/grep1.dat:8976:262586:	case ORTOP:
../inputs/grep1.dat:8977:262599:	  if (mp < &musts[2])
../inputs/grep1.dat:8978:262622:	    goto done;		/* "cannot happen" */
../inputs/grep1.dat:8979:262661:	  {
../inputs/grep1.dat:8980:262666:	    char **new;
../inputs/grep1.dat:8981:262683:	    must *lmp;
../inputs/grep1.dat:8982:262699:	    must *rmp;
../inputs/grep1.dat:8983:262715:	    int j, ln, rn, n;
../inputs/grep1.dat:8984:262738:
../inputs/grep1.dat:8985:262739:	    rmp = --mp;
../inputs/grep1.dat:8986:262756:	    lmp = --mp;
../inputs/grep1.dat:8987:262773:	    /* Guaranteed to be.  Unlikely, but. . . */
../inputs/grep1.dat:8988:262822:	    if (strcmp(lmp->is, rmp->is) != 0)
../inputs/grep1.dat:8989:262862:	      lmp->is[0] = '\0';
../inputs/grep1.dat:8990:262888:	    /* Left side--easy */
../inputs/grep1.dat:8991:262915:	    i = 0;
../inputs/grep1.dat:8992:262927:	    while (lmp->left[i] != '\0' && lmp->left[i] == rmp->left[i])
../inputs/grep1.dat:8993:262993:	      ++i;
../inputs/grep1.dat:8994:263005:	    lmp->left[i] = '\0';
../inputs/grep1.dat:8995:263031:	    /* Right side */
../inputs/grep1.dat:8996:263053:	    ln = strlen(lmp->right);
../inputs/grep1.dat:8997:263083:	    rn = strlen(rmp->right);
../inputs/grep1.dat:8998:263113:	    n = ln;
../inputs/grep1.dat:8999:263126:	    if (n > rn)
../inputs/grep1.dat:9000:263143:	      n = rn;
../inputs/grep1.dat:9001:263158:	    for (i = 0; i < n; ++i)
../inputs/grep1.dat:9002:263187:	      if (lmp->right[ln - i - 1] != rmp->right[rn - i - 1])
../inputs/grep1.dat:9003:263248:		break;
../inputs/grep1.dat:9004:263257:	    for (j = 0; j < i; ++j)
../inputs/grep1.dat:9005:263286:	      lmp->right[j] = lmp->right[(ln - i) + j];
../inputs/grep1.dat:9006:263335:	    lmp->right[j] = '\0';
../inputs/grep1.dat:9007:263362:	    new = inboth(lmp->in, rmp->in);
../inputs/grep1.dat:9008:263399:	    if (new == NULL)
../inputs/grep1.dat:9009:263421:	      goto done;
../inputs/grep1.dat:9010:263439:	    freelist(lmp->in);
../inputs/grep1.dat:9011:263463:	    free((char *) lmp->in);
../inputs/grep1.dat:9012:263492:	    lmp->in = new;
../inputs/grep1.dat:9013:263512:	  }
../inputs/grep1.dat:9014:263517:	  break;
../inputs/grep1.dat:9015:263527:	case PLUS:
../inputs/grep1.dat:9016:263539:	  if (mp <= musts)
../inputs/grep1.dat:9017:263559:	    goto done;		/* "cannot happen" */
../inputs/grep1.dat:9018:263598:	  --mp;
../inputs/grep1.dat:9019:263607:	  mp->is[0] = '\0';
../inputs/grep1.dat:9020:263628:	  break;
../inputs/grep1.dat:9021:263638:	case END:
../inputs/grep1.dat:9022:263649:	  if (mp != &musts[1])
../inputs/grep1.dat:9023:263673:	    goto done;		/* "cannot happen" */
../inputs/grep1.dat:9024:263712:	  for (i = 0; musts[0].in[i] != NULL; ++i)
../inputs/grep1.dat:9025:263756:	    if (strlen(musts[0].in[i]) > strlen(result))
../inputs/grep1.dat:9026:263806:	      result = musts[0].in[i];
../inputs/grep1.dat:9027:263838:	  if (strcmp(result, musts[0].is) == 0)
../inputs/grep1.dat:9028:263879:	    exact = 1;
../inputs/grep1.dat:9029:263895:	  goto done;
../inputs/grep1.dat:9030:263909:	case CAT:
../inputs/grep1.dat:9031:263920:	  if (mp < &musts[2])
../inputs/grep1.dat:9032:263943:	    goto done;		/* "cannot happen" */
../inputs/grep1.dat:9033:263982:	  {
../inputs/grep1.dat:9034:263987:	    must *lmp;
../inputs/grep1.dat:9035:264003:	    must *rmp;
../inputs/grep1.dat:9036:264019:
../inputs/grep1.dat:9037:264020:	    rmp = --mp;
../inputs/grep1.dat:9038:264037:	    lmp = --mp;
../inputs/grep1.dat:9039:264054:	    /* In.  Everything in left, plus everything in
../inputs/grep1.dat:9040:264106:	       right, plus catenation of
../inputs/grep1.dat:9041:264140:	       left's right and right's left. */
../inputs/grep1.dat:9042:264182:	    lmp->in = addlists(lmp->in, rmp->in);
../inputs/grep1.dat:9043:264225:	    if (lmp->in == NULL)
../inputs/grep1.dat:9044:264251:	      goto done;
../inputs/grep1.dat:9045:264269:	    if (lmp->right[0] != '\0' &&
../inputs/grep1.dat:9046:264303:		rmp->left[0] != '\0')
../inputs/grep1.dat:9047:264327:	      {
../inputs/grep1.dat:9048:264336:		char *tp;
../inputs/grep1.dat:9049:264348:
../inputs/grep1.dat:9050:264349:		tp = icpyalloc(lmp->right);
../inputs/grep1.dat:9051:264379:		if (tp == NULL)
../inputs/grep1.dat:9052:264397:		  goto done;
../inputs/grep1.dat:9053:264412:		tp = icatalloc(tp, rmp->left);
../inputs/grep1.dat:9054:264445:		if (tp == NULL)
../inputs/grep1.dat:9055:264463:		  goto done;
../inputs/grep1.dat:9056:264478:		lmp->in = enlist(lmp->in, tp,
../inputs/grep1.dat:9057:264510:				 strlen(tp));
../inputs/grep1.dat:9058:264528:		free(tp);
../inputs/grep1.dat:9059:264540:		if (lmp->in == NULL)
../inputs/grep1.dat:9060:264563:		  goto done;
../inputs/grep1.dat:9061:264578:	      }
../inputs/grep1.dat:9062:264587:	    /* Left-hand */
../inputs/grep1.dat:9063:264608:	    if (lmp->is[0] != '\0')
../inputs/grep1.dat:9064:264637:	      {
../inputs/grep1.dat:9065:264646:		lmp->left = icatalloc(lmp->left,
../inputs/grep1.dat:9066:264681:				      rmp->left);
../inputs/grep1.dat:9067:264703:		if (lmp->left == NULL)
../inputs/grep1.dat:9068:264728:		  goto done;
../inputs/grep1.dat:9069:264743:	      }
../inputs/grep1.dat:9070:264752:	    /* Right-hand */
../inputs/grep1.dat:9071:264774:	    if (rmp->is[0] == '\0')
../inputs/grep1.dat:9072:264803:	      lmp->right[0] = '\0';
../inputs/grep1.dat:9073:264832:	    lmp->right = icatalloc(lmp->right, rmp->right);
../inputs/grep1.dat:9074:264885:	    if (lmp->right == NULL)
../inputs/grep1.dat:9075:264914:	      goto done;
../inputs/grep1.dat:9076:264932:	    /* Guaranteed to be */
../inputs/grep1.dat:9077:264960:	    if (lmp->is[0] != '\0' && rmp->is[0] != '\0')
../inputs/grep1.dat:9078:265011:	      {
../inputs/grep1.dat:9079:265020:		lmp->is = icatalloc(lmp->is, rmp->is);
../inputs/grep1.dat:9080:265061:		if (lmp->is == NULL)
../inputs/grep1.dat:9081:265084:		  goto done;
../inputs/grep1.dat:9082:265099:	      }
../inputs/grep1.dat:9083:265108:	    else
../inputs/grep1.dat:9084:265118:	      lmp->is[0] = '\0';
../inputs/grep1.dat:9085:265144:	  }
../inputs/grep1.dat:9086:265149:	  break;
../inputs/grep1.dat:9087:265159:	default:
../inputs/grep1.dat:9088:265169:	  if (t < END)
../inputs/grep1.dat:9089:265185:	    {
../inputs/grep1.dat:9090:265192:	      /* "cannot happen" */
../inputs/grep1.dat:9091:265221:	      goto done;
../inputs/grep1.dat:9092:265239:	    }
../inputs/grep1.dat:9093:265246:	  else if (t == '\0')
../inputs/grep1.dat:9094:265269:	    {
../inputs/grep1.dat:9095:265276:	      /* not on *my* shift */
../inputs/grep1.dat:9096:265307:	      goto done;
../inputs/grep1.dat:9097:265325:	    }
../inputs/grep1.dat:9098:265332:	  else if (t >= CSET)
../inputs/grep1.dat:9099:265355:	    {
../inputs/grep1.dat:9100:265362:	      /* easy enough */
../inputs/grep1.dat:9101:265387:	      resetmust(mp);
../inputs/grep1.dat:9102:265409:	    }
../inputs/grep1.dat:9103:265416:	  else
../inputs/grep1.dat:9104:265424:	    {
../inputs/grep1.dat:9105:265431:	      /* plain character */
../inputs/grep1.dat:9106:265460:	      resetmust(mp);
../inputs/grep1.dat:9107:265482:	      mp->is[0] = mp->left[0] = mp->right[0] = t;
../inputs/grep1.dat:9108:265533:	      mp->is[1] = mp->left[1] = mp->right[1] = '\0';
../inputs/grep1.dat:9109:265587:	      mp->in = enlist(mp->in, mp->is, 1);
../inputs/grep1.dat:9110:265630:	      if (mp->in == NULL)
../inputs/grep1.dat:9111:265657:		goto done;
../inputs/grep1.dat:9112:265670:	    }
../inputs/grep1.dat:9113:265677:	  break;
../inputs/grep1.dat:9114:265687:	}
../inputs/grep1.dat:9115:265690:#ifdef DEBUG
../inputs/grep1.dat:9116:265703:      fprintf(stderr, " node: %d:", ri);
../inputs/grep1.dat:9117:265744:      prtok(dfa->tokens[ri]);
../inputs/grep1.dat:9118:265774:      fprintf(stderr, "\n  in:");
../inputs/grep1.dat:9119:265808:      for (i = 0; mp->in[i]; ++i)
../inputs/grep1.dat:9120:265842:	fprintf(stderr, " \"%s\"", mp->in[i]);
../inputs/grep1.dat:9121:265882:      fprintf(stderr, "\n  is: \"%s\"\n", mp->is);
../inputs/grep1.dat:9122:265933:      fprintf(stderr, "  left: \"%s\"\n", mp->left);
../inputs/grep1.dat:9123:265986:      fprintf(stderr, "  right: \"%s\"\n", mp->right);
../inputs/grep1.dat:9124:266041:#endif
../inputs/grep1.dat:9125:266048:      ++mp;
../inputs/grep1.dat:9126:266060:    }
../inputs/grep1.dat:9127:266066: done:
../inputs/grep1.dat:9128:266073:  if (strlen(result))
../inputs/grep1.dat:9129:266095:    {
../inputs/grep1.dat:9130:266101:      dm = (struct dfamust *) malloc(sizeof (struct dfamust));
../inputs/grep1.dat:9131:266164:      dm->exact = exact;
../inputs/grep1.dat:9132:266189:      dm->must = malloc(strlen(result) + 1);
../inputs/grep1.dat:9133:266234:      strcpy(dm->must, result);
../inputs/grep1.dat:9134:266266:      dm->next = dfa->musts;
../inputs/grep1.dat:9135:266295:      dfa->musts = dm;
../inputs/grep1.dat:9136:266318:    }
../inputs/grep1.dat:9137:266324:  mp = musts;
../inputs/grep1.dat:9138:266338:  for (i = 0; i <= dfa->tindex; ++i)
../inputs/grep1.dat:9139:266375:    {
../inputs/grep1.dat:9140:266381:      freelist(mp[i].in);
../inputs/grep1.dat:9141:266407:      ifree((char *) mp[i].in);
../inputs/grep1.dat:9142:266439:      ifree(mp[i].left);
../inputs/grep1.dat:9143:266464:      ifree(mp[i].right);
../inputs/grep1.dat:9144:266490:      ifree(mp[i].is);
../inputs/grep1.dat:9145:266513:    }
../inputs/grep1.dat:9146:266519:  free((char *) mp);
../inputs/grep1.dat:9147:266540:}
../inputs/grep1.dat:9148:266542:/* kwset.c - search for any of a set of keywords.
../inputs/grep1.dat:9149:266592:   Copyright 1989 Free Software Foundation
../inputs/grep1.dat:9150:266635:		  Written August 1989 by Mike Haertel.
../inputs/grep1.dat:9151:266676:
../inputs/grep1.dat:9152:266677:   This program is free software; you can redistribute it and/or modify
../inputs/grep1.dat:9153:266749:   it under the terms of the GNU General Public License as published by
../inputs/grep1.dat:9154:266821:   the Free Software Foundation; either version 1, or (at your option)
../inputs/grep1.dat:9155:266892:   any later version.
../inputs/grep1.dat:9156:266914:
../inputs/grep1.dat:9157:266915:   This program is distributed in the hope that it will be useful,
../inputs/grep1.dat:9158:266982:   but WITHOUT ANY WARRANTY; without even the implied warranty of
../inputs/grep1.dat:9159:267048:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
../inputs/grep1.dat:9160:267113:   GNU General Public License for more details.
../inputs/grep1.dat:9161:267161:
../inputs/grep1.dat:9162:267162:   You should have received a copy of the GNU General Public License
../inputs/grep1.dat:9163:267231:   along with this program; if not, write to the Free Software
../inputs/grep1.dat:9164:267294:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
../inputs/grep1.dat:9165:267355:
../inputs/grep1.dat:9166:267356:   The author may be reached (Email) at the address mike@ai.mit.edu,
../inputs/grep1.dat:9167:267425:   or (US mail) as Mike Haertel c/o Free Software Foundation. */
../inputs/grep1.dat:9168:267490:
../inputs/grep1.dat:9169:267491:/* The algorithm implemented by these routines bears a startling resemblence
../inputs/grep1.dat:9170:267568:   to one discovered by Beate Commentz-Walter, although it is not identical.
../inputs/grep1.dat:9171:267645:   See "A String Matching Algorithm Fast on the Average," Technical Report,
../inputs/grep1.dat:9172:267721:   IBM-Germany, Scientific Center Heidelberg, Tiergartenstrasse 15, D-6900
../inputs/grep1.dat:9173:267796:   Heidelberg, Germany.  See also Aho, A.V., and M. Corasick, "Efficient
../inputs/grep1.dat:9174:267869:   String Matching:  An Aid to Bibliographic Search," CACM June 1975,
../inputs/grep1.dat:9175:267939:   Vol. 18, No. 6, which describes the failure function used below. */
../inputs/grep1.dat:9176:268010:
../inputs/grep1.dat:9177:268011:
../inputs/grep1.dat:9178:268012:#ifdef STDC_HEADERS
../inputs/grep1.dat:9179:268032:#undef RE_DUP_MAX
../inputs/grep1.dat:9181:268070:#define flag_limits 1
../inputs/grep1.dat:9182:268092:#if flag_stdlib==0 
../inputs/grep1.dat:9184:268132:#define flag_stdlib 1
../inputs/grep1.dat:9185:268154:#endif
../inputs/grep1.dat:9186:268161:#else
../inputs/grep1.dat:9187:268167:#define INT_MAX 2147483647
../inputs/grep1.dat:9188:268194:#define UCHAR_MAX 255
../inputs/grep1.dat:9189:268216:#ifdef __STDC__
../inputs/grep1.dat:9191:268252:#else
../inputs/grep1.dat:9192:268258:#if flag_systypes==0
../inputs/grep1.dat:9194:268302:#define flag_systypes 1
../inputs/grep1.dat:9195:268326:#endif
../inputs/grep1.dat:9196:268333:#endif
../inputs/grep1.dat:9197:268340:extern char *malloc();
../inputs/grep1.dat:9198:268363:extern void free();
../inputs/grep1.dat:9199:268383:#endif
../inputs/grep1.dat:9200:268390:
../inputs/grep1.dat:9201:268391:#ifdef HAVE_MEMCHR
../inputs/grep1.dat:9202:268410:#if flag_string==0
../inputs/grep1.dat:9204:268449:#define flag_string 1
../inputs/grep1.dat:9205:268471:#endif
../inputs/grep1.dat:9206:268478:#ifdef NEED_MEMORY_H
../inputs/grep1.dat:9207:268499:#if flag_memory==0
../inputs/grep1.dat:9209:268538:#define flag_memory 1
../inputs/grep1.dat:9210:268560:#endif
../inputs/grep1.dat:9211:268567:#endif
../inputs/grep1.dat:9212:268574:#else
../inputs/grep1.dat:9213:268580:#ifdef __STDC__
../inputs/grep1.dat:9214:268596:extern void *memchr();
../inputs/grep1.dat:9215:268619:#else
../inputs/grep1.dat:9216:268625:extern char *memchr();
../inputs/grep1.dat:9217:268648:#endif
../inputs/grep1.dat:9218:268655:#endif
../inputs/grep1.dat:9219:268662:
../inputs/grep1.dat:9220:268663:#ifdef GREP
../inputs/grep1.dat:9221:268675:extern char *xmalloc();
../inputs/grep1.dat:9222:268699:#define malloc xmalloc
../inputs/grep1.dat:9223:268722:#endif
../inputs/grep1.dat:9224:268729:
../inputs/grep1.dat:9227:268770:
../inputs/grep1.dat:9228:268771:#define NCHAR (UCHAR_MAX + 1)
../inputs/grep1.dat:9229:268801:#define obstack_chunk_alloc malloc
../inputs/grep1.dat:9230:268836:#define obstack_chunk_free free
../inputs/grep1.dat:9231:268868:
../inputs/grep1.dat:9232:268869:/* Balanced tree of edges and labels leaving a given trie node. */
../inputs/grep1.dat:9233:268936:struct tree
../inputs/grep1.dat:9234:268948:{
../inputs/grep1.dat:9235:268950:  struct tree *llink;		/* Left link; MUST be first field. */
../inputs/grep1.dat:9236:269011:  struct tree *rlink;		/* Right link (to larger labels). */
../inputs/grep1.dat:9237:269071:  struct trie *trie;		/* Trie node pointed to by this edge. */
../inputs/grep1.dat:9238:269134:  unsigned char label;		/* Label on this edge. */
../inputs/grep1.dat:9239:269184:  char balance;			/* Difference in depths of subtrees. */
../inputs/grep1.dat:9240:269242:};
../inputs/grep1.dat:9241:269245:
../inputs/grep1.dat:9242:269246:/* Node of a trie representing a set of reversed keywords. */
../inputs/grep1.dat:9243:269308:struct trie
../inputs/grep1.dat:9244:269320:{
../inputs/grep1.dat:9245:269322:  unsigned int accepting;	/* Word index of accepted word, or zero. */
../inputs/grep1.dat:9246:269392:  struct tree *links;		/* Tree of edges leaving this node. */
../inputs/grep1.dat:9247:269454:  struct trie *parent;		/* Parent of this node. */
../inputs/grep1.dat:9248:269505:  struct trie *next;		/* List of all trie nodes in level order. */
../inputs/grep1.dat:9249:269572:  struct trie *fail;		/* Aho-Corasick failure function. */
../inputs/grep1.dat:9250:269631:  int depth;			/* Depth of this node from the root. */
../inputs/grep1.dat:9251:269686:  int shift;			/* Shift function for search failures. */
../inputs/grep1.dat:9252:269743:  int maxshift;			/* Max shift of self and descendents. */
../inputs/grep1.dat:9253:269802:};
../inputs/grep1.dat:9254:269805:
../inputs/grep1.dat:9255:269806:/* Structure returned opaquely to the caller, containing everything. */
../inputs/grep1.dat:9256:269878:struct kwset
../inputs/grep1.dat:9257:269891:{
../inputs/grep1.dat:9258:269893:  struct obstack obstack;	/* Obstack for node allocation. */
../inputs/grep1.dat:9259:269954:  int words;			/* Number of words in the trie. */
../inputs/grep1.dat:9260:270004:  struct trie *trie;		/* The trie itself. */
../inputs/grep1.dat:9261:270049:  int mind;			/* Minimum depth of an accepting node. */
../inputs/grep1.dat:9262:270105:  int maxd;			/* Maximum depth of any node. */
../inputs/grep1.dat:9263:270152:  unsigned char delta[NCHAR];	/* Delta table for rapid search. */
../inputs/grep1.dat:9264:270218:  struct trie *next[NCHAR];	/* Table of children of the root. */
../inputs/grep1.dat:9265:270283:  char *target;			/* Target string if there's only one. */
../inputs/grep1.dat:9266:270342:  int mind2;			/* Used in Boyer-Moore search for one string. */
../inputs/grep1.dat:9267:270406:  char *trans;			/* Character translation table. */
../inputs/grep1.dat:9268:270458:};
../inputs/grep1.dat:9269:270461:
../inputs/grep1.dat:9270:270462:/* Allocate and initialize a keyword set object, returning an opaque
../inputs/grep1.dat:9271:270531:   pointer to it.  Return NULL if memory is not available. */
../inputs/grep1.dat:9272:270593:kwset_t
../inputs/grep1.dat:9273:270601:kwsalloc(trans)
../inputs/grep1.dat:9274:270617:     char *trans;
../inputs/grep1.dat:9275:270635:{
../inputs/grep1.dat:9276:270637:  struct kwset *kwset;
../inputs/grep1.dat:9277:270660:
../inputs/grep1.dat:9278:270661:  kwset = (struct kwset *) malloc(sizeof (struct kwset));
../inputs/grep1.dat:9279:270719:  if (!kwset)
../inputs/grep1.dat:9280:270733:    return 0;
../inputs/grep1.dat:9281:270747:
../inputs/grep1.dat:9282:270748:  obstack_init(&kwset->obstack);
../inputs/grep1.dat:9283:270781:  kwset->words = 0;
../inputs/grep1.dat:9284:270801:  kwset->trie
../inputs/grep1.dat:9285:270815:    = (struct trie *) obstack_alloc(&kwset->obstack, sizeof (struct trie));
../inputs/grep1.dat:9286:270891:  if (!kwset->trie)
../inputs/grep1.dat:9287:270911:    {
../inputs/grep1.dat:9288:270917:      kwsfree((kwset_t) kwset);
../inputs/grep1.dat:9289:270949:      return 0;
../inputs/grep1.dat:9290:270965:    }
../inputs/grep1.dat:9291:270971:  kwset->trie->accepting = 0;
../inputs/grep1.dat:9292:271001:  kwset->trie->links = 0;
../inputs/grep1.dat:9293:271027:  kwset->trie->parent = 0;
../inputs/grep1.dat:9294:271054:  kwset->trie->next = 0;
../inputs/grep1.dat:9295:271079:  kwset->trie->fail = 0;
../inputs/grep1.dat:9296:271104:  kwset->trie->depth = 0;
../inputs/grep1.dat:9297:271130:  kwset->trie->shift = 0;
../inputs/grep1.dat:9298:271156:  kwset->mind = INT_MAX;
../inputs/grep1.dat:9299:271181:  kwset->maxd = -1;
../inputs/grep1.dat:9300:271201:  kwset->target = 0;
../inputs/grep1.dat:9301:271222:  kwset->trans = trans;
../inputs/grep1.dat:9302:271246:
../inputs/grep1.dat:9303:271247:  return (kwset_t) kwset;
../inputs/grep1.dat:9304:271273:}
../inputs/grep1.dat:9305:271275:
../inputs/grep1.dat:9306:271276:/* Add the given string to the contents of the keyword set.  Return NULL
../inputs/grep1.dat:9307:271349:   for success, an error message otherwise. */
../inputs/grep1.dat:9308:271396:char *
../inputs/grep1.dat:9309:271403:kwsincr(kws, text, len)
../inputs/grep1.dat:9310:271427:     kwset_t kws;
../inputs/grep1.dat:9311:271445:     char *text;
../inputs/grep1.dat:9312:271462:     size_t len;
../inputs/grep1.dat:9313:271479:{
../inputs/grep1.dat:9314:271481:  struct kwset *kwset;
../inputs/grep1.dat:9315:271504:  register struct trie *trie;
../inputs/grep1.dat:9316:271534:  register unsigned char label;
../inputs/grep1.dat:9317:271566:  register struct tree *link;
../inputs/grep1.dat:9318:271596:  register int depth;
../inputs/grep1.dat:9319:271618:  struct tree *links[12];
../inputs/grep1.dat:9320:271644:  enum { L, R } dirs[12];
../inputs/grep1.dat:9321:271670:  struct tree *t, *r, *l, *rl, *lr;
../inputs/grep1.dat:9322:271706:
../inputs/grep1.dat:9323:271707:  kwset = (struct kwset *) kws;
../inputs/grep1.dat:9324:271739:  trie = kwset->trie;
../inputs/grep1.dat:9325:271761:  text += len;
../inputs/grep1.dat:9326:271776:
../inputs/grep1.dat:9327:271777:  /* Descend the trie (built of reversed keywords) character-by-character,
../inputs/grep1.dat:9328:271852:     installing new nodes when necessary. */
../inputs/grep1.dat:9329:271897:  while (len--)
../inputs/grep1.dat:9330:271913:    {
../inputs/grep1.dat:9331:271919:      label = kwset->trans ? kwset->trans[(unsigned char) *--text] : *--text;
../inputs/grep1.dat:9332:271997:
../inputs/grep1.dat:9333:271998:      /* Descend the tree of outgoing links for this trie node,
../inputs/grep1.dat:9334:272062:	 looking for the current character and keeping track
../inputs/grep1.dat:9335:272116:	 of the path followed. */
../inputs/grep1.dat:9336:272143:      link = trie->links;
../inputs/grep1.dat:9337:272169:      links[0] = (struct tree *) &trie->links;
../inputs/grep1.dat:9338:272216:      dirs[0] = L;
../inputs/grep1.dat:9339:272235:      depth = 1;
../inputs/grep1.dat:9340:272252:
../inputs/grep1.dat:9341:272253:      while (link && label != link->label)
../inputs/grep1.dat:9342:272296:	{
../inputs/grep1.dat:9343:272299:	  links[depth] = link;
../inputs/grep1.dat:9344:272323:	  if (label < link->label)
../inputs/grep1.dat:9345:272351:	    dirs[depth++] = L, link = link->llink;
../inputs/grep1.dat:9346:272395:	  else
../inputs/grep1.dat:9347:272403:	    dirs[depth++] = R, link = link->rlink;
../inputs/grep1.dat:9348:272447:	}
../inputs/grep1.dat:9349:272450:
../inputs/grep1.dat:9350:272451:      /* The current character doesn't have an outgoing link at
../inputs/grep1.dat:9351:272515:	 this trie node, so build a new trie node and install
../inputs/grep1.dat:9352:272570:	 a link in the current trie node's tree. */
../inputs/grep1.dat:9353:272615:      if (!link)
../inputs/grep1.dat:9354:272632:	{
../inputs/grep1.dat:9355:272635:	  link = (struct tree *) obstack_alloc(&kwset->obstack,
../inputs/grep1.dat:9356:272692:					       sizeof (struct tree));
../inputs/grep1.dat:9357:272727:	  if (!link)
../inputs/grep1.dat:9358:272741:	    return "memory exhausted";
../inputs/grep1.dat:9359:272773:	  link->llink = 0;
../inputs/grep1.dat:9360:272793:	  link->rlink = 0;
../inputs/grep1.dat:9361:272813:	  link->trie = (struct trie *) obstack_alloc(&kwset->obstack,
../inputs/grep1.dat:9362:272876:						     sizeof (struct trie));
../inputs/grep1.dat:9363:272910:	  if (!link->trie)
../inputs/grep1.dat:9364:272930:	    return "memory exhausted";
../inputs/grep1.dat:9365:272962:	  link->trie->accepting = 0;
../inputs/grep1.dat:9366:272992:	  link->trie->links = 0;
../inputs/grep1.dat:9367:273018:	  link->trie->parent = trie;
../inputs/grep1.dat:9368:273048:	  link->trie->next = 0;
../inputs/grep1.dat:9369:273073:	  link->trie->fail = 0;
../inputs/grep1.dat:9370:273098:	  link->trie->depth = trie->depth + 1;
../inputs/grep1.dat:9371:273138:	  link->trie->shift = 0;
../inputs/grep1.dat:9372:273164:	  link->label = label;
../inputs/grep1.dat:9373:273188:	  link->balance = 0;
../inputs/grep1.dat:9374:273210:
../inputs/grep1.dat:9375:273211:	  /* Install the new tree node in its parent. */
../inputs/grep1.dat:9376:273261:	  if (dirs[--depth] == L)
../inputs/grep1.dat:9377:273288:	    links[depth]->llink = link;
../inputs/grep1.dat:9378:273321:	  else
../inputs/grep1.dat:9379:273329:	    links[depth]->rlink = link;
../inputs/grep1.dat:9380:273362:
../inputs/grep1.dat:9381:273363:	  /* Back up the tree fixing the balance flags. */
../inputs/grep1.dat:9382:273415:	  while (depth && !links[depth]->balance)
../inputs/grep1.dat:9383:273458:	    {
../inputs/grep1.dat:9384:273465:	      if (dirs[depth] == L)
../inputs/grep1.dat:9385:273494:		--links[depth]->balance;
../inputs/grep1.dat:9386:273521:	      else
../inputs/grep1.dat:9387:273533:		++links[depth]->balance;
../inputs/grep1.dat:9388:273560:	      --depth;
../inputs/grep1.dat:9389:273576:	    }
../inputs/grep1.dat:9390:273583:
../inputs/grep1.dat:9391:273584:	  /* Rebalance the tree by pointer rotations if necessary. */
../inputs/grep1.dat:9392:273647:	  if (depth && ((dirs[depth] == L && --links[depth]->balance)
../inputs/grep1.dat:9393:273710:			|| (dirs[depth] == R && ++links[depth]->balance)))
../inputs/grep1.dat:9394:273764:	    {
../inputs/grep1.dat:9395:273771:	      switch (links[depth]->balance)
../inputs/grep1.dat:9396:273809:		{
../inputs/grep1.dat:9397:273813:		case (char) -2:
../inputs/grep1.dat:9398:273831:		  switch (dirs[depth + 1])
../inputs/grep1.dat:9399:273860:		    {
../inputs/grep1.dat:9400:273868:		    case L:
../inputs/grep1.dat:9401:273882:		      r = links[depth], t = r->llink, rl = t->rlink;
../inputs/grep1.dat:9402:273937:		      t->rlink = r, r->llink = rl;
../inputs/grep1.dat:9403:273974:		      t->balance = r->balance = 0;
../inputs/grep1.dat:9404:274011:		      break;
../inputs/grep1.dat:9405:274026:		    case R:
../inputs/grep1.dat:9406:274040:		      r = links[depth], l = r->llink, t = l->rlink;
../inputs/grep1.dat:9407:274094:		      rl = t->rlink, lr = t->llink;
../inputs/grep1.dat:9408:274132:		      t->llink = l, l->rlink = lr, t->rlink = r, r->llink = rl;
../inputs/grep1.dat:9409:274198:		      l->balance = t->balance != 1 ? 0 : -1;
../inputs/grep1.dat:9410:274245:		      r->balance = t->balance != (char) -1 ? 0 : 1;
../inputs/grep1.dat:9411:274299:		      t->balance = 0;
../inputs/grep1.dat:9412:274323:		      break;
../inputs/grep1.dat:9413:274338:		    }
../inputs/grep1.dat:9414:274346:		  break;
../inputs/grep1.dat:9415:274357:		case 2:
../inputs/grep1.dat:9416:274367:		  switch (dirs[depth + 1])
../inputs/grep1.dat:9417:274396:		    {
../inputs/grep1.dat:9418:274404:		    case R:
../inputs/grep1.dat:9419:274418:		      l = links[depth], t = l->rlink, lr = t->llink;
../inputs/grep1.dat:9420:274473:		      t->llink = l, l->rlink = lr;
../inputs/grep1.dat:9421:274510:		      t->balance = l->balance = 0;
../inputs/grep1.dat:9422:274547:		      break;
../inputs/grep1.dat:9423:274562:		    case L:
../inputs/grep1.dat:9424:274576:		      l = links[depth], r = l->rlink, t = r->llink;
../inputs/grep1.dat:9425:274630:		      lr = t->llink, rl = t->rlink;
../inputs/grep1.dat:9426:274668:		      t->llink = l, l->rlink = lr, t->rlink = r, r->llink = rl;
../inputs/grep1.dat:9427:274734:		      l->balance = t->balance != 1 ? 0 : -1;
../inputs/grep1.dat:9428:274781:		      r->balance = t->balance != (char) -1 ? 0 : 1;
../inputs/grep1.dat:9429:274835:		      t->balance = 0;
../inputs/grep1.dat:9430:274859:		      break;
../inputs/grep1.dat:9431:274874:		    }
../inputs/grep1.dat:9432:274882:		  break;
../inputs/grep1.dat:9433:274893:		}
../inputs/grep1.dat:9434:274897:
../inputs/grep1.dat:9435:274898:	      if (dirs[depth - 1] == L)
../inputs/grep1.dat:9436:274931:		links[depth - 1]->llink = t;
../inputs/grep1.dat:9437:274962:	      else
../inputs/grep1.dat:9438:274974:		links[depth - 1]->rlink = t;
../inputs/grep1.dat:9439:275005:	    }
../inputs/grep1.dat:9440:275012:	}
../inputs/grep1.dat:9441:275015:
../inputs/grep1.dat:9442:275016:      trie = link->trie;
../inputs/grep1.dat:9443:275041:    }
../inputs/grep1.dat:9444:275047:
../inputs/grep1.dat:9445:275048:  /* Mark the node we finally reached as accepting, encoding the
../inputs/grep1.dat:9446:275113:     index number of this word in the keyword set so far. */
../inputs/grep1.dat:9447:275174:  if (!trie->accepting)
../inputs/grep1.dat:9448:275198:    trie->accepting = 1 + 2 * kwset->words;
../inputs/grep1.dat:9449:275242:  ++kwset->words;
../inputs/grep1.dat:9450:275260:
../inputs/grep1.dat:9451:275261:  /* Keep track of the longest and shortest string of the keyword set. */
../inputs/grep1.dat:9452:275335:  if (trie->depth < kwset->mind)
../inputs/grep1.dat:9453:275368:    kwset->mind = trie->depth;
../inputs/grep1.dat:9454:275399:  if (trie->depth > kwset->maxd)
../inputs/grep1.dat:9455:275432:    kwset->maxd = trie->depth;
../inputs/grep1.dat:9456:275463:
../inputs/grep1.dat:9457:275464:  return 0;
../inputs/grep1.dat:9458:275476:}
../inputs/grep1.dat:9459:275478:
../inputs/grep1.dat:9460:275479:/* Enqueue the trie nodes referenced from the given tree in the
../inputs/grep1.dat:9461:275543:   given queue. */
../inputs/grep1.dat:9462:275562:static void
../inputs/grep1.dat:9463:275574:enqueue(tree, last)
../inputs/grep1.dat:9464:275594:     struct tree *tree;
../inputs/grep1.dat:9465:275618:     struct trie **last;
../inputs/grep1.dat:9466:275643:{
../inputs/grep1.dat:9467:275645:  if (!tree)
../inputs/grep1.dat:9468:275658:    return;
../inputs/grep1.dat:9469:275670:  enqueue(tree->llink, last);
../inputs/grep1.dat:9470:275700:  enqueue(tree->rlink, last);
../inputs/grep1.dat:9471:275730:  (*last) = (*last)->next = tree->trie;
../inputs/grep1.dat:9472:275770:}
../inputs/grep1.dat:9473:275772:
../inputs/grep1.dat:9474:275773:/* Compute the Aho-Corasick failure function for the trie nodes referenced
../inputs/grep1.dat:9475:275848:   from the given tree, given the failure function for their parent as
../inputs/grep1.dat:9476:275919:   well as a last resort failure node. */
../inputs/grep1.dat:9477:275961:static void
../inputs/grep1.dat:9478:275973:treefails(tree, fail, recourse)
../inputs/grep1.dat:9479:276005:     register struct tree *tree;
../inputs/grep1.dat:9480:276038:     struct trie *fail;
../inputs/grep1.dat:9481:276062:     struct trie *recourse;
../inputs/grep1.dat:9482:276090:{
../inputs/grep1.dat:9483:276092:  register struct tree *link;
../inputs/grep1.dat:9484:276122:
../inputs/grep1.dat:9485:276123:  if (!tree)
../inputs/grep1.dat:9486:276136:    return;
../inputs/grep1.dat:9487:276148:
../inputs/grep1.dat:9488:276149:  treefails(tree->llink, fail, recourse);
../inputs/grep1.dat:9489:276191:  treefails(tree->rlink, fail, recourse);
../inputs/grep1.dat:9490:276233:
../inputs/grep1.dat:9491:276234:  /* Find, in the chain of fails going back to the root, the first
../inputs/grep1.dat:9492:276301:     node that has a descendent on the current label. */
../inputs/grep1.dat:9493:276358:  while (fail)
../inputs/grep1.dat:9494:276373:    {
../inputs/grep1.dat:9495:276379:      link = fail->links;
../inputs/grep1.dat:9496:276405:      while (link && tree->label != link->label)
../inputs/grep1.dat:9497:276454:	if (tree->label < link->label)
../inputs/grep1.dat:9498:276486:	  link = link->llink;
../inputs/grep1.dat:9499:276509:	else
../inputs/grep1.dat:9500:276515:	  link = link->rlink;
../inputs/grep1.dat:9501:276538:      if (link)
../inputs/grep1.dat:9502:276554:	{
../inputs/grep1.dat:9503:276557:	  tree->trie->fail = link->trie;
../inputs/grep1.dat:9504:276591:	  return;
../inputs/grep1.dat:9505:276602:	}
../inputs/grep1.dat:9506:276605:      fail = fail->fail;
../inputs/grep1.dat:9507:276630:    }
../inputs/grep1.dat:9508:276636:
../inputs/grep1.dat:9509:276637:  tree->trie->fail = recourse;
../inputs/grep1.dat:9510:276668:}
../inputs/grep1.dat:9511:276670:
../inputs/grep1.dat:9512:276671:/* Set delta entries for the links of the given tree such that
../inputs/grep1.dat:9513:276734:   the preexisting delta value is larger than the current depth. */
../inputs/grep1.dat:9514:276802:static void
../inputs/grep1.dat:9515:276814:treedelta(tree, depth, delta)
../inputs/grep1.dat:9516:276844:     register struct tree *tree;
../inputs/grep1.dat:9517:276877:     register unsigned int depth;
../inputs/grep1.dat:9518:276911:     unsigned char delta[];
../inputs/grep1.dat:9519:276939:{
../inputs/grep1.dat:9520:276941:  if (!tree)
../inputs/grep1.dat:9521:276954:    return;
../inputs/grep1.dat:9522:276966:  treedelta(tree->llink, depth, delta);
../inputs/grep1.dat:9523:277006:  treedelta(tree->rlink, depth, delta);
../inputs/grep1.dat:9524:277046:  if (depth < delta[tree->label])
../inputs/grep1.dat:9525:277080:    delta[tree->label] = depth;
../inputs/grep1.dat:9526:277112:}
../inputs/grep1.dat:9527:277114:
../inputs/grep1.dat:9528:277115:/* Return true if A has every label in B. */
../inputs/grep1.dat:9529:277160:static int
../inputs/grep1.dat:9530:277171:hasevery(a, b)
../inputs/grep1.dat:9531:277186:     register struct tree *a;
../inputs/grep1.dat:9532:277216:     register struct tree *b;
../inputs/grep1.dat:9533:277246:{
../inputs/grep1.dat:9534:277248:  if (!b)
../inputs/grep1.dat:9535:277258:    return 1;
../inputs/grep1.dat:9536:277272:  if (!hasevery(a, b->llink))
../inputs/grep1.dat:9537:277302:    return 0;
../inputs/grep1.dat:9538:277316:  if (!hasevery(a, b->rlink))
../inputs/grep1.dat:9539:277346:    return 0;
../inputs/grep1.dat:9540:277360:  while (a && b->label != a->label)
../inputs/grep1.dat:9541:277396:    if (b->label < a->label)
../inputs/grep1.dat:9542:277425:      a = a->llink;
../inputs/grep1.dat:9543:277445:    else
../inputs/grep1.dat:9544:277454:      a = a->rlink;
../inputs/grep1.dat:9545:277474:  return !!a;
../inputs/grep1.dat:9546:277488:}
../inputs/grep1.dat:9547:277490:
../inputs/grep1.dat:9548:277491:/* Compute a vector, indexed by character code, of the trie nodes
../inputs/grep1.dat:9549:277557:   referenced from the given tree. */
../inputs/grep1.dat:9550:277595:static void
../inputs/grep1.dat:9551:277607:treenext(tree, next)
../inputs/grep1.dat:9552:277628:     struct tree *tree;
../inputs/grep1.dat:9553:277652:     struct trie *next[];
../inputs/grep1.dat:9554:277678:{
../inputs/grep1.dat:9555:277680:  if (!tree)
../inputs/grep1.dat:9556:277693:    return;
../inputs/grep1.dat:9557:277705:  treenext(tree->llink, next);
../inputs/grep1.dat:9558:277736:  treenext(tree->rlink, next);
../inputs/grep1.dat:9559:277767:  next[tree->label] = tree->trie;
../inputs/grep1.dat:9560:277801:}
../inputs/grep1.dat:9561:277803:
../inputs/grep1.dat:9562:277804:/* Compute the shift for each trie node, as well as the delta
../inputs/grep1.dat:9563:277866:   table and next cache for the given keyword set. */
../inputs/grep1.dat:9564:277920:char *
../inputs/grep1.dat:9565:277927:kwsprep(kws)
../inputs/grep1.dat:9566:277940:     kwset_t kws;
../inputs/grep1.dat:9567:277958:{
../inputs/grep1.dat:9568:277960:  register struct kwset *kwset;
../inputs/grep1.dat:9569:277992:  register int i;
../inputs/grep1.dat:9570:278010:  register struct trie *curr, *fail;
../inputs/grep1.dat:9571:278047:  register char *trans;
../inputs/grep1.dat:9572:278071:  unsigned char delta[NCHAR];
../inputs/grep1.dat:9573:278101:  struct trie *last, *next[NCHAR];
../inputs/grep1.dat:9574:278136:
../inputs/grep1.dat:9575:278137:  kwset = (struct kwset *) kws;
../inputs/grep1.dat:9576:278169:
../inputs/grep1.dat:9577:278170:  /* Initial values for the delta table; will be changed later.  The
../inputs/grep1.dat:9578:278239:     delta entry for a given character is the smallest depth of any
../inputs/grep1.dat:9579:278307:     node at which an outgoing edge is labeled by that character. */
../inputs/grep1.dat:9580:278376:  if (kwset->mind < 256)
../inputs/grep1.dat:9581:278401:    for (i = 0; i < NCHAR; ++i)
../inputs/grep1.dat:9582:278433:      delta[i] = kwset->mind;
../inputs/grep1.dat:9583:278463:  else
../inputs/grep1.dat:9584:278470:    for (i = 0; i < NCHAR; ++i)
../inputs/grep1.dat:9585:278502:      delta[i] = 255;
../inputs/grep1.dat:9586:278524:
../inputs/grep1.dat:9587:278525:  /* Check if we can use the simple boyer-moore algorithm, instead
../inputs/grep1.dat:9588:278592:     of the hairy commentz-walter algorithm. */
../inputs/grep1.dat:9589:278640:  if (kwset->words == 1 && kwset->trans == 0)
../inputs/grep1.dat:9590:278686:    {
../inputs/grep1.dat:9591:278692:      /* Looking for just one string.  Extract it from the trie. */
../inputs/grep1.dat:9592:278760:      kwset->target = obstack_alloc(&kwset->obstack, kwset->mind);
../inputs/grep1.dat:9593:278827:      for (i = kwset->mind - 1, curr = kwset->trie; i >= 0; --i)
../inputs/grep1.dat:9594:278892:	{
../inputs/grep1.dat:9595:278895:	  kwset->target[i] = curr->links->label;
../inputs/grep1.dat:9596:278937:	  curr = curr->links->trie;
../inputs/grep1.dat:9597:278966:	}
../inputs/grep1.dat:9598:278969:      /* Build the Boyer Moore delta.  Boy that's easy compared to CW. */
../inputs/grep1.dat:9599:279043:      for (i = 0; i < kwset->mind; ++i)
../inputs/grep1.dat:9600:279083:	delta[(unsigned char) kwset->target[i]] = kwset->mind - (i + 1);
../inputs/grep1.dat:9601:279149:      kwset->mind2 = kwset->mind;
../inputs/grep1.dat:9602:279183:      /* Find the minimal delta2 shift that we might make after
../inputs/grep1.dat:9603:279247:	 a backwards match has failed. */
../inputs/grep1.dat:9604:279282:      for (i = 0; i < kwset->mind - 1; ++i)
../inputs/grep1.dat:9605:279326:	if (kwset->target[i] == kwset->target[kwset->mind - 1])
../inputs/grep1.dat:9606:279383:	  kwset->mind2 = kwset->mind - (i + 1);
../inputs/grep1.dat:9607:279424:    }
../inputs/grep1.dat:9608:279430:  else
../inputs/grep1.dat:9609:279437:    {
../inputs/grep1.dat:9610:279443:      /* Traverse the nodes of the trie in level order, simultaneously
../inputs/grep1.dat:9611:279514:	 computing the delta table, failure function, and shift function. */
../inputs/grep1.dat:9612:279584:      for (curr = last = kwset->trie; curr; curr = curr->next)
../inputs/grep1.dat:9613:279647:	{
../inputs/grep1.dat:9614:279650:	  /* Enqueue the immediate descendents in the level order queue. */
../inputs/grep1.dat:9615:279719:	  enqueue(curr->links, &last);
../inputs/grep1.dat:9616:279751:
../inputs/grep1.dat:9617:279752:	  curr->shift = kwset->mind;
../inputs/grep1.dat:9618:279782:	  curr->maxshift = kwset->mind;
../inputs/grep1.dat:9619:279815:
../inputs/grep1.dat:9620:279816:	  /* Update the delta table for the descendents of this node. */
../inputs/grep1.dat:9621:279882:	  treedelta(curr->links, curr->depth, delta);
../inputs/grep1.dat:9622:279929:
../inputs/grep1.dat:9623:279930:	  /* Compute the failure function for the decendents of this node. */
../inputs/grep1.dat:9624:280001:	  treefails(curr->links, curr->fail, kwset->trie);
../inputs/grep1.dat:9625:280053:
../inputs/grep1.dat:9626:280054:	  /* Update the shifts at each node in the current node's chain
../inputs/grep1.dat:9627:280119:	     of fails back to the root. */
../inputs/grep1.dat:9628:280155:	  for (fail = curr->fail; fail; fail = fail->fail)
../inputs/grep1.dat:9629:280207:	    {
../inputs/grep1.dat:9630:280214:	      /* If the current node has some outgoing edge that the fail
../inputs/grep1.dat:9631:280281:		 doesn't, then the shift at the fail should be no larger
../inputs/grep1.dat:9632:280340:		 than the difference of their depths. */
../inputs/grep1.dat:9633:280383:	      if (!hasevery(fail->links, curr->links))
../inputs/grep1.dat:9634:280431:		if (curr->depth - fail->depth < fail->shift)
../inputs/grep1.dat:9635:280478:		  fail->shift = curr->depth - fail->depth;
../inputs/grep1.dat:9636:280523:
../inputs/grep1.dat:9637:280524:	      /* If the current node is accepting then the shift at the
../inputs/grep1.dat:9638:280589:		 fail and its descendents should be no larger than the
../inputs/grep1.dat:9639:280646:		 difference of their depths. */
../inputs/grep1.dat:9640:280680:	      if (curr->accepting && fail->maxshift > curr->depth - fail->depth)
../inputs/grep1.dat:9641:280754:		fail->maxshift = curr->depth - fail->depth;
../inputs/grep1.dat:9642:280800:	    }
../inputs/grep1.dat:9643:280807:	}
../inputs/grep1.dat:9644:280810:
../inputs/grep1.dat:9645:280811:      /* Traverse the trie in level order again, fixing up all nodes whose
../inputs/grep1.dat:9646:280886:	 shift exceeds their inherited maxshift. */
../inputs/grep1.dat:9647:280931:      for (curr = kwset->trie->next; curr; curr = curr->next)
../inputs/grep1.dat:9648:280993:	{
../inputs/grep1.dat:9649:280996:	  if (curr->maxshift > curr->parent->maxshift)
../inputs/grep1.dat:9650:281044:	    curr->maxshift = curr->parent->maxshift;
../inputs/grep1.dat:9651:281090:	  if (curr->shift > curr->maxshift)
../inputs/grep1.dat:9652:281127:	    curr->shift = curr->maxshift;
../inputs/grep1.dat:9653:281162:	}
../inputs/grep1.dat:9654:281165:
../inputs/grep1.dat:9655:281166:      /* Create a vector, indexed by character code, of the outgoing links
../inputs/grep1.dat:9656:281241:	 from the root node. */
../inputs/grep1.dat:9657:281266:      for (i = 0; i < NCHAR; ++i)
../inputs/grep1.dat:9658:281300:	next[i] = 0;
../inputs/grep1.dat:9659:281314:      treenext(kwset->trie->links, next);
../inputs/grep1.dat:9660:281356:
../inputs/grep1.dat:9661:281357:      if ((trans = kwset->trans) != 0)
../inputs/grep1.dat:9662:281396:	for (i = 0; i < NCHAR; ++i)
../inputs/grep1.dat:9663:281425:	  kwset->next[i] = next[(unsigned char) trans[i]];
../inputs/grep1.dat:9664:281477:      else
../inputs/grep1.dat:9665:281488:	for (i = 0; i < NCHAR; ++i)
../inputs/grep1.dat:9666:281517:	  kwset->next[i] = next[i];
../inputs/grep1.dat:9667:281546:    }
../inputs/grep1.dat:9668:281552:
../inputs/grep1.dat:9669:281553:  /* Fix things up for any translation table. */
../inputs/grep1.dat:9670:281602:  if ((trans = kwset->trans) != 0)
../inputs/grep1.dat:9671:281637:    for (i = 0; i < NCHAR; ++i)
../inputs/grep1.dat:9672:281669:      kwset->delta[i] = delta[(unsigned char) trans[i]];
../inputs/grep1.dat:9673:281726:  else
../inputs/grep1.dat:9674:281733:    for (i = 0; i < NCHAR; ++i)
../inputs/grep1.dat:9675:281765:      kwset->delta[i] = delta[i];
../inputs/grep1.dat:9676:281799:
../inputs/grep1.dat:9677:281800:  return 0;
../inputs/grep1.dat:9678:281812:}
../inputs/grep1.dat:9679:281814:
../inputs/grep1.dat:9680:281815:#define U(C) ((unsigned char) (C))
../inputs/grep1.dat:9681:281850:
../inputs/grep1.dat:9682:281851:/* Fast boyer-moore search. */
../inputs/grep1.dat:9683:281882:static char *
../inputs/grep1.dat:9684:281896:bmexec(kws, text, size)
../inputs/grep1.dat:9685:281920:     kwset_t kws;
../inputs/grep1.dat:9686:281938:     char *text;
../inputs/grep1.dat:9687:281955:     size_t size;
../inputs/grep1.dat:9688:281973:{
../inputs/grep1.dat:9689:281975:  struct kwset *kwset;
../inputs/grep1.dat:9690:281998:  register unsigned char *d1;
../inputs/grep1.dat:9691:282028:  register char *ep, *sp, *tp;
../inputs/grep1.dat:9692:282059:  register int d, gc, i, len, md2;
../inputs/grep1.dat:9693:282094:
../inputs/grep1.dat:9694:282095:  kwset = (struct kwset *) kws;
../inputs/grep1.dat:9695:282127:  len = kwset->mind;
../inputs/grep1.dat:9696:282148:
../inputs/grep1.dat:9697:282149:  if (len == 0)
../inputs/grep1.dat:9698:282165:    return text;
../inputs/grep1.dat:9699:282182:  if (len > size)
../inputs/grep1.dat:9700:282200:    return 0;
../inputs/grep1.dat:9701:282214:  if (len == 1)
../inputs/grep1.dat:9702:282230:    return memchr(text, kwset->target[0], size);
../inputs/grep1.dat:9703:282279:
../inputs/grep1.dat:9704:282280:  d1 = kwset->delta;
../inputs/grep1.dat:9705:282301:  sp = kwset->target + len;
../inputs/grep1.dat:9706:282329:  gc = U(sp[-2]);
../inputs/grep1.dat:9707:282347:  md2 = kwset->mind2;
../inputs/grep1.dat:9708:282369:  tp = text + len;
../inputs/grep1.dat:9709:282388:
../inputs/grep1.dat:9710:282389:  /* Significance of 12: 1 (initial offset) + 10 (skip loop) + 1 (md2). */
../inputs/grep1.dat:9711:282464:  if (size > 12 * len)
../inputs/grep1.dat:9712:282487:    /* 11 is not a bug, the initial offset happens only once. */
../inputs/grep1.dat:9713:282552:    for (ep = text + size - 11 * len;;)
../inputs/grep1.dat:9714:282592:      {
../inputs/grep1.dat:9715:282600:	while (tp <= ep)
../inputs/grep1.dat:9716:282618:	  {
../inputs/grep1.dat:9717:282623:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:9718:282656:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:9719:282689:	    if (d == 0)
../inputs/grep1.dat:9720:282706:	      goto found;
../inputs/grep1.dat:9721:282725:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:9722:282758:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:9723:282791:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:9724:282824:	    if (d == 0)
../inputs/grep1.dat:9725:282841:	      goto found;
../inputs/grep1.dat:9726:282860:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:9727:282893:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:9728:282926:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:9729:282959:	    if (d == 0)
../inputs/grep1.dat:9730:282976:	      goto found;
../inputs/grep1.dat:9731:282995:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:9732:283028:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:9733:283061:	  }
../inputs/grep1.dat:9734:283066:	break;
../inputs/grep1.dat:9735:283074:      found:
../inputs/grep1.dat:9736:283087:	if (U(tp[-2]) == gc)
../inputs/grep1.dat:9737:283109:	  {
../inputs/grep1.dat:9738:283114:	    for (i = 3; i <= len && U(tp[-i]) == U(sp[-i]); ++i)
../inputs/grep1.dat:9739:283172:	      ;
../inputs/grep1.dat:9740:283181:	    if (i > len)
../inputs/grep1.dat:9741:283199:	      return tp - len;
../inputs/grep1.dat:9742:283223:	  }
../inputs/grep1.dat:9743:283228:	tp += md2;
../inputs/grep1.dat:9744:283240:      }
../inputs/grep1.dat:9745:283248:
../inputs/grep1.dat:9746:283249:  /* Now we have only a few characters left to search.  We
../inputs/grep1.dat:9747:283308:     carefully avoid ever producing an out-of-bounds pointer. */
../inputs/grep1.dat:9748:283373:  ep = text + size;
../inputs/grep1.dat:9749:283393:  d = d1[U(tp[-1])];
../inputs/grep1.dat:9750:283414:  while (d <= ep - tp)
../inputs/grep1.dat:9751:283437:    {
../inputs/grep1.dat:9752:283443:      d = d1[U((tp += d)[-1])];
../inputs/grep1.dat:9753:283475:      if (d != 0)
../inputs/grep1.dat:9754:283493:	continue;
../inputs/grep1.dat:9755:283504:      if (tp[-2] == gc)
../inputs/grep1.dat:9756:283528:	{
../inputs/grep1.dat:9757:283531:	  for (i = 3; i <= len && U(tp[-i]) == U(sp[-i]); ++i)
../inputs/grep1.dat:9758:283587:	    ;
../inputs/grep1.dat:9759:283594:	  if (i > len)
../inputs/grep1.dat:9760:283610:	    return tp - len;
../inputs/grep1.dat:9761:283632:	}
../inputs/grep1.dat:9762:283635:      d = md2;
../inputs/grep1.dat:9763:283650:    }
../inputs/grep1.dat:9764:283656:
../inputs/grep1.dat:9765:283657:  return 0;
../inputs/grep1.dat:9766:283669:}
../inputs/grep1.dat:9767:283671:
../inputs/grep1.dat:9768:283672:/* Hairy multiple string search. */
../inputs/grep1.dat:9769:283708:static char *
../inputs/grep1.dat:9770:283722:cwexec(kws, text, len, kwsmatch)
../inputs/grep1.dat:9771:283755:     kwset_t kws;
../inputs/grep1.dat:9772:283773:     char *text;
../inputs/grep1.dat:9773:283790:     size_t len;
../inputs/grep1.dat:9774:283807:     struct kwsmatch *kwsmatch;
../inputs/grep1.dat:9775:283839:{
../inputs/grep1.dat:9776:283841:  struct kwset *kwset;
../inputs/grep1.dat:9777:283864:  struct trie **next, *trie, *accept;
../inputs/grep1.dat:9778:283902:  char *beg, *lim, *mch, *lmch;
../inputs/grep1.dat:9779:283934:  register unsigned char c, *delta;
../inputs/grep1.dat:9780:283970:  register int d;
../inputs/grep1.dat:9781:283988:  register char *end, *qlim;
../inputs/grep1.dat:9782:284017:  register struct tree *tree;
../inputs/grep1.dat:9783:284047:  register char *trans;
../inputs/grep1.dat:9784:284071:
../inputs/grep1.dat:9785:284072:  /* Initialize register copies and look for easy ways out. */
../inputs/grep1.dat:9786:284135:  kwset = (struct kwset *) kws;
../inputs/grep1.dat:9787:284167:  if (len < kwset->mind)
../inputs/grep1.dat:9788:284192:    return 0;
../inputs/grep1.dat:9789:284206:  next = kwset->next;
../inputs/grep1.dat:9790:284228:  delta = kwset->delta;
../inputs/grep1.dat:9791:284252:  trans = kwset->trans;
../inputs/grep1.dat:9792:284276:  lim = text + len;
../inputs/grep1.dat:9793:284296:  end = text;
../inputs/grep1.dat:9794:284310:  if ((d = kwset->mind) != 0)
../inputs/grep1.dat:9795:284340:    mch = 0;
../inputs/grep1.dat:9796:284353:  else
../inputs/grep1.dat:9797:284360:    {
../inputs/grep1.dat:9798:284366:      mch = text, accept = kwset->trie;
../inputs/grep1.dat:9799:284406:      goto match;
../inputs/grep1.dat:9800:284424:    }
../inputs/grep1.dat:9801:284430:
../inputs/grep1.dat:9802:284431:  if (len >= 4 * kwset->mind)
../inputs/grep1.dat:9803:284461:    qlim = lim - 4 * kwset->mind;
../inputs/grep1.dat:9804:284495:  else
../inputs/grep1.dat:9805:284502:    qlim = 0;
../inputs/grep1.dat:9806:284516:
../inputs/grep1.dat:9807:284517:  while (lim - end >= d)
../inputs/grep1.dat:9808:284542:    {
../inputs/grep1.dat:9809:284548:      if (qlim && end <= qlim)
../inputs/grep1.dat:9810:284579:	{
../inputs/grep1.dat:9811:284582:	  end += d - 1;
../inputs/grep1.dat:9812:284599:	  while ((d = delta[c = *end]) && end < qlim)
../inputs/grep1.dat:9813:284646:	    {
../inputs/grep1.dat:9814:284653:	      end += d;
../inputs/grep1.dat:9815:284670:	      end += delta[(unsigned char) *end];
../inputs/grep1.dat:9816:284713:	      end += delta[(unsigned char) *end];
../inputs/grep1.dat:9817:284756:	    }
../inputs/grep1.dat:9818:284763:	  ++end;
../inputs/grep1.dat:9819:284773:	}
../inputs/grep1.dat:9820:284776:      else
../inputs/grep1.dat:9821:284787:	d = delta[c = (end += d)[-1]];
../inputs/grep1.dat:9822:284819:      if (d)
../inputs/grep1.dat:9823:284832:	continue;
../inputs/grep1.dat:9824:284843:      beg = end - 1;
../inputs/grep1.dat:9825:284864:      trie = next[c];
../inputs/grep1.dat:9826:284886:      if (trie->accepting)
../inputs/grep1.dat:9827:284913:	{
../inputs/grep1.dat:9828:284916:	  mch = beg;
../inputs/grep1.dat:9829:284930:	  accept = trie;
../inputs/grep1.dat:9830:284948:	}
../inputs/grep1.dat:9831:284951:      d = trie->shift;
../inputs/grep1.dat:9832:284974:      while (beg > text)
../inputs/grep1.dat:9833:284999:	{
../inputs/grep1.dat:9834:285002:	  c = trans ? trans[(unsigned char) *--beg] : *--beg;
../inputs/grep1.dat:9835:285057:	  tree = trie->links;
../inputs/grep1.dat:9836:285080:	  while (tree && c != tree->label)
../inputs/grep1.dat:9837:285116:	    if (c < tree->label)
../inputs/grep1.dat:9838:285142:	      tree = tree->llink;
../inputs/grep1.dat:9839:285169:	    else
../inputs/grep1.dat:9840:285179:	      tree = tree->rlink;
../inputs/grep1.dat:9841:285206:	  if (tree)
../inputs/grep1.dat:9842:285219:	    {
../inputs/grep1.dat:9843:285226:	      trie = tree->trie;
../inputs/grep1.dat:9844:285252:	      if (trie->accepting)
../inputs/grep1.dat:9845:285280:		{
../inputs/grep1.dat:9846:285284:		  mch = beg;
../inputs/grep1.dat:9847:285299:		  accept = trie;
../inputs/grep1.dat:9848:285318:		}
../inputs/grep1.dat:9849:285322:	    }
../inputs/grep1.dat:9850:285329:	  else
../inputs/grep1.dat:9851:285337:	    break;
../inputs/grep1.dat:9852:285349:	  d = trie->shift;
../inputs/grep1.dat:9853:285369:	}
../inputs/grep1.dat:9854:285372:      if (mch)
../inputs/grep1.dat:9855:285387:	goto match;
../inputs/grep1.dat:9856:285400:    }
../inputs/grep1.dat:9857:285406:  return 0;
../inputs/grep1.dat:9858:285418:
../inputs/grep1.dat:9859:285419: match:
../inputs/grep1.dat:9860:285427:  /* Given a known match, find the longest possible match anchored
../inputs/grep1.dat:9861:285494:     at or before its starting point.  This is nearly a verbatim
../inputs/grep1.dat:9862:285559:     copy of the preceding main search loops. */
../inputs/grep1.dat:9863:285608:  if (lim - mch > kwset->maxd)
../inputs/grep1.dat:9864:285639:    lim = mch + kwset->maxd;
../inputs/grep1.dat:9865:285668:  lmch = 0;
../inputs/grep1.dat:9866:285680:  d = 1;
../inputs/grep1.dat:9867:285689:  while (lim - end >= d)
../inputs/grep1.dat:9868:285714:    {
../inputs/grep1.dat:9869:285720:      if ((d = delta[c = (end += d)[-1]]) != 0)
../inputs/grep1.dat:9870:285768:	continue;
../inputs/grep1.dat:9871:285779:      beg = end - 1;
../inputs/grep1.dat:9872:285800:      if (!(trie = next[c]))
../inputs/grep1.dat:9873:285829:	{
../inputs/grep1.dat:9874:285832:	  d = 1;
../inputs/grep1.dat:9875:285842:	  continue;
../inputs/grep1.dat:9876:285855:	}
../inputs/grep1.dat:9877:285858:      if (trie->accepting && beg <= mch)
../inputs/grep1.dat:9878:285899:	{
../inputs/grep1.dat:9879:285902:	  lmch = beg;
../inputs/grep1.dat:9880:285917:	  accept = trie;
../inputs/grep1.dat:9881:285935:	}
../inputs/grep1.dat:9882:285938:      d = trie->shift;
../inputs/grep1.dat:9883:285961:      while (beg > text)
../inputs/grep1.dat:9884:285986:	{
../inputs/grep1.dat:9885:285989:	  c = trans ? trans[(unsigned char) *--beg] : *--beg;
../inputs/grep1.dat:9886:286044:	  tree = trie->links;
../inputs/grep1.dat:9887:286067:	  while (tree && c != tree->label)
../inputs/grep1.dat:9888:286103:	    if (c < tree->label)
../inputs/grep1.dat:9889:286129:	      tree = tree->llink;
../inputs/grep1.dat:9890:286156:	    else
../inputs/grep1.dat:9891:286166:	      tree = tree->rlink;
../inputs/grep1.dat:9892:286193:	  if (tree)
../inputs/grep1.dat:9893:286206:	    {
../inputs/grep1.dat:9894:286213:	      trie = tree->trie;
../inputs/grep1.dat:9895:286239:	      if (trie->accepting && beg <= mch)
../inputs/grep1.dat:9896:286281:		{
../inputs/grep1.dat:9897:286285:		  lmch = beg;
../inputs/grep1.dat:9898:286301:		  accept = trie;
../inputs/grep1.dat:9899:286320:		}
../inputs/grep1.dat:9900:286324:	    }
../inputs/grep1.dat:9901:286331:	  else
../inputs/grep1.dat:9902:286339:	    break;
../inputs/grep1.dat:9903:286351:	  d = trie->shift;
../inputs/grep1.dat:9904:286371:	}
../inputs/grep1.dat:9905:286374:      if (lmch)
../inputs/grep1.dat:9906:286390:	{
../inputs/grep1.dat:9907:286393:	  mch = lmch;
../inputs/grep1.dat:9908:286408:	  goto match;
../inputs/grep1.dat:9909:286423:	}
../inputs/grep1.dat:9910:286426:      if (!d)
../inputs/grep1.dat:9911:286440:	d = 1;
../inputs/grep1.dat:9912:286448:    }
../inputs/grep1.dat:9913:286454:
../inputs/grep1.dat:9914:286455:  if (kwsmatch)
../inputs/grep1.dat:9915:286471:    {
../inputs/grep1.dat:9916:286477:      kwsmatch->index = accept->accepting / 2;
../inputs/grep1.dat:9917:286524:      kwsmatch->beg[0] = mch;
../inputs/grep1.dat:9918:286554:      kwsmatch->size[0] = accept->depth;
../inputs/grep1.dat:9919:286595:    }
../inputs/grep1.dat:9920:286601:  return mch;
../inputs/grep1.dat:9921:286615:}
../inputs/grep1.dat:9922:286617:  
../inputs/grep1.dat:9923:286620:/* Search through the given text for a match of any member of the
../inputs/grep1.dat:9924:286686:   given keyword set.  Return a pointer to the first character of
../inputs/grep1.dat:9925:286752:   the matching substring, or NULL if no match is found.  If FOUNDLEN
../inputs/grep1.dat:9926:286822:   is non-NULL store in the referenced location the length of the
../inputs/grep1.dat:9927:286888:   matching substring.  Similarly, if FOUNDIDX is non-NULL, store
../inputs/grep1.dat:9928:286954:   in the referenced location the index number of the particular
../inputs/grep1.dat:9929:287019:   keyword matched. */
../inputs/grep1.dat:9930:287042:char *
../inputs/grep1.dat:9931:287049:kwsexec(kws, text, size, kwsmatch)
../inputs/grep1.dat:9932:287084:     kwset_t kws;
../inputs/grep1.dat:9933:287102:     char *text;
../inputs/grep1.dat:9934:287119:     size_t size;
../inputs/grep1.dat:9935:287137:     struct kwsmatch *kwsmatch;
../inputs/grep1.dat:9936:287169:{
../inputs/grep1.dat:9937:287171:  struct kwset *kwset;
../inputs/grep1.dat:9938:287194:  char *ret;
../inputs/grep1.dat:9939:287207:
../inputs/grep1.dat:9940:287208:  kwset = (struct kwset *) kws;
../inputs/grep1.dat:9941:287240:  if (kwset->words == 1 && kwset->trans == 0)
../inputs/grep1.dat:9942:287286:    {
../inputs/grep1.dat:9943:287292:      ret = bmexec(kws, text, size);
../inputs/grep1.dat:9944:287329:      if (kwsmatch != 0 && ret != 0)
../inputs/grep1.dat:9945:287366:	{
../inputs/grep1.dat:9946:287369:	  kwsmatch->index = 0;
../inputs/grep1.dat:9947:287393:	  kwsmatch->beg[0] = ret;
../inputs/grep1.dat:9948:287420:	  kwsmatch->size[0] = kwset->mind;
../inputs/grep1.dat:9949:287456:	}
../inputs/grep1.dat:9950:287459:      return ret;
../inputs/grep1.dat:9951:287477:    }
../inputs/grep1.dat:9952:287483:  else
../inputs/grep1.dat:9953:287490:    return cwexec(kws, text, size, kwsmatch);
../inputs/grep1.dat:9954:287536:}
../inputs/grep1.dat:9955:287538:
../inputs/grep1.dat:9956:287539:/* Free the components of the given keyword set. */
../inputs/grep1.dat:9957:287591:void
../inputs/grep1.dat:9958:287596:kwsfree(kws)
../inputs/grep1.dat:9959:287609:     kwset_t kws;
../inputs/grep1.dat:9960:287627:{
../inputs/grep1.dat:9961:287629:  struct kwset *kwset;
../inputs/grep1.dat:9962:287652:
../inputs/grep1.dat:9963:287653:  kwset = (struct kwset *) kws;
../inputs/grep1.dat:9964:287685:  obstack_free(&kwset->obstack, 0);
../inputs/grep1.dat:9965:287721:  free(kws);
../inputs/grep1.dat:9966:287734:}
../inputs/grep1.dat:9967:287736:/* obstack.c - subroutines used implicitly by object stack macros
../inputs/grep1.dat:9968:287802:   Copyright (C) 1988, 1993 Free Software Foundation, Inc.
../inputs/grep1.dat:9969:287861:
../inputs/grep1.dat:9970:287862:This program is free software; you can redistribute it and/or modify it
../inputs/grep1.dat:9971:287934:under the terms of the GNU General Public License as published by the
../inputs/grep1.dat:9972:288004:Free Software Foundation; either version 2, or (at your option) any
../inputs/grep1.dat:9973:288072:later version.
../inputs/grep1.dat:9974:288087:
../inputs/grep1.dat:9975:288088:This program is distributed in the hope that it will be useful,
../inputs/grep1.dat:9976:288152:but WITHOUT ANY WARRANTY; without even the implied warranty of
../inputs/grep1.dat:9977:288215:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
../inputs/grep1.dat:9978:288277:GNU General Public License for more details.
../inputs/grep1.dat:9979:288322:
../inputs/grep1.dat:9980:288323:You should have received a copy of the GNU General Public License
../inputs/grep1.dat:9981:288389:along with this program; if not, write to the Free Software
../inputs/grep1.dat:9982:288449:Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
../inputs/grep1.dat:9983:288505:
../inputs/grep1.dat:9985:288531:
../inputs/grep1.dat:9986:288532:/* This is just to get __GNU_LIBRARY__ defined.  */
../inputs/grep1.dat:9988:288607:
../inputs/grep1.dat:9989:288608:/* Comment out all this code if we are using the GNU C Library, and are not
../inputs/grep1.dat:9990:288684:   actually compiling the library itself.  This code is part of the GNU C
../inputs/grep1.dat:9992:288832:   and linking in this code is a waste when using the GNU C library
../inputs/grep1.dat:9993:288900:   (especially if it is a shared library).  Rather than having every GNU
../inputs/grep1.dat:9994:288973:   program understand `configure --with-gnu-libc' and omit the object files,
../inputs/grep1.dat:9995:289050:   it is simpler to just do this in the source for each such file.  */
../inputs/grep1.dat:9996:289121:
../inputs/grep1.dat:9997:289122:#if defined (_LIBC) || !defined (__GNU_LIBRARY__)
../inputs/grep1.dat:9998:289172:
../inputs/grep1.dat:9999:289173:
../inputs/grep1.dat:10000:289174:#ifdef __STDC__
../inputs/grep1.dat:10001:289190:#define POINTER void *
../inputs/grep1.dat:10002:289213:#else
../inputs/grep1.dat:10003:289219:#define POINTER char *
../inputs/grep1.dat:10004:289242:#endif
../inputs/grep1.dat:10005:289249:
../inputs/grep1.dat:10006:289250:/* Determine default alignment.  */
../inputs/grep1.dat:10007:289286:struct fooalign {char x; double d;};
../inputs/grep1.dat:10008:289323:#define DEFAULT_ALIGNMENT  \
../inputs/grep1.dat:10009:289352:  ((PTR_INT_TYPE) ((char *)&((struct fooalign *) 0)->d - (char *)0))
../inputs/grep1.dat:10010:289421:/* If malloc were really smart, it would round addresses to DEFAULT_ALIGNMENT.
../inputs/grep1.dat:10011:289500:   But in fact it might be less smart and round addresses to as much as
../inputs/grep1.dat:10012:289572:   DEFAULT_ROUNDING.  So we prepare for it to do that.  */
../inputs/grep1.dat:10013:289631:union fooround {long x; double d;};
../inputs/grep1.dat:10014:289667:#define DEFAULT_ROUNDING (sizeof (union fooround))
../inputs/grep1.dat:10015:289718:
../inputs/grep1.dat:10016:289719:/* When we copy a long block of data, this is the unit to do it with.
../inputs/grep1.dat:10017:289789:   On some machines, copying successive ints does not work;
../inputs/grep1.dat:10018:289849:   in such a case, redefine COPYING_UNIT to `long' (if that works)
../inputs/grep1.dat:10019:289916:   or `char' as a last resort.  */
../inputs/grep1.dat:10020:289951:#ifndef COPYING_UNIT
../inputs/grep1.dat:10021:289972:#define COPYING_UNIT int
../inputs/grep1.dat:10022:289997:#endif
../inputs/grep1.dat:10023:290004:
../inputs/grep1.dat:10024:290005:/* The non-GNU-C macros copy the obstack into this global variable
../inputs/grep1.dat:10025:290072:   to avoid multiple evaluation.  */
../inputs/grep1.dat:10026:290109:
../inputs/grep1.dat:10027:290110:struct obstack *_obstack;
../inputs/grep1.dat:10028:290136:
../inputs/grep1.dat:10029:290137:/* Define a macro that either calls functions with the traditional malloc/free
../inputs/grep1.dat:10030:290216:   calling interface, or calls functions with the mmalloc/mfree interface
../inputs/grep1.dat:10031:290290:   (that adds an extra first argument), based on the state of use_extra_arg.
../inputs/grep1.dat:10032:290367:   For free, do not use ?:, since some compilers, like the MIPS compilers,
../inputs/grep1.dat:10033:290442:   do not allow (expr) ? void : void.  */
../inputs/grep1.dat:10034:290484:
../inputs/grep1.dat:10035:290485:#define CALL_CHUNKFUN(h, size) \
../inputs/grep1.dat:10036:290518:  (((h) -> use_extra_arg) \
../inputs/grep1.dat:10037:290546:   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
../inputs/grep1.dat:10038:290595:   : (*(h)->chunkfun) ((size)))
../inputs/grep1.dat:10039:290627:
../inputs/grep1.dat:10040:290628:#define CALL_FREEFUN(h, old_chunk) \
../inputs/grep1.dat:10041:290665:  do { \
../inputs/grep1.dat:10042:290674:    if ((h) -> use_extra_arg) \
../inputs/grep1.dat:10043:290706:      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
../inputs/grep1.dat:10044:290761:    else \
../inputs/grep1.dat:10045:290772:      (*(h)->freefun) ((old_chunk)); \
../inputs/grep1.dat:10046:290811:  } while (0)
../inputs/grep1.dat:10047:290825:
../inputs/grep1.dat:10048:290826:
../inputs/grep1.dat:10049:290828:/* Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).
../inputs/grep1.dat:10050:290908:   Objects start on multiples of ALIGNMENT (0 means use default).
../inputs/grep1.dat:10051:290974:   CHUNKFUN is the function to use to allocate chunks,
../inputs/grep1.dat:10052:291029:   and FREEFUN the function to free them.  */
../inputs/grep1.dat:10053:291075:
../inputs/grep1.dat:10054:291076:void
../inputs/grep1.dat:10055:291081:_obstack_begin (h, size, alignment, chunkfun, freefun)
../inputs/grep1.dat:10056:291136:     struct obstack *h;
../inputs/grep1.dat:10057:291160:     int size;
../inputs/grep1.dat:10058:291175:     int alignment;
../inputs/grep1.dat:10059:291195:     POINTER (*chunkfun) ();
../inputs/grep1.dat:10060:291224:     void (*freefun) ();
../inputs/grep1.dat:10061:291249:{
../inputs/grep1.dat:10062:291251:  register struct _obstack_chunk* chunk; /* points to new chunk */
../inputs/grep1.dat:10063:291318:
../inputs/grep1.dat:10064:291319:  if (alignment == 0)
../inputs/grep1.dat:10065:291341:    alignment = DEFAULT_ALIGNMENT;
../inputs/grep1.dat:10066:291376:  if (size == 0)
../inputs/grep1.dat:10067:291393:    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
../inputs/grep1.dat:10068:291466:    {
../inputs/grep1.dat:10069:291472:      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
../inputs/grep1.dat:10070:291534:	 Use the values for range checking, because if range checking is off,
../inputs/grep1.dat:10071:291605:	 the extra bytes won't be missed terribly, but if range checking is on
../inputs/grep1.dat:10072:291677:	 and we used a larger request, a whole extra 4096 bytes would be
../inputs/grep1.dat:10073:291743:	 allocated.
../inputs/grep1.dat:10074:291756:
../inputs/grep1.dat:10075:291757:	 These number are irrelevant to the new GNU malloc.  I suspect it is
../inputs/grep1.dat:10076:291827:	 less sensitive to the size of the request.  */
../inputs/grep1.dat:10077:291876:      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
../inputs/grep1.dat:10078:291952:		    + 4 + DEFAULT_ROUNDING - 1)
../inputs/grep1.dat:10079:291986:		   & ~(DEFAULT_ROUNDING - 1));
../inputs/grep1.dat:10080:292019:      size = 4096 - extra;
../inputs/grep1.dat:10081:292046:    }
../inputs/grep1.dat:10082:292052:
../inputs/grep1.dat:10083:292053:  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
../inputs/grep1.dat:10084:292111:  h->freefun = freefun;
../inputs/grep1.dat:10085:292135:  h->chunk_size = size;
../inputs/grep1.dat:10086:292159:  h->alignment_mask = alignment - 1;
../inputs/grep1.dat:10087:292196:  h->use_extra_arg = 0;
../inputs/grep1.dat:10088:292220:
../inputs/grep1.dat:10089:292221:  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
../inputs/grep1.dat:10090:292278:  h->next_free = h->object_base = chunk->contents;
../inputs/grep1.dat:10091:292329:  h->chunk_limit = chunk->limit
../inputs/grep1.dat:10092:292361:    = (char *) chunk + h->chunk_size;
../inputs/grep1.dat:10093:292399:  chunk->prev = 0;
../inputs/grep1.dat:10094:292418:  /* The initial chunk now contains no empty object.  */
../inputs/grep1.dat:10095:292475:  h->maybe_empty_object = 0;
../inputs/grep1.dat:10096:292504:}
../inputs/grep1.dat:10097:292506:
../inputs/grep1.dat:10098:292507:void
../inputs/grep1.dat:10099:292512:_obstack_begin_1 (h, size, alignment, chunkfun, freefun, arg)
../inputs/grep1.dat:10100:292574:     struct obstack *h;
../inputs/grep1.dat:10101:292598:     int size;
../inputs/grep1.dat:10102:292613:     int alignment;
../inputs/grep1.dat:10103:292633:     POINTER (*chunkfun) ();
../inputs/grep1.dat:10104:292662:     void (*freefun) ();
../inputs/grep1.dat:10105:292687:     POINTER arg;
../inputs/grep1.dat:10106:292705:{
../inputs/grep1.dat:10107:292707:  register struct _obstack_chunk* chunk; /* points to new chunk */
../inputs/grep1.dat:10108:292774:
../inputs/grep1.dat:10109:292775:  if (alignment == 0)
../inputs/grep1.dat:10110:292797:    alignment = DEFAULT_ALIGNMENT;
../inputs/grep1.dat:10111:292832:  if (size == 0)
../inputs/grep1.dat:10112:292849:    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
../inputs/grep1.dat:10113:292922:    {
../inputs/grep1.dat:10114:292928:      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
../inputs/grep1.dat:10115:292990:	 Use the values for range checking, because if range checking is off,
../inputs/grep1.dat:10116:293061:	 the extra bytes won't be missed terribly, but if range checking is on
../inputs/grep1.dat:10117:293133:	 and we used a larger request, a whole extra 4096 bytes would be
../inputs/grep1.dat:10118:293199:	 allocated.
../inputs/grep1.dat:10119:293212:
../inputs/grep1.dat:10120:293213:	 These number are irrelevant to the new GNU malloc.  I suspect it is
../inputs/grep1.dat:10121:293283:	 less sensitive to the size of the request.  */
../inputs/grep1.dat:10122:293332:      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
../inputs/grep1.dat:10123:293408:		    + 4 + DEFAULT_ROUNDING - 1)
../inputs/grep1.dat:10124:293442:		   & ~(DEFAULT_ROUNDING - 1));
../inputs/grep1.dat:10125:293475:      size = 4096 - extra;
../inputs/grep1.dat:10126:293502:    }
../inputs/grep1.dat:10127:293508:
../inputs/grep1.dat:10128:293509:  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
../inputs/grep1.dat:10129:293567:  h->freefun = freefun;
../inputs/grep1.dat:10130:293591:  h->chunk_size = size;
../inputs/grep1.dat:10131:293615:  h->alignment_mask = alignment - 1;
../inputs/grep1.dat:10132:293652:  h->extra_arg = arg;
../inputs/grep1.dat:10133:293674:  h->use_extra_arg = 1;
../inputs/grep1.dat:10134:293698:
../inputs/grep1.dat:10135:293699:  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
../inputs/grep1.dat:10136:293756:  h->next_free = h->object_base = chunk->contents;
../inputs/grep1.dat:10137:293807:  h->chunk_limit = chunk->limit
../inputs/grep1.dat:10138:293839:    = (char *) chunk + h->chunk_size;
../inputs/grep1.dat:10139:293877:  chunk->prev = 0;
../inputs/grep1.dat:10140:293896:  /* The initial chunk now contains no empty object.  */
../inputs/grep1.dat:10141:293953:  h->maybe_empty_object = 0;
../inputs/grep1.dat:10142:293982:}
../inputs/grep1.dat:10143:293984:
../inputs/grep1.dat:10144:293985:/* Allocate a new current chunk for the obstack *H
../inputs/grep1.dat:10145:294036:   on the assumption that LENGTH bytes need to be added
../inputs/grep1.dat:10146:294092:   to the current object, or a new object of length LENGTH allocated.
../inputs/grep1.dat:10147:294162:   Copies any partial object from the end of the old chunk
../inputs/grep1.dat:10148:294221:   to the beginning of the new one.  */
../inputs/grep1.dat:10149:294261:
../inputs/grep1.dat:10150:294262:void
../inputs/grep1.dat:10151:294267:_obstack_newchunk (h, length)
../inputs/grep1.dat:10152:294297:     struct obstack *h;
../inputs/grep1.dat:10153:294321:     int length;
../inputs/grep1.dat:10154:294338:{
../inputs/grep1.dat:10155:294340:  register struct _obstack_chunk*	old_chunk = h->chunk;
../inputs/grep1.dat:10156:294396:  register struct _obstack_chunk*	new_chunk;
../inputs/grep1.dat:10157:294441:  register long	new_size;
../inputs/grep1.dat:10158:294467:  register int obj_size = h->next_free - h->object_base;
../inputs/grep1.dat:10159:294524:  register int i;
../inputs/grep1.dat:10160:294542:  int already;
../inputs/grep1.dat:10161:294557:
../inputs/grep1.dat:10162:294558:  /* Compute size for new chunk.  */
../inputs/grep1.dat:10163:294595:  new_size = (obj_size + length) + (obj_size >> 3) + 100;
../inputs/grep1.dat:10164:294653:  if (new_size < h->chunk_size)
../inputs/grep1.dat:10165:294685:    new_size = h->chunk_size;
../inputs/grep1.dat:10166:294715:
../inputs/grep1.dat:10167:294716:  /* Allocate and initialize the new chunk.  */
../inputs/grep1.dat:10168:294764:  new_chunk = h->chunk = CALL_CHUNKFUN (h, new_size);
../inputs/grep1.dat:10169:294818:  new_chunk->prev = old_chunk;
../inputs/grep1.dat:10170:294849:  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;
../inputs/grep1.dat:10171:294918:
../inputs/grep1.dat:10172:294919:  /* Move the existing object to the new chunk.
../inputs/grep1.dat:10173:294967:     Word at a time is fast and is safe if the object
../inputs/grep1.dat:10174:295021:     is sufficiently aligned.  */
../inputs/grep1.dat:10175:295055:  if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)
../inputs/grep1.dat:10176:295105:    {
../inputs/grep1.dat:10177:295111:      for (i = obj_size / sizeof (COPYING_UNIT) - 1;
../inputs/grep1.dat:10178:295164:	   i >= 0; i--)
../inputs/grep1.dat:10179:295181:	((COPYING_UNIT *)new_chunk->contents)[i]
../inputs/grep1.dat:10180:295223:	  = ((COPYING_UNIT *)h->object_base)[i];
../inputs/grep1.dat:10181:295265:      /* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,
../inputs/grep1.dat:10182:295345:	 but that can cross a page boundary on a machine
../inputs/grep1.dat:10183:295395:	 which does not do strict alignment for COPYING_UNITS.  */
../inputs/grep1.dat:10184:295455:      already = obj_size / sizeof (COPYING_UNIT) * sizeof (COPYING_UNIT);
../inputs/grep1.dat:10185:295529:    }
../inputs/grep1.dat:10186:295535:  else
../inputs/grep1.dat:10187:295542:    already = 0;
../inputs/grep1.dat:10188:295559:  /* Copy remaining bytes one by one.  */
../inputs/grep1.dat:10189:295601:  for (i = already; i < obj_size; i++)
../inputs/grep1.dat:10190:295640:    new_chunk->contents[i] = h->object_base[i];
../inputs/grep1.dat:10191:295688:
../inputs/grep1.dat:10192:295689:  /* If the object just copied was the only data in OLD_CHUNK,
../inputs/grep1.dat:10193:295752:     free that chunk and remove it from the chain.
../inputs/grep1.dat:10194:295803:     But not if that chunk might contain an empty object.  */
../inputs/grep1.dat:10195:295865:  if (h->object_base == old_chunk->contents && ! h->maybe_empty_object)
../inputs/grep1.dat:10196:295937:    {
../inputs/grep1.dat:10197:295943:      new_chunk->prev = old_chunk->prev;
../inputs/grep1.dat:10198:295984:      CALL_FREEFUN (h, old_chunk);
../inputs/grep1.dat:10199:296019:    }
../inputs/grep1.dat:10200:296025:
../inputs/grep1.dat:10201:296026:  h->object_base = new_chunk->contents;
../inputs/grep1.dat:10202:296066:  h->next_free = h->object_base + obj_size;
../inputs/grep1.dat:10203:296110:  /* The new chunk certainly contains no empty object yet.  */
../inputs/grep1.dat:10204:296173:  h->maybe_empty_object = 0;
../inputs/grep1.dat:10205:296202:}
../inputs/grep1.dat:10206:296204:
../inputs/grep1.dat:10207:296205:/* Return nonzero if object OBJ has been allocated from obstack H.
../inputs/grep1.dat:10208:296272:   This is here for debugging.
../inputs/grep1.dat:10209:296303:   If you use it in a program, you are probably losing.  */
../inputs/grep1.dat:10210:296363:
../inputs/grep1.dat:10211:296364:int
../inputs/grep1.dat:10212:296368:_obstack_allocated_p (h, obj)
../inputs/grep1.dat:10213:296398:     struct obstack *h;
../inputs/grep1.dat:10214:296422:     POINTER obj;
../inputs/grep1.dat:10215:296440:{
../inputs/grep1.dat:10216:296442:  register struct _obstack_chunk*  lp;	/* below addr of any objects in this chunk */
../inputs/grep1.dat:10217:296527:  register struct _obstack_chunk*  plp;	/* point to previous chunk if any */
../inputs/grep1.dat:10218:296604:
../inputs/grep1.dat:10219:296605:  lp = (h)->chunk;
../inputs/grep1.dat:10220:296624:  /* We use >= rather than > since the object cannot be exactly at
../inputs/grep1.dat:10221:296691:     the beginning of the chunk but might be an empty object exactly
../inputs/grep1.dat:10222:296760:     at the end of an adjacent chunk. */
../inputs/grep1.dat:10223:296801:  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
../inputs/grep1.dat:10224:296873:    {
../inputs/grep1.dat:10225:296879:      plp = lp->prev;
../inputs/grep1.dat:10226:296901:      lp = plp;
../inputs/grep1.dat:10227:296917:    }
../inputs/grep1.dat:10228:296923:  return lp != 0;
../inputs/grep1.dat:10229:296941:}
../inputs/grep1.dat:10230:296943:
../inputs/grep1.dat:10231:296945:/* Free objects in obstack H, including OBJ and everything allocate
../inputs/grep1.dat:10232:297013:   more recently than OBJ.  If OBJ is zero, free everything in H.  */
../inputs/grep1.dat:10233:297083:
../inputs/grep1.dat:10234:297084:#undef obstack_free
../inputs/grep1.dat:10235:297104:
../inputs/grep1.dat:10236:297105:/* This function has two names with identical definitions.
../inputs/grep1.dat:10237:297164:   This is the first one, called from non-ANSI code.  */
../inputs/grep1.dat:10238:297221:
../inputs/grep1.dat:10239:297222:void
../inputs/grep1.dat:10240:297227:_obstack_free (h, obj)
../inputs/grep1.dat:10241:297250:     struct obstack *h;
../inputs/grep1.dat:10242:297274:     POINTER obj;
../inputs/grep1.dat:10243:297292:{
../inputs/grep1.dat:10244:297294:  register struct _obstack_chunk*  lp;	/* below addr of any objects in this chunk */
../inputs/grep1.dat:10245:297379:  register struct _obstack_chunk*  plp;	/* point to previous chunk if any */
../inputs/grep1.dat:10246:297456:
../inputs/grep1.dat:10247:297457:  lp = h->chunk;
../inputs/grep1.dat:10248:297474:  /* We use >= because there cannot be an object at the beginning of a chunk.
../inputs/grep1.dat:10249:297552:     But there can be an empty object at that address
../inputs/grep1.dat:10250:297606:     at the end of another chunk.  */
../inputs/grep1.dat:10251:297644:  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
../inputs/grep1.dat:10252:297716:    {
../inputs/grep1.dat:10253:297722:      plp = lp->prev;
../inputs/grep1.dat:10254:297744:      CALL_FREEFUN (h, lp);
../inputs/grep1.dat:10255:297772:      lp = plp;
../inputs/grep1.dat:10256:297788:      /* If we switch chunks, we can't tell whether the new current
../inputs/grep1.dat:10257:297856:	 chunk contains an empty object, so assume that it may.  */
../inputs/grep1.dat:10258:297917:      h->maybe_empty_object = 1;
../inputs/grep1.dat:10259:297950:    }
../inputs/grep1.dat:10260:297956:  if (lp)
../inputs/grep1.dat:10261:297966:    {
../inputs/grep1.dat:10262:297972:      h->object_base = h->next_free = (char *)(obj);
../inputs/grep1.dat:10263:298025:      h->chunk_limit = lp->limit;
../inputs/grep1.dat:10264:298059:      h->chunk = lp;
../inputs/grep1.dat:10265:298080:    }
../inputs/grep1.dat:10266:298086:  else if (obj != 0)
../inputs/grep1.dat:10267:298107:    /* obj is not in any of the chunks! */
../inputs/grep1.dat:10268:298150:    abort ();
../inputs/grep1.dat:10269:298164:}
../inputs/grep1.dat:10270:298166:
../inputs/grep1.dat:10271:298167:/* This function is used from ANSI code.  */
../inputs/grep1.dat:10272:298212:
../inputs/grep1.dat:10273:298213:void
../inputs/grep1.dat:10274:298218:obstack_free (h, obj)
../inputs/grep1.dat:10275:298240:     struct obstack *h;
../inputs/grep1.dat:10276:298264:     POINTER obj;
../inputs/grep1.dat:10277:298282:{
../inputs/grep1.dat:10278:298284:  register struct _obstack_chunk*  lp;	/* below addr of any objects in this chunk */
../inputs/grep1.dat:10279:298369:  register struct _obstack_chunk*  plp;	/* point to previous chunk if any */
../inputs/grep1.dat:10280:298446:
../inputs/grep1.dat:10281:298447:  lp = h->chunk;
../inputs/grep1.dat:10282:298464:  /* We use >= because there cannot be an object at the beginning of a chunk.
../inputs/grep1.dat:10283:298542:     But there can be an empty object at that address
../inputs/grep1.dat:10284:298596:     at the end of another chunk.  */
../inputs/grep1.dat:10285:298634:  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
../inputs/grep1.dat:10286:298706:    {
../inputs/grep1.dat:10287:298712:      plp = lp->prev;
../inputs/grep1.dat:10288:298734:      CALL_FREEFUN (h, lp);
../inputs/grep1.dat:10289:298762:      lp = plp;
../inputs/grep1.dat:10290:298778:      /* If we switch chunks, we can't tell whether the new current
../inputs/grep1.dat:10291:298846:	 chunk contains an empty object, so assume that it may.  */
../inputs/grep1.dat:10292:298907:      h->maybe_empty_object = 1;
../inputs/grep1.dat:10293:298940:    }
../inputs/grep1.dat:10294:298946:  if (lp)
../inputs/grep1.dat:10295:298956:    {
../inputs/grep1.dat:10296:298962:      h->object_base = h->next_free = (char *)(obj);
../inputs/grep1.dat:10297:299015:      h->chunk_limit = lp->limit;
../inputs/grep1.dat:10298:299049:      h->chunk = lp;
../inputs/grep1.dat:10299:299070:    }
../inputs/grep1.dat:10300:299076:  else if (obj != 0)
../inputs/grep1.dat:10301:299097:    /* obj is not in any of the chunks! */
../inputs/grep1.dat:10302:299140:    abort ();
../inputs/grep1.dat:10303:299154:}
../inputs/grep1.dat:10304:299156:
../inputs/grep1.dat:10305:299158:#if 0
../inputs/grep1.dat:10306:299164:/* These are now turned off because the applications do not use it
../inputs/grep1.dat:10307:299231:   and it uses bcopy via obstack_grow, which causes trouble on sysV.  */
../inputs/grep1.dat:10308:299304:
../inputs/grep1.dat:10309:299305:/* Now define the functional versions of the obstack macros.
../inputs/grep1.dat:10310:299366:   Define them to simply use the corresponding macros to do the job.  */
../inputs/grep1.dat:10311:299439:
../inputs/grep1.dat:10312:299440:#ifdef __STDC__
../inputs/grep1.dat:10313:299456:/* These function definitions do not work with non-ANSI preprocessors;
../inputs/grep1.dat:10314:299527:   they won't pass through the macro names in parentheses.  */
../inputs/grep1.dat:10315:299590:
../inputs/grep1.dat:10316:299591:/* The function names appear in parentheses in order to prevent
../inputs/grep1.dat:10317:299655:   the macro-definitions of the names from being expanded there.  */
../inputs/grep1.dat:10318:299724:
../inputs/grep1.dat:10319:299725:POINTER (obstack_base) (obstack)
../inputs/grep1.dat:10320:299758:     struct obstack *obstack;
../inputs/grep1.dat:10321:299788:{
../inputs/grep1.dat:10322:299790:  return obstack_base (obstack);
../inputs/grep1.dat:10323:299823:}
../inputs/grep1.dat:10324:299825:
../inputs/grep1.dat:10325:299826:POINTER (obstack_next_free) (obstack)
../inputs/grep1.dat:10326:299864:     struct obstack *obstack;
../inputs/grep1.dat:10327:299894:{
../inputs/grep1.dat:10328:299896:  return obstack_next_free (obstack);
../inputs/grep1.dat:10329:299934:}
../inputs/grep1.dat:10330:299936:
../inputs/grep1.dat:10331:299937:int (obstack_object_size) (obstack)
../inputs/grep1.dat:10332:299973:     struct obstack *obstack;
../inputs/grep1.dat:10333:300003:{
../inputs/grep1.dat:10334:300005:  return obstack_object_size (obstack);
../inputs/grep1.dat:10335:300045:}
../inputs/grep1.dat:10336:300047:
../inputs/grep1.dat:10337:300048:int (obstack_room) (obstack)
../inputs/grep1.dat:10338:300077:     struct obstack *obstack;
../inputs/grep1.dat:10339:300107:{
../inputs/grep1.dat:10340:300109:  return obstack_room (obstack);
../inputs/grep1.dat:10341:300142:}
../inputs/grep1.dat:10342:300144:
../inputs/grep1.dat:10343:300145:void (obstack_grow) (obstack, pointer, length)
../inputs/grep1.dat:10344:300192:     struct obstack *obstack;
../inputs/grep1.dat:10345:300222:     POINTER pointer;
../inputs/grep1.dat:10346:300244:     int length;
../inputs/grep1.dat:10347:300261:{
../inputs/grep1.dat:10348:300263:  obstack_grow (obstack, pointer, length);
../inputs/grep1.dat:10349:300306:}
../inputs/grep1.dat:10350:300308:
../inputs/grep1.dat:10351:300309:void (obstack_grow0) (obstack, pointer, length)
../inputs/grep1.dat:10352:300357:     struct obstack *obstack;
../inputs/grep1.dat:10353:300387:     POINTER pointer;
../inputs/grep1.dat:10354:300409:     int length;
../inputs/grep1.dat:10355:300426:{
../inputs/grep1.dat:10356:300428:  obstack_grow0 (obstack, pointer, length);
../inputs/grep1.dat:10357:300472:}
../inputs/grep1.dat:10358:300474:
../inputs/grep1.dat:10359:300475:void (obstack_1grow) (obstack, character)
../inputs/grep1.dat:10360:300517:     struct obstack *obstack;
../inputs/grep1.dat:10361:300547:     int character;
../inputs/grep1.dat:10362:300567:{
../inputs/grep1.dat:10363:300569:  obstack_1grow (obstack, character);
../inputs/grep1.dat:10364:300607:}
../inputs/grep1.dat:10365:300609:
../inputs/grep1.dat:10366:300610:void (obstack_blank) (obstack, length)
../inputs/grep1.dat:10367:300649:     struct obstack *obstack;
../inputs/grep1.dat:10368:300679:     int length;
../inputs/grep1.dat:10369:300696:{
../inputs/grep1.dat:10370:300698:  obstack_blank (obstack, length);
../inputs/grep1.dat:10371:300733:}
../inputs/grep1.dat:10372:300735:
../inputs/grep1.dat:10373:300736:void (obstack_1grow_fast) (obstack, character)
../inputs/grep1.dat:10374:300783:     struct obstack *obstack;
../inputs/grep1.dat:10375:300813:     int character;
../inputs/grep1.dat:10376:300833:{
../inputs/grep1.dat:10377:300835:  obstack_1grow_fast (obstack, character);
../inputs/grep1.dat:10378:300878:}
../inputs/grep1.dat:10379:300880:
../inputs/grep1.dat:10380:300881:void (obstack_blank_fast) (obstack, length)
../inputs/grep1.dat:10381:300925:     struct obstack *obstack;
../inputs/grep1.dat:10382:300955:     int length;
../inputs/grep1.dat:10383:300972:{
../inputs/grep1.dat:10384:300974:  obstack_blank_fast (obstack, length);
../inputs/grep1.dat:10385:301014:}
../inputs/grep1.dat:10386:301016:
../inputs/grep1.dat:10387:301017:POINTER (obstack_finish) (obstack)
../inputs/grep1.dat:10388:301052:     struct obstack *obstack;
../inputs/grep1.dat:10389:301082:{
../inputs/grep1.dat:10390:301084:  return obstack_finish (obstack);
../inputs/grep1.dat:10391:301119:}
../inputs/grep1.dat:10392:301121:
../inputs/grep1.dat:10393:301122:POINTER (obstack_alloc) (obstack, length)
../inputs/grep1.dat:10394:301164:     struct obstack *obstack;
../inputs/grep1.dat:10395:301194:     int length;
../inputs/grep1.dat:10396:301211:{
../inputs/grep1.dat:10397:301213:  return obstack_alloc (obstack, length);
../inputs/grep1.dat:10398:301255:}
../inputs/grep1.dat:10399:301257:
../inputs/grep1.dat:10400:301258:POINTER (obstack_copy) (obstack, pointer, length)
../inputs/grep1.dat:10401:301308:     struct obstack *obstack;
../inputs/grep1.dat:10402:301338:     POINTER pointer;
../inputs/grep1.dat:10403:301360:     int length;
../inputs/grep1.dat:10404:301377:{
../inputs/grep1.dat:10405:301379:  return obstack_copy (obstack, pointer, length);
../inputs/grep1.dat:10406:301429:}
../inputs/grep1.dat:10407:301431:
../inputs/grep1.dat:10408:301432:POINTER (obstack_copy0) (obstack, pointer, length)
../inputs/grep1.dat:10409:301483:     struct obstack *obstack;
../inputs/grep1.dat:10410:301513:     POINTER pointer;
../inputs/grep1.dat:10411:301535:     int length;
../inputs/grep1.dat:10412:301552:{
../inputs/grep1.dat:10413:301554:  return obstack_copy0 (obstack, pointer, length);
../inputs/grep1.dat:10414:301605:}
../inputs/grep1.dat:10415:301607:
../inputs/grep1.dat:10416:301608:#endif /* __STDC__ */
../inputs/grep1.dat:10417:301630:
../inputs/grep1.dat:10418:301631:#endif /* 0 */
../inputs/grep1.dat:10419:301646:
../inputs/grep1.dat:10420:301647:#endif	/* _LIBC or not __GNU_LIBRARY__.  */
../inputs/grep1.dat:10421:301691:/* search.c - searching subroutines using dfa, kwset and regex for grep.
../inputs/grep1.dat:10422:301764:   Copyright (C) 1992 Free Software Foundation, Inc.
../inputs/grep1.dat:10423:301817:
../inputs/grep1.dat:10424:301818:   This program is free software; you can redistribute it and/or modify
../inputs/grep1.dat:10425:301890:   it under the terms of the GNU General Public License as published by
../inputs/grep1.dat:10426:301962:   the Free Software Foundation; either version 2, or (at your option)
../inputs/grep1.dat:10427:302033:   any later version.
../inputs/grep1.dat:10428:302055:
../inputs/grep1.dat:10429:302056:   This program is distributed in the hope that it will be useful,
../inputs/grep1.dat:10430:302123:   but WITHOUT ANY WARRANTY; without even the implied warranty of
../inputs/grep1.dat:10431:302189:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
../inputs/grep1.dat:10432:302254:   GNU General Public License for more details.
../inputs/grep1.dat:10433:302302:
../inputs/grep1.dat:10434:302303:   You should have received a copy of the GNU General Public License
../inputs/grep1.dat:10435:302372:   along with this program; if not, write to the Free Software
../inputs/grep1.dat:10436:302435:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
../inputs/grep1.dat:10437:302496:
../inputs/grep1.dat:10438:302497:   Written August 1992 by Mike Haertel. */
../inputs/grep1.dat:10439:302540:
../inputs/grep1.dat:10441:302564:
../inputs/grep1.dat:10442:302565:#ifdef STDC_HEADERS
../inputs/grep1.dat:10443:302585:#if flag_limits==0
../inputs/grep1.dat:10444:302604:#undef RE_DUP_MAX
../inputs/grep1.dat:10446:302642:#define flag_limits 1
../inputs/grep1.dat:10447:302664:#endif
../inputs/grep1.dat:10448:302671:#if flag_stdlib==0
../inputs/grep1.dat:10450:302710:#define flag_stdlib 1
../inputs/grep1.dat:10451:302732:#endif
../inputs/grep1.dat:10452:302739:#else
../inputs/grep1.dat:10453:302745:#define UCHAR_MAX 255
../inputs/grep1.dat:10454:302767:#if flag_systypes==0
../inputs/grep1.dat:10456:302811:#define flag_systypes 1
../inputs/grep1.dat:10457:302835:#endif
../inputs/grep1.dat:10458:302842:extern char *malloc();
../inputs/grep1.dat:10459:302865:#endif
../inputs/grep1.dat:10460:302872:
../inputs/grep1.dat:10461:302873:#ifdef HAVE_MEMCHR
../inputs/grep1.dat:10462:302892:#if flag_string==0
../inputs/grep1.dat:10464:302931:#define flag_string 1
../inputs/grep1.dat:10465:302953:#endif
../inputs/grep1.dat:10466:302960:#ifdef NEED_MEMORY_H
../inputs/grep1.dat:10467:302981:#if flag_memory==0
../inputs/grep1.dat:10469:303020:#define flag_memory 1
../inputs/grep1.dat:10470:303042:#endif
../inputs/grep1.dat:10471:303049:#endif
../inputs/grep1.dat:10472:303056:#else
../inputs/grep1.dat:10473:303062:#ifdef __STDC__
../inputs/grep1.dat:10474:303078:extern void *memchr();
../inputs/grep1.dat:10475:303101:#else
../inputs/grep1.dat:10476:303107:extern char *memchr();
../inputs/grep1.dat:10477:303130:#endif
../inputs/grep1.dat:10478:303137:#endif
../inputs/grep1.dat:10479:303144:
../inputs/grep1.dat:10480:303145:#if defined(HAVE_STRING_H) || defined(STDC_HEADERS)
../inputs/grep1.dat:10481:303197:#undef bcopy
../inputs/grep1.dat:10482:303210:#define bcopy(s, d, n) memcpy((d), (s), (n))
../inputs/grep1.dat:10483:303255:#endif
../inputs/grep1.dat:10484:303262:
../inputs/grep1.dat:10485:303263:#ifdef isascii
../inputs/grep1.dat:10486:303278:#define ISALNUM(C) (isascii(C) && isalnum(C))
../inputs/grep1.dat:10487:303324:#define ISUPPER(C) (isascii(C) && isupper(C))
../inputs/grep1.dat:10488:303370:#else
../inputs/grep1.dat:10489:303376:#define ISALNUM(C) isalnum(C)
../inputs/grep1.dat:10490:303406:#define ISUPPER(C) isupper(C)
../inputs/grep1.dat:10491:303436:#endif
../inputs/grep1.dat:10492:303443:
../inputs/grep1.dat:10493:303444:#define TOLOWER(C) (ISUPPER(C) ? tolower(C) : (C))
../inputs/grep1.dat:10494:303495:
../inputs/grep1.dat:10499:303585:
../inputs/grep1.dat:10500:303586:#define NCHAR (UCHAR_MAX + 1)
../inputs/grep1.dat:10501:303616:
../inputs/grep1.dat:10502:303617:#if __STDC__
../inputs/grep1.dat:10503:303630:static void Gcompile(char *, size_t);
../inputs/grep1.dat:10504:303668:static void Ecompile(char *, size_t);
../inputs/grep1.dat:10505:303706:static char *EGexecute(char *, size_t, char **);
../inputs/grep1.dat:10506:303755:static void Fcompile(char *, size_t);
../inputs/grep1.dat:10507:303793:static char *Fexecute(char *, size_t, char **);
../inputs/grep1.dat:10508:303841:#else
../inputs/grep1.dat:10509:303847:static void Gcompile();
../inputs/grep1.dat:10510:303871:static void Ecompile();
../inputs/grep1.dat:10511:303895:static char *EGexecute();
../inputs/grep1.dat:10512:303921:static void Fcompile();
../inputs/grep1.dat:10513:303945:static char *Fexecute();
../inputs/grep1.dat:10514:303970:#endif
../inputs/grep1.dat:10515:303977:
../inputs/grep1.dat:10516:303978:/* Here is the matchers vector for the main program. */
../inputs/grep1.dat:10517:304034:struct matcher matchers[] = {
../inputs/grep1.dat:10518:304064:  { "default", Gcompile, EGexecute },
../inputs/grep1.dat:10519:304102:  { "grep", Gcompile, EGexecute },
../inputs/grep1.dat:10520:304137:  { "ggrep", Gcompile, EGexecute },
../inputs/grep1.dat:10521:304173:  { "egrep", Ecompile, EGexecute },
../inputs/grep1.dat:10522:304209:  { "posix-egrep", Ecompile, EGexecute },
../inputs/grep1.dat:10523:304251:  { "gegrep", Ecompile, EGexecute },
../inputs/grep1.dat:10524:304288:  { "fgrep", Fcompile, Fexecute },
../inputs/grep1.dat:10525:304323:  { "gfgrep", Fcompile, Fexecute },
../inputs/grep1.dat:10526:304359:  { 0, 0, 0 },
../inputs/grep1.dat:10527:304374:};
../inputs/grep1.dat:10528:304377:
../inputs/grep1.dat:10529:304378:/* For -w, we also consider _ to be word constituent.  */
../inputs/grep1.dat:10530:304436:#define WCHAR(C) (ISALNUM(C) || (C) == '_')
../inputs/grep1.dat:10531:304480:
../inputs/grep1.dat:10532:304481:/* DFA compiled regexp. */
../inputs/grep1.dat:10533:304508:static struct dfa dfa_1;
../inputs/grep1.dat:10534:304533:
../inputs/grep1.dat:10535:304534:/* Regex compiled regexp. */
../inputs/grep1.dat:10536:304563:static struct re_pattern_buffer regex;
../inputs/grep1.dat:10537:304602:
../inputs/grep1.dat:10538:304603:/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
../inputs/grep1.dat:10539:304669:   a list of strings, at least one of which is known to occur in
../inputs/grep1.dat:10540:304734:   any string matching the regexp. */
../inputs/grep1.dat:10541:304772:static kwset_t kwset;
../inputs/grep1.dat:10542:304794:
../inputs/grep1.dat:10543:304795:/* Last compiled fixed string known to exactly match the regexp.
../inputs/grep1.dat:10544:304860:   If kwsexec() returns < lastexact, then we don't need to
../inputs/grep1.dat:10545:304919:   call the regexp matcher at all. */
../inputs/grep1.dat:10546:304957:static int lastexact;
../inputs/grep1.dat:10547:304979:
../inputs/grep1.dat:10548:304980:void
../inputs/grep1.dat:10549:304985:dfaerror(mesg)
../inputs/grep1.dat:10550:305000:     char *mesg;
../inputs/grep1.dat:10551:305017:{
../inputs/grep1.dat:10552:305019:  fatal(mesg, 0);
../inputs/grep1.dat:10553:305037:}
../inputs/grep1.dat:10554:305039:
../inputs/grep1.dat:10555:305040:static void
../inputs/grep1.dat:10556:305052:kwsinit()
../inputs/grep1.dat:10557:305062:{
../inputs/grep1.dat:10558:305064:  static char trans[NCHAR];
../inputs/grep1.dat:10559:305092:  int i;
../inputs/grep1.dat:10560:305101:
../inputs/grep1.dat:10561:305102:  if (match_icase)
../inputs/grep1.dat:10562:305121:    for (i = 0; i < NCHAR; ++i)
../inputs/grep1.dat:10563:305153:      trans[i] = TOLOWER(i);
../inputs/grep1.dat:10564:305182:
../inputs/grep1.dat:10565:305183:  if (!(kwset = kwsalloc(match_icase ? trans : (char *) 0)))
../inputs/grep1.dat:10566:305244:    fatal("memory exhausted", 0);
../inputs/grep1.dat:10567:305278:}  
../inputs/grep1.dat:10568:305282:
../inputs/grep1.dat:10569:305283:/* If the DFA turns out to have some set of fixed strings one of
../inputs/grep1.dat:10570:305348:   which must occur in the match, then we build a kwset matcher
../inputs/grep1.dat:10571:305412:   to find those strings, and thus quickly filter out impossible
../inputs/grep1.dat:10572:305477:   matches. */
../inputs/grep1.dat:10573:305492:static void
../inputs/grep1.dat:10574:305504:kwsmusts()
../inputs/grep1.dat:10575:305515:{
../inputs/grep1.dat:10576:305517:  struct dfamust *dm;
../inputs/grep1.dat:10577:305539:  char *err;
../inputs/grep1.dat:10578:305552:
../inputs/grep1.dat:10579:305553:  if (dfa_1.musts)
../inputs/grep1.dat:10580:305572:    {
../inputs/grep1.dat:10581:305578:      kwsinit();
../inputs/grep1.dat:10582:305595:      /* First, we compile in the substrings known to be exact
../inputs/grep1.dat:10583:305658:	 matches.  The kwset matcher will return the index
../inputs/grep1.dat:10584:305710:	 of the matching string that it chooses. */
../inputs/grep1.dat:10585:305755:      for (dm = dfa_1.musts; dm; dm = dm->next)
../inputs/grep1.dat:10586:305803:	{
../inputs/grep1.dat:10587:305806:	  if (!dm->exact)
../inputs/grep1.dat:10588:305825:	    continue;
../inputs/grep1.dat:10589:305840:	  ++lastexact;
../inputs/grep1.dat:10590:305856:	  if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0)
../inputs/grep1.dat:10591:305920:	    fatal(err, 0);
../inputs/grep1.dat:10592:305940:	}
../inputs/grep1.dat:10593:305943:      /* Now, we compile the substrings that will require
../inputs/grep1.dat:10594:306001:	 the use of the regexp matcher.  */
../inputs/grep1.dat:10595:306038:      for (dm = dfa_1.musts; dm; dm = dm->next)
../inputs/grep1.dat:10596:306086:	{
../inputs/grep1.dat:10597:306089:	  if (dm->exact)
../inputs/grep1.dat:10598:306107:	    continue;
../inputs/grep1.dat:10599:306122:	  if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0)
../inputs/grep1.dat:10600:306186:	    fatal(err, 0);
../inputs/grep1.dat:10601:306206:	}
../inputs/grep1.dat:10602:306209:      if ((err = kwsprep(kwset)) != 0)
../inputs/grep1.dat:10603:306248:	fatal(err, 0);
../inputs/grep1.dat:10604:306264:    }
../inputs/grep1.dat:10605:306270:}
../inputs/grep1.dat:10606:306272:
../inputs/grep1.dat:10607:306273:static void
../inputs/grep1.dat:10608:306285:Gcompile(pattern, size)
../inputs/grep1.dat:10609:306309:     char *pattern;
../inputs/grep1.dat:10610:306329:     size_t size;
../inputs/grep1.dat:10611:306347:{
../inputs/grep1.dat:10612:306349:#ifdef __STDC__
../inputs/grep1.dat:10613:306365:  const
../inputs/grep1.dat:10614:306373:#endif
../inputs/grep1.dat:10615:306380:  char *err;
../inputs/grep1.dat:10616:306393:
../inputs/grep1.dat:10617:306394:  re_set_syntax(RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
../inputs/grep1.dat:10618:306454:  dfasyntax(RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE, match_icase);
../inputs/grep1.dat:10619:306523:
../inputs/grep1.dat:10620:306524:  if ((err = re_compile_pattern(pattern, size, &regex)) != 0)
../inputs/grep1.dat:10621:306586:    fatal(err, 0);
../inputs/grep1.dat:10622:306605:
../inputs/grep1.dat:10623:306606:  dfainit(&dfa_1);
../inputs/grep1.dat:10624:306625:
../inputs/grep1.dat:10625:306626:  /* In the match_words and match_lines cases, we use a different pattern
../inputs/grep1.dat:10626:306700:     for the DFA matcher that will quickly throw out cases that won't work.
../inputs/grep1.dat:10627:306776:     Then if DFA succeeds we do some hairy stuff using the regex matcher
../inputs/grep1.dat:10628:306849:     to decide whether the match should really count. */
../inputs/grep1.dat:10629:306906:  if (match_words || match_lines)
../inputs/grep1.dat:10630:306940:    {
../inputs/grep1.dat:10631:306946:      /* In the whole-word case, we use the pattern:
../inputs/grep1.dat:10632:306999:	 (^|[^A-Za-z_])(userpattern)([^A-Za-z_]|$).
../inputs/grep1.dat:10633:307044:	 In the whole-line case, we use the pattern:
../inputs/grep1.dat:10634:307090:	 ^(userpattern)$.
../inputs/grep1.dat:10635:307109:	 BUG: Using [A-Za-z_] is locale-dependent!  */
../inputs/grep1.dat:10636:307157:
../inputs/grep1.dat:10637:307158:      char *n = malloc(size + 50);
../inputs/grep1.dat:10638:307193:      int i = 0;
../inputs/grep1.dat:10639:307210:
../inputs/grep1.dat:10640:307211:      strcpy(n, "");
../inputs/grep1.dat:10641:307232:
../inputs/grep1.dat:10642:307233:      if (match_lines)
../inputs/grep1.dat:10643:307256:	strcpy(n, "^\\(");
../inputs/grep1.dat:10644:307276:      if (match_words)
../inputs/grep1.dat:10645:307299:	strcpy(n, "\\(^\\|[^0-9A-Za-z_]\\)\\(");
../inputs/grep1.dat:10646:307341:
../inputs/grep1.dat:10647:307342:      i = strlen(n);
../inputs/grep1.dat:10648:307363:      bcopy(pattern, n + i, size);
../inputs/grep1.dat:10649:307398:      i += size;
../inputs/grep1.dat:10650:307415:
../inputs/grep1.dat:10651:307416:      if (match_words)
../inputs/grep1.dat:10652:307439:	strcpy(n + i, "\\)\\([^0-9A-Za-z_]\\|$\\)");
../inputs/grep1.dat:10653:307485:      if (match_lines)
../inputs/grep1.dat:10654:307508:	strcpy(n + i, "\\)$");
../inputs/grep1.dat:10655:307532:
../inputs/grep1.dat:10656:307533:      i += strlen(n + i);
../inputs/grep1.dat:10657:307559:      dfacomp(n, i, &dfa_1, 1);
../inputs/grep1.dat:10658:307591:    }
../inputs/grep1.dat:10659:307597:  else
../inputs/grep1.dat:10660:307604:    dfacomp(pattern, size, &dfa_1, 1);
../inputs/grep1.dat:10661:307643:
../inputs/grep1.dat:10662:307644:  kwsmusts();
../inputs/grep1.dat:10663:307658:}
../inputs/grep1.dat:10664:307660:
../inputs/grep1.dat:10665:307661:static void
../inputs/grep1.dat:10666:307673:Ecompile(pattern, size)
../inputs/grep1.dat:10667:307697:     char *pattern;
../inputs/grep1.dat:10668:307717:     size_t size;
../inputs/grep1.dat:10669:307735:{
../inputs/grep1.dat:10670:307737:#ifdef __STDC__
../inputs/grep1.dat:10671:307753:  const
../inputs/grep1.dat:10672:307761:#endif
../inputs/grep1.dat:10673:307768:  char *err;
../inputs/grep1.dat:10674:307781:
../inputs/grep1.dat:10675:307782:  if (strcmp(matcher, "posix-egrep") == 0)
../inputs/grep1.dat:10676:307825:    {
../inputs/grep1.dat:10677:307831:      re_set_syntax(RE_SYNTAX_POSIX_EGREP);
../inputs/grep1.dat:10678:307875:      dfasyntax(RE_SYNTAX_POSIX_EGREP, match_icase);
../inputs/grep1.dat:10679:307928:    }
../inputs/grep1.dat:10680:307934:  else
../inputs/grep1.dat:10681:307941:    {
../inputs/grep1.dat:10682:307947:      re_set_syntax(RE_SYNTAX_EGREP);
../inputs/grep1.dat:10683:307985:      dfasyntax(RE_SYNTAX_EGREP, match_icase);
../inputs/grep1.dat:10684:308032:    }
../inputs/grep1.dat:10685:308038:
../inputs/grep1.dat:10686:308039:  if ((err = re_compile_pattern(pattern, size, &regex)) != 0)
../inputs/grep1.dat:10687:308101:    fatal(err, 0);
../inputs/grep1.dat:10688:308120:
../inputs/grep1.dat:10689:308121:  dfainit(&dfa_1);
../inputs/grep1.dat:10690:308140:
../inputs/grep1.dat:10691:308141:  /* In the match_words and match_lines cases, we use a different pattern
../inputs/grep1.dat:10692:308215:     for the DFA matcher that will quickly throw out cases that won't work.
../inputs/grep1.dat:10693:308291:     Then if DFA succeeds we do some hairy stuff using the regex matcher
../inputs/grep1.dat:10694:308364:     to decide whether the match should really count. */
../inputs/grep1.dat:10695:308421:  if (match_words || match_lines)
../inputs/grep1.dat:10696:308455:    {
../inputs/grep1.dat:10697:308461:      /* In the whole-word case, we use the pattern:
../inputs/grep1.dat:10698:308514:	 (^|[^A-Za-z_])(userpattern)([^A-Za-z_]|$).
../inputs/grep1.dat:10699:308559:	 In the whole-line case, we use the pattern:
../inputs/grep1.dat:10700:308605:	 ^(userpattern)$.
../inputs/grep1.dat:10701:308624:	 BUG: Using [A-Za-z_] is locale-dependent!  */
../inputs/grep1.dat:10702:308672:
../inputs/grep1.dat:10703:308673:      char *n = malloc(size + 50);
../inputs/grep1.dat:10704:308708:      int i = 0;
../inputs/grep1.dat:10705:308725:
../inputs/grep1.dat:10706:308726:      strcpy(n, "");
../inputs/grep1.dat:10707:308747:
../inputs/grep1.dat:10708:308748:      if (match_lines)
../inputs/grep1.dat:10709:308771:	strcpy(n, "^(");
../inputs/grep1.dat:10710:308789:      if (match_words)
../inputs/grep1.dat:10711:308812:	strcpy(n, "(^|[^0-9A-Za-z_])(");
../inputs/grep1.dat:10712:308846:
../inputs/grep1.dat:10713:308847:      i = strlen(n);
../inputs/grep1.dat:10714:308868:      bcopy(pattern, n + i, size);
../inputs/grep1.dat:10715:308903:      i += size;
../inputs/grep1.dat:10716:308920:
../inputs/grep1.dat:10717:308921:      if (match_words)
../inputs/grep1.dat:10718:308944:	strcpy(n + i, ")([^0-9A-Za-z_]|$)");
../inputs/grep1.dat:10719:308982:      if (match_lines)
../inputs/grep1.dat:10720:309005:	strcpy(n + i, ")$");
../inputs/grep1.dat:10721:309027:
../inputs/grep1.dat:10722:309028:      i += strlen(n + i);
../inputs/grep1.dat:10723:309054:      dfacomp(n, i, &dfa_1, 1);
../inputs/grep1.dat:10724:309086:    }
../inputs/grep1.dat:10725:309092:  else
../inputs/grep1.dat:10726:309099:    dfacomp(pattern, size, &dfa_1, 1);
../inputs/grep1.dat:10727:309138:
../inputs/grep1.dat:10728:309139:  kwsmusts();
../inputs/grep1.dat:10729:309153:}
../inputs/grep1.dat:10730:309155:
../inputs/grep1.dat:10731:309156:static char *
../inputs/grep1.dat:10732:309170:EGexecute(buf, size, endp)
../inputs/grep1.dat:10733:309197:     char *buf;
../inputs/grep1.dat:10734:309213:     size_t size;
../inputs/grep1.dat:10735:309231:     char **endp;
../inputs/grep1.dat:10736:309249:{
../inputs/grep1.dat:10737:309251:  register char *buflim, *beg, *end, save;
../inputs/grep1.dat:10738:309294:  int backref, start, len;
../inputs/grep1.dat:10739:309321:  struct kwsmatch kwsm;
../inputs/grep1.dat:10740:309345:  static struct re_registers regs; /* This is static on account of a BRAIN-DEAD
../inputs/grep1.dat:10741:309425:				    Q@#%!# library interface in regex.c.  */
../inputs/grep1.dat:10742:309474:
../inputs/grep1.dat:10743:309475:  buflim = buf + size;
../inputs/grep1.dat:10744:309498:
../inputs/grep1.dat:10745:309499:  for (beg = end = buf; end < buflim; beg = end + 1)
../inputs/grep1.dat:10746:309552:    {
../inputs/grep1.dat:10747:309558:      if (kwset)
../inputs/grep1.dat:10748:309575:	{
../inputs/grep1.dat:10749:309578:	  /* Find a possible match using the KWset matcher. */
../inputs/grep1.dat:10750:309634:	  beg = kwsexec(kwset, beg, buflim - beg, &kwsm);
../inputs/grep1.dat:10751:309685:	  if (!beg)
../inputs/grep1.dat:10752:309698:	    goto failure;
../inputs/grep1.dat:10753:309717:	  /* Narrow down to the line containing the candidate, and
../inputs/grep1.dat:10754:309777:	     run it through DFA. */
../inputs/grep1.dat:10755:309806:	  end = memchr(beg, '\n', buflim - beg);
../inputs/grep1.dat:10756:309848:	  if (!end)
../inputs/grep1.dat:10757:309861:	    end = buflim;
../inputs/grep1.dat:10758:309880:	  while (beg > buf && beg[-1] != '\n')
../inputs/grep1.dat:10759:309920:	    --beg;
../inputs/grep1.dat:10760:309932:	  save = *end;
../inputs/grep1.dat:10761:309948:	  if (kwsm.index < lastexact)
../inputs/grep1.dat:10762:309979:	    goto success;
../inputs/grep1.dat:10763:309998:	  if (!dfaexec(&dfa_1, beg, end, 0, (int *) 0, &backref))
../inputs/grep1.dat:10764:310057:	    {
../inputs/grep1.dat:10765:310064:	      *end = save;
../inputs/grep1.dat:10766:310084:	      continue;
../inputs/grep1.dat:10767:310101:	    }
../inputs/grep1.dat:10768:310108:	  *end = save;
../inputs/grep1.dat:10769:310124:	  /* Successful, no backreferences encountered. */
../inputs/grep1.dat:10770:310176:	  if (!backref)
../inputs/grep1.dat:10771:310193:	    goto success;
../inputs/grep1.dat:10772:310212:	}
../inputs/grep1.dat:10773:310215:      else
../inputs/grep1.dat:10774:310226:	{
../inputs/grep1.dat:10775:310229:	  /* No good fixed strings; start with DFA. */
../inputs/grep1.dat:10776:310277:	  save = *buflim;
../inputs/grep1.dat:10777:310296:	  beg = dfaexec(&dfa_1, beg, buflim, 0, (int *) 0, &backref);
../inputs/grep1.dat:10778:310359:	  *buflim = save;
../inputs/grep1.dat:10779:310378:	  if (!beg)
../inputs/grep1.dat:10780:310391:	    goto failure;
../inputs/grep1.dat:10781:310410:	  /* Narrow down to the line we've found. */
../inputs/grep1.dat:10782:310456:	  end = memchr(beg, '\n', buflim - beg);
../inputs/grep1.dat:10783:310498:	  if (!end)
../inputs/grep1.dat:10784:310511:	    end = buflim;
../inputs/grep1.dat:10785:310530:	  while (beg > buf && beg[-1] != '\n')
../inputs/grep1.dat:10786:310570:	    --beg;
../inputs/grep1.dat:10787:310582:	  /* Successful, no backreferences encountered! */
../inputs/grep1.dat:10788:310634:	  if (!backref)
../inputs/grep1.dat:10789:310651:	    goto success;
../inputs/grep1.dat:10790:310670:	}
../inputs/grep1.dat:10791:310673:      /* If we've made it to this point, this means DFA has seen
../inputs/grep1.dat:10792:310738:	 a probable match, and we need to run it through Regex. */
../inputs/grep1.dat:10793:310798:      regex.not_eol = 0;
../inputs/grep1.dat:10794:310823:      if ((start = re_search(&regex, beg, end - beg, 0, end - beg, &regs)) >= 0)
../inputs/grep1.dat:10795:310904:	{
../inputs/grep1.dat:10796:310907:	  len = regs.end[0] - start;
../inputs/grep1.dat:10797:310937:	  if (!match_lines && !match_words || match_lines && len == end - beg)
../inputs/grep1.dat:10798:311009:	    goto success;
../inputs/grep1.dat:10799:311028:	  /* If -w, check if the match aligns with word boundaries.
../inputs/grep1.dat:10800:311089:	     We do this iteratively because:
../inputs/grep1.dat:10801:311127:	     (a) the line may contain more than one occurence of the pattern, and
../inputs/grep1.dat:10802:311202:	     (b) Several alternatives in the pattern might be valid at a given
../inputs/grep1.dat:10803:311274:	     point, and we may need to consider a shorter one to find a word
../inputs/grep1.dat:10804:311344:	     boundary. */
../inputs/grep1.dat:10805:311363:	  if (match_words)
../inputs/grep1.dat:10806:311383:	    while (start >= 0)
../inputs/grep1.dat:10807:311407:	      {
../inputs/grep1.dat:10808:311416:		if ((start == 0 || !WCHAR(beg[start - 1]))
../inputs/grep1.dat:10809:311461:		    && (len == end - beg || !WCHAR(beg[start + len])))
../inputs/grep1.dat:10810:311518:		  goto success;
../inputs/grep1.dat:10811:311536:		if (len > 0)
../inputs/grep1.dat:10812:311551:		  {
../inputs/grep1.dat:10813:311557:		    /* Try a shorter length anchored at the same place. */
../inputs/grep1.dat:10814:311618:		    --len;
../inputs/grep1.dat:10815:311631:		    regex.not_eol = 1;
../inputs/grep1.dat:10816:311656:		    len = re_match(&regex, beg, start + len, start, &regs);
../inputs/grep1.dat:10817:311718:		  }
../inputs/grep1.dat:10818:311724:		if (len <= 0)
../inputs/grep1.dat:10819:311740:		  {
../inputs/grep1.dat:10820:311746:		    /* Try looking further on. */
../inputs/grep1.dat:10821:311782:		    if (start == end - beg)
../inputs/grep1.dat:10822:311812:		      break;
../inputs/grep1.dat:10823:311827:		    ++start;
../inputs/grep1.dat:10824:311842:		    regex.not_eol = 0;
../inputs/grep1.dat:10825:311867:		    start = re_search(&regex, beg, end - beg,
../inputs/grep1.dat:10826:311915:				      start, end - beg - start, &regs);
../inputs/grep1.dat:10827:311959:		    len = regs.end[0] - start;
../inputs/grep1.dat:10828:311992:		  }
../inputs/grep1.dat:10829:311998:	      }
../inputs/grep1.dat:10830:312007:	}
../inputs/grep1.dat:10831:312010:    }
../inputs/grep1.dat:10832:312016:
../inputs/grep1.dat:10833:312017: failure:
../inputs/grep1.dat:10834:312027:  return 0;
../inputs/grep1.dat:10835:312039:
../inputs/grep1.dat:10836:312040: success:
../inputs/grep1.dat:10837:312050:  *endp = end < buflim ? end + 1 : end;
../inputs/grep1.dat:10838:312090:  return beg;
../inputs/grep1.dat:10839:312104:}
../inputs/grep1.dat:10840:312106:
../inputs/grep1.dat:10841:312107:static void
../inputs/grep1.dat:10842:312119:Fcompile(pattern, size)
../inputs/grep1.dat:10843:312143:     char *pattern;
../inputs/grep1.dat:10844:312163:     size_t size;
../inputs/grep1.dat:10845:312181:{
../inputs/grep1.dat:10846:312183:  char *beg, *lim, *err;
../inputs/grep1.dat:10847:312208:
../inputs/grep1.dat:10848:312209:  kwsinit();
../inputs/grep1.dat:10849:312222:  beg = pattern;
../inputs/grep1.dat:10850:312239:  do
../inputs/grep1.dat:10851:312244:    {
../inputs/grep1.dat:10852:312250:      for (lim = beg; lim < pattern + size && *lim != '\n'; ++lim)
../inputs/grep1.dat:10853:312317:	;
../inputs/grep1.dat:10854:312320:      if ((err = kwsincr(kwset, beg, lim - beg)) != 0)
../inputs/grep1.dat:10855:312375:	fatal(err, 0);
../inputs/grep1.dat:10856:312391:      if (lim < pattern + size)
../inputs/grep1.dat:10857:312423:	++lim;
../inputs/grep1.dat:10858:312431:      beg = lim;
../inputs/grep1.dat:10859:312448:    }
../inputs/grep1.dat:10860:312454:  while (beg < pattern + size);
../inputs/grep1.dat:10861:312486:
../inputs/grep1.dat:10862:312487:  if ((err = kwsprep(kwset)) != 0)
../inputs/grep1.dat:10863:312522:    fatal(err, 0);
../inputs/grep1.dat:10864:312541:}
../inputs/grep1.dat:10865:312543:
../inputs/grep1.dat:10866:312544:static char *
../inputs/grep1.dat:10867:312558:Fexecute(buf, size, endp)
../inputs/grep1.dat:10868:312584:     char *buf;
../inputs/grep1.dat:10869:312600:     size_t size;
../inputs/grep1.dat:10870:312618:     char **endp;
../inputs/grep1.dat:10871:312636:{
../inputs/grep1.dat:10872:312638:  register char *beg, *try, *end;
../inputs/grep1.dat:10873:312672:  register size_t len;
../inputs/grep1.dat:10874:312695:  struct kwsmatch kwsmatch;
../inputs/grep1.dat:10875:312723:
../inputs/grep1.dat:10876:312724:  for (beg = buf; beg <= buf + size; ++beg)
../inputs/grep1.dat:10877:312768:    {
../inputs/grep1.dat:10878:312774:      if (!(beg = kwsexec(kwset, beg, buf + size - beg, &kwsmatch)))
../inputs/grep1.dat:10879:312843:	return 0;
../inputs/grep1.dat:10880:312854:      len = kwsmatch.size[0];
../inputs/grep1.dat:10881:312884:      if (match_lines)
../inputs/grep1.dat:10882:312907:	{
../inputs/grep1.dat:10883:312910:	  if (beg > buf && beg[-1] != '\n')
../inputs/grep1.dat:10884:312947:	    continue;
../inputs/grep1.dat:10885:312962:	  if (beg + len < buf + size && beg[len] != '\n')
../inputs/grep1.dat:10886:313013:	    continue;
../inputs/grep1.dat:10887:313028:	  goto success;
../inputs/grep1.dat:10888:313045:	}
../inputs/grep1.dat:10889:313048:      else if (match_words)
../inputs/grep1.dat:10890:313076:	for (try = beg; len && try;)
../inputs/grep1.dat:10891:313106:	  {
../inputs/grep1.dat:10892:313111:	    if (try > buf && WCHAR((unsigned char) try[-1]))
../inputs/grep1.dat:10893:313165:	      break;
../inputs/grep1.dat:10894:313179:	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
../inputs/grep1.dat:10895:313247:	      {
../inputs/grep1.dat:10896:313256:		try = kwsexec(kwset, beg, --len, &kwsmatch);
../inputs/grep1.dat:10897:313303:		len = kwsmatch.size[0];
../inputs/grep1.dat:10898:313329:	      }
../inputs/grep1.dat:10899:313338:	    else
../inputs/grep1.dat:10900:313348:	      goto success;
../inputs/grep1.dat:10901:313369:	  }
../inputs/grep1.dat:10902:313374:      else
../inputs/grep1.dat:10903:313385:	goto success;
../inputs/grep1.dat:10904:313400:    }
../inputs/grep1.dat:10905:313406:
../inputs/grep1.dat:10906:313407:  return 0;
../inputs/grep1.dat:10907:313419:
../inputs/grep1.dat:10908:313420: success:
../inputs/grep1.dat:10909:313430:  if ((end = memchr(beg + len, '\n', (buf + size) - (beg + len))) != 0)
../inputs/grep1.dat:10910:313502:    ++end;
../inputs/grep1.dat:10911:313513:  else
../inputs/grep1.dat:10912:313520:    end = buf + size;
../inputs/grep1.dat:10913:313542:  *endp = end;
../inputs/grep1.dat:10914:313557:  while (beg > buf && beg[-1] != '\n')
../inputs/grep1.dat:10915:313596:    --beg;
../inputs/grep1.dat:10916:313607:  return beg;
../inputs/grep1.dat:10917:313621:}
../inputs/grep1.dat:10918:313623:
../inputs/grep1.dat:10919:313624:if (out)
../inputs/grep1.dat:10920:313633:if (gout)
../inputs/grep1.dat:10921:313643:if (gsth)
../inputs/grep1.dat:10922:313653:if out
../inputs/grep1.dat:10923:313660:if gout
../inputs/grep1.dat:10924:313668:if agout
../inputs/grep1.dat:10925:313677:if agout end = buf + size;
../inputs/grep1.dat:10926:313704:if aout
../inputs/grep1.dat:10927:313712:if ag
../inputs/grep1.dat:10928:313718:if g
../inputs/grep1.dat:10929:313723:if a
../inputs/grep1.dat:10930:313728:
../inputs/grep1.dat:10931:313729:swswsif (out)
../inputs/grep1.dat:10932:313743:wwif (gout)
../inputs/grep1.dat:10933:313755:wssif (gsth)
../inputs/grep1.dat:10934:313768:wswswsif out
../inputs/grep1.dat:10935:313781:3if gout
../inputs/grep1.dat:10936:313790:wsif agout
../inputs/grep1.dat:10937:313801:3eif agout end = buf + size;
../inputs/grep1.dat:10938:313830:dseif aout
../inputs/grep1.dat:10939:313841:dsif ag
../inputs/grep1.dat:10940:313849:isxsif g
../inputs/grep1.dat:10941:313858:xxsxif awwsw
../inputs/grep1.dat:10942:313871:
../inputs/grep1.dat:10943:313872:swswsif (out)fvvfvf
../inputs/grep1.dat:10944:313892:wwif (gout)
../inputs/grep1.dat:10945:313904:wssif (gsth)
../inputs/grep1.dat:10946:313917:wswswsif outvfvf
../inputs/grep1.dat:10947:313934:3if goutfvf
../inputs/grep1.dat:10948:313946:wsif agoutvfv
../inputs/grep1.dat:10949:313960:3eif agoutvf end = buf + size;
../inputs/grep1.dat:10950:313991:dseif aoutvfv
../inputs/grep1.dat:10951:314005:dsif agvff
../inputs/grep1.dat:10952:314016:isxsif gvfv
../inputs/grep1.dat:10953:314028:xxsxif awwsw
../inputs/grep1.dat:10954:314041:
../inputs/grep1.dat:10955:314042:s  if (out)
../inputs/grep1.dat:10956:314054:    if (gout)
../inputs/grep1.dat:10957:314068: sds if (gsth)
../inputs/grep1.dat:10958:314083:  if out
../inputs/grep1.dat:10959:314092:dc if gout
../inputs/grep1.dat:10960:314103:dv if agout
../inputs/grep1.dat:10961:314115:argue if agout end = buf + size;
../inputs/grep1.dat:10962:314148:  if aout
../inputs/grep1.dat:10963:314158:          if ag
../inputs/grep1.dat:10964:314174:  argue if g
../inputs/grep1.dat:10965:314187: if a