../inputs/grep0.dat:        : next_backslash && next_next && *next_next == ')')
../inputs/grep1.dat:#define MAX(A,B) ((A) > (B) ? (A) : (B))
../inputs/grep1.dat:#define strerror(E) ((E) < sys_nerr ? sys_errlist[(E)] : "bogus error number")
../inputs/grep1.dat:    fprintf(stderr, "%s: %s: %s\n", prog, mesg, strerror(errnum));
../inputs/grep1.dat:    fprintf(stderr, "%s: %s\n", prog, mesg);
../inputs/grep1.dat:	  fprintf(stderr, "%s: warning: %s: %s\n", filename,
../inputs/grep1.dat:    tryread:
../inputs/grep1.dat:      bp = lastout ? lastout : bufbeg;
../inputs/grep1.dat:	    prline(p, nl, ':');
../inputs/grep1.dat:      prline(beg, lim, ':');
../inputs/grep1.dat:  "usage: %s [-[[AB] ]<num>] [-[CEFGVchilnqsvwx]] [-[ef]] <expr> [<files...>]\n"
../inputs/grep1.dat:  while ((opt = getopt(argc, argv, "0123456789A:B:CEFGVX:bce:f:hiLlnqsvwxy"))
../inputs/grep1.dat:      case '0':
../inputs/grep1.dat:      case '1':
../inputs/grep1.dat:      case '2':
../inputs/grep1.dat:      case '3':
../inputs/grep1.dat:      case '4':
../inputs/grep1.dat:      case '5':
../inputs/grep1.dat:      case '6':
../inputs/grep1.dat:      case '7':
../inputs/grep1.dat:      case '8':
../inputs/grep1.dat:      case '9':
../inputs/grep1.dat:      case 'A':
../inputs/grep1.dat:      case 'B':
../inputs/grep1.dat:      case 'C':
../inputs/grep1.dat:      case 'E':
../inputs/grep1.dat:      case 'F':
../inputs/grep1.dat:      case 'G':
../inputs/grep1.dat:      case 'V':
../inputs/grep1.dat:      case 'X':
../inputs/grep1.dat:      case 'b':
../inputs/grep1.dat:      case 'c':
../inputs/grep1.dat:      case 'e':
../inputs/grep1.dat:      case 'f':
../inputs/grep1.dat:	fp = strcmp(optarg, "-") != 0 ? fopen(optarg, "r") : stdin;
../inputs/grep1.dat:      case 'h':
../inputs/grep1.dat:      case 'i':
../inputs/grep1.dat:      case 'y':			/* For old-timers . . . */
../inputs/grep1.dat:      case 'L':
../inputs/grep1.dat:      case 'l':
../inputs/grep1.dat:      case 'n':
../inputs/grep1.dat:      case 'q':
../inputs/grep1.dat:      case 's':
../inputs/grep1.dat:      case 'v':
../inputs/grep1.dat:      case 'w':
../inputs/grep1.dat:      case 'x':
../inputs/grep1.dat:      default:
../inputs/grep1.dat:	desc = strcmp(argv[optind], "-") ? open(argv[optind], O_RDONLY) : 0;
../inputs/grep1.dat:	    filename = desc == 0 ? "(standard input)" : argv[optind];
../inputs/grep1.dat:		  printf("%s:", filename);
../inputs/grep1.dat:  exit(errseen ? 2 : status);
../inputs/grep1.dat:   NOTE: getopt is now part of the C library, so if you don't know what
../inputs/grep1.dat:	    fprintf (stderr, "%s: option `%s' is ambiguous\n",
../inputs/grep1.dat:				 "%s: option `--%s' doesn't allow an argument\n",
../inputs/grep1.dat:			     "%s: option `%c%s' doesn't allow an argument\n",
../inputs/grep1.dat:		    fprintf (stderr, "%s: option `%s' requires an argument\n",
../inputs/grep1.dat:		  return optstring[0] == ':' ? ':' : '?';
../inputs/grep1.dat:		fprintf (stderr, "%s: unrecognized option `--%s'\n",
../inputs/grep1.dat:		fprintf (stderr, "%s: unrecognized option `%c%s'\n",
../inputs/grep1.dat:    if (temp == NULL || c == ':')
../inputs/grep1.dat:	      fprintf (stderr, "%s: unrecognized option, character code 0%o\n",
../inputs/grep1.dat:	      fprintf (stderr, "%s: unrecognized option `-%c'\n", argv[0], c);
../inputs/grep1.dat:	    fprintf (stderr, "%s: illegal option -- %c\n", argv[0], c);
../inputs/grep1.dat:    if (temp[1] == ':')
../inputs/grep1.dat:	if (temp[2] == ':')
../inputs/grep1.dat:		    fprintf (stderr, "%s: option `-%c' requires an argument\n",
../inputs/grep1.dat:		    fprintf (stderr, "%s: option requires an argument -- %c\n",
../inputs/grep1.dat:		if (optstring[0] == ':')
../inputs/grep1.dat:		  c = ':';
../inputs/grep1.dat:      int this_option_optind = optind ? optind : 1;
../inputs/grep1.dat:      c = getopt (argc, argv, "abc:d:0123456789");
../inputs/grep1.dat:	case '0':
../inputs/grep1.dat:	case '1':
../inputs/grep1.dat:	case '2':
../inputs/grep1.dat:	case '3':
../inputs/grep1.dat:	case '4':
../inputs/grep1.dat:	case '5':
../inputs/grep1.dat:	case '6':
../inputs/grep1.dat:	case '7':
../inputs/grep1.dat:	case '8':
../inputs/grep1.dat:	case '9':
../inputs/grep1.dat:	case 'a':
../inputs/grep1.dat:	case 'b':
../inputs/grep1.dat:	case 'c':
../inputs/grep1.dat:	case '?':
../inputs/grep1.dat:	default:
../inputs/grep1.dat:      printf ("non-option ARGV-elements: ");
../inputs/grep1.dat:/* Jim Meyering writes:
../inputs/grep1.dat:#define MAX(a, b) ((a) > (b) ? (a) : (b))
../inputs/grep1.dat:#define MIN(a, b) ((a) < (b) ? (a) : (b))
../inputs/grep1.dat:      printf ("%d:\t", p - start);
../inputs/grep1.dat:        case no_op:
../inputs/grep1.dat:	case exactn:
../inputs/grep1.dat:	case start_memory:
../inputs/grep1.dat:	case stop_memory:
../inputs/grep1.dat:	case duplicate:
../inputs/grep1.dat:	case anychar:
../inputs/grep1.dat:	case charset:
../inputs/grep1.dat:        case charset_not:
../inputs/grep1.dat:	            (re_opcode_t) *(p - 1) == charset_not ? "^" : "");
../inputs/grep1.dat:	case begline:
../inputs/grep1.dat:	case endline:
../inputs/grep1.dat:	case on_failure_jump:
../inputs/grep1.dat:	case on_failure_keep_string_jump:
../inputs/grep1.dat:	case dummy_failure_jump:
../inputs/grep1.dat:	case push_dummy_failure:
../inputs/grep1.dat:        case maybe_pop_jump:
../inputs/grep1.dat:        case pop_failure_jump:
../inputs/grep1.dat:        case jump_past_alt:
../inputs/grep1.dat:        case jump:
../inputs/grep1.dat:        case succeed_n: 
../inputs/grep1.dat:        case jump_n: 
../inputs/grep1.dat:        case set_number_at: 
../inputs/grep1.dat:        case wordbound:
../inputs/grep1.dat:	case notwordbound:
../inputs/grep1.dat:	case wordbeg:
../inputs/grep1.dat:	case wordend:
../inputs/grep1.dat:	case before_dot:
../inputs/grep1.dat:	case at_dot:
../inputs/grep1.dat:	case after_dot:
../inputs/grep1.dat:	case syntaxspec:
../inputs/grep1.dat:	case notsyntaxspec:
../inputs/grep1.dat:	case wordchar:
../inputs/grep1.dat:	case notwordchar:
../inputs/grep1.dat:	case begbuf:
../inputs/grep1.dat:	case endbuf:
../inputs/grep1.dat:        default:
../inputs/grep1.dat:  printf ("%d:\tend of pattern.\n", p - start);
../inputs/grep1.dat:      printf ("fastmap: ");
../inputs/grep1.dat:  printf ("re_nsub: %d\t", bufp->re_nsub);
../inputs/grep1.dat:  printf ("regs_alloc: %d\t", bufp->regs_allocated);
../inputs/grep1.dat:  printf ("can_be_null: %d\t", bufp->can_be_null);
../inputs/grep1.dat:  printf ("newline_anchor: %d\n", bufp->newline_anchor);
../inputs/grep1.dat:  printf ("no_sub: %d\t", bufp->no_sub);
../inputs/grep1.dat:  printf ("not_bol: %d\t", bufp->not_bol);
../inputs/grep1.dat:  printf ("not_eol: %d\t", bufp->not_eol);
../inputs/grep1.dat:  printf ("syntax: %d\n", bufp->syntax);
../inputs/grep1.dat:   also be assigned to arbitrarily: each pattern buffer stores its own
../inputs/grep1.dat:#define TRANSLATE(d) (translate ? translate[(unsigned char) (d)] : (d))
../inputs/grep1.dat:/* This is not an arbitrary limit: the arguments which represent offsets
../inputs/grep1.dat:   contents of BUFP are undefined):
../inputs/grep1.dat:  DEBUG_PRINT1 ("\nCompiling pattern: ");
../inputs/grep1.dat:        case '^':
../inputs/grep1.dat:        case '$':
../inputs/grep1.dat:	case '+':
../inputs/grep1.dat:        case '?':
../inputs/grep1.dat:        handle_plus:
../inputs/grep1.dat:        case '*':
../inputs/grep1.dat:                                       : on_failure_jump,
../inputs/grep1.dat:	case '.':
../inputs/grep1.dat:        case '[':
../inputs/grep1.dat:            /* Ensure that we have enough space to push a charset: the
../inputs/grep1.dat:            BUF_PUSH (*p == '^' ? charset_not : charset); 
../inputs/grep1.dat:                   was a character: if this is a hyphen not at the
../inputs/grep1.dat:                else if (syntax & RE_CHAR_CLASSES && c == '[' && *p == ':')
../inputs/grep1.dat:                    /* If pattern is `[[:'.  */
../inputs/grep1.dat:                        if (c == ':' || c == ']' || p == pend
../inputs/grep1.dat:                    /* If isn't a word bracketed by `[:' and:`]':
../inputs/grep1.dat:                       the leading `:' and `[' (but set bits for them).  */
../inputs/grep1.dat:                    if (c == ':' && *p == ']')
../inputs/grep1.dat:                        SET_LIST_BIT (':');
../inputs/grep1.dat:	case '(':
../inputs/grep1.dat:        case ')':
../inputs/grep1.dat:        case '\n':
../inputs/grep1.dat:	case '|':
../inputs/grep1.dat:        case '{':
../inputs/grep1.dat:        case '\\':
../inputs/grep1.dat:            case '(':
../inputs/grep1.dat:            handle_open:
../inputs/grep1.dat:                = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
../inputs/grep1.dat:            case ')':
../inputs/grep1.dat:            handle_close:
../inputs/grep1.dat:                    : 0;
../inputs/grep1.dat:            case '|':					/* `\|'.  */
../inputs/grep1.dat:            handle_alt:
../inputs/grep1.dat:                 jump jumps to the correct final destination.  A picture:
../inputs/grep1.dat:            case '{': 
../inputs/grep1.dat:            handle_interval:
../inputs/grep1.dat:                    we're all done, the pattern will look like:
../inputs/grep1.dat:                            Conclusion: (b - 2) - (laststart + 3) + 5,
../inputs/grep1.dat:            unfetch_interval:
../inputs/grep1.dat:            case '=':
../inputs/grep1.dat:            case 's':	
../inputs/grep1.dat:            case 'S':
../inputs/grep1.dat:            case 'w':
../inputs/grep1.dat:            case 'W':
../inputs/grep1.dat:            case '<':
../inputs/grep1.dat:            case '>':
../inputs/grep1.dat:            case 'b':
../inputs/grep1.dat:            case 'B':
../inputs/grep1.dat:            case '`':
../inputs/grep1.dat:            case '\'':
../inputs/grep1.dat:            case '1': case '2': case '3': case '4': case '5':
../inputs/grep1.dat:            case '6': case '7': case '8': case '9':
../inputs/grep1.dat:            case '+':
../inputs/grep1.dat:            case '?':
../inputs/grep1.dat:            default:
../inputs/grep1.dat:            normal_backslash:
../inputs/grep1.dat:	default:
../inputs/grep1.dat:	normal_char:
../inputs/grep1.dat:		  : (*p == '+' || *p == '?'))
../inputs/grep1.dat:                      : (p[0] == '\\' && p[1] == '{'))))
../inputs/grep1.dat:      DEBUG_PRINT1 ("\nCompiled pattern: \n");
../inputs/grep1.dat:  const char *next_next = p + 1 < pend ? p + 1 : NULL;
../inputs/grep1.dat:        : next_backslash && next_next && *next_next == ')')
../inputs/grep1.dat:        : next_backslash && next_next && *next_next == '|');
../inputs/grep1.dat:    return syntax & RE_NO_EMPTY_RANGES ? REG_ERANGE : REG_NOERROR;
../inputs/grep1.dat:   : ((fail_stack).stack = (fail_stack_elt_t *)				\
../inputs/grep1.dat:      : ((fail_stack).size <<= 1, 					\
../inputs/grep1.dat:    : ((fail_stack).stack[(fail_stack).avail++] = pattern_op,		\
../inputs/grep1.dat:    DEBUG_PRINT2 ("\nPUSH_FAILURE_POINT #%u:\n", failure_id);		\
../inputs/grep1.dat:    DEBUG_PRINT2 ("  Before push, next avail: %d\n", (fail_stack).avail);\
../inputs/grep1.dat:    DEBUG_PRINT2 ("                     size: %d\n", (fail_stack).size);\
../inputs/grep1.dat:    DEBUG_PRINT2 ("  slots needed: %d\n", NUM_FAILURE_ITEMS);		\
../inputs/grep1.dat:    DEBUG_PRINT2 ("     available: %d\n", REMAINING_AVAIL_SLOTS);	\
../inputs/grep1.dat:        DEBUG_PRINT2 ("\n  Doubled stack; size now: %d\n",		\
../inputs/grep1.dat:        DEBUG_PRINT2 ("  slots available: %d\n", REMAINING_AVAIL_SLOTS);\
../inputs/grep1.dat:	DEBUG_PRINT2 ("  Pushing reg: %d\n", this_reg);			\
../inputs/grep1.dat:	DEBUG_PRINT2 ("    start: 0x%x\n", regstart[this_reg]);		\
../inputs/grep1.dat:	DEBUG_PRINT2 ("    end: 0x%x\n", regend[this_reg]);		\
../inputs/grep1.dat:	DEBUG_PRINT2 ("    info: 0x%x\n      ", reg_info[this_reg]);	\
../inputs/grep1.dat:    DEBUG_PRINT2 ("  Pushing  low active reg: %d\n", lowest_active_reg);\
../inputs/grep1.dat:    DEBUG_PRINT2 ("  Pushing high active reg: %d\n", highest_active_reg);\
../inputs/grep1.dat:    DEBUG_PRINT2 ("  Pushing pattern 0x%x: ", pattern_place);		\
../inputs/grep1.dat:    DEBUG_PRINT2 ("  Pushing string 0x%x: `", string_place);		\
../inputs/grep1.dat:    DEBUG_PRINT2 ("  Pushing failure id: %u\n", failure_id);		\
../inputs/grep1.dat:   We restore into the parameters, all of which should be lvalues:
../inputs/grep1.dat:  DEBUG_PRINT1 ("POP_FAILURE_POINT:\n");				\
../inputs/grep1.dat:  DEBUG_PRINT2 ("  Before pop, next avail: %d\n", fail_stack.avail);	\
../inputs/grep1.dat:  DEBUG_PRINT2 ("                    size: %d\n", fail_stack.size);	\
../inputs/grep1.dat:  DEBUG_PRINT2 ("  Popping failure id: %u\n", failure_id);		\
../inputs/grep1.dat:  DEBUG_PRINT2 ("  Popping string 0x%x: `", str);			\
../inputs/grep1.dat:  DEBUG_PRINT2 ("  Popping pattern 0x%x: ", pat);			\
../inputs/grep1.dat:  DEBUG_PRINT2 ("  Popping high active reg: %d\n", high_reg);		\
../inputs/grep1.dat:  DEBUG_PRINT2 ("  Popping  low active reg: %d\n", low_reg);		\
../inputs/grep1.dat:      DEBUG_PRINT2 ("    Popping reg: %d\n", this_reg);			\
../inputs/grep1.dat:      DEBUG_PRINT2 ("      info: 0x%x\n", reg_info[this_reg]);		\
../inputs/grep1.dat:      DEBUG_PRINT2 ("      end: 0x%x\n", regend[this_reg]);		\
../inputs/grep1.dat:      DEBUG_PRINT2 ("      start: 0x%x\n", regstart[this_reg]);		\
../inputs/grep1.dat:	case duplicate:
../inputs/grep1.dat:	case exactn:
../inputs/grep1.dat:        case charset:
../inputs/grep1.dat:	case charset_not:
../inputs/grep1.dat:	case wordchar:
../inputs/grep1.dat:	case notwordchar:
../inputs/grep1.dat:        case anychar:
../inputs/grep1.dat:        case syntaxspec:
../inputs/grep1.dat:	case notsyntaxspec:
../inputs/grep1.dat:	case before_dot:
../inputs/grep1.dat:	case at_dot:
../inputs/grep1.dat:	case after_dot:
../inputs/grep1.dat:        case no_op:
../inputs/grep1.dat:        case begline:
../inputs/grep1.dat:        case endline:
../inputs/grep1.dat:	case begbuf:
../inputs/grep1.dat:	case endbuf:
../inputs/grep1.dat:	case wordbound:
../inputs/grep1.dat:	case notwordbound:
../inputs/grep1.dat:	case wordbeg:
../inputs/grep1.dat:	case wordend:
../inputs/grep1.dat:        case push_dummy_failure:
../inputs/grep1.dat:	case jump_n:
../inputs/grep1.dat:        case pop_failure_jump:
../inputs/grep1.dat:	case maybe_pop_jump:
../inputs/grep1.dat:	case jump:
../inputs/grep1.dat:        case jump_past_alt:
../inputs/grep1.dat:	case dummy_failure_jump:
../inputs/grep1.dat:        case on_failure_jump:
../inputs/grep1.dat:        case on_failure_keep_string_jump:
../inputs/grep1.dat:	handle_on_failure_jump:
../inputs/grep1.dat:	case succeed_n:
../inputs/grep1.dat:	case set_number_at:
../inputs/grep1.dat:	case start_memory:
../inputs/grep1.dat:        case stop_memory:
../inputs/grep1.dat:	default:
../inputs/grep1.dat:	      d = (startpos >= size1 ? string2 - size1 : string1) + startpos;
../inputs/grep1.dat:                                 : string1[startpos]);
../inputs/grep1.dat:    advance:
../inputs/grep1.dat:   We are making a (strictly speaking) nonportable assumption here: that
../inputs/grep1.dat:    unsigned match_null_string_p : 2;
../inputs/grep1.dat:    unsigned is_active : 1;
../inputs/grep1.dat:    unsigned matched_something : 1;
../inputs/grep1.dat:    unsigned ever_matched_something : 1;
../inputs/grep1.dat:  (FIRST_STRING_P (ptr) ? (ptr) - string1 : (ptr) - string2 + size1)
../inputs/grep1.dat:#define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)
../inputs/grep1.dat:   two special cases to check for: if past the end of string1, look at
../inputs/grep1.dat:           : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\
../inputs/grep1.dat:  DEBUG_PRINT1 ("The compiled pattern is: ");
../inputs/grep1.dat:  DEBUG_PRINT1 ("The string to match is: `");
../inputs/grep1.dat:      DEBUG_PRINT2 ("\n0x%x: ", p);
../inputs/grep1.dat:  	        restore_best_regs:
../inputs/grep1.dat:		           ? end_match_1 : end_match_2);
../inputs/grep1.dat:			          : d - string2 + size1);
../inputs/grep1.dat:			    : string2 - size1);
../inputs/grep1.dat:        case no_op:
../inputs/grep1.dat:	case exactn:
../inputs/grep1.dat:	case anychar:
../inputs/grep1.dat:	case charset:
../inputs/grep1.dat:	case charset_not:
../inputs/grep1.dat:            DEBUG_PRINT2 ("EXECUTING charset%s.\n", not ? "_not" : "");
../inputs/grep1.dat:        case start_memory:
../inputs/grep1.dat:	  DEBUG_PRINT3 ("EXECUTING start_memory %d (%d):\n", *p, p[1]);
../inputs/grep1.dat:                             ? REG_UNSET (regstart[*p]) ? d : regstart[*p]
../inputs/grep1.dat:                             : regstart[*p];
../inputs/grep1.dat:	  DEBUG_PRINT2 ("  old_regstart: %d\n", 
../inputs/grep1.dat:	  DEBUG_PRINT2 ("  regstart: %d\n", POINTER_TO_OFFSET (regstart[*p]));
../inputs/grep1.dat:           arguments are the same as start_memory's: the register
../inputs/grep1.dat:	case stop_memory:
../inputs/grep1.dat:	  DEBUG_PRINT3 ("EXECUTING stop_memory %d (%d):\n", *p, p[1]);
../inputs/grep1.dat:                           ? REG_UNSET (regend[*p]) ? d : regend[*p]
../inputs/grep1.dat:			   : regend[*p];
../inputs/grep1.dat:	  DEBUG_PRINT2 ("      old_regend: %d\n", 
../inputs/grep1.dat:	  DEBUG_PRINT2 ("      regend: %d\n", POINTER_TO_OFFSET (regend[*p]));
../inputs/grep1.dat:                 it isn't necessarily one less than now: consider
../inputs/grep1.dat:                  case jump_n:
../inputs/grep1.dat:                  case pop_failure_jump:
../inputs/grep1.dat:		  case maybe_pop_jump:
../inputs/grep1.dat:		  case jump:
../inputs/grep1.dat:		  case dummy_failure_jump:
../inputs/grep1.dat:                  default:
../inputs/grep1.dat:        case duplicate:
../inputs/grep1.dat:		     ? regend[regno] : end_match_1);
../inputs/grep1.dat:                    : bcmp (d, d2, mcnt))
../inputs/grep1.dat:	case begline:
../inputs/grep1.dat:	case endline:
../inputs/grep1.dat:          else if ((d == end1 ? *string2 : *d) == '\n'
../inputs/grep1.dat:        case begbuf:
../inputs/grep1.dat:        case endbuf:
../inputs/grep1.dat:        case on_failure_keep_string_jump:
../inputs/grep1.dat:          DEBUG_PRINT3 (" %d (to 0x%x):\n", mcnt, p + mcnt);
../inputs/grep1.dat:	/* Uses of on_failure_jump:
../inputs/grep1.dat:	case on_failure_jump:
../inputs/grep1.dat:        on_failure:
../inputs/grep1.dat:          DEBUG_PRINT1 (":\n");
../inputs/grep1.dat:        case maybe_pop_jump:
../inputs/grep1.dat:               This is not true in the case of alternatives: in
../inputs/grep1.dat:		/* Consider what happens when matching ":\(.*\)"
../inputs/grep1.dat:		   against ":/".  I don't really understand this code
../inputs/grep1.dat:                  ("  End of pattern: change to `pop_failure_jump'.\n");
../inputs/grep1.dat:                  = *p2 == (unsigned char) endline ? '\n' : p2[2];
../inputs/grep1.dat:        case pop_failure_jump:
../inputs/grep1.dat:        case jump:
../inputs/grep1.dat:	unconditional_jump:
../inputs/grep1.dat:        case jump_past_alt:
../inputs/grep1.dat:        case dummy_failure_jump:
../inputs/grep1.dat:        case push_dummy_failure:
../inputs/grep1.dat:        case succeed_n: 
../inputs/grep1.dat:        case jump_n: 
../inputs/grep1.dat:	case set_number_at:
../inputs/grep1.dat:        case wordbound:
../inputs/grep1.dat:	case notwordbound:
../inputs/grep1.dat:	case wordbeg:
../inputs/grep1.dat:	case wordend:
../inputs/grep1.dat:  	case before_dot:
../inputs/grep1.dat:  	case at_dot:
../inputs/grep1.dat:  	case after_dot:
../inputs/grep1.dat:	case at_dot:
../inputs/grep1.dat:	case syntaxspec:
../inputs/grep1.dat:        case wordchar:
../inputs/grep1.dat:        matchsyntax:
../inputs/grep1.dat:	case notsyntaxspec:
../inputs/grep1.dat:        case notwordchar:
../inputs/grep1.dat:        matchnotsyntax:
../inputs/grep1.dat:	case wordchar:
../inputs/grep1.dat:	case notwordchar:
../inputs/grep1.dat:        default:
../inputs/grep1.dat:    fail:
../inputs/grep1.dat:          DEBUG_PRINT1 ("\nFAIL:\n");
../inputs/grep1.dat:                case jump_n:
../inputs/grep1.dat:                case maybe_pop_jump:
../inputs/grep1.dat:                case pop_failure_jump:
../inputs/grep1.dat:                case jump:
../inputs/grep1.dat:                default:
../inputs/grep1.dat:        case on_failure_jump:
../inputs/grep1.dat:                 with a jump, e.g., here is the pattern for `a|b|c':
../inputs/grep1.dat:              /* Deal with the last alternative: go back and get number
../inputs/grep1.dat:        case stop_memory:
../inputs/grep1.dat:        default: 
../inputs/grep1.dat:/* Similar to group_match_null_string_p, but doesn't deal with alternatives:
../inputs/grep1.dat:        case on_failure_jump:
../inputs/grep1.dat:	default: 
../inputs/grep1.dat:    case no_op:
../inputs/grep1.dat:    case begline:
../inputs/grep1.dat:    case endline:
../inputs/grep1.dat:    case begbuf:
../inputs/grep1.dat:    case endbuf:
../inputs/grep1.dat:    case wordbeg:
../inputs/grep1.dat:    case wordend:
../inputs/grep1.dat:    case wordbound:
../inputs/grep1.dat:    case notwordbound:
../inputs/grep1.dat:    case before_dot:
../inputs/grep1.dat:    case at_dot:
../inputs/grep1.dat:    case after_dot:
../inputs/grep1.dat:    case start_memory:
../inputs/grep1.dat:    case jump:
../inputs/grep1.dat:    case succeed_n:
../inputs/grep1.dat:    case duplicate: 
../inputs/grep1.dat:    case set_number_at:
../inputs/grep1.dat:    default:
../inputs/grep1.dat:/* re_compile_pattern is the GNU regular expression compiler: it
../inputs/grep1.dat:      RE_SYNTAX_POSIX_EXTENDED : RE_SYNTAX_POSIX_BASIC;
../inputs/grep1.dat:     REG_NEWLINE case: if we used a fastmap, we'd have to put all the
../inputs/grep1.dat:        preg->translate[i] = ISUPPER (i) ? tolower (i) : i;
../inputs/grep1.dat:     unmatched close-group: both are REG_EPAREN.  */
../inputs/grep1.dat:   EFLAGS specifies `execution flags' which affect matching: if
../inputs/grep1.dat:                   /* start: */ 0, /* range: */ len,
../inputs/grep1.dat:                   want_reg_info ? &regs : (struct re_registers *) 0);
../inputs/grep1.dat:  return ret >= 0 ? (int) REG_NOERROR : (int) REG_NOMATCH;
../inputs/grep1.dat:Local variables:
../inputs/grep1.dat:make-backup-files: t
../inputs/grep1.dat:version-control: t
../inputs/grep1.dat:trim-versions-without-asking: nil
../inputs/grep1.dat:End:
../inputs/grep1.dat:	case EMPTY: s = "EMPTY"; break;
../inputs/grep1.dat:	case BACKREF: s = "BACKREF"; break;
../inputs/grep1.dat:	case BEGLINE: s = "BEGLINE"; break;
../inputs/grep1.dat:	case ENDLINE: s = "ENDLINE"; break;
../inputs/grep1.dat:	case BEGWORD: s = "BEGWORD"; break;
../inputs/grep1.dat:	case ENDWORD: s = "ENDWORD"; break;
../inputs/grep1.dat:	case LIMWORD: s = "LIMWORD"; break;
../inputs/grep1.dat:	case NOTLIMWORD: s = "NOTLIMWORD"; break;
../inputs/grep1.dat:	case QMARK: s = "QMARK"; break;
../inputs/grep1.dat:	case STAR: s = "STAR"; break;
../inputs/grep1.dat:	case PLUS: s = "PLUS"; break;
../inputs/grep1.dat:	case CAT: s = "CAT"; break;
../inputs/grep1.dat:	case OR: s = "OR"; break;
../inputs/grep1.dat:	case ORTOP: s = "ORTOP"; break;
../inputs/grep1.dat:	case LPAREN: s = "LPAREN"; break;
../inputs/grep1.dat:	case RPAREN: s = "RPAREN"; break;
../inputs/grep1.dat:	default: s = "CSET"; break;
../inputs/grep1.dat:  ":alpha:]", is_alpha,
../inputs/grep1.dat:  ":upper:]", is_upper,
../inputs/grep1.dat:  ":lower:]", is_lower,
../inputs/grep1.dat:  ":digit:]", is_digit,
../inputs/grep1.dat:  ":xdigit:]", is_xdigit,
../inputs/grep1.dat:  ":space:]", is_space,
../inputs/grep1.dat:  ":punct:]", is_punct,
../inputs/grep1.dat:  ":alnum:]", is_alnum,
../inputs/grep1.dat:  ":print:]", is_print,
../inputs/grep1.dat:  ":graph:]", is_graph,
../inputs/grep1.dat:  ":cntrl:]", is_cntrl,
../inputs/grep1.dat:  /* Basic plan: We fetch a character.  If it's a backslash,
../inputs/grep1.dat:	case '\\':
../inputs/grep1.dat:	case '^':
../inputs/grep1.dat:	case '$':
../inputs/grep1.dat:		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == ')')
../inputs/grep1.dat:		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == '|')
../inputs/grep1.dat:	case '1':
../inputs/grep1.dat:	case '2':
../inputs/grep1.dat:	case '3':
../inputs/grep1.dat:	case '4':
../inputs/grep1.dat:	case '5':
../inputs/grep1.dat:	case '6':
../inputs/grep1.dat:	case '7':
../inputs/grep1.dat:	case '8':
../inputs/grep1.dat:	case '9':
../inputs/grep1.dat:	case '<':
../inputs/grep1.dat:	case '>':
../inputs/grep1.dat:	case 'b':
../inputs/grep1.dat:	case 'B':
../inputs/grep1.dat:	case '?':
../inputs/grep1.dat:	case '*':
../inputs/grep1.dat:	case '+':
../inputs/grep1.dat:	case '{':
../inputs/grep1.dat:	  /* Cases:
../inputs/grep1.dat:	case '|':
../inputs/grep1.dat:	case '\n':
../inputs/grep1.dat:	case '(':
../inputs/grep1.dat:	case ')':
../inputs/grep1.dat:	case '.':
../inputs/grep1.dat:	case 'w':
../inputs/grep1.dat:	case 'W':
../inputs/grep1.dat:	case '[':
../inputs/grep1.dat:	      /* Nobody ever said this had to be fast. :-)
../inputs/grep1.dat:		 Note that if we're looking at some other [:...:]
../inputs/grep1.dat:	    skip:
../inputs/grep1.dat:	default:
../inputs/grep1.dat:	normal_char:
../inputs/grep1.dat:    case QMARK:
../inputs/grep1.dat:    case STAR:
../inputs/grep1.dat:    case PLUS:
../inputs/grep1.dat:    case CAT:
../inputs/grep1.dat:    case OR:
../inputs/grep1.dat:    case ORTOP:
../inputs/grep1.dat:    default:
../inputs/grep1.dat:    case EMPTY:
../inputs/grep1.dat:   regexp:
../inputs/grep1.dat:   branch:
../inputs/grep1.dat:   closure:
../inputs/grep1.dat:   atom:
../inputs/grep1.dat:    default:
../inputs/grep1.dat:    case QMARK:
../inputs/grep1.dat:    case STAR:
../inputs/grep1.dat:    case PLUS:
../inputs/grep1.dat:    case CAT:
../inputs/grep1.dat:    case OR:
../inputs/grep1.dat:    case ORTOP:
../inputs/grep1.dat:  newline = newline ? 1 : 0;
../inputs/grep1.dat:  letter = letter ? 1 : 0;
../inputs/grep1.dat:	  case BEGLINE:
../inputs/grep1.dat:	  case ENDLINE:
../inputs/grep1.dat:	  case BEGWORD:
../inputs/grep1.dat:	  case ENDWORD:
../inputs/grep1.dat:	  case LIMWORD:
../inputs/grep1.dat:	  case NOTLIMWORD:
../inputs/grep1.dat:	  default:
../inputs/grep1.dat:   Nullable:  A node is nullable if it is at the root of a regexp that can
../inputs/grep1.dat:   Firstpos:  The firstpos of a node is the set of positions (nonempty leaves)
../inputs/grep1.dat:   Lastpos:  The lastpos of a node is the set of positions that could
../inputs/grep1.dat:   Follow:  The follow of a position is the set of positions that could
../inputs/grep1.dat:  fprintf(stderr, "dfaanalyze:\n");
../inputs/grep1.dat:      fprintf(stderr, " %d:", i);
../inputs/grep1.dat:      case EMPTY:
../inputs/grep1.dat:      case STAR:
../inputs/grep1.dat:      case PLUS:
../inputs/grep1.dat:      case QMARK:
../inputs/grep1.dat:      case CAT:
../inputs/grep1.dat:      case OR:
../inputs/grep1.dat:      case ORTOP:
../inputs/grep1.dat:      default:
../inputs/grep1.dat:      fprintf(stderr, "node %d:", i);
../inputs/grep1.dat:      fprintf(stderr, nullable[-1] ? " nullable: yes\n" : " nullable: no\n");
../inputs/grep1.dat:      fprintf(stderr, " firstpos:");
../inputs/grep1.dat:	  fprintf(stderr, " %d:", firstpos[j].index);
../inputs/grep1.dat:      fprintf(stderr, "\n lastpos:");
../inputs/grep1.dat:	  fprintf(stderr, " %d:", lastpos[j].index);
../inputs/grep1.dat:	fprintf(stderr, "follows(%d:", i);
../inputs/grep1.dat:	fprintf(stderr, "):");
../inputs/grep1.dat:	    fprintf(stderr, " %d:", d->follows[i].elems[j].index);
../inputs/grep1.dat:	    (intersect[k] = matches[k] & labels[j][k]) ? intersectf = 1 : 0;
../inputs/grep1.dat:	      (leftovers[k] = ~match & label) ? leftoversf = 1 : 0;
../inputs/grep1.dat:	      (matches[k] = match & ~label) ? matchesf = 1 : 0;
../inputs/grep1.dat:   TODO: Improve this comment, get rid of the unnecessary redundancy. */
../inputs/grep1.dat:    last_was_s:
../inputs/grep1.dat:    last_was_s1:
../inputs/grep1.dat:   representation:
../inputs/grep1.dat:		p->left :	q->right :	q->is!=ZERO) ?	q->in plus
../inputs/grep1.dat:		p->is##q->left	p->right##q->is	p->is##q->is :	p->right##q->left
../inputs/grep1.dat:		and q->left	and q->right	p->is : NULL	
../inputs/grep1.dat:   There are several issues:
../inputs/grep1.dat:  newsize = (new == NULL) ? 0 : strlen(new);
../inputs/grep1.dat:  fprintf(stderr, "dfamust:\n");
../inputs/grep1.dat:      fprintf(stderr, " %d:", i);
../inputs/grep1.dat:	case LPAREN:
../inputs/grep1.dat:	case RPAREN:
../inputs/grep1.dat:	case EMPTY:
../inputs/grep1.dat:	case BEGLINE:
../inputs/grep1.dat:	case ENDLINE:
../inputs/grep1.dat:	case BEGWORD:
../inputs/grep1.dat:	case ENDWORD:
../inputs/grep1.dat:	case LIMWORD:
../inputs/grep1.dat:	case NOTLIMWORD:
../inputs/grep1.dat:	case BACKREF:
../inputs/grep1.dat:	case STAR:
../inputs/grep1.dat:	case QMARK:
../inputs/grep1.dat:	case OR:
../inputs/grep1.dat:	case ORTOP:
../inputs/grep1.dat:	case PLUS:
../inputs/grep1.dat:	case END:
../inputs/grep1.dat:	case CAT:
../inputs/grep1.dat:	default:
../inputs/grep1.dat:      fprintf(stderr, " node: %d:", ri);
../inputs/grep1.dat:      fprintf(stderr, "\n  in:");
../inputs/grep1.dat:      fprintf(stderr, "\n  is: \"%s\"\n", mp->is);
../inputs/grep1.dat:      fprintf(stderr, "  left: \"%s\"\n", mp->left);
../inputs/grep1.dat:      fprintf(stderr, "  right: \"%s\"\n", mp->right);
../inputs/grep1.dat: done:
../inputs/grep1.dat:   String Matching:  An Aid to Bibliographic Search," CACM June 1975,
../inputs/grep1.dat:      label = kwset->trans ? kwset->trans[(unsigned char) *--text] : *--text;
../inputs/grep1.dat:		case (char) -2:
../inputs/grep1.dat:		    case L:
../inputs/grep1.dat:		    case R:
../inputs/grep1.dat:		      l->balance = t->balance != 1 ? 0 : -1;
../inputs/grep1.dat:		      r->balance = t->balance != (char) -1 ? 0 : 1;
../inputs/grep1.dat:		case 2:
../inputs/grep1.dat:		    case R:
../inputs/grep1.dat:		    case L:
../inputs/grep1.dat:		      l->balance = t->balance != 1 ? 0 : -1;
../inputs/grep1.dat:		      r->balance = t->balance != (char) -1 ? 0 : 1;
../inputs/grep1.dat:  /* Significance of 12: 1 (initial offset) + 10 (skip loop) + 1 (md2). */
../inputs/grep1.dat:      found:
../inputs/grep1.dat:	  c = trans ? trans[(unsigned char) *--beg] : *--beg;
../inputs/grep1.dat: match:
../inputs/grep1.dat:	  c = trans ? trans[(unsigned char) *--beg] : *--beg;
../inputs/grep1.dat:   For free, do not use ?:, since some compilers, like the MIPS compilers,
../inputs/grep1.dat:   do not allow (expr) ? void : void.  */
../inputs/grep1.dat:   : (*(h)->chunkfun) ((size)))
../inputs/grep1.dat:#define TOLOWER(C) (ISUPPER(C) ? tolower(C) : (C))
../inputs/grep1.dat:  if (!(kwset = kwsalloc(match_icase ? trans : (char *) 0)))
../inputs/grep1.dat:      /* In the whole-word case, we use the pattern:
../inputs/grep1.dat:	 In the whole-line case, we use the pattern:
../inputs/grep1.dat:	 BUG: Using [A-Za-z_] is locale-dependent!  */
../inputs/grep1.dat:      /* In the whole-word case, we use the pattern:
../inputs/grep1.dat:	 In the whole-line case, we use the pattern:
../inputs/grep1.dat:	 BUG: Using [A-Za-z_] is locale-dependent!  */
../inputs/grep1.dat:	     We do this iteratively because:
../inputs/grep1.dat: failure:
../inputs/grep1.dat: success:
../inputs/grep1.dat:  *endp = end < buflim ? end + 1 : end;
../inputs/grep1.dat: success:
