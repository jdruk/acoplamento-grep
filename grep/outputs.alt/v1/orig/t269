../inputs/grep0.dat:store_op2 (op, loc, arg1, arg2)
../inputs/grep0.dat:store_op2 (op, loc, arg1, arg2)
../inputs/grep1.dat:   Copyright (C) 1992 Free Software Foundation, Inc.
../inputs/grep1.dat:   the Free Software Foundation; either version 2, or (at your option)
../inputs/grep1.dat:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
../inputs/grep1.dat:   Written July 1992 by Mike Haertel.  */
../inputs/grep1.dat:#define GREP 1
../inputs/grep1.dat:#define STDC_HEADERS 1
../inputs/grep1.dat:#define HAVE_STRING_H 1
../inputs/grep1.dat:#define HAVE_SYS_PARAM_H 1
../inputs/grep1.dat:#define HAVE_UNISTD_H 1
../inputs/grep1.dat:#define HAVE_ALLOCA_H 1
../inputs/grep1.dat:#define HAVE_GETPAGESIZE 1
../inputs/grep1.dat:#define HAVE_MEMCHR 1
../inputs/grep1.dat:#define HAVE_STRERROR 1
../inputs/grep1.dat:#define HAVE_VALLOC 1
../inputs/grep1.dat:#define HAVE_WORKING_MMAP 1
../inputs/grep1.dat:#define flag_stdlib 1
../inputs/grep1.dat:#define flag_systypes 1
../inputs/grep1.dat:#define flag_string 1
../inputs/grep1.dat:#define flag_memory 1
../inputs/grep1.dat:#define flag_strings 1
../inputs/grep1.dat:#define flag_systypes 1
../inputs/grep1.dat:  errseen = 1;
../inputs/grep1.dat:  exit(2);
../inputs/grep1.dat:#define flag_systypes 1
../inputs/grep1.dat:      initialized = 1;
../inputs/grep1.dat:      bufsalloc = MAX(8192, getpagesize());
../inputs/grep1.dat:      /* The 1 byte of overflow is a kludge for dfaexec(), which
../inputs/grep1.dat:      buffer = valloc(bufalloc + 1);
../inputs/grep1.dat:      bufmapped = 1;
../inputs/grep1.dat:      bufoffset = lseek(fd, 0, 1);
../inputs/grep1.dat:	bufsalloc *= 2;
../inputs/grep1.dat:      nbuffer = valloc(bufalloc + 1);
../inputs/grep1.dat:      if (maddr == (caddr_t) -1)
../inputs/grep1.dat:	 but it doesn't, at least not on a Sun running 4.1.
../inputs/grep1.dat:  fwrite(beg, 1, lim - beg, stdout);
../inputs/grep1.dat:	  while (p > bp && p[-1] != '\n');
../inputs/grep1.dat:	  prline(p, nl + 1, '-');
../inputs/grep1.dat:	  p = nl + 1;
../inputs/grep1.dat:  used = 1;
../inputs/grep1.dat:      if (b == lim && ((b > beg && b[-1] == '\n') || b == beg))
../inputs/grep1.dat:	  nlines += 1;
../inputs/grep1.dat:      for (lim = buflim; lim > beg && lim[-1] != '\n'; --lim)
../inputs/grep1.dat:	  while (beg > bufbeg && beg[-1] != '\n');
../inputs/grep1.dat:static char version[] = "GNU grep version 2.0";
../inputs/grep1.dat:  exit(2);
../inputs/grep1.dat:   If we find it, install it in compile and execute, and return 1.  */
../inputs/grep1.dat:	return 1;
../inputs/grep1.dat:    prog = strrchr(prog, '/') + 1;
../inputs/grep1.dat:  while ((opt = getopt(argc, argv, "0123456789A:B:CEFGVX:bce:f:hiLlnqsvwxy"))
../inputs/grep1.dat:      case '1':
../inputs/grep1.dat:      case '2':
../inputs/grep1.dat:	out_before = 10 * out_before + opt - '0';
../inputs/grep1.dat:	out_after = 10 * out_after + opt - '0';
../inputs/grep1.dat:	out_before = out_after = 2;
../inputs/grep1.dat:	out_byte = 1;
../inputs/grep1.dat:	out_quiet = 1;
../inputs/grep1.dat:	count_matches = 1;
../inputs/grep1.dat:	keys = xrealloc(keys, keycc + cc + 1);
../inputs/grep1.dat:	keyfound = 1;
../inputs/grep1.dat:	for (keyalloc = 1; keyalloc <= keycc; keyalloc *= 2)
../inputs/grep1.dat:	       && (cc = fread(keys + keycc, 1, keyalloc - keycc, fp)) > 0)
../inputs/grep1.dat:	      keys = xrealloc(keys, keyalloc *= 2);
../inputs/grep1.dat:	if (keycc - oldcc > 0 && keys[keycc - 1] == '\n')
../inputs/grep1.dat:	keyfound = 1;
../inputs/grep1.dat:	no_filenames = 1;
../inputs/grep1.dat:	match_icase = 1;
../inputs/grep1.dat:	out_quiet = 1;
../inputs/grep1.dat:	list_files = -1;
../inputs/grep1.dat:	out_quiet = 1;
../inputs/grep1.dat:	list_files = 1;
../inputs/grep1.dat:	out_line = 1;
../inputs/grep1.dat:	out_quiet = 1;
../inputs/grep1.dat:	suppress_errors = 1;
../inputs/grep1.dat:	out_invert = 1;
../inputs/grep1.dat:	match_words = 1;
../inputs/grep1.dat:	match_lines = 1;
../inputs/grep1.dat:  if (argc - optind > 1 && !no_filenames)
../inputs/grep1.dat:    out_file = 1;
../inputs/grep1.dat:  status = 1;
../inputs/grep1.dat:		if (list_files == 1)
../inputs/grep1.dat:	    else if (list_files == -1)
../inputs/grep1.dat:	  if (list_files == 1)
../inputs/grep1.dat:      else if (list_files == -1)
../inputs/grep1.dat:  exit(errseen ? 2 : status);
../inputs/grep1.dat:   Copyright (C) 1987, 88, 89, 90, 91, 92, 1993
../inputs/grep1.dat:   Free Software Foundation; either version 2, or (at your option) any
../inputs/grep1.dat:   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
../inputs/grep1.dat:#define flag_config 1
../inputs/grep1.dat:#define flag_alloca 1
../inputs/grep1.dat:/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.  */
../inputs/grep1.dat:#define flag_stdlib 1
../inputs/grep1.dat:   long-named option.  Because this is not POSIX.2 compliant, it is
../inputs/grep1.dat:/* XXX 1003.2 says this must be 1 before any call.  */
../inputs/grep1.dat:int opterr = 1;
../inputs/grep1.dat:   as if it were the argument of an option with character code 1.
../inputs/grep1.dat:#define flag_string 1
../inputs/grep1.dat:     Start processing options with ARGV-element 1 (since ARGV-element 0
../inputs/grep1.dat:      first_nonopt = last_nonopt = optind = 1;
../inputs/grep1.dat:		 && (argv[optind][0] != '-' || argv[optind][1] == '\0')
../inputs/grep1.dat:		     || argv[optind][0] != '+' || argv[optind][1] == '\0')
../inputs/grep1.dat:      if ((argv[optind][0] != '-' || argv[optind][1] == '\0')
../inputs/grep1.dat:	      || argv[optind][0] != '+' || argv[optind][1] == '\0')
../inputs/grep1.dat:	  return 1;
../inputs/grep1.dat:      nextchar = (argv[optind] + 1
../inputs/grep1.dat:		  + (longopts != NULL && argv[optind][1] == '-'));
../inputs/grep1.dat:	   && (argv[optind][1] == '-' || long_only))
../inputs/grep1.dat:		exact = 1;
../inputs/grep1.dat:	      ambig = 1;
../inputs/grep1.dat:		optarg = s + 1;
../inputs/grep1.dat:		      if (argv[optind - 1][1] == '-')
../inputs/grep1.dat:			     argv[0], argv[optind - 1][0], pfound->name);
../inputs/grep1.dat:	  else if (pfound->has_arg == 1)
../inputs/grep1.dat:			     argv[0], argv[optind - 1]);
../inputs/grep1.dat:      if (!long_only || argv[optind][1] == '-'
../inputs/grep1.dat:	      if (argv[optind][1] == '-')
../inputs/grep1.dat:	    if (c < 040 || c >= 0177)
../inputs/grep1.dat:	    /* 1003.2 specifies the format of this message.  */
../inputs/grep1.dat:    if (temp[1] == ':')
../inputs/grep1.dat:	if (temp[2] == ':')
../inputs/grep1.dat:		    /* 1003.2 specifies the format of this message.  */
../inputs/grep1.dat:  while (1)
../inputs/grep1.dat:      int this_option_optind = optind ? optind : 1;
../inputs/grep1.dat:      c = getopt (argc, argv, "abc:d:0123456789");
../inputs/grep1.dat:	case '1':
../inputs/grep1.dat:	case '2':
../inputs/grep1.dat:   version 0.12.
../inputs/grep1.dat:   (Implements POSIX draft P10003.2/D11.2, except for
../inputs/grep1.dat:   Copyright (C) 1993 Free Software Foundation, Inc.
../inputs/grep1.dat:   the Free Software Foundation; either version 2, or (at your option)
../inputs/grep1.dat:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
../inputs/grep1.dat:#define flag_systypes 1
../inputs/grep1.dat:#define flag_config 1
../inputs/grep1.dat:#define flag_string 1
../inputs/grep1.dat:#define bcmp(s1, s2, n)	memcmp ((s1), (s2), (n))
../inputs/grep1.dat:#define flag_strings 1
../inputs/grep1.dat:#define flag_stdlib 1
../inputs/grep1.dat:   commands in re_match_2.  */
../inputs/grep1.dat:#define Sword 1
../inputs/grep1.dat:#define CHAR_SET_SIZE 256
../inputs/grep1.dat:   done = 1;
../inputs/grep1.dat:   Defining isascii to 1 should let any compiler worth its salt
../inputs/grep1.dat:#define isascii(c) 1
../inputs/grep1.dat:#define SIGN_EXTEND_CHAR(c) ((((unsigned char) (c)) ^ 128) - 128)
../inputs/grep1.dat:#define flag_alloca 1
../inputs/grep1.dat:/* True if `size1' is non-NULL and PTR is pointing anywhere inside
../inputs/grep1.dat:   `string1' or just past its end.  This works if PTR is NULL, which is
../inputs/grep1.dat:  (size1 && string1 <= (ptr) && (ptr) <= string1 + size1)
../inputs/grep1.dat:#define STREQ(s1, s2) ((strcmp (s1, s2) == 0))
../inputs/grep1.dat:#define true 1
../inputs/grep1.dat:   So regex.h defines a symbol `RE_EXACTN_VALUE' to be 1; the value of
../inputs/grep1.dat:   `exactn' we use here must also be 1.  */
../inputs/grep1.dat:  exactn = 1,
../inputs/grep1.dat:           bit is 1.  A character too large to have a bit in the map is
../inputs/grep1.dat:           of re_match_2.)  */
../inputs/grep1.dat:    (destination)[1] = (number) >> 8;					\
../inputs/grep1.dat:    (destination) += 2;							\
../inputs/grep1.dat:    (destination) += SIGN_EXTEND_CHAR (*((source) + 1)) << 8;		\
../inputs/grep1.dat:  int temp = SIGN_EXTEND_CHAR (*(source + 1)); 
../inputs/grep1.dat:    (source) += 2; 							\
../inputs/grep1.dat:  *source += 2;
../inputs/grep1.dat:#define DEBUG_PRINT1(x) if (debug) printf (x)
../inputs/grep1.dat:#define DEBUG_PRINT2(x1, x2) if (debug) printf (x1, x2)
../inputs/grep1.dat:#define DEBUG_PRINT3(x1, x2, x3) if (debug) printf (x1, x2, x3)
../inputs/grep1.dat:#define DEBUG_PRINT4(x1, x2, x3, x4) if (debug) printf (x1, x2, x3, x4)
../inputs/grep1.dat:#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)			\
../inputs/grep1.dat:  if (debug) print_double_string (w, s1, sz1, s2, sz2)
../inputs/grep1.dat:  while (i < (1 << BYTEWIDTH))
../inputs/grep1.dat:          printchar (i - 1);
../inputs/grep1.dat:          while (i < (1 << BYTEWIDTH)  &&  fastmap[i])
../inputs/grep1.dat:              was_a_range = 1;
../inputs/grep1.dat:              printchar (i - 1);
../inputs/grep1.dat:  int mcnt, mcnt2;
../inputs/grep1.dat:            register int c, last = -100;
../inputs/grep1.dat:	            (re_opcode_t) *(p - 1) == charset_not ? "^" : "");
../inputs/grep1.dat:            for (c = 0; c < 256; c++)
../inputs/grep1.dat:		  && (p[1 + (c/8)] & (1 << (c % 8))))
../inputs/grep1.dat:		  if (last + 1 == c && ! in_range)
../inputs/grep1.dat:		      in_range = 1;
../inputs/grep1.dat:		  else if (last + 1 != c && in_range)
../inputs/grep1.dat:	    p += 1 + *p;
../inputs/grep1.dat:          extract_number_and_incr (&mcnt2, &p);
../inputs/grep1.dat:	  printf ("/succeed_n to %d, %d times", p + mcnt - start, mcnt2);
../inputs/grep1.dat:          extract_number_and_incr (&mcnt2, &p);
../inputs/grep1.dat:	  printf ("/jump_n to %d, %d times", p + mcnt - start, mcnt2);
../inputs/grep1.dat:          extract_number_and_incr (&mcnt2, &p);
../inputs/grep1.dat:	  printf ("/set_number_at location %d to %d", p + mcnt - start, mcnt2);
../inputs/grep1.dat:          printf ("?%d", *(p-1));
../inputs/grep1.dat:print_double_string (where, string1, size1, string2, size2)
../inputs/grep1.dat:    const char *string1;
../inputs/grep1.dat:    const char *string2;
../inputs/grep1.dat:    int size1;
../inputs/grep1.dat:    int size2;
../inputs/grep1.dat:          for (this_char = where - string1; this_char < size1; this_char++)
../inputs/grep1.dat:            printchar (string1[this_char]);
../inputs/grep1.dat:          where = string2;    
../inputs/grep1.dat:      for (this_char = where - string2; this_char < size2; this_char++)
../inputs/grep1.dat:        printchar (string2[this_char]);
../inputs/grep1.dat:#define DEBUG_PRINT1(x)
../inputs/grep1.dat:#define DEBUG_PRINT2(x1, x2)
../inputs/grep1.dat:#define DEBUG_PRINT3(x1, x2, x3)
../inputs/grep1.dat:#define DEBUG_PRINT4(x1, x2, x3, x4)
../inputs/grep1.dat:#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)
../inputs/grep1.dat:static void store_op1 (), store_op2 ();
../inputs/grep1.dat:static void insert_op1 (), insert_op2 ();
../inputs/grep1.dat:#define INIT_BUF_SIZE  32
../inputs/grep1.dat:    GET_BUFFER_SPACE (1);						\
../inputs/grep1.dat:/* Ensure we have two more bytes of buffer space and then append C1 and C2.  */
../inputs/grep1.dat:#define BUF_PUSH_2(c1, c2)						\
../inputs/grep1.dat:    GET_BUFFER_SPACE (2);						\
../inputs/grep1.dat:    *b++ = (unsigned char) (c1);					\
../inputs/grep1.dat:    *b++ = (unsigned char) (c2);					\
../inputs/grep1.dat:/* As with BUF_PUSH_2, except for three bytes.  */
../inputs/grep1.dat:#define BUF_PUSH_3(c1, c2, c3)						\
../inputs/grep1.dat:    *b++ = (unsigned char) (c1);					\
../inputs/grep1.dat:    *b++ = (unsigned char) (c2);					\
../inputs/grep1.dat:  store_op1 (op, loc, (to) - (loc) - 3)
../inputs/grep1.dat:#define STORE_JUMP2(op, loc, to, arg) \
../inputs/grep1.dat:  store_op2 (op, loc, (to) - (loc) - 3, arg)
../inputs/grep1.dat:  insert_op1 (op, loc, (to) - (loc) - 3, b)
../inputs/grep1.dat:/* Like `STORE_JUMP2', but for inserting.  Assume `b' is the buffer end.  */
../inputs/grep1.dat:#define INSERT_JUMP2(op, loc, to, arg) \
../inputs/grep1.dat:  insert_op2 (op, loc, (to) - (loc) - 3, arg, b)
../inputs/grep1.dat:   into the pattern are two bytes long.  So if 2^16 bytes turns out to
../inputs/grep1.dat:#define MAX_BUF_SIZE (1L << 16)
../inputs/grep1.dat:    bufp->allocated <<= 1;						\
../inputs/grep1.dat:#define MAX_REGNUM 255
../inputs/grep1.dat:   be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
../inputs/grep1.dat:#define INIT_COMPILE_STACK_SIZE 32
../inputs/grep1.dat:   |= 1 << (((unsigned char) c) % BYTEWIDTH))
../inputs/grep1.dat:           num = num * 10 + c - '0'; 					\
../inputs/grep1.dat:  register unsigned char c, c1;
../inputs/grep1.dat:  const char *p1;
../inputs/grep1.dat:  DEBUG_PRINT1 ("\nCompiling pattern: ");
../inputs/grep1.dat:                   p == pattern + 1
../inputs/grep1.dat:            /* 1 means zero (many) matches is allowed.  */
../inputs/grep1.dat:               interval operators with these because of, e.g., `a{2}*',
../inputs/grep1.dat:                    PATFETCH (c1);
../inputs/grep1.dat:                    if (!(c1 == '+' || c1 == '?'))
../inputs/grep1.dat:                    c = c1;
../inputs/grep1.dat:                assert (p - 1 > pattern);
../inputs/grep1.dat:                if (TRANSLATE (*(p - 2)) == TRANSLATE ('.')
../inputs/grep1.dat:            p1 = p;
../inputs/grep1.dat:            BUF_PUSH ((1 << BYTEWIDTH) / BYTEWIDTH);
../inputs/grep1.dat:            bzero (b, (1 << BYTEWIDTH) / BYTEWIDTH);
../inputs/grep1.dat:            if ((re_opcode_t) b[-2] == charset_not
../inputs/grep1.dat:                    PATFETCH (c1);
../inputs/grep1.dat:                    SET_LIST_BIT (c1);
../inputs/grep1.dat:                if (c == ']' && p != p1 + 1)
../inputs/grep1.dat:                    && !(p - 2 >= pattern && p[-2] == '[') 
../inputs/grep1.dat:                    && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^')
../inputs/grep1.dat:                else if (p[0] == '-' && p[1] != ']')
../inputs/grep1.dat:                    PATFETCH (c1);
../inputs/grep1.dat:                    char str[CHAR_CLASS_MAX_LENGTH + 1];
../inputs/grep1.dat:                    c1 = 0;
../inputs/grep1.dat:                            || c1 == CHAR_CLASS_MAX_LENGTH)
../inputs/grep1.dat:                        str[c1++] = c;
../inputs/grep1.dat:                    str[c1] = '\0';
../inputs/grep1.dat:                        for (ch = 0; ch < 1 << BYTEWIDTH; ch++)
../inputs/grep1.dat:                        c1++;
../inputs/grep1.dat:                        while (c1--)    
../inputs/grep1.dat:            while ((int) b[-1] > 0 && b[b[-1] - 1] == 0) 
../inputs/grep1.dat:              b[-1]--; 
../inputs/grep1.dat:            b += b[-1];
../inputs/grep1.dat:                  RETALLOC (compile_stack.stack, compile_stack.size << 1,
../inputs/grep1.dat:                  compile_stack.size <<= 1;
../inputs/grep1.dat:                = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
../inputs/grep1.dat:                  COMPILE_STACK_TOP.inner_group_offset = b - bufp->buffer + 2;
../inputs/grep1.dat:                     `push_dummy_failure' in `re_match_2'.  */
../inputs/grep1.dat:                  STORE_JUMP (jump_past_alt, fixup_alt_jump, b - 1);
../inputs/grep1.dat:                   as in `(ab)c(de)' -- the second group is #2.  */
../inputs/grep1.dat:                    ? bufp->buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1 
../inputs/grep1.dat:                  || (p - 2 == pattern  &&  p == pend))
../inputs/grep1.dat:                int lower_bound = -1, upper_bound = -1;
../inputs/grep1.dat:                beg_interval = p - 1;
../inputs/grep1.dat:                  /* Interval such as `{1}' => match exactly once. */
../inputs/grep1.dat:                    `upper_bound' is 1, though.)  */
../inputs/grep1.dat:                   { /* If the upper bound is > 1, we need to insert
../inputs/grep1.dat:                     unsigned nbytes = 10 + (upper_bound > 1) * 10;
../inputs/grep1.dat:                     INSERT_JUMP2 (succeed_n, laststart,
../inputs/grep1.dat:                                   b + 5 + (upper_bound > 1) * 5,
../inputs/grep1.dat:                     insert_op2 (set_number_at, laststart, 5, lower_bound, b);
../inputs/grep1.dat:                     if (upper_bound > 1)
../inputs/grep1.dat:                            jump back only `upper_bound - 1' times.  */
../inputs/grep1.dat:                         STORE_JUMP2 (jump_n, b, laststart + 5,
../inputs/grep1.dat:                                      upper_bound - 1);
../inputs/grep1.dat:                            parameter of the `jump_n'; that is `b-2' as
../inputs/grep1.dat:                            Conclusion: (b - 2) - (laststart + 3) + 5,
../inputs/grep1.dat:                         insert_op2 (set_number_at, laststart, b - laststart,
../inputs/grep1.dat:                                     upper_bound - 1, b);
../inputs/grep1.dat:                   if (p > pattern  &&  p[-1] == '\\')
../inputs/grep1.dat:              BUF_PUSH_2 (syntaxspec, syntax_spec_code[c]);
../inputs/grep1.dat:              BUF_PUSH_2 (notsyntaxspec, syntax_spec_code[c]);
../inputs/grep1.dat:            case '1': case '2': case '3': case '4': case '5':
../inputs/grep1.dat:              c1 = c - '0';
../inputs/grep1.dat:              if (c1 > regnum)
../inputs/grep1.dat:              if (group_in_compile_stack (compile_stack, c1))
../inputs/grep1.dat:              BUF_PUSH_2 (duplicate, c1);
../inputs/grep1.dat:              || pending_exact + *pending_exact + 1 != b
../inputs/grep1.dat:	      || *pending_exact == (1 << BYTEWIDTH) - 1
../inputs/grep1.dat:		  ? *p == '\\' && (p[1] == '+' || p[1] == '?')
../inputs/grep1.dat:                      : (p[0] == '\\' && p[1] == '{'))))
../inputs/grep1.dat:	      BUF_PUSH_2 (exactn, 0);
../inputs/grep1.dat:	      pending_exact = b - 1;
../inputs/grep1.dat:      DEBUG_PRINT1 ("\nCompiled pattern: \n");
../inputs/grep1.dat:store_op1 (op, loc, arg)
../inputs/grep1.dat:  STORE_NUMBER (loc + 1, arg);
../inputs/grep1.dat:/* Like `store_op1', but" for 'two two-byte parameters ARG1 and ARG2.  */
../inputs/grep1.dat:store_op2 (op, loc, arg1, arg2)
../inputs/grep1.dat:    int arg1, arg2;
../inputs/grep1.dat:  STORE_NUMBER (loc + 1, arg1);
../inputs/grep1.dat:  STORE_NUMBER (loc + 3, arg2);
../inputs/grep1.dat:insert_op1 (op, loc, arg, end)
../inputs/grep1.dat:  store_op1 (op, loc, arg);
../inputs/grep1.dat:/* Like `insert_op1', but for two two-byte parameters ARG1 and ARG2.  */
../inputs/grep1.dat:insert_op2 (op, loc, arg1, arg2, end)
../inputs/grep1.dat:    int arg1, arg2;
../inputs/grep1.dat:  store_op2 (op, loc, arg1, arg2);
../inputs/grep1.dat:  const char *prev = p - 2;
../inputs/grep1.dat:  boolean prev_prev_backslash = prev > pattern && prev[-1] == '\\';
../inputs/grep1.dat:  const char *next_next = p + 1 < pend ? p + 1 : NULL;
../inputs/grep1.dat:  for (this_element = compile_stack.avail - 1;  
../inputs/grep1.dat:   starting character is in `P[-2]'.  (`P[-1]' is the character `-'.)
../inputs/grep1.dat:  range_start = ((unsigned char *) p)[-2];
../inputs/grep1.dat:   re_match_2 use a failure stack.  These have to be macros because of
../inputs/grep1.dat:int re_max_failures = 2000;
../inputs/grep1.dat:/* Initialize `fail_stack'.  Do `return -2' if the alloc fails.  */
../inputs/grep1.dat:      return -2;							\
../inputs/grep1.dat:   Return 1 if succeeds, and 0 if either ran out of memory
../inputs/grep1.dat:          ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),	\
../inputs/grep1.dat:      : ((fail_stack).size <<= 1, 					\
../inputs/grep1.dat:         1)))
../inputs/grep1.dat:   Return 1 if was able to do so and 0 if ran out of memory allocating
../inputs/grep1.dat:       1))
../inputs/grep1.dat:       of 0 + -1 isn't done as unsigned.  */				\
../inputs/grep1.dat:    DEBUG_PRINT2 ("\nPUSH_FAILURE_POINT #%u:\n", failure_id);		\
../inputs/grep1.dat:    DEBUG_PRINT2 ("  Before push, next avail: %d\n", (fail_stack).avail);\
../inputs/grep1.dat:    DEBUG_PRINT2 ("                     size: %d\n", (fail_stack).size);\
../inputs/grep1.dat:    DEBUG_PRINT2 ("  slots needed: %d\n", NUM_FAILURE_ITEMS);		\
../inputs/grep1.dat:    DEBUG_PRINT2 ("     available: %d\n", REMAINING_AVAIL_SLOTS);	\
../inputs/grep1.dat:        DEBUG_PRINT2 ("\n  Doubled stack; size now: %d\n",		\
../inputs/grep1.dat:        DEBUG_PRINT2 ("  slots available: %d\n", REMAINING_AVAIL_SLOTS);\
../inputs/grep1.dat:    DEBUG_PRINT1 ("\n");						\
../inputs/grep1.dat:	DEBUG_PRINT2 ("  Pushing reg: %d\n", this_reg);			\
../inputs/grep1.dat:	DEBUG_PRINT2 ("    start: 0x%x\n", regstart[this_reg]);		\
../inputs/grep1.dat:	DEBUG_PRINT2 ("    end: 0x%x\n", regend[this_reg]);		\
../inputs/grep1.dat:	DEBUG_PRINT2 ("    info: 0x%x\n      ", reg_info[this_reg]);	\
../inputs/grep1.dat:        DEBUG_PRINT2 (" match_null=%d",					\
../inputs/grep1.dat:        DEBUG_PRINT2 (" active=%d", IS_ACTIVE (reg_info[this_reg]));	\
../inputs/grep1.dat:        DEBUG_PRINT2 (" matched_something=%d",				\
../inputs/grep1.dat:        DEBUG_PRINT2 (" ever_matched=%d",				\
../inputs/grep1.dat:	DEBUG_PRINT1 ("\n");						\
../inputs/grep1.dat:    DEBUG_PRINT2 ("  Pushing  low active reg: %d\n", lowest_active_reg);\
../inputs/grep1.dat:    DEBUG_PRINT2 ("  Pushing high active reg: %d\n", highest_active_reg);\
../inputs/grep1.dat:    DEBUG_PRINT2 ("  Pushing pattern 0x%x: ", pattern_place);		\
../inputs/grep1.dat:    DEBUG_PRINT2 ("  Pushing string 0x%x: `", string_place);		\
../inputs/grep1.dat:    DEBUG_PRINT_DOUBLE_STRING (string_place, string1, size1, string2,   \
../inputs/grep1.dat:				 size2);				\
../inputs/grep1.dat:    DEBUG_PRINT1 ("'\n");						\
../inputs/grep1.dat:    DEBUG_PRINT2 ("  Pushing failure id: %u\n", failure_id);		\
../inputs/grep1.dat:#define MAX_FAILURE_ITEMS ((num_regs - 1) * NUM_REG_ITEMS + NUM_NONREG_ITEMS)
../inputs/grep1.dat:  ((highest_active_reg - lowest_active_reg + 1) * NUM_REG_ITEMS 	\
../inputs/grep1.dat:   `pend', `string1', `size1', `string2', and `size2'.  */
../inputs/grep1.dat:  DEBUG_PRINT1 ("POP_FAILURE_POINT:\n");				\
../inputs/grep1.dat:  DEBUG_PRINT2 ("  Before pop, next avail: %d\n", fail_stack.avail);	\
../inputs/grep1.dat:  DEBUG_PRINT2 ("                    size: %d\n", fail_stack.size);	\
../inputs/grep1.dat:  DEBUG_PRINT2 ("  Popping failure id: %u\n", failure_id);		\
../inputs/grep1.dat:  DEBUG_PRINT2 ("  Popping string 0x%x: `", str);			\
../inputs/grep1.dat:  DEBUG_PRINT_DOUBLE_STRING (str, string1, size1, string2, size2);	\
../inputs/grep1.dat:  DEBUG_PRINT1 ("'\n");							\
../inputs/grep1.dat:  DEBUG_PRINT2 ("  Popping pattern 0x%x: ", pat);			\
../inputs/grep1.dat:  DEBUG_PRINT2 ("  Popping high active reg: %d\n", high_reg);		\
../inputs/grep1.dat:  DEBUG_PRINT2 ("  Popping  low active reg: %d\n", low_reg);		\
../inputs/grep1.dat:      DEBUG_PRINT2 ("    Popping reg: %d\n", this_reg);			\
../inputs/grep1.dat:      DEBUG_PRINT2 ("      info: 0x%x\n", reg_info[this_reg]);		\
../inputs/grep1.dat:      DEBUG_PRINT2 ("      end: 0x%x\n", regend[this_reg]);		\
../inputs/grep1.dat:      DEBUG_PRINT2 ("      start: 0x%x\n", regstart[this_reg]);		\
../inputs/grep1.dat:   BUFP.  A fastmap records which of the (1 << BYTEWIDTH) possible
../inputs/grep1.dat:   The caller must supply the address of a (1 << BYTEWIDTH)-byte data
../inputs/grep1.dat:   Returns 0 if we succeed, -2 if an internal error.   */
../inputs/grep1.dat:  bzero (fastmap, 1 << BYTEWIDTH);  /* Assume nothing's valid.  */
../inputs/grep1.dat:  bufp->fastmap_accurate = 1;	    /* It will be when we're done.  */
../inputs/grep1.dat:           `can_be_null' stops `re_search_2' from using the fastmap, so
../inputs/grep1.dat:	  bufp->can_be_null = 1;
../inputs/grep1.dat:          fastmap[p[1]] = 1;
../inputs/grep1.dat:          for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
../inputs/grep1.dat:	    if (p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH)))
../inputs/grep1.dat:              fastmap[j] = 1;
../inputs/grep1.dat:	  for (j = *p * BYTEWIDTH; j < (1 << BYTEWIDTH); j++)
../inputs/grep1.dat:            fastmap[j] = 1;
../inputs/grep1.dat:	  for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
../inputs/grep1.dat:	    if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))))
../inputs/grep1.dat:              fastmap[j] = 1;
../inputs/grep1.dat:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
../inputs/grep1.dat:	      fastmap[j] = 1;
../inputs/grep1.dat:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
../inputs/grep1.dat:	      fastmap[j] = 1;
../inputs/grep1.dat:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
../inputs/grep1.dat:            fastmap[j] = 1;
../inputs/grep1.dat:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
../inputs/grep1.dat:	      fastmap[j] = 1;
../inputs/grep1.dat:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
../inputs/grep1.dat:	      fastmap[j] = 1;
../inputs/grep1.dat:	      && fail_stack.stack[fail_stack.avail - 1] == p)
../inputs/grep1.dat:                return -2;
../inputs/grep1.dat:            bufp->can_be_null = 1;
../inputs/grep1.dat:          p += 2;		
../inputs/grep1.dat:	  p += 2;
../inputs/grep1.dat:/* Like re_search_2, below, but only one string is specified, and
../inputs/grep1.dat:  return re_search_2 (bufp, NULL, 0, string, size, startpos, range, 
../inputs/grep1.dat:   virtual concatenation of STRING1 and STRING2, starting first at index
../inputs/grep1.dat:   STARTPOS, then at STARTPOS + 1, and so on.
../inputs/grep1.dat:   STRING1 and STRING2 have length SIZE1 and SIZE2, respectively.
../inputs/grep1.dat:   In REGS, return the indices of the virtual concatenation of STRING1
../inputs/grep1.dat:   and STRING2 that matched the entire BUFP->buffer and its contained
../inputs/grep1.dat:   concatenation of STRING1 and STRING2.
../inputs/grep1.dat:   found, -1 if no match, or -2 if error (such as failure
../inputs/grep1.dat:re_search_2 (bufp, string1, size1, string2, size2, startpos, range, regs, stop)
../inputs/grep1.dat:     const char *string1, *string2;
../inputs/grep1.dat:     int size1, size2;
../inputs/grep1.dat:  int total_size = size1 + size2;
../inputs/grep1.dat:    return -1;
../inputs/grep1.dat:     the virtual concatenation of STRING1 and STRING2.  */
../inputs/grep1.dat:  if (endpos < -1)
../inputs/grep1.dat:    range = -1 - startpos;
../inputs/grep1.dat:	return -1;
../inputs/grep1.dat:	range = 1;
../inputs/grep1.dat:    if (re_compile_fastmap (bufp) == -2)
../inputs/grep1.dat:      return -2;
../inputs/grep1.dat:              if (startpos < size1 && startpos + range >= size1)
../inputs/grep1.dat:                lim = range - (size1 - startpos);
../inputs/grep1.dat:	      d = (startpos >= size1 ? string2 - size1 : string1) + startpos;
../inputs/grep1.dat:	      register char c = (size1 == 0 || startpos >= size1
../inputs/grep1.dat:                                 ? string2[startpos - size1] 
../inputs/grep1.dat:                                 : string1[startpos]);
../inputs/grep1.dat:	return -1;
../inputs/grep1.dat:      val = re_match_2 (bufp, string1, size1, string2, size2,
../inputs/grep1.dat:      if (val == -2)
../inputs/grep1.dat:	return -2;
../inputs/grep1.dat:  return -1;
../inputs/grep1.dat:} /* re_search_2 */
../inputs/grep1.dat:/* Declarations and macros for re_match_2.  */
../inputs/grep1.dat:    unsigned match_null_string_p : 2;
../inputs/grep1.dat:    unsigned is_active : 1;
../inputs/grep1.dat:    unsigned matched_something : 1;
../inputs/grep1.dat:    unsigned ever_matched_something : 1;
../inputs/grep1.dat:            = 1;							\
../inputs/grep1.dat:/* This converts PTR, a pointer into one of the search strings `string1'
../inputs/grep1.dat:   and `string2' into an offset from the beginning of that string.  */
../inputs/grep1.dat:  (FIRST_STRING_P (ptr) ? (ptr) - string1 : (ptr) - string2 + size1)
../inputs/grep1.dat:#define REG_UNSET_VALUE ((char *) -1)
../inputs/grep1.dat:/* Macros for dealing with the split strings in re_match_2.  */
../inputs/grep1.dat:#define MATCHING_IN_FIRST_STRING  (dend == end_match_1)
../inputs/grep1.dat:   string2 if necessary.  */
../inputs/grep1.dat:      /* End of string2 => fail.  */					\
../inputs/grep1.dat:      if (dend == end_match_2) 						\
../inputs/grep1.dat:      /* End of string1 => advance to string2.  */ 			\
../inputs/grep1.dat:      d = string2;						        \
../inputs/grep1.dat:      dend = end_match_2;						\
../inputs/grep1.dat:   of `string1' and `string2'.  If only one string, it's `string2'.  */
../inputs/grep1.dat:#define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)
../inputs/grep1.dat:#define AT_STRINGS_END(d) ((d) == end2)	
../inputs/grep1.dat:   two special cases to check for: if past the end of string1, look at
../inputs/grep1.dat:   the first character in string2; and if before the beginning of
../inputs/grep1.dat:   string2, look at the last character in string1.  */
../inputs/grep1.dat:  (SYNTAX ((d) == end1 ? *string2					\
../inputs/grep1.dat:           : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\
../inputs/grep1.dat:   || WORDCHAR_P (d - 1) != WORDCHAR_P (d))
../inputs/grep1.dat:   register values; since we have a limit of 255 registers (because
../inputs/grep1.dat:   use numbers larger than 255.  They must differ by 1, because of
../inputs/grep1.dat:#define NO_HIGHEST_ACTIVE_REG (1 << BYTEWIDTH)
../inputs/grep1.dat:#define NO_LOWEST_ACTIVE_REG (NO_HIGHEST_ACTIVE_REG + 1)
../inputs/grep1.dat:/* re_match is like re_match_2 except it takes only a single string.  */
../inputs/grep1.dat:  return re_match_2 (bufp, NULL, 0, string, size, pos, regs, size); 
../inputs/grep1.dat:/* re_match_2 matches the compiled pattern in BUFP against the
../inputs/grep1.dat:   the (virtual) concatenation of STRING1 and STRING2 (of length SIZE1
../inputs/grep1.dat:   and SIZE2, respectively).  We start matching at POS, and stop
../inputs/grep1.dat:   We return -1 if no match, -2 if an internal error (such as the
../inputs/grep1.dat:re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
../inputs/grep1.dat:     const char *string1, *string2;
../inputs/grep1.dat:     int size1, size2;
../inputs/grep1.dat:  unsigned char *p1;
../inputs/grep1.dat:  const char *end1, *end2;
../inputs/grep1.dat:  /* Pointers into string1 and string2, just past the last characters in
../inputs/grep1.dat:  const char *end_match_1, *end_match_2;
../inputs/grep1.dat:  unsigned num_regs = bufp->re_nsub + 1;
../inputs/grep1.dat:  DEBUG_PRINT1 ("\n\nEntering re_match_2.\n");
../inputs/grep1.dat:          return -2;
../inputs/grep1.dat:  if (pos < 0 || pos > size1 + size2)
../inputs/grep1.dat:      return -1;
../inputs/grep1.dat:  /* Initialize subexpression text positions to -1 to mark ones that no
../inputs/grep1.dat:  for (mcnt = 1; mcnt < num_regs; mcnt++)
../inputs/grep1.dat:  /* We move `string1' into `string2' if the latter's empty -- but not if
../inputs/grep1.dat:     `string1' is null.  */
../inputs/grep1.dat:  if (size2 == 0 && string1 != NULL)
../inputs/grep1.dat:      string2 = string1;
../inputs/grep1.dat:      size2 = size1;
../inputs/grep1.dat:      string1 = 0;
../inputs/grep1.dat:      size1 = 0;
../inputs/grep1.dat:  end1 = string1 + size1;
../inputs/grep1.dat:  end2 = string2 + size2;
../inputs/grep1.dat:  if (stop <= size1)
../inputs/grep1.dat:      end_match_1 = string1 + stop;
../inputs/grep1.dat:      end_match_2 = string2;
../inputs/grep1.dat:      end_match_1 = end1;
../inputs/grep1.dat:      end_match_2 = string2 + stop - size1;
../inputs/grep1.dat:     equal `string2'.  */
../inputs/grep1.dat:  if (size1 > 0 && pos <= size1)
../inputs/grep1.dat:      d = string1 + pos;
../inputs/grep1.dat:      dend = end_match_1;
../inputs/grep1.dat:      d = string2 + pos - size1;
../inputs/grep1.dat:      dend = end_match_2;
../inputs/grep1.dat:  DEBUG_PRINT1 ("The compiled pattern is: ");
../inputs/grep1.dat:  DEBUG_PRINT1 ("The string to match is: `");
../inputs/grep1.dat:  DEBUG_PRINT_DOUBLE_STRING (d, string1, size1, string2, size2);
../inputs/grep1.dat:  DEBUG_PRINT1 ("'\n");
../inputs/grep1.dat:      DEBUG_PRINT2 ("\n0x%x: ", p);
../inputs/grep1.dat:          DEBUG_PRINT1 ("end of pattern ... ");
../inputs/grep1.dat:          if (d != end_match_2)
../inputs/grep1.dat:              DEBUG_PRINT1 ("backtracking.\n");
../inputs/grep1.dat:                      DEBUG_PRINT1 ("\nSAVING match as best so far.\n");
../inputs/grep1.dat:                      for (mcnt = 1; mcnt < num_regs; mcnt++)
../inputs/grep1.dat:                     end_match_1' while the restored d is in string2.
../inputs/grep1.dat:                  DEBUG_PRINT1 ("Restoring best registers.\n");
../inputs/grep1.dat:                  dend = ((d >= string1 && d <= end1)
../inputs/grep1.dat:		           ? end_match_1 : end_match_2);
../inputs/grep1.dat:		  for (mcnt = 1; mcnt < num_regs; mcnt++)
../inputs/grep1.dat:            } /* d != end_match_2 */
../inputs/grep1.dat:          DEBUG_PRINT1 ("Accepting match.\n");
../inputs/grep1.dat:                     extra element beyond `num_regs' for the `-1' marker
../inputs/grep1.dat:                  regs->num_regs = MAX (RE_NREGS, num_regs + 1);
../inputs/grep1.dat:                    return -2;
../inputs/grep1.dat:                  if (regs->num_regs < num_regs + 1)
../inputs/grep1.dat:                      regs->num_regs = num_regs + 1;
../inputs/grep1.dat:                        return -2;
../inputs/grep1.dat:                  regs->end[0] = (MATCHING_IN_FIRST_STRING ? d - string1
../inputs/grep1.dat:			          : d - string2 + size1);
../inputs/grep1.dat:	      for (mcnt = 1; mcnt < MIN (num_regs, regs->num_regs); mcnt++)
../inputs/grep1.dat:                    regs->start[mcnt] = regs->end[mcnt] = -1;
../inputs/grep1.dat:                 were in the pattern, set the extra elements to -1.  If
../inputs/grep1.dat:                 -1 at the end.  */
../inputs/grep1.dat:                regs->start[mcnt] = regs->end[mcnt] = -1;
../inputs/grep1.dat:          DEBUG_PRINT2 ("%u registers pushed.\n", num_regs_pushed);
../inputs/grep1.dat:			    ? string1 
../inputs/grep1.dat:			    : string2 - size1);
../inputs/grep1.dat:          DEBUG_PRINT2 ("Returning %d from re_match_2.\n", mcnt);
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING no_op.\n");
../inputs/grep1.dat:          DEBUG_PRINT2 ("EXECUTING exactn %d.\n", mcnt);
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING anychar.\n");
../inputs/grep1.dat:          DEBUG_PRINT2 ("  Matched `%d'.\n", *d);
../inputs/grep1.dat:	    boolean not = (re_opcode_t) *(p - 1) == charset_not;
../inputs/grep1.dat:            DEBUG_PRINT2 ("EXECUTING charset%s.\n", not ? "_not" : "");
../inputs/grep1.dat:               bit list is a full 32 bytes long.  */
../inputs/grep1.dat:		&& p[1 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
../inputs/grep1.dat:	    p += 1 + *p;
../inputs/grep1.dat:	  DEBUG_PRINT3 ("EXECUTING start_memory %d (%d):\n", *p, p[1]);
../inputs/grep1.dat:	  p1 = p;		/* To send to group_match_null_string_p.  */
../inputs/grep1.dat:              = group_match_null_string_p (&p1, pend, reg_info);
../inputs/grep1.dat:	  DEBUG_PRINT2 ("  old_regstart: %d\n", 
../inputs/grep1.dat:	  DEBUG_PRINT2 ("  regstart: %d\n", POINTER_TO_OFFSET (regstart[*p]));
../inputs/grep1.dat:          IS_ACTIVE (reg_info[*p]) = 1;
../inputs/grep1.dat:          p += 2;
../inputs/grep1.dat:	  DEBUG_PRINT3 ("EXECUTING stop_memory %d (%d):\n", *p, p[1]);
../inputs/grep1.dat:	  DEBUG_PRINT2 ("      old_regend: %d\n", 
../inputs/grep1.dat:	  DEBUG_PRINT2 ("      regend: %d\n", POINTER_TO_OFFSET (regend[*p]));
../inputs/grep1.dat:                 new highest active register is 1.  */
../inputs/grep1.dat:              unsigned char r = *p - 1;
../inputs/grep1.dat:                 registers 1 and 2 as a result of the *, but when we pop
../inputs/grep1.dat:                 back to the second ), we are at the stop_memory 1.
../inputs/grep1.dat:	      && (p + 2) < pend)              
../inputs/grep1.dat:              p1 = p + 2;
../inputs/grep1.dat:              switch ((re_opcode_t) *p1++)
../inputs/grep1.dat:                    EXTRACT_NUMBER_AND_INCR (mcnt, p1);
../inputs/grep1.dat:		      p1 += 2;
../inputs/grep1.dat:	      p1 += mcnt;
../inputs/grep1.dat:              if (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump
../inputs/grep1.dat:                  && (re_opcode_t) p1[3] == start_memory && p1[4] == *p)
../inputs/grep1.dat:                     regstart[1], and, e.g., with `((a*)*(b*)*)*'
../inputs/grep1.dat:                      for (r = *p; r < *p + *(p + 1); r++)
../inputs/grep1.dat:		  p1++;
../inputs/grep1.dat:                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
../inputs/grep1.dat:                  PUSH_FAILURE_POINT (p1 + mcnt, d, -2);
../inputs/grep1.dat:          p += 2;
../inputs/grep1.dat:	    register const char *d2, *dend2;
../inputs/grep1.dat:	    DEBUG_PRINT2 ("EXECUTING duplicate %d.\n", regno);
../inputs/grep1.dat:            d2 = regstart[regno];
../inputs/grep1.dat:            dend2 = ((FIRST_STRING_P (regstart[regno]) 
../inputs/grep1.dat:		     ? regend[regno] : end_match_1);
../inputs/grep1.dat:		while (d2 == dend2)
../inputs/grep1.dat:		    if (dend2 == end_match_2) break;
../inputs/grep1.dat:		    if (dend2 == regend[regno]) break;
../inputs/grep1.dat:                    /* End of string1 => advance to string2. */
../inputs/grep1.dat:                    d2 = string2;
../inputs/grep1.dat:                    dend2 = regend[regno];
../inputs/grep1.dat:		if (d2 == dend2) break;
../inputs/grep1.dat:                if (mcnt > dend2 - d2)
../inputs/grep1.dat:		  mcnt = dend2 - d2;
../inputs/grep1.dat:                    ? bcmp_translate (d, d2, mcnt, translate) 
../inputs/grep1.dat:                    : bcmp (d, d2, mcnt))
../inputs/grep1.dat:		d += mcnt, d2 += mcnt;
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING begline.\n");
../inputs/grep1.dat:          else if (d[-1] == '\n' && bufp->newline_anchor)
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING endline.\n");
../inputs/grep1.dat:          else if ((d == end1 ? *string2 : *d) == '\n'
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING begbuf.\n");
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING endbuf.\n");
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING on_failure_keep_string_jump");
../inputs/grep1.dat:          PUSH_FAILURE_POINT (p + mcnt, NULL, -2);
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING on_failure_jump");
../inputs/grep1.dat:             For example, in \(a*\)*\1, we need the preceding group,
../inputs/grep1.dat:             and in \(\(a*\)b*\)\2, we need the inner group.  */
../inputs/grep1.dat:          p1 = p;
../inputs/grep1.dat:             the result of a completed succeed_n, as in \(a\)\{1,3\}b\1
../inputs/grep1.dat:          while (p1 < pend && (re_opcode_t) *p1 == no_op)
../inputs/grep1.dat:            p1++;
../inputs/grep1.dat:          if (p1 < pend && (re_opcode_t) *p1 == start_memory)
../inputs/grep1.dat:              highest_active_reg = *(p1 + 1) + *(p1 + 2);
../inputs/grep1.dat:                lowest_active_reg = *(p1 + 1);
../inputs/grep1.dat:          DEBUG_PRINT1 (":\n");
../inputs/grep1.dat:          PUSH_FAILURE_POINT (p + mcnt, d, -2);
../inputs/grep1.dat:          DEBUG_PRINT2 ("EXECUTING maybe_pop_jump %d.\n", mcnt);
../inputs/grep1.dat:	    register unsigned char *p2 = p;
../inputs/grep1.dat:	    while (p2 + 2 < pend
../inputs/grep1.dat:		   && ((re_opcode_t) *p2 == stop_memory
../inputs/grep1.dat:		       || (re_opcode_t) *p2 == start_memory))
../inputs/grep1.dat:	      p2 += 3;			/* Skip over args, too.  */
../inputs/grep1.dat:            if (p2 == pend)
../inputs/grep1.dat:                DEBUG_PRINT1
../inputs/grep1.dat:            else if ((re_opcode_t) *p2 == exactn
../inputs/grep1.dat:		     || (bufp->newline_anchor && (re_opcode_t) *p2 == endline))
../inputs/grep1.dat:                  = *p2 == (unsigned char) endline ? '\n' : p2[2];
../inputs/grep1.dat:		p1 = p + mcnt;
../inputs/grep1.dat:                /* p1[0] ... p1[2] are the `on_failure_jump' corresponding
../inputs/grep1.dat:                if ((re_opcode_t) p1[3] == exactn && p1[5] != c)
../inputs/grep1.dat:                                  c, p1[5]);
../inputs/grep1.dat:		else if ((re_opcode_t) p1[3] == charset
../inputs/grep1.dat:			 || (re_opcode_t) p1[3] == charset_not)
../inputs/grep1.dat:		    int not = (re_opcode_t) p1[3] == charset_not;
../inputs/grep1.dat:		    if (c < (unsigned char) (p1[4] * BYTEWIDTH)
../inputs/grep1.dat:			&& p1[5 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
../inputs/grep1.dat:                    /* `not' is equal to 1 if c would match, which means
../inputs/grep1.dat:                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
../inputs/grep1.dat:	  p -= 2;		/* Point at relative address again.  */
../inputs/grep1.dat:	  if ((re_opcode_t) p[-1] != pop_failure_jump)
../inputs/grep1.dat:	      p[-1] = (unsigned char) jump;
../inputs/grep1.dat:              DEBUG_PRINT1 ("  Match => jump.\n");
../inputs/grep1.dat:            DEBUG_PRINT1 ("EXECUTING pop_failure_jump.\n");
../inputs/grep1.dat:          DEBUG_PRINT2 ("EXECUTING jump %d ", mcnt);
../inputs/grep1.dat:          DEBUG_PRINT2 ("(to 0x%x).\n", p);
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING jump_past_alt.\n");
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING dummy_failure_jump.\n");
../inputs/grep1.dat:          PUSH_FAILURE_POINT (0, 0, -2);
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING push_dummy_failure.\n");
../inputs/grep1.dat:          PUSH_FAILURE_POINT (0, 0, -2);
../inputs/grep1.dat:          EXTRACT_NUMBER (mcnt, p + 2);
../inputs/grep1.dat:          DEBUG_PRINT2 ("EXECUTING succeed_n %d.\n", mcnt);
../inputs/grep1.dat:	       p += 2;
../inputs/grep1.dat:              DEBUG_PRINT2 ("  Setting two bytes from 0x%x to no_op.\n", p+2);
../inputs/grep1.dat:	      p[2] = (unsigned char) no_op;
../inputs/grep1.dat:          EXTRACT_NUMBER (mcnt, p + 2);
../inputs/grep1.dat:          DEBUG_PRINT2 ("EXECUTING jump_n %d.\n", mcnt);
../inputs/grep1.dat:               STORE_NUMBER (p + 2, mcnt);
../inputs/grep1.dat:            DEBUG_PRINT1 ("EXECUTING set_number_at.\n");
../inputs/grep1.dat:            p1 = p + mcnt;
../inputs/grep1.dat:            DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p1, mcnt);
../inputs/grep1.dat:	    STORE_NUMBER (p1, mcnt);
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING wordbound.\n");
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING notwordbound.\n");
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING wordbeg.\n");
../inputs/grep1.dat:	  if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING wordend.\n");
../inputs/grep1.dat:	  if (!AT_STRINGS_BEG (d) && WORDCHAR_P (d - 1)
../inputs/grep1.dat:#ifdef emacs19
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING before_dot.\n");
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING at_dot.\n");
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING after_dot.\n");
../inputs/grep1.dat:#else /* not emacs19 */
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING at_dot.\n");
../inputs/grep1.dat:	  if (PTR_CHAR_POS ((unsigned char *) d) + 1 != point)
../inputs/grep1.dat:#endif /* not emacs19 */
../inputs/grep1.dat:          DEBUG_PRINT2 ("EXECUTING syntaxspec %d.\n", mcnt);
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING Emacs wordchar.\n");
../inputs/grep1.dat:          DEBUG_PRINT2 ("EXECUTING notsyntaxspec %d.\n", mcnt);
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING Emacs notwordchar.\n");
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING non-Emacs wordchar.\n");
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING non-Emacs notwordchar.\n");
../inputs/grep1.dat:          DEBUG_PRINT1 ("\nFAIL:\n");
../inputs/grep1.dat:                  p1 = p + 1;
../inputs/grep1.dat:                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
../inputs/grep1.dat:                  p1 += mcnt;	
../inputs/grep1.dat:                  if ((is_a_jump_n && (re_opcode_t) *p1 == succeed_n)
../inputs/grep1.dat:                          && (re_opcode_t) *p1 == on_failure_jump))
../inputs/grep1.dat:          if (d >= string1 && d <= end1)
../inputs/grep1.dat:	    dend = end_match_1;
../inputs/grep1.dat:  return -1;         			/* Failure to match.  */
../inputs/grep1.dat:} /* re_match_2 */
../inputs/grep1.dat:/* Subroutine definitions for re_match_2.  */
../inputs/grep1.dat:  unsigned char *p1 = *p + 2;
../inputs/grep1.dat:  while (p1 < end)
../inputs/grep1.dat:      switch ((re_opcode_t) *p1)
../inputs/grep1.dat:          p1++;
../inputs/grep1.dat:          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
../inputs/grep1.dat:                 /on_failure_jump/0/6/exactn/1/a/jump_past_alt/0/6
../inputs/grep1.dat:                 /on_failure_jump/0/6/exactn/1/b/jump_past_alt/0/3
../inputs/grep1.dat:                 /exactn/1/c						
../inputs/grep1.dat:                 So, we have to first go through the first (n-1)
../inputs/grep1.dat:              /* Deal with the first (n-1) alternatives, which start
../inputs/grep1.dat:              while ((re_opcode_t) p1[mcnt-3] == jump_past_alt)
../inputs/grep1.dat:                  if (!alt_match_null_string_p (p1, p1 + mcnt - 3, 
../inputs/grep1.dat:                  p1 += mcnt;	
../inputs/grep1.dat:                  if ((re_opcode_t) *p1 != on_failure_jump)
../inputs/grep1.dat:		  p1++;
../inputs/grep1.dat:                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
../inputs/grep1.dat:                  if ((re_opcode_t) p1[mcnt-3] != jump_past_alt)
../inputs/grep1.dat:                      p1 -= 3;
../inputs/grep1.dat:              EXTRACT_NUMBER (mcnt, p1 - 2);
../inputs/grep1.dat:              if (!alt_match_null_string_p (p1, p1 + mcnt, reg_info))
../inputs/grep1.dat:              p1 += mcnt;	/* Get past the n-th alternative.  */
../inputs/grep1.dat:	  assert (p1[1] == **p);
../inputs/grep1.dat:          *p = p1 + 2;
../inputs/grep1.dat:          if (!common_op_match_null_string_p (&p1, end, reg_info))
../inputs/grep1.dat:    } /* while p1 < end */
../inputs/grep1.dat:  unsigned char *p1 = p;
../inputs/grep1.dat:  while (p1 < end)
../inputs/grep1.dat:      switch ((re_opcode_t) *p1)
../inputs/grep1.dat:          p1++;
../inputs/grep1.dat:          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
../inputs/grep1.dat:          p1 += mcnt;
../inputs/grep1.dat:          if (!common_op_match_null_string_p (&p1, end, reg_info))
../inputs/grep1.dat:    }  /* while p1 < end */
../inputs/grep1.dat:  unsigned char *p1 = *p;
../inputs/grep1.dat:  switch ((re_opcode_t) *p1++)
../inputs/grep1.dat:      reg_no = *p1;
../inputs/grep1.dat:      ret = group_match_null_string_p (&p1, end, reg_info);
../inputs/grep1.dat:      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
../inputs/grep1.dat:        p1 += mcnt;
../inputs/grep1.dat:      p1 += 2;		
../inputs/grep1.dat:      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
../inputs/grep1.dat:          p1 -= 4;
../inputs/grep1.dat:          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
../inputs/grep1.dat:          p1 += mcnt;
../inputs/grep1.dat:      if (!REG_MATCH_NULL_STRING_P (reg_info[*p1]))
../inputs/grep1.dat:      p1 += 4;
../inputs/grep1.dat:  *p = p1;
../inputs/grep1.dat:/* Return zero if TRANSLATE[S1] and TRANSLATE[S2] are identical for LEN
../inputs/grep1.dat:bcmp_translate (s1, s2, len, translate)
../inputs/grep1.dat:     unsigned char *s1, *s2;
../inputs/grep1.dat:  register unsigned char *p1 = s1, *p2 = s2;
../inputs/grep1.dat:      if (translate[*p1++] != translate[*p2++]) return 1;
../inputs/grep1.dat:     (and at least one extra will be -1).  */
../inputs/grep1.dat:  bufp->newline_anchor = 1;
../inputs/grep1.dat:/* Entry points compatible with 4.2 BSD regex library.  We don't define
../inputs/grep1.dat:      re_comp_buf.buffer = (unsigned char *) malloc (200);
../inputs/grep1.dat:      re_comp_buf.allocated = 200;
../inputs/grep1.dat:      re_comp_buf.fastmap = (char *) malloc (1 << BYTEWIDTH);
../inputs/grep1.dat:  re_comp_buf.newline_anchor = 1;
../inputs/grep1.dat:/* POSIX.2 functions.  Don't define these for Emacs.  */
../inputs/grep1.dat:      preg->newline_anchor = 1;
../inputs/grep1.dat:  msg_size = strlen (msg) + 1; /* Includes the null.  */
../inputs/grep1.dat:          strncpy (errbuf, msg, errbuf_size - 1);
../inputs/grep1.dat:          errbuf[errbuf_size - 1] = 0;
../inputs/grep1.dat:   Copyright (C) 1988 Free Software Foundation, Inc.
../inputs/grep1.dat:   the Free Software Foundation; either version 2, or (at your option)
../inputs/grep1.dat:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
../inputs/grep1.dat:/* Written June, 1988 by Mike Haertel
../inputs/grep1.dat:   Modified July, 1988 by Arthur David Olson to assist BMG speedups  */
../inputs/grep1.dat:#define flag_stdlib 1
../inputs/grep1.dat:#define flag_systypes 1
../inputs/grep1.dat:#define flag_string 1
../inputs/grep1.dat:#define flag_strings 1
../inputs/grep1.dat:xmalloc_1(n)
../inputs/grep1.dat:xrealloc_1(p, n)
../inputs/grep1.dat:#define MALLOC(p, t, n) ((p) = (t *) xmalloc_1((n) * sizeof (t)))
../inputs/grep1.dat:#define REALLOC(p, t, n) ((p) = (t *) xrealloc_1((ptr_t) (p), (n) * sizeof (t)))
../inputs/grep1.dat:	(nalloc) *= 2;				  \
../inputs/grep1.dat:  return c[b / INTBITS] & 1 << b % INTBITS;
../inputs/grep1.dat:  c[b / INTBITS] |= 1 << b % INTBITS;
../inputs/grep1.dat:  c[b / INTBITS] &= ~(1 << b % INTBITS);
../inputs/grep1.dat:equal(s1, s2)
../inputs/grep1.dat:     charclass s1;
../inputs/grep1.dat:     charclass s2;
../inputs/grep1.dat:    if (s1[i] != s2[i])
../inputs/grep1.dat:  return 1;
../inputs/grep1.dat:  syntax_bits_set = 1;
../inputs/grep1.dat:  token c, c1, c2;
../inputs/grep1.dat:  for (i = 0; i < 2; ++i)
../inputs/grep1.dat:	  backslash = 1;
../inputs/grep1.dat:		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == ')')
../inputs/grep1.dat:		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == '|')
../inputs/grep1.dat:	case '1':
../inputs/grep1.dat:	case '2':
../inputs/grep1.dat:		  minrep = 10 * minrep + c - '0';
../inputs/grep1.dat:		maxrep = 10 * maxrep + c - '0';
../inputs/grep1.dat:	  laststart = 1;
../inputs/grep1.dat:	  laststart = 1;
../inputs/grep1.dat:	  laststart = 1;
../inputs/grep1.dat:	  for (c2 = 0; c2 < NOTCHAR; ++c2)
../inputs/grep1.dat:	    if (ISALNUM(c2))
../inputs/grep1.dat:	      setbit(c2, ccl);
../inputs/grep1.dat:	      invert = 1;
../inputs/grep1.dat:		for (c1 = 0; prednames[c1].name; ++c1)
../inputs/grep1.dat:		  if (looking_at(prednames[c1].name))
../inputs/grep1.dat:		      for (c2 = 0; c2 < NOTCHAR; ++c2)
../inputs/grep1.dat:			if ((*prednames[c1].pred)(c2))
../inputs/grep1.dat:			  setbit(c2, ccl);
../inputs/grep1.dat:		      lexptr += strlen(prednames[c1].name);
../inputs/grep1.dat:		      lexleft -= strlen(prednames[c1].name);
../inputs/grep1.dat:		      FETCH(c1, "Unbalanced [");
../inputs/grep1.dat:	      FETCH(c1, "Unbalanced [");
../inputs/grep1.dat:	      if (c1 == '-')
../inputs/grep1.dat:		  FETCH(c2, "Unbalanced [");
../inputs/grep1.dat:		  if (c2 == ']')
../inputs/grep1.dat:			 which is left in c1, the lookahead character. */
../inputs/grep1.dat:		      c2 = c;
../inputs/grep1.dat:		      if (c2 == '\\'
../inputs/grep1.dat:			FETCH(c2, "Unbalanced [");
../inputs/grep1.dat:		      FETCH(c1, "Unbalanced [");
../inputs/grep1.dat:		c2 = c;
../inputs/grep1.dat:	      while (c <= c2)
../inputs/grep1.dat:	  while ((c = c1) != ']');
../inputs/grep1.dat:  int ntoks1;
../inputs/grep1.dat:  switch (dfa->tokens[tindex - 1])
../inputs/grep1.dat:      return 1;
../inputs/grep1.dat:      return 1 + nsubtoks(tindex - 1);
../inputs/grep1.dat:      ntoks1 = nsubtoks(tindex - 1);
../inputs/grep1.dat:      return 1 + ntoks1 + nsubtoks(tindex - 1 - ntoks1);
../inputs/grep1.dat:	for (i = 1; i < minrep; ++i)
../inputs/grep1.dat:  laststart = 1;
../inputs/grep1.dat:  regexp(1);
../inputs/grep1.dat:  position t1, t2;
../inputs/grep1.dat:      t1 = p;
../inputs/grep1.dat:	  t2 = s->elems[i];
../inputs/grep1.dat:	  s->elems[i++] = t1;
../inputs/grep1.dat:	  t1 = t2;
../inputs/grep1.dat:merge(s1, s2, m)
../inputs/grep1.dat:     position_set *s1;
../inputs/grep1.dat:     position_set *s2;
../inputs/grep1.dat:  while (i < s1->nelem && j < s2->nelem)
../inputs/grep1.dat:    if (s1->elems[i].index > s2->elems[j].index)
../inputs/grep1.dat:      m->elems[m->nelem++] = s1->elems[i++];
../inputs/grep1.dat:    else if (s1->elems[i].index < s2->elems[j].index)
../inputs/grep1.dat:      m->elems[m->nelem++] = s2->elems[j++];
../inputs/grep1.dat:	m->elems[m->nelem] = s1->elems[i++];
../inputs/grep1.dat:	m->elems[m->nelem++].constraint |= s2->elems[j++].constraint;
../inputs/grep1.dat:  while (i < s1->nelem)
../inputs/grep1.dat:    m->elems[m->nelem++] = s1->elems[i++];
../inputs/grep1.dat:  while (j < s2->nelem)
../inputs/grep1.dat:    m->elems[m->nelem++] = s2->elems[j++];
../inputs/grep1.dat:      s->elems[i] = s->elems[i + 1];
../inputs/grep1.dat:  newline = newline ? 1 : 0;
../inputs/grep1.dat:  letter = letter ? 1 : 0;
../inputs/grep1.dat:	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 0, letter, 1)
../inputs/grep1.dat:	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 1, letter, 0)
../inputs/grep1.dat:	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 1, letter, 1))
../inputs/grep1.dat:	d->states[i].backref = 1;
../inputs/grep1.dat:	visited[old.index] = 1;
../inputs/grep1.dat:	i = -1;
../inputs/grep1.dat:	*nullable++ = 1;
../inputs/grep1.dat:	tmp.nelem = nfirstpos[-1];
../inputs/grep1.dat:	for (j = 0; j < nlastpos[-1]; ++j)
../inputs/grep1.dat:				 nalloc[pos[j].index], merged.nelem - 1);
../inputs/grep1.dat:	  nullable[-1] = 1;
../inputs/grep1.dat:	tmp.nelem = nfirstpos[-1];
../inputs/grep1.dat:	pos = lastpos + nlastpos[-1];
../inputs/grep1.dat:	for (j = 0; j < nlastpos[-2]; ++j)
../inputs/grep1.dat:				 nalloc[pos[j].index], merged.nelem - 1);
../inputs/grep1.dat:	if (nullable[-2])
../inputs/grep1.dat:	  nfirstpos[-2] += nfirstpos[-1];
../inputs/grep1.dat:	  firstpos += nfirstpos[-1];
../inputs/grep1.dat:	if (nullable[-1])
../inputs/grep1.dat:	  nlastpos[-2] += nlastpos[-1];
../inputs/grep1.dat:	    pos = lastpos + nlastpos[-2];
../inputs/grep1.dat:	    for (j = nlastpos[-1] - 1; j >= 0; --j)
../inputs/grep1.dat:	    lastpos += nlastpos[-2];
../inputs/grep1.dat:	    nlastpos[-2] = nlastpos[-1];
../inputs/grep1.dat:	nullable[-2] = nullable[-1] && nullable[-2];
../inputs/grep1.dat:	nfirstpos[-2] += nfirstpos[-1];
../inputs/grep1.dat:	nlastpos[-2] += nlastpos[-1];
../inputs/grep1.dat:	nullable[-2] = nullable[-1] || nullable[-2];
../inputs/grep1.dat:	*nfirstpos++ = *nlastpos++ = 1;
../inputs/grep1.dat:	nalloc[i] = 1;
../inputs/grep1.dat:      fprintf(stderr, nullable[-1] ? " nullable: yes\n" : " nullable: no\n");
../inputs/grep1.dat:      for (j = nfirstpos[-1] - 1; j >= 0; --j)
../inputs/grep1.dat:      for (j = nlastpos[-1] - 1; j >= 0; --j)
../inputs/grep1.dat:	for (j = d->follows[i].nelem - 1; j >= 0; --j)
../inputs/grep1.dat:  for (i = 0; i < nfirstpos[-1]; ++i)
../inputs/grep1.dat:      wants_newline = 1;
../inputs/grep1.dat:  d->salloc = 1;
../inputs/grep1.dat:      initialized = 1;
../inputs/grep1.dat:					 d->states[s].newline, 1))
../inputs/grep1.dat:					d->states[s].letter, 1))
../inputs/grep1.dat:	    (intersect[k] = matches[k] & labels[j][k]) ? intersectf = 1 : 0;
../inputs/grep1.dat:	      (leftovers[k] = ~match & label) ? leftoversf = 1 : 0;
../inputs/grep1.dat:	      (matches[k] = match & ~label) ? matchesf = 1 : 0;
../inputs/grep1.dat:	  grps[ngrps].nelem = 1;
../inputs/grep1.dat:	    wants_newline = 1;
../inputs/grep1.dat:	    wants_letter = 1;
../inputs/grep1.dat:	state_newline = state_index(d, &follows, 1, 0);
../inputs/grep1.dat:	state_letter = state_index(d, &follows, 0, 1);
../inputs/grep1.dat:      trans[i] = -1;
../inputs/grep1.dat:	    wants_newline = 1;
../inputs/grep1.dat:	    wants_letter = 1;
../inputs/grep1.dat:	state_newline = state_index(d, &follows, 1, 0);
../inputs/grep1.dat:	state_letter = state_index(d, &follows, 0, 1);
../inputs/grep1.dat:	  if (labels[i][j] & 1 << k)
../inputs/grep1.dat:     exist at once.  1024 is arbitrary.  The idea is that the frequently
../inputs/grep1.dat:  if (d->trcount >= 1024)
../inputs/grep1.dat:  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 1, d->states[s].letter, 0,
../inputs/grep1.dat:  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 0, d->states[s].letter, 1,
../inputs/grep1.dat:    d->success[s] |= 2;
../inputs/grep1.dat:    d->success[s] |= 1;
../inputs/grep1.dat:	  d->tralloc *= 2;
../inputs/grep1.dat:	REALLOC(d->realtrans, int *, d->tralloc + 1);
../inputs/grep1.dat:	d->trans = d->realtrans + 1;
../inputs/grep1.dat:  trans['\n'] = -1;
../inputs/grep1.dat:  d->tralloc = 1;
../inputs/grep1.dat:  CALLOC(d->realtrans, int *, d->tralloc + 1);
../inputs/grep1.dat:  d->trans = d->realtrans + 1;
../inputs/grep1.dat:   where we're supposed to store a 1 if backreferencing happened and the
../inputs/grep1.dat:  register s, s1, tmp;		/* Current state. */
../inputs/grep1.dat:      sbit_init = 1;
../inputs/grep1.dat:	  sbit[i] = 2;
../inputs/grep1.dat:	  sbit[i] = 1;
../inputs/grep1.dat:  s = s1 = 0;
../inputs/grep1.dat:	    s1 = t[*p++];
../inputs/grep1.dat:	    if (! (t = trans[s1]))
../inputs/grep1.dat:      goto last_was_s1;
../inputs/grep1.dat:      tmp = s, s = s1, s1 = tmp;
../inputs/grep1.dat:    last_was_s1:
../inputs/grep1.dat:		  *backref = 1;
../inputs/grep1.dat:	  s1 = s;
../inputs/grep1.dat:      if (count && (char *) p <= end && p[-1] == '\n')
../inputs/grep1.dat:      if (p[-1] == '\n' && newline)
../inputs/grep1.dat:	  s = d->newlines[s1];
../inputs/grep1.dat:  d->calloc = 1;
../inputs/grep1.dat:  d->talloc = 1;
../inputs/grep1.dat:      case_fold = 1;
../inputs/grep1.dat:    result = (char *) malloc(newsize + 1);
../inputs/grep1.dat:    result = (char *) realloc((void *) old, oldsize + newsize + 1);
../inputs/grep1.dat:  cpp = (char **) realloc((char *) cpp, (i + 2) * sizeof *cpp);
../inputs/grep1.dat:  cpp[i + 1] = NULL;
../inputs/grep1.dat:	  for (i = 1; lcp[i] != '\0' && lcp[i] == rcp[i]; ++i)
../inputs/grep1.dat:	  rcp = index(rcp + 1, *lcp);
../inputs/grep1.dat:  musts = (must *) malloc((dfa->tindex + 1) * sizeof *musts);
../inputs/grep1.dat:      mp[i].left = malloc(2);
../inputs/grep1.dat:      mp[i].right = malloc(2);
../inputs/grep1.dat:      mp[i].is = malloc(2);
../inputs/grep1.dat:	  if (mp < &musts[2])
../inputs/grep1.dat:	      if (lmp->right[ln - i - 1] != rmp->right[rn - i - 1])
../inputs/grep1.dat:	  if (mp != &musts[1])
../inputs/grep1.dat:	    exact = 1;
../inputs/grep1.dat:	  if (mp < &musts[2])
../inputs/grep1.dat:	      mp->is[1] = mp->left[1] = mp->right[1] = '\0';
../inputs/grep1.dat:	      mp->in = enlist(mp->in, mp->is, 1);
../inputs/grep1.dat:      dm->must = malloc(strlen(result) + 1);
../inputs/grep1.dat:   Copyright 1989 Free Software Foundation
../inputs/grep1.dat:		  Written August 1989 by Mike Haertel.
../inputs/grep1.dat:   the Free Software Foundation; either version 1, or (at your option)
../inputs/grep1.dat:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
../inputs/grep1.dat:   IBM-Germany, Scientific Center Heidelberg, Tiergartenstrasse 15, D-6900
../inputs/grep1.dat:   String Matching:  An Aid to Bibliographic Search," CACM June 1975,
../inputs/grep1.dat:   Vol. 18, No. 6, which describes the failure function used below. */
../inputs/grep1.dat:#define flag_limits 1
../inputs/grep1.dat:#define flag_stdlib 1
../inputs/grep1.dat:#define INT_MAX 2147483647
../inputs/grep1.dat:#define UCHAR_MAX 255
../inputs/grep1.dat:#define flag_systypes 1
../inputs/grep1.dat:#define flag_string 1
../inputs/grep1.dat:#define flag_memory 1
../inputs/grep1.dat:#define NCHAR (UCHAR_MAX + 1)
../inputs/grep1.dat:  int mind2;			/* Used in Boyer-Moore search for one string. */
../inputs/grep1.dat:  kwset->maxd = -1;
../inputs/grep1.dat:  struct tree *links[12];
../inputs/grep1.dat:  enum { L, R } dirs[12];
../inputs/grep1.dat:      depth = 1;
../inputs/grep1.dat:	  link->trie->depth = trie->depth + 1;
../inputs/grep1.dat:		case (char) -2:
../inputs/grep1.dat:		  switch (dirs[depth + 1])
../inputs/grep1.dat:		      l->balance = t->balance != 1 ? 0 : -1;
../inputs/grep1.dat:		      r->balance = t->balance != (char) -1 ? 0 : 1;
../inputs/grep1.dat:		case 2:
../inputs/grep1.dat:		  switch (dirs[depth + 1])
../inputs/grep1.dat:		      l->balance = t->balance != 1 ? 0 : -1;
../inputs/grep1.dat:		      r->balance = t->balance != (char) -1 ? 0 : 1;
../inputs/grep1.dat:	      if (dirs[depth - 1] == L)
../inputs/grep1.dat:		links[depth - 1]->llink = t;
../inputs/grep1.dat:		links[depth - 1]->rlink = t;
../inputs/grep1.dat:    trie->accepting = 1 + 2 * kwset->words;
../inputs/grep1.dat:    return 1;
../inputs/grep1.dat:  if (kwset->mind < 256)
../inputs/grep1.dat:      delta[i] = 255;
../inputs/grep1.dat:  if (kwset->words == 1 && kwset->trans == 0)
../inputs/grep1.dat:      for (i = kwset->mind - 1, curr = kwset->trie; i >= 0; --i)
../inputs/grep1.dat:	delta[(unsigned char) kwset->target[i]] = kwset->mind - (i + 1);
../inputs/grep1.dat:      kwset->mind2 = kwset->mind;
../inputs/grep1.dat:      /* Find the minimal delta2 shift that we might make after
../inputs/grep1.dat:      for (i = 0; i < kwset->mind - 1; ++i)
../inputs/grep1.dat:	if (kwset->target[i] == kwset->target[kwset->mind - 1])
../inputs/grep1.dat:	  kwset->mind2 = kwset->mind - (i + 1);
../inputs/grep1.dat:  register unsigned char *d1;
../inputs/grep1.dat:  register int d, gc, i, len, md2;
../inputs/grep1.dat:  if (len == 1)
../inputs/grep1.dat:  d1 = kwset->delta;
../inputs/grep1.dat:  gc = U(sp[-2]);
../inputs/grep1.dat:  md2 = kwset->mind2;
../inputs/grep1.dat:  /* Significance of 12: 1 (initial offset) + 10 (skip loop) + 1 (md2). */
../inputs/grep1.dat:  if (size > 12 * len)
../inputs/grep1.dat:    /* 11 is not a bug, the initial offset happens only once. */
../inputs/grep1.dat:    for (ep = text + size - 11 * len;;)
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	if (U(tp[-2]) == gc)
../inputs/grep1.dat:	tp += md2;
../inputs/grep1.dat:  d = d1[U(tp[-1])];
../inputs/grep1.dat:      d = d1[U((tp += d)[-1])];
../inputs/grep1.dat:      if (tp[-2] == gc)
../inputs/grep1.dat:      d = md2;
../inputs/grep1.dat:	  end += d - 1;
../inputs/grep1.dat:	d = delta[c = (end += d)[-1]];
../inputs/grep1.dat:      beg = end - 1;
../inputs/grep1.dat:  d = 1;
../inputs/grep1.dat:      if ((d = delta[c = (end += d)[-1]]) != 0)
../inputs/grep1.dat:      beg = end - 1;
../inputs/grep1.dat:	  d = 1;
../inputs/grep1.dat:	d = 1;
../inputs/grep1.dat:      kwsmatch->index = accept->accepting / 2;
../inputs/grep1.dat:  if (kwset->words == 1 && kwset->trans == 0)
../inputs/grep1.dat:   Copyright (C) 1988, 1993 Free Software Foundation, Inc.
../inputs/grep1.dat:Free Software Foundation; either version 2, or (at your option) any
../inputs/grep1.dat:Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
../inputs/grep1.dat:      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
../inputs/grep1.dat:      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
../inputs/grep1.dat:		    + 4 + DEFAULT_ROUNDING - 1)
../inputs/grep1.dat:		   & ~(DEFAULT_ROUNDING - 1));
../inputs/grep1.dat:  h->alignment_mask = alignment - 1;
../inputs/grep1.dat:_obstack_begin_1 (h, size, alignment, chunkfun, freefun, arg)
../inputs/grep1.dat:      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
../inputs/grep1.dat:      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
../inputs/grep1.dat:		    + 4 + DEFAULT_ROUNDING - 1)
../inputs/grep1.dat:		   & ~(DEFAULT_ROUNDING - 1));
../inputs/grep1.dat:  h->alignment_mask = alignment - 1;
../inputs/grep1.dat:  h->use_extra_arg = 1;
../inputs/grep1.dat:  new_size = (obj_size + length) + (obj_size >> 3) + 100;
../inputs/grep1.dat:  if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)
../inputs/grep1.dat:      for (i = obj_size / sizeof (COPYING_UNIT) - 1;
../inputs/grep1.dat:      h->maybe_empty_object = 1;
../inputs/grep1.dat:      h->maybe_empty_object = 1;
../inputs/grep1.dat:void (obstack_1grow) (obstack, character)
../inputs/grep1.dat:  obstack_1grow (obstack, character);
../inputs/grep1.dat:void (obstack_1grow_fast) (obstack, character)
../inputs/grep1.dat:  obstack_1grow_fast (obstack, character);
../inputs/grep1.dat:   Copyright (C) 1992 Free Software Foundation, Inc.
../inputs/grep1.dat:   the Free Software Foundation; either version 2, or (at your option)
../inputs/grep1.dat:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
../inputs/grep1.dat:   Written August 1992 by Mike Haertel. */
../inputs/grep1.dat:#define flag_limits 1
../inputs/grep1.dat:#define flag_stdlib 1
../inputs/grep1.dat:#define UCHAR_MAX 255
../inputs/grep1.dat:#define flag_systypes 1
../inputs/grep1.dat:#define flag_string 1
../inputs/grep1.dat:#define flag_memory 1
../inputs/grep1.dat:#define NCHAR (UCHAR_MAX + 1)
../inputs/grep1.dat:static struct dfa dfa_1;
../inputs/grep1.dat:  if (dfa_1.musts)
../inputs/grep1.dat:      for (dm = dfa_1.musts; dm; dm = dm->next)
../inputs/grep1.dat:      for (dm = dfa_1.musts; dm; dm = dm->next)
../inputs/grep1.dat:  dfainit(&dfa_1);
../inputs/grep1.dat:      dfacomp(n, i, &dfa_1, 1);
../inputs/grep1.dat:    dfacomp(pattern, size, &dfa_1, 1);
../inputs/grep1.dat:  dfainit(&dfa_1);
../inputs/grep1.dat:      dfacomp(n, i, &dfa_1, 1);
../inputs/grep1.dat:    dfacomp(pattern, size, &dfa_1, 1);
../inputs/grep1.dat:  for (beg = end = buf; end < buflim; beg = end + 1)
../inputs/grep1.dat:	  while (beg > buf && beg[-1] != '\n')
../inputs/grep1.dat:	  if (!dfaexec(&dfa_1, beg, end, 0, (int *) 0, &backref))
../inputs/grep1.dat:	  beg = dfaexec(&dfa_1, beg, buflim, 0, (int *) 0, &backref);
../inputs/grep1.dat:	  while (beg > buf && beg[-1] != '\n')
../inputs/grep1.dat:		if ((start == 0 || !WCHAR(beg[start - 1]))
../inputs/grep1.dat:		    regex.not_eol = 1;
../inputs/grep1.dat:  *endp = end < buflim ? end + 1 : end;
../inputs/grep1.dat:	  if (beg > buf && beg[-1] != '\n')
../inputs/grep1.dat:	    if (try > buf && WCHAR((unsigned char) try[-1]))
../inputs/grep1.dat:  while (beg > buf && beg[-1] != '\n')
