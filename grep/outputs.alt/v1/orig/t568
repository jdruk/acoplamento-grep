../inputs/grep0.dat:Before an alternative
../inputs/grep0.dat:store_op2 (op, loc, arg1, arg2)
../inputs/grep0.dat:store_op2 (op, loc, arg1, arg2)
../inputs/grep0.dat:syntax & RE_NO_BK_PARENS ? *next == ')'
../inputs/grep0.dat:re_opcode_t op;
../inputs/grep0.dat:static void
../inputs/grep0.dat:syntax & RE_NO_BK_PARENS ? *next == ')'
../inputs/grep0.dat:        : next_backslash && next_next && *next_next == ')')
../inputs/grep0.dat:Before an alternative
../inputs/grep0.dat:struct trie
../inputs/grep0.dat: ../inputs/grep1.dat:/* grep.c - main driver file for grep.
../inputs/grep1.dat:   Copyright (C) 1992 Free Software Foundation, Inc.
../inputs/grep1.dat:
../inputs/grep1.dat:   This program is free software; you can redistribute it and/or modify
../inputs/grep1.dat:   it under the terms of the GNU General Public License as published by
../inputs/grep1.dat:   the Free Software Foundation; either version 2, or (at your option)
../inputs/grep1.dat:   any later version.
../inputs/grep1.dat:
../inputs/grep1.dat:   This program is distributed in the hope that it will be useful,
../inputs/grep1.dat:   but WITHOUT ANY WARRANTY; without even the implied warranty of
../inputs/grep1.dat:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
../inputs/grep1.dat:   GNU General Public License for more details.
../inputs/grep1.dat:
../inputs/grep1.dat:   You should have received a copy of the GNU General Public License
../inputs/grep1.dat:   along with this program; if not, write to the Free Software
../inputs/grep1.dat:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
../inputs/grep1.dat:
../inputs/grep1.dat:   Written July 1992 by Mike Haertel.  */
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* I added a series define from makefile here in order to run cfe */
../inputs/grep1.dat:#define GREP 1
../inputs/grep1.dat:#define STDC_HEADERS 1
../inputs/grep1.dat:#define HAVE_STRING_H 1
../inputs/grep1.dat:#define HAVE_SYS_PARAM_H 1
../inputs/grep1.dat:#define HAVE_UNISTD_H 1
../inputs/grep1.dat:#define HAVE_ALLOCA_H 1
../inputs/grep1.dat:#define HAVE_GETPAGESIZE 1
../inputs/grep1.dat:#define HAVE_MEMCHR 1
../inputs/grep1.dat:#define HAVE_STRERROR 1
../inputs/grep1.dat:#define HAVE_VALLOC 1
../inputs/grep1.dat:#define HAVE_WORKING_MMAP 1
../inputs/grep1.dat:/*** end of cfe purpose **/
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:#ifndef errno
../inputs/grep1.dat:extern int errno;
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef STDC_HEADERS
../inputs/grep1.dat:#define flag_stdlib 1
../inputs/grep1.dat:#else
../inputs/grep1.dat:#define flag_systypes 1
../inputs/grep1.dat:extern char *malloc(), *realloc();
../inputs/grep1.dat:extern void free();
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:#if defined(STDC_HEADERS) || defined(HAVE_STRING_H)
../inputs/grep1.dat:#define flag_string 1
../inputs/grep1.dat:#ifdef NEED_MEMORY_H
../inputs/grep1.dat:#define flag_memory 1
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#else
../inputs/grep1.dat:#define flag_strings 1
../inputs/grep1.dat:#ifdef __STDC__
../inputs/grep1.dat:extern void *memchr();
../inputs/grep1.dat:#else
../inputs/grep1.dat:extern char *memchr();
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#define strrchr rindex
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef HAVE_UNISTD_H
../inputs/grep1.dat:#if flag_systypes==0
../inputs/grep1.dat:#define flag_systypes 1
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#else
../inputs/grep1.dat:#define O_RDONLY 0
../inputs/grep1.dat:extern int open(), read(), close();
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:#undef MAX
../inputs/grep1.dat:#define MAX(A,B) ((A) > (B) ? (A) : (B))
../inputs/grep1.dat:
../inputs/grep1.dat:/* Provide missing ANSI features if necessary. */
../inputs/grep1.dat:
../inputs/grep1.dat:#ifndef HAVE_STRERROR
../inputs/grep1.dat:extern int sys_nerr;
../inputs/grep1.dat:extern char *sys_errlist[];
../inputs/grep1.dat:#define strerror(E) ((E) < sys_nerr ? sys_errlist[(E)] : "bogus error number")
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:#ifndef HAVE_MEMCHR
../inputs/grep1.dat:#ifdef __STDC__
../inputs/grep1.dat:#define VOID void
../inputs/grep1.dat:#else
../inputs/grep1.dat:#define VOID char
../inputs/grep1.dat:#endif
../inputs/grep1.dat:VOID *
../inputs/grep1.dat:memchr(vp, c, n)
../inputs/grep1.dat:     VOID *vp;
../inputs/grep1.dat:     int c;
../inputs/grep1.dat:     size_t n;
../inputs/grep1.dat:{
../inputs/grep1.dat:  unsigned char *p;
../inputs/grep1.dat:
../inputs/grep1.dat:  for (p = (unsigned char *) vp; n--; ++p)
../inputs/grep1.dat:    if (*p == c)
../inputs/grep1.dat:      return (VOID *) p;
../inputs/grep1.dat:  return 0;
../inputs/grep1.dat:}
../inputs/grep1.dat:#endif
../inputs/grep1.dat:    
../inputs/grep1.dat:/* Define flags declared in grep.h. */
../inputs/grep1.dat:char *matcher;
../inputs/grep1.dat:int match_icase;
../inputs/grep1.dat:int match_words;
../inputs/grep1.dat:int match_lines;
../inputs/grep1.dat:
../inputs/grep1.dat:/* Functions we'll use to search. */
../inputs/grep1.dat:static void (*compile)();
../inputs/grep1.dat:static char *(*execute)();
../inputs/grep1.dat:
../inputs/grep1.dat:/* For error messages. */
../inputs/grep1.dat:static char *prog;
../inputs/grep1.dat:static char *filename;
../inputs/grep1.dat:static int errseen;
../inputs/grep1.dat:
../inputs/grep1.dat:/* Print a message and possibly an error string.  Remember
../inputs/grep1.dat:   that something awful happened. */
../inputs/grep1.dat:static void
../inputs/grep1.dat:error(mesg, errnum)
../inputs/grep1.dat:#ifdef __STDC__
../inputs/grep1.dat:     const
../inputs/grep1.dat:#endif
../inputs/grep1.dat:     char *mesg;
../inputs/grep1.dat:     int errnum;
../inputs/grep1.dat:{
../inputs/grep1.dat:  if (errnum)
../inputs/grep1.dat:    fprintf(stderr, "%s: %s: %s\n", prog, mesg, strerror(errnum));
../inputs/grep1.dat:  else
../inputs/grep1.dat:    fprintf(stderr, "%s: %s\n", prog, mesg);
../inputs/grep1.dat:  errseen = 1;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Like error(), but die horribly after printing. */
../inputs/grep1.dat:void
../inputs/grep1.dat:fatal(mesg, errnum)
../inputs/grep1.dat:#ifdef __STDC__
../inputs/grep1.dat:     const
../inputs/grep1.dat:#endif
../inputs/grep1.dat:     char *mesg;
../inputs/grep1.dat:     int errnum;
../inputs/grep1.dat:{
../inputs/grep1.dat:  error(mesg, errnum);
../inputs/grep1.dat:  exit(2);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Interface to handle errors and fix library lossage. */
../inputs/grep1.dat:char *
../inputs/grep1.dat:xmalloc(size)
../inputs/grep1.dat:     size_t size;
../inputs/grep1.dat:{
../inputs/grep1.dat:  char *result;
../inputs/grep1.dat:
../inputs/grep1.dat:  result = malloc(size);
../inputs/grep1.dat:  if (size && !result)
../inputs/grep1.dat:    fatal("memory exhausted", 0);
../inputs/grep1.dat:  return result;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Interface to handle errors and fix some library lossage. */
../inputs/grep1.dat:char *
../inputs/grep1.dat:xrealloc(ptr, size)
../inputs/grep1.dat:     char *ptr;
../inputs/grep1.dat:     size_t size;
../inputs/grep1.dat:{
../inputs/grep1.dat:  char *result;
../inputs/grep1.dat:
../inputs/grep1.dat:  if (ptr)
../inputs/grep1.dat:    result = realloc(ptr, size);
../inputs/grep1.dat:  else
../inputs/grep1.dat:    result = malloc(size);
../inputs/grep1.dat:  if (size && !result)
../inputs/grep1.dat:    fatal("memory exhausted", 0);
../inputs/grep1.dat:  return result;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:#if !defined(HAVE_VALLOC)
../inputs/grep1.dat:#define valloc malloc
../inputs/grep1.dat:#else
../inputs/grep1.dat:#ifdef __STDC__
../inputs/grep1.dat:extern void *valloc(size_t);
../inputs/grep1.dat:#else
../inputs/grep1.dat:extern char *valloc();
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:/* Hairy buffering mechanism for grep.  The intent is to keep
../inputs/grep1.dat:   all reads aligned on a page boundary and multiples of the
../inputs/grep1.dat:   page size. */
../inputs/grep1.dat:
../inputs/grep1.dat:static char *buffer;		/* Base of buffer. */
../inputs/grep1.dat:static size_t bufsalloc;	/* Allocated size of buffer save region. */
../inputs/grep1.dat:static size_t bufalloc;		/* Total buffer size. */
../inputs/grep1.dat:static int bufdesc;		/* File descriptor. */
../inputs/grep1.dat:static char *bufbeg;		/* Beginning of user-visible stuff. */
../inputs/grep1.dat:static char *buflim;		/* Limit of user-visible stuff. */
../inputs/grep1.dat:
../inputs/grep1.dat:#if defined(HAVE_WORKING_MMAP)
../inputs/grep1.dat:#if flag_systypes==0
../inputs/grep1.dat:#define flag_systypes 1
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:static int bufmapped;		/* True for ordinary files. */
../inputs/grep1.dat:static struct stat bufstat;	/* From fstat(). */
../inputs/grep1.dat:static off_t bufoffset;		/* What read() normally remembers. */
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:/* Reset the buffer for a new file.  Initialize
../inputs/grep1.dat:   on the first time through. */
../inputs/grep1.dat:void
../inputs/grep1.dat:reset(fd)
../inputs/grep1.dat:     int fd;
../inputs/grep1.dat:{
../inputs/grep1.dat:  static int initialized;
../inputs/grep1.dat:
../inputs/grep1.dat:  if (!initialized)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      initialized = 1;
../inputs/grep1.dat:#ifndef BUFSALLOC
../inputs/grep1.dat:      bufsalloc = MAX(8192, getpagesize());
../inputs/grep1.dat:#else
../inputs/grep1.dat:      bufsalloc = BUFSALLOC;
../inputs/grep1.dat:#endif
../inputs/grep1.dat:      bufalloc = 5 * bufsalloc;
../inputs/grep1.dat:      /* The 1 byte of overflow is a kludge for dfaexec(), which
../inputs/grep1.dat:	 inserts a sentinel newline at the end of the buffer
../inputs/grep1.dat:	 being searched.  There's gotta be a better way... */
../inputs/grep1.dat:      buffer = valloc(bufalloc + 1);
../inputs/grep1.dat:      if (!buffer)
../inputs/grep1.dat:	fatal("memory exhausted", 0);
../inputs/grep1.dat:      bufbeg = buffer;
../inputs/grep1.dat:      buflim = buffer;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  bufdesc = fd;
../inputs/grep1.dat:#if defined(HAVE_WORKING_MMAP)
../inputs/grep1.dat:  if (fstat(fd, &bufstat) < 0 || !S_ISREG(bufstat.st_mode))
../inputs/grep1.dat:    bufmapped = 0;
../inputs/grep1.dat:  else
../inputs/grep1.dat:    {
../inputs/grep1.dat:      bufmapped = 1;
../inputs/grep1.dat:      bufoffset = lseek(fd, 0, 1);
../inputs/grep1.dat:    }
../inputs/grep1.dat:#endif
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Read new stuff into the buffer, saving the specified
../inputs/grep1.dat:   amount of old stuff.  When we're done, 'bufbeg' points
../inputs/grep1.dat:   to the beginning of the buffer contents, and 'buflim'
../inputs/grep1.dat:   points just after the end.  Return count of new stuff. */
../inputs/grep1.dat:static int
../inputs/grep1.dat:fillbuf(save)
../inputs/grep1.dat:     size_t save;
../inputs/grep1.dat:{
../inputs/grep1.dat:  char *nbuffer, *dp, *sp;
../inputs/grep1.dat:  int cc;
../inputs/grep1.dat:#if defined(HAVE_WORKING_MMAP)
../inputs/grep1.dat:  caddr_t maddr;
../inputs/grep1.dat:#endif
../inputs/grep1.dat:  static int pagesize;
../inputs/grep1.dat:
../inputs/grep1.dat:  if (pagesize == 0 && (pagesize = getpagesize()) == 0)
../inputs/grep1.dat:    abort();
../inputs/grep1.dat:
../inputs/grep1.dat:  if (save > bufsalloc)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      while (save > bufsalloc)
../inputs/grep1.dat:	bufsalloc *= 2;
../inputs/grep1.dat:      bufalloc = 5 * bufsalloc;
../inputs/grep1.dat:      nbuffer = valloc(bufalloc + 1);
../inputs/grep1.dat:      if (!nbuffer)
../inputs/grep1.dat:	fatal("memory exhausted", 0);
../inputs/grep1.dat:    }
../inputs/grep1.dat:  else
../inputs/grep1.dat:    nbuffer = buffer;
../inputs/grep1.dat:
../inputs/grep1.dat:  sp = buflim - save;
../inputs/grep1.dat:  dp = nbuffer + bufsalloc - save;
../inputs/grep1.dat:  bufbeg = dp;
../inputs/grep1.dat:  while (save--)
../inputs/grep1.dat:    *dp++ = *sp++;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* We may have allocated a new, larger buffer.  Since
../inputs/grep1.dat:     there is no portable vfree(), we just have to forget
../inputs/grep1.dat:     about the old one.  Sorry. */
../inputs/grep1.dat:  buffer = nbuffer;
../inputs/grep1.dat:
../inputs/grep1.dat:#if defined(HAVE_WORKING_MMAP)
../inputs/grep1.dat:  if (bufmapped && bufoffset % pagesize == 0
../inputs/grep1.dat:      && bufstat.st_size - bufoffset >= bufalloc - bufsalloc)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      maddr = buffer + bufsalloc;
../inputs/grep1.dat:      maddr = mmap(maddr, bufalloc - bufsalloc, PROT_READ | PROT_WRITE,
../inputs/grep1.dat:		   MAP_PRIVATE | MAP_FIXED, bufdesc, bufoffset);
../inputs/grep1.dat:      if (maddr == (caddr_t) -1)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  fprintf(stderr, "%s: warning: %s: %s\n", filename,
../inputs/grep1.dat:		  strerror(errno));
../inputs/grep1.dat:	  goto tryread;
../inputs/grep1.dat:	}
../inputs/grep1.dat:#if 0
../inputs/grep1.dat:      /* You might thing this (or MADV_WILLNEED) would help,
../inputs/grep1.dat:	 but it doesn't, at least not on a Sun running 4.1.
../inputs/grep1.dat:	 In fact, it actually slows us down about 30%! */
../inputs/grep1.dat:      madvise(maddr, bufalloc - bufsalloc, MADV_SEQUENTIAL);
../inputs/grep1.dat:#endif
../inputs/grep1.dat:      cc = bufalloc - bufsalloc;
../inputs/grep1.dat:      bufoffset += cc;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  else
../inputs/grep1.dat:    {
../inputs/grep1.dat:    tryread:
../inputs/grep1.dat:      /* We come here when we're not going to use mmap() any more.
../inputs/grep1.dat:	 Note that we need to synchronize the file offset the
../inputs/grep1.dat:	 first time through. */
../inputs/grep1.dat:      if (bufmapped)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  bufmapped = 0;
../inputs/grep1.dat:	  lseek(bufdesc, bufoffset, 0);
../inputs/grep1.dat:	}
../inputs/grep1.dat:      cc = read(bufdesc, buffer + bufsalloc, bufalloc - bufsalloc);
../inputs/grep1.dat:    }
../inputs/grep1.dat:#else
../inputs/grep1.dat:  cc = read(bufdesc, buffer + bufsalloc, bufalloc - bufsalloc);
../inputs/grep1.dat:#endif
../inputs/grep1.dat:  if (cc > 0)
../inputs/grep1.dat:    buflim = buffer + bufsalloc + cc;
../inputs/grep1.dat:  else
../inputs/grep1.dat:    buflim = buffer + bufsalloc;
../inputs/grep1.dat:  return cc;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Flags controlling the style of output. */
../inputs/grep1.dat:static int out_quiet;		/* Suppress all normal output. */
../inputs/grep1.dat:static int out_invert;		/* Print nonmatching stuff. */
../inputs/grep1.dat:static int out_file;		/* Print filenames. */
../inputs/grep1.dat:static int out_line;		/* Print line numbers. */
../inputs/grep1.dat:static int out_byte;		/* Print byte offsets. */
../inputs/grep1.dat:static int out_before;		/* Lines of leading context. */
../inputs/grep1.dat:static int out_after;		/* Lines of trailing context. */
../inputs/grep1.dat:
../inputs/grep1.dat:/* Internal variables to keep track of byte count, context, etc. */
../inputs/grep1.dat:static size_t totalcc;		/* Total character count before bufbeg. */
../inputs/grep1.dat:static char *lastnl;		/* Pointer after last newline counted. */
../inputs/grep1.dat:static char *lastout;		/* Pointer after last character output;
../inputs/grep1.dat:				   NULL if no character has been output
../inputs/grep1.dat:				   or if it's conceptually before bufbeg. */
../inputs/grep1.dat:static size_t totalnl;		/* Total newline count before lastnl. */
../inputs/grep1.dat:static int pending;		/* Pending lines of output. */
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:nlscan(lim)
../inputs/grep1.dat:     char *lim;
../inputs/grep1.dat:{
../inputs/grep1.dat:  char *beg;
../inputs/grep1.dat:
../inputs/grep1.dat:  for (beg = lastnl; beg < lim; ++beg)
../inputs/grep1.dat:    if (*beg == '\n')
../inputs/grep1.dat:      ++totalnl;
../inputs/grep1.dat:  lastnl = beg;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:prline(beg, lim, sep)
../inputs/grep1.dat:     char *beg;
../inputs/grep1.dat:     char *lim;
../inputs/grep1.dat:     char sep;
../inputs/grep1.dat:{
../inputs/grep1.dat:  if (out_file)
../inputs/grep1.dat:    printf("%s%c", filename, sep);
../inputs/grep1.dat:  if (out_line)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      nlscan(beg);
../inputs/grep1.dat:      printf("%d%c", ++totalnl, sep);
../inputs/grep1.dat:      lastnl = lim;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  if (out_byte)
../inputs/grep1.dat:    printf("%lu%c", totalcc + (beg - bufbeg), sep);
../inputs/grep1.dat:  fwrite(beg, 1, lim - beg, stdout);
../inputs/grep1.dat:  if (ferror(stdout))
../inputs/grep1.dat:    error("writing output", errno);
../inputs/grep1.dat:  lastout = lim;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Print pending lines of trailing context prior to LIM. */
../inputs/grep1.dat:static void
../inputs/grep1.dat:prpending(lim)
../inputs/grep1.dat:     char *lim;
../inputs/grep1.dat:{
../inputs/grep1.dat:  char *nl;
../inputs/grep1.dat:
../inputs/grep1.dat:  if (!lastout)
../inputs/grep1.dat:    lastout = bufbeg;
../inputs/grep1.dat:  while (pending > 0 && lastout < lim)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      --pending;
../inputs/grep1.dat:      if ((nl = memchr(lastout, '\n', lim - lastout)) != 0)
../inputs/grep1.dat:	++nl;
../inputs/grep1.dat:      else
../inputs/grep1.dat:	nl = lim;
../inputs/grep1.dat:      prline(lastout, nl, '-');
../inputs/grep1.dat:    }
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Print the lines between BEG and LIM.  Deal with context crap.
../inputs/grep1.dat:   If NLINESP is non-null, store a count of lines between BEG and LIM. */
../inputs/grep1.dat:static void
../inputs/grep1.dat:prtext(beg, lim, nlinesp)
../inputs/grep1.dat:     char *beg;
../inputs/grep1.dat:     char *lim;
../inputs/grep1.dat:     int *nlinesp;
../inputs/grep1.dat:{
../inputs/grep1.dat:  static int used;		/* avoid printing "--" before any output */
../inputs/grep1.dat:  char *bp, *p, *nl;
../inputs/grep1.dat:  int i, n;
../inputs/grep1.dat:
../inputs/grep1.dat:  if (!out_quiet && pending > 0)
../inputs/grep1.dat:    prpending(beg);
../inputs/grep1.dat:
../inputs/grep1.dat:  p = beg;
../inputs/grep1.dat:
../inputs/grep1.dat:  if (!out_quiet)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      /* Deal with leading context crap. */
../inputs/grep1.dat:
../inputs/grep1.dat:      bp = lastout ? lastout : bufbeg;
../inputs/grep1.dat:      for (i = 0; i < out_before; ++i)
../inputs/grep1.dat:	if (p > bp)
../inputs/grep1.dat:	  do
../inputs/grep1.dat:	    --p;
../inputs/grep1.dat:	  while (p > bp && p[-1] != '\n');
../inputs/grep1.dat:
../inputs/grep1.dat:      /* We only print the "--" separator if our output is
../inputs/grep1.dat:	 discontiguous from the last output in the file. */
../inputs/grep1.dat:      if ((out_before || out_after) && used && p != lastout)
../inputs/grep1.dat:	puts("--");
../inputs/grep1.dat:
../inputs/grep1.dat:      while (p < beg)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  nl = memchr(p, '\n', beg - p);
../inputs/grep1.dat:	  prline(p, nl + 1, '-');
../inputs/grep1.dat:	  p = nl + 1;
../inputs/grep1.dat:	}
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  if (nlinesp)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      /* Caller wants a line count. */
../inputs/grep1.dat:      for (n = 0; p < lim; ++n)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  if ((nl = memchr(p, '\n', lim - p)) != 0)
../inputs/grep1.dat:	    ++nl;
../inputs/grep1.dat:	  else
../inputs/grep1.dat:	    nl = lim;
../inputs/grep1.dat:	  if (!out_quiet)
../inputs/grep1.dat:	    prline(p, nl, ':');
../inputs/grep1.dat:	  p = nl;
../inputs/grep1.dat:	}
../inputs/grep1.dat:      *nlinesp = n;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  else
../inputs/grep1.dat:    if (!out_quiet)
../inputs/grep1.dat:      prline(beg, lim, ':');
../inputs/grep1.dat:
../inputs/grep1.dat:  pending = out_after;
../inputs/grep1.dat:  used = 1;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Scan the specified portion of the buffer, matching lines (or
../inputs/grep1.dat:   between matching lines if OUT_INVERT is true).  Return a count of
../inputs/grep1.dat:   lines printed. */
../inputs/grep1.dat:static int
../inputs/grep1.dat:grepbuf(beg, lim)
../inputs/grep1.dat:     char *beg;
../inputs/grep1.dat:     char *lim;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int nlines, n;
../inputs/grep1.dat:  register char *p, *b;
../inputs/grep1.dat:  char *endp;
../inputs/grep1.dat:
../inputs/grep1.dat:  nlines = 0;
../inputs/grep1.dat:  p = beg;
../inputs/grep1.dat:  while ((b = (*execute)(p, lim - p, &endp)) != 0)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      /* Avoid matching the empty line at the end of the buffer. */
../inputs/grep1.dat:      if (b == lim && ((b > beg && b[-1] == '\n') || b == beg))
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      if (!out_invert)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  prtext(b, endp, (int *) 0);
../inputs/grep1.dat:	  nlines += 1;
../inputs/grep1.dat:	}
../inputs/grep1.dat:      else if (p < b)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  prtext(p, b, &n);
../inputs/grep1.dat:	  nlines += n;
../inputs/grep1.dat:	}
../inputs/grep1.dat:      p = endp;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  if (out_invert && p < lim)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      prtext(p, lim, &n);
../inputs/grep1.dat:      nlines += n;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  return nlines;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Search a given file.  Return a count of lines printed. */
../inputs/grep1.dat:static int
../inputs/grep1.dat:grep(fd)
../inputs/grep1.dat:     int fd;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int nlines, i;
../inputs/grep1.dat:  size_t residue, save;
../inputs/grep1.dat:  char *beg, *lim;
../inputs/grep1.dat:
../inputs/grep1.dat:  reset(fd);
../inputs/grep1.dat:
../inputs/grep1.dat:  totalcc = 0;
../inputs/grep1.dat:  lastout = 0;
../inputs/grep1.dat:  totalnl = 0;
../inputs/grep1.dat:  pending = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:  nlines = 0;
../inputs/grep1.dat:  residue = 0;
../inputs/grep1.dat:  save = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:  for (;;)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      if (fillbuf(save) < 0)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  error(filename, errno);
../inputs/grep1.dat:	  return nlines;
../inputs/grep1.dat:	}
../inputs/grep1.dat:      lastnl = bufbeg;
../inputs/grep1.dat:      if (lastout)
../inputs/grep1.dat:	lastout = bufbeg;
../inputs/grep1.dat:      if (buflim - bufbeg == save)
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      beg = bufbeg + save - residue;
../inputs/grep1.dat:      for (lim = buflim; lim > beg && lim[-1] != '\n'; --lim)
../inputs/grep1.dat:	;
../inputs/grep1.dat:      residue = buflim - lim;
../inputs/grep1.dat:      if (beg < lim)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  nlines += grepbuf(beg, lim);
../inputs/grep1.dat:	  if (pending)
../inputs/grep1.dat:	    prpending(lim);
../inputs/grep1.dat:	}
../inputs/grep1.dat:      i = 0;
../inputs/grep1.dat:      beg = lim;
../inputs/grep1.dat:      while (i < out_before && beg > bufbeg && beg != lastout)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  ++i;
../inputs/grep1.dat:	  do
../inputs/grep1.dat:	    --beg;
../inputs/grep1.dat:	  while (beg > bufbeg && beg[-1] != '\n');
../inputs/grep1.dat:	}
../inputs/grep1.dat:      if (beg != lastout)
../inputs/grep1.dat:	lastout = 0;
../inputs/grep1.dat:      save = residue + lim - beg;
../inputs/grep1.dat:      totalcc += buflim - bufbeg - save;
../inputs/grep1.dat:      if (out_line)
../inputs/grep1.dat:	nlscan(beg);
../inputs/grep1.dat:    }
../inputs/grep1.dat:  if (residue)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      nlines += grepbuf(bufbeg + save - residue, buflim);
../inputs/grep1.dat:      if (pending)
../inputs/grep1.dat:	prpending(buflim);
../inputs/grep1.dat:    }
../inputs/grep1.dat:  return nlines;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static char version[] = "GNU grep version 2.0";
../inputs/grep1.dat:
../inputs/grep1.dat:#define USAGE \
../inputs/grep1.dat:  "usage: %s [-[[AB] ]<num>] [-[CEFGVchilnqsvwx]] [-[ef]] <expr> [<files...>]\n"
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:usage()
../inputs/grep1.dat:{
../inputs/grep1.dat:  fprintf(stderr, USAGE, prog);
../inputs/grep1.dat:  exit(2);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Go through the matchers vector and look for the specified matcher.
../inputs/grep1.dat:   If we find it, install it in compile and execute, and return 1.  */
../inputs/grep1.dat:int
../inputs/grep1.dat:setmatcher(name)
../inputs/grep1.dat:     char *name;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int i;
../inputs/grep1.dat:
../inputs/grep1.dat:  for (i = 0; matchers[i].name; ++i)
../inputs/grep1.dat:    if (strcmp(name, matchers[i].name) == 0)
../inputs/grep1.dat:      {
../inputs/grep1.dat:	compile = matchers[i].compile;
../inputs/grep1.dat:	execute = matchers[i].execute;
../inputs/grep1.dat:	return 1;
../inputs/grep1.dat:      }
../inputs/grep1.dat:  return 0;
../inputs/grep1.dat:}  
../inputs/grep1.dat:
../inputs/grep1.dat:int
../inputs/grep1.dat:main(argc, argv)
../inputs/grep1.dat:     int argc;
../inputs/grep1.dat:     char *argv[];
../inputs/grep1.dat:{
../inputs/grep1.dat:  char *keys;
../inputs/grep1.dat:  size_t keycc, oldcc, keyalloc;
../inputs/grep1.dat:  int keyfound, count_matches, no_filenames, list_files, suppress_errors;
../inputs/grep1.dat:  int opt, cc, desc, count, status;
../inputs/grep1.dat:  FILE *fp;
../inputs/grep1.dat:  extern char *optarg;
../inputs/grep1.dat:  extern int optind;
../inputs/grep1.dat:
../inputs/grep1.dat:  prog = argv[0];
../inputs/grep1.dat:  if (prog && strrchr(prog, '/'))
../inputs/grep1.dat:    prog = strrchr(prog, '/') + 1;
../inputs/grep1.dat:
../inputs/grep1.dat:  keys = NULL;
../inputs/grep1.dat:  keycc = 0;
../inputs/grep1.dat:  keyfound = 0;
../inputs/grep1.dat:  count_matches = 0;
../inputs/grep1.dat:  no_filenames = 0;
../inputs/grep1.dat:  list_files = 0;
../inputs/grep1.dat:  suppress_errors = 0;
../inputs/grep1.dat:  matcher = NULL;
../inputs/grep1.dat:
../inputs/grep1.dat:  while ((opt = getopt(argc, argv, "0123456789A:B:CEFGVX:bce:f:hiLlnqsvwxy"))
../inputs/grep1.dat:	 != EOF)
../inputs/grep1.dat:    switch (opt)
../inputs/grep1.dat:      {
../inputs/grep1.dat:      case '0':
../inputs/grep1.dat:      case '1':
../inputs/grep1.dat:      case '2':
../inputs/grep1.dat:      case '3':
../inputs/grep1.dat:      case '4':
../inputs/grep1.dat:      case '5':
../inputs/grep1.dat:      case '6':
../inputs/grep1.dat:      case '7':
../inputs/grep1.dat:      case '8':
../inputs/grep1.dat:      case '9':
../inputs/grep1.dat:	out_before = 10 * out_before + opt - '0';
../inputs/grep1.dat:	out_after = 10 * out_after + opt - '0';
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      case 'A':
../inputs/grep1.dat:	out_after = atoi(optarg);
../inputs/grep1.dat:	if (out_after < 0)
../inputs/grep1.dat:	  usage();
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      case 'B':
../inputs/grep1.dat:	out_before = atoi(optarg);
../inputs/grep1.dat:	if (out_before < 0)
../inputs/grep1.dat:	  usage();
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      case 'C':
../inputs/grep1.dat:	out_before = out_after = 2;
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      case 'E':
../inputs/grep1.dat:	if (matcher && strcmp(matcher, "egrep") != 0)
../inputs/grep1.dat:	  fatal("you may specify only one of -E, -F, or -G", 0);
../inputs/grep1.dat:	matcher = "posix-egrep";
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      case 'F':
../inputs/grep1.dat:	if (matcher && strcmp(matcher, "fgrep") != 0)
../inputs/grep1.dat:	  fatal("you may specify only one of -E, -F, or -G", 0);;
../inputs/grep1.dat:	matcher = "fgrep";
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      case 'G':
../inputs/grep1.dat:	if (matcher && strcmp(matcher, "grep") != 0)
../inputs/grep1.dat:	  fatal("you may specify only one of -E, -F, or -G", 0);
../inputs/grep1.dat:	matcher = "grep";
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      case 'V':
../inputs/grep1.dat:	fprintf(stderr, "%s\n", version);
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      case 'X':
../inputs/grep1.dat:	if (matcher)
../inputs/grep1.dat:	  fatal("matcher already specified", 0);
../inputs/grep1.dat:	matcher = optarg;
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      case 'b':
../inputs/grep1.dat:	out_byte = 1;
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      case 'c':
../inputs/grep1.dat:	out_quiet = 1;
../inputs/grep1.dat:	count_matches = 1;
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      case 'e':
../inputs/grep1.dat:	cc = strlen(optarg);
../inputs/grep1.dat:	keys = xrealloc(keys, keycc + cc + 1);
../inputs/grep1.dat:	if (keyfound)
../inputs/grep1.dat:	  keys[keycc++] = '\n';
../inputs/grep1.dat:	strcpy(&keys[keycc], optarg);
../inputs/grep1.dat:	keycc += cc;
../inputs/grep1.dat:	keyfound = 1;
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      case 'f':
../inputs/grep1.dat:	fp = strcmp(optarg, "-") != 0 ? fopen(optarg, "r") : stdin;
../inputs/grep1.dat:	if (!fp)
../inputs/grep1.dat:	  fatal(optarg, errno);
../inputs/grep1.dat:	for (keyalloc = 1; keyalloc <= keycc; keyalloc *= 2)
../inputs/grep1.dat:	  ;
../inputs/grep1.dat:	keys = xrealloc(keys, keyalloc);
../inputs/grep1.dat:	oldcc = keycc;
../inputs/grep1.dat:	if (keyfound)
../inputs/grep1.dat:	  keys[keycc++] = '\n';
../inputs/grep1.dat:	while (!feof(fp)
../inputs/grep1.dat:	       && (cc = fread(keys + keycc, 1, keyalloc - keycc, fp)) > 0)
../inputs/grep1.dat:	  {
../inputs/grep1.dat:	    keycc += cc;
../inputs/grep1.dat:	    if (keycc == keyalloc)
../inputs/grep1.dat:	      keys = xrealloc(keys, keyalloc *= 2);
../inputs/grep1.dat:	  }
../inputs/grep1.dat:	if (fp != stdin)
../inputs/grep1.dat:	  fclose(fp);
../inputs/grep1.dat:	/* Nuke the final newline to avoid matching a null string. */
../inputs/grep1.dat:	if (keycc - oldcc > 0 && keys[keycc - 1] == '\n')
../inputs/grep1.dat:	  --keycc;
../inputs/grep1.dat:	keyfound = 1;
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      case 'h':
../inputs/grep1.dat:	no_filenames = 1;
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      case 'i':
../inputs/grep1.dat:      case 'y':			/* For old-timers . . . */
../inputs/grep1.dat:	match_icase = 1;
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      case 'L':
../inputs/grep1.dat:	/* Like -l, except list files that don't contain matches.
../inputs/grep1.dat:	   Inspired by the same option in Hume's gre. */
../inputs/grep1.dat:	out_quiet = 1;
../inputs/grep1.dat:	list_files = -1;
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      case 'l':
../inputs/grep1.dat:	out_quiet = 1;
../inputs/grep1.dat:	list_files = 1;
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      case 'n':
../inputs/grep1.dat:	out_line = 1;
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      case 'q':
../inputs/grep1.dat:	out_quiet = 1;
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      case 's':
../inputs/grep1.dat:	suppress_errors = 1;
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      case 'v':
../inputs/grep1.dat:	out_invert = 1;
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      case 'w':
../inputs/grep1.dat:	match_words = 1;
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      case 'x':
../inputs/grep1.dat:	match_lines = 1;
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      default:
../inputs/grep1.dat:	usage();
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      }
../inputs/grep1.dat:
../inputs/grep1.dat:  if (!keyfound)
../inputs/grep1.dat:    if (optind < argc)
../inputs/grep1.dat:      {
../inputs/grep1.dat:	keys = argv[optind++];
../inputs/grep1.dat:	keycc = strlen(keys);
../inputs/grep1.dat:      }
../inputs/grep1.dat:    else
../inputs/grep1.dat:      usage();
../inputs/grep1.dat:
../inputs/grep1.dat:  if (!matcher)
../inputs/grep1.dat:    matcher = prog;
../inputs/grep1.dat:
../inputs/grep1.dat:  if (!setmatcher(matcher) && !setmatcher("default"))
../inputs/grep1.dat:    abort();
../inputs/grep1.dat:
../inputs/grep1.dat:  (*compile)(keys, keycc);
../inputs/grep1.dat:
../inputs/grep1.dat:  if (argc - optind > 1 && !no_filenames)
../inputs/grep1.dat:    out_file = 1;
../inputs/grep1.dat:
../inputs/grep1.dat:  status = 1;
../inputs/grep1.dat:
../inputs/grep1.dat:  if (optind < argc)
../inputs/grep1.dat:    while (optind < argc)
../inputs/grep1.dat:      {
../inputs/grep1.dat:	desc = strcmp(argv[optind], "-") ? open(argv[optind], O_RDONLY) : 0;
../inputs/grep1.dat:	if (desc < 0)
../inputs/grep1.dat:	  {
../inputs/grep1.dat:	    if (!suppress_errors)
../inputs/grep1.dat:	      error(argv[optind], errno);
../inputs/grep1.dat:	  }
../inputs/grep1.dat:	else
../inputs/grep1.dat:	  {
../inputs/grep1.dat:	    filename = desc == 0 ? "(standard input)" : argv[optind];
../inputs/grep1.dat:	    count = grep(desc);
../inputs/grep1.dat:	    if (count_matches)
../inputs/grep1.dat:	      {
../inputs/grep1.dat:		if (out_file)
../inputs/grep1.dat:		  printf("%s:", filename);
../inputs/grep1.dat:		printf("%d\n", count);
../inputs/grep1.dat:	      }
../inputs/grep1.dat:	    if (count)
../inputs/grep1.dat:	      {
../inputs/grep1.dat:		status = 0;
../inputs/grep1.dat:		if (list_files == 1)
../inputs/grep1.dat:		  printf("%s\n", filename);
../inputs/grep1.dat:	      }
../inputs/grep1.dat:	    else if (list_files == -1)
../inputs/grep1.dat:	      printf("%s\n", filename);
../inputs/grep1.dat:	  }
../inputs/grep1.dat:	if (desc != 0)
../inputs/grep1.dat:	  close(desc);
../inputs/grep1.dat:	++optind;
../inputs/grep1.dat:      }
../inputs/grep1.dat:  else
../inputs/grep1.dat:    {
../inputs/grep1.dat:      filename = "(standard input)";
../inputs/grep1.dat:      count = grep(0);
../inputs/grep1.dat:      if (count_matches)
../inputs/grep1.dat:	printf("%d\n", count);
../inputs/grep1.dat:      if (count)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  status = 0;
../inputs/grep1.dat:	  if (list_files == 1)
../inputs/grep1.dat:	    printf("(standard input)\n");
../inputs/grep1.dat:	}
../inputs/grep1.dat:      else if (list_files == -1)
../inputs/grep1.dat:	printf("(standard input)\n");
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  exit(errseen ? 2 : status);
../inputs/grep1.dat:}
../inputs/grep1.dat:/* Getopt for GNU.
../inputs/grep1.dat:   NOTE: getopt is now part of the C library, so if you don't know what
../inputs/grep1.dat:   "Keep this file name-space clean" means, talk to roland@gnu.ai.mit.edu
../inputs/grep1.dat:   before changing it!
../inputs/grep1.dat:
../inputs/grep1.dat:   Copyright (C) 1987, 88, 89, 90, 91, 92, 1993
../inputs/grep1.dat:   	Free Software Foundation, Inc.
../inputs/grep1.dat:
../inputs/grep1.dat:   This program is free software; you can redistribute it and/or modify it
../inputs/grep1.dat:   under the terms of the GNU General Public License as published by the
../inputs/grep1.dat:   Free Software Foundation; either version 2, or (at your option) any
../inputs/grep1.dat:   later version.
../inputs/grep1.dat:
../inputs/grep1.dat:   This program is distributed in the hope that it will be useful,
../inputs/grep1.dat:   but WITHOUT ANY WARRANTY; without even the implied warranty of
../inputs/grep1.dat:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
../inputs/grep1.dat:   GNU General Public License for more details.
../inputs/grep1.dat:
../inputs/grep1.dat:   You should have received a copy of the GNU General Public License
../inputs/grep1.dat:   along with this program; if not, write to the Free Software
../inputs/grep1.dat:   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
../inputs/grep1.dat:
../inputs/grep1.dat:/* NOTE!!!  AIX requires this to be the first thing in the file.
../inputs/grep1.dat:   Do not put ANYTHING before it!  */
../inputs/grep1.dat:#if !defined (__GNUC__) && defined (_AIX)
../inputs/grep1.dat: #pragma alloca
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef HAVE_CONFIG_H
../inputs/grep1.dat:#define flag_config 1
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef __GNUC__
../inputs/grep1.dat:#define alloca __builtin_alloca
../inputs/grep1.dat:#else /* not __GNUC__ */
../inputs/grep1.dat:#if defined (HAVE_ALLOCA_H) || (defined(sparc) && (defined(sun) || (!defined(USG) && !defined(SVR4) && !defined(__svr4__))))
../inputs/grep1.dat:#define flag_alloca 1
../inputs/grep1.dat:#else
../inputs/grep1.dat:#ifndef _AIX
../inputs/grep1.dat:char *alloca ();
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#endif /* alloca.h */
../inputs/grep1.dat:#endif /* not __GNUC__ */
../inputs/grep1.dat:
../inputs/grep1.dat:#if !__STDC__ && !defined(const) && IN_GCC
../inputs/grep1.dat:#define const
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.  */
../inputs/grep1.dat:#ifndef _NO_PROTO
../inputs/grep1.dat:#define _NO_PROTO
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Comment out all this code if we are using the GNU C Library, and are not
../inputs/grep1.dat:   actually compiling the library itself.  This code is part of the GNU C
../inputs/grep1.dat:   and linking in this code is a waste when using the GNU C library
../inputs/grep1.dat:   (especially if it is a shared library).  Rather than having every GNU
../inputs/grep1.dat:   program understand `configure --with-gnu-libc' and omit the object files,
../inputs/grep1.dat:   it is simpler to just do this in the source for each such file.  */
../inputs/grep1.dat:
../inputs/grep1.dat:#if defined (_LIBC) || !defined (__GNU_LIBRARY__)
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:   to get __GNU_LIBRARY__ defined.  */
../inputs/grep1.dat:#ifdef	__GNU_LIBRARY__
../inputs/grep1.dat:#undef	alloca
../inputs/grep1.dat:   contain conflicting prototypes for getopt.  */
../inputs/grep1.dat:#if flag_stdlib==0   
../inputs/grep1.dat:#define flag_stdlib 1
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#else	/* Not GNU C library.  */
../inputs/grep1.dat:#define	__alloca	alloca
../inputs/grep1.dat:#endif	/* GNU C library.  */
../inputs/grep1.dat:
../inputs/grep1.dat:/* If GETOPT_COMPAT is defined, `+' as well as `--' can introduce a
../inputs/grep1.dat:   long-named option.  Because this is not POSIX.2 compliant, it is
../inputs/grep1.dat:   being phased out.  */
../inputs/grep1.dat:/* #define GETOPT_COMPAT */
../inputs/grep1.dat:
../inputs/grep1.dat:/* This version of `getopt' appears to the caller like standard Unix `getopt'
../inputs/grep1.dat:   but it behaves differently for the user, since it allows the user
../inputs/grep1.dat:   to intersperse the options with the other arguments.
../inputs/grep1.dat:
../inputs/grep1.dat:   As `getopt' works, it permutes the elements of ARGV so that,
../inputs/grep1.dat:   when it is done, all the options precede everything else.  Thus
../inputs/grep1.dat:   all application programs are extended to handle flexible argument order.
../inputs/grep1.dat:
../inputs/grep1.dat:   Setting the environment variable POSIXLY_CORRECT disables permutation.
../inputs/grep1.dat:   Then the behavior is completely standard.
../inputs/grep1.dat:
../inputs/grep1.dat:   GNU application programs can use a third alternative mode in which
../inputs/grep1.dat:   they can distinguish the relative order of options and other arguments.  */
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* For communication from `getopt' to the caller.
../inputs/grep1.dat:   When `getopt' finds an option that takes an argument,
../inputs/grep1.dat:   the argument value is returned here.
../inputs/grep1.dat:   Also, when `ordering' is RETURN_IN_ORDER,
../inputs/grep1.dat:   each non-option ARGV-element is returned here.  */
../inputs/grep1.dat:
../inputs/grep1.dat:char *optarg = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:/* Index in ARGV of the next element to be scanned.
../inputs/grep1.dat:   This is used for communication to and from the caller
../inputs/grep1.dat:   and for communication between successive calls to `getopt'.
../inputs/grep1.dat:
../inputs/grep1.dat:   On entry to `getopt', zero means this is the first call; initialize.
../inputs/grep1.dat:
../inputs/grep1.dat:   When `getopt' returns EOF, this is the index of the first of the
../inputs/grep1.dat:   non-option elements that the caller should itself scan.
../inputs/grep1.dat:
../inputs/grep1.dat:   Otherwise, `optind' communicates from one call to the next
../inputs/grep1.dat:   how much of ARGV has been scanned so far.  */
../inputs/grep1.dat:
../inputs/grep1.dat:/* XXX 1003.2 says this must be 1 before any call.  */
../inputs/grep1.dat:int optind = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:/* The next char to be scanned in the option-element
../inputs/grep1.dat:   in which the last option character we returned was found.
../inputs/grep1.dat:   This allows us to pick up the scan where we left off.
../inputs/grep1.dat:
../inputs/grep1.dat:   If this is zero, or a null string, it means resume the scan
../inputs/grep1.dat:   by advancing to the next ARGV-element.  */
../inputs/grep1.dat:
../inputs/grep1.dat:static char *nextchar;
../inputs/grep1.dat:
../inputs/grep1.dat:/* Callers store zero here to inhibit the error message
../inputs/grep1.dat:   for unrecognized options.  */
../inputs/grep1.dat:
../inputs/grep1.dat:int opterr = 1;
../inputs/grep1.dat:
../inputs/grep1.dat:/* Set to an option character which was unrecognized.
../inputs/grep1.dat:   This must be initialized on some systems to avoid linking in the
../inputs/grep1.dat:   system's own getopt implementation.  */
../inputs/grep1.dat:
../inputs/grep1.dat:int optopt = '?';
../inputs/grep1.dat:
../inputs/grep1.dat:/* Describe how to deal with options that follow non-option ARGV-elements.
../inputs/grep1.dat:
../inputs/grep1.dat:   If the caller did not specify anything,
../inputs/grep1.dat:   the default is REQUIRE_ORDER if the environment variable
../inputs/grep1.dat:   POSIXLY_CORRECT is defined, PERMUTE otherwise.
../inputs/grep1.dat:
../inputs/grep1.dat:   REQUIRE_ORDER means don't recognize them as options;
../inputs/grep1.dat:   stop option processing when the first non-option is seen.
../inputs/grep1.dat:   This is what Unix does.
../inputs/grep1.dat:   This mode of operation is selected by either setting the environment
../inputs/grep1.dat:   variable POSIXLY_CORRECT, or using `+' as the first character
../inputs/grep1.dat:   of the list of option characters.
../inputs/grep1.dat:
../inputs/grep1.dat:   PERMUTE is the default.  We permute the contents of ARGV as we scan,
../inputs/grep1.dat:   so that eventually all the non-options are at the end.  This allows options
../inputs/grep1.dat:   to be given in any order, even with programs that were not written to
../inputs/grep1.dat:   expect this.
../inputs/grep1.dat:
../inputs/grep1.dat:   RETURN_IN_ORDER is an option available to programs that were written
../inputs/grep1.dat:   to expect options and other ARGV-elements in any order and that care about
../inputs/grep1.dat:   the ordering of the two.  We describe each non-option ARGV-element
../inputs/grep1.dat:   as if it were the argument of an option with character code 1.
../inputs/grep1.dat:   Using `-' as the first character of the list of option characters
../inputs/grep1.dat:   selects this mode of operation.
../inputs/grep1.dat:
../inputs/grep1.dat:   The special argument `--' forces an end of option-scanning regardless
../inputs/grep1.dat:   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
../inputs/grep1.dat:   `--' can cause `getopt' to return EOF with `optind' != ARGC.  */
../inputs/grep1.dat:
../inputs/grep1.dat:static enum
../inputs/grep1.dat:{
../inputs/grep1.dat:  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
../inputs/grep1.dat:} ordering;
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef	__GNU_LIBRARY__
../inputs/grep1.dat:/* We want to avoid inclusion of string.h with non-GNU libraries
../inputs/grep1.dat:   because there are many ways it can cause trouble.
../inputs/grep1.dat:   On some systems, it contains special magic macros that don't work
../inputs/grep1.dat:   in GCC.  */
../inputs/grep1.dat:#if flag_string==0   
../inputs/grep1.dat:#define flag_string 1
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#define	my_index	strchr
../inputs/grep1.dat:#define	my_bcopy(src, dst, n)	memcpy ((dst), (src), (n))
../inputs/grep1.dat:#else
../inputs/grep1.dat:
../inputs/grep1.dat:/* Avoid depending on library functions or files
../inputs/grep1.dat:   whose names are inconsistent.  */
../inputs/grep1.dat:
../inputs/grep1.dat:char *getenv ();
../inputs/grep1.dat:
../inputs/grep1.dat:static char *
../inputs/grep1.dat:my_index (str, chr)
../inputs/grep1.dat:     const char *str;
../inputs/grep1.dat:     int chr;
../inputs/grep1.dat:{
../inputs/grep1.dat:  while (*str)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      if (*str == chr)
../inputs/grep1.dat:	return (char *) str;
../inputs/grep1.dat:      str++;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  return 0;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:my_bcopy (from, to, size)
../inputs/grep1.dat:     const char *from;
../inputs/grep1.dat:     char *to;
../inputs/grep1.dat:     int size;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int i;
../inputs/grep1.dat:  for (i = 0; i < size; i++)
../inputs/grep1.dat:    to[i] = from[i];
../inputs/grep1.dat:}
../inputs/grep1.dat:#endif				/* GNU C library.  */
../inputs/grep1.dat:
../inputs/grep1.dat:/* Handle permutation of arguments.  */
../inputs/grep1.dat:
../inputs/grep1.dat:/* Describe the part of ARGV that contains non-options that have
../inputs/grep1.dat:   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
../inputs/grep1.dat:   `last_nonopt' is the index after the last of them.  */
../inputs/grep1.dat:
../inputs/grep1.dat:static int first_nonopt;
../inputs/grep1.dat:static int last_nonopt;
../inputs/grep1.dat:
../inputs/grep1.dat:/* Exchange two adjacent subsequences of ARGV.
../inputs/grep1.dat:   One subsequence is elements [first_nonopt,last_nonopt)
../inputs/grep1.dat:   which contains all the non-options that have been skipped so far.
../inputs/grep1.dat:   The other is elements [last_nonopt,optind), which contains all
../inputs/grep1.dat:   the options processed since those non-options were skipped.
../inputs/grep1.dat:
../inputs/grep1.dat:   `first_nonopt' and `last_nonopt' are relocated so that they describe
../inputs/grep1.dat:   the new indices of the non-options in ARGV after they are moved.  */
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:exchange (argv)
../inputs/grep1.dat:     char **argv;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int nonopts_size = (last_nonopt - first_nonopt) * sizeof (char *);
../inputs/grep1.dat:  char **temp = (char **) __alloca (nonopts_size);
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Interchange the two blocks of data in ARGV.  */
../inputs/grep1.dat:
../inputs/grep1.dat:  my_bcopy ((char *) &argv[first_nonopt], (char *) temp, nonopts_size);
../inputs/grep1.dat:  my_bcopy ((char *) &argv[last_nonopt], (char *) &argv[first_nonopt],
../inputs/grep1.dat:	    (optind - last_nonopt) * sizeof (char *));
../inputs/grep1.dat:  my_bcopy ((char *) temp,
../inputs/grep1.dat:	    (char *) &argv[first_nonopt + optind - last_nonopt],
../inputs/grep1.dat:	    nonopts_size);
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Update records for the slots the non-options now occupy.  */
../inputs/grep1.dat:
../inputs/grep1.dat:  first_nonopt += (optind - last_nonopt);
../inputs/grep1.dat:  last_nonopt = optind;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Scan elements of ARGV (whose length is ARGC) for option characters
../inputs/grep1.dat:   given in OPTSTRING.
../inputs/grep1.dat:
../inputs/grep1.dat:   If an element of ARGV starts with '-', and is not exactly "-" or "--",
../inputs/grep1.dat:   then it is an option element.  The characters of this element
../inputs/grep1.dat:   (aside from the initial '-') are option characters.  If `getopt'
../inputs/grep1.dat:   is called repeatedly, it returns successively each of the option characters
../inputs/grep1.dat:   from each of the option elements.
../inputs/grep1.dat:
../inputs/grep1.dat:   If `getopt' finds another option character, it returns that character,
../inputs/grep1.dat:   updating `optind' and `nextchar' so that the next call to `getopt' can
../inputs/grep1.dat:   resume the scan with the following option character or ARGV-element.
../inputs/grep1.dat:
../inputs/grep1.dat:   If there are no more option characters, `getopt' returns `EOF'.
../inputs/grep1.dat:   Then `optind' is the index in ARGV of the first ARGV-element
../inputs/grep1.dat:   that is not an option.  (The ARGV-elements have been permuted
../inputs/grep1.dat:   so that those that are not options now come last.)
../inputs/grep1.dat:
../inputs/grep1.dat:   OPTSTRING is a string containing the legitimate option characters.
../inputs/grep1.dat:   If an option character is seen that is not listed in OPTSTRING,
../inputs/grep1.dat:   return '?' after printing an error message.  If you set `opterr' to
../inputs/grep1.dat:   zero, the error message is suppressed but we still return '?'.
../inputs/grep1.dat:
../inputs/grep1.dat:   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
../inputs/grep1.dat:   so the following text in the same ARGV-element, or the text of the following
../inputs/grep1.dat:   ARGV-element, is returned in `optarg'.  Two colons mean an option that
../inputs/grep1.dat:   wants an optional arg; if there is text in the current ARGV-element,
../inputs/grep1.dat:   it is returned in `optarg', otherwise `optarg' is set to zero.
../inputs/grep1.dat:
../inputs/grep1.dat:   If OPTSTRING starts with `-' or `+', it requests different methods of
../inputs/grep1.dat:   handling the non-option ARGV-elements.
../inputs/grep1.dat:   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
../inputs/grep1.dat:
../inputs/grep1.dat:   Long-named options begin with `--' instead of `-'.
../inputs/grep1.dat:   Their names may be abbreviated as long as the abbreviation is unique
../inputs/grep1.dat:   or is an exact match for some defined option.  If they have an
../inputs/grep1.dat:   argument, it follows the option name in the same ARGV-element, separated
../inputs/grep1.dat:   from the option name by a `=', or else the in next ARGV-element.
../inputs/grep1.dat:   When `getopt' finds a long-named option, it returns 0 if that option's
../inputs/grep1.dat:   `flag' field is nonzero, the value of the option's `val' field
../inputs/grep1.dat:   if the `flag' field is zero.
../inputs/grep1.dat:
../inputs/grep1.dat:   The elements of ARGV aren't really const, because we permute them.
../inputs/grep1.dat:   But we pretend they're const in the prototype to be compatible
../inputs/grep1.dat:   with other systems.
../inputs/grep1.dat:
../inputs/grep1.dat:   LONGOPTS is a vector of `struct option' terminated by an
../inputs/grep1.dat:   element containing a name which is zero.
../inputs/grep1.dat:
../inputs/grep1.dat:   LONGIND returns the index in LONGOPT of the long-named option found.
../inputs/grep1.dat:   It is only valid when a long-named option has been found by the most
../inputs/grep1.dat:   recent call.
../inputs/grep1.dat:
../inputs/grep1.dat:   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
../inputs/grep1.dat:   long-named options.  */
../inputs/grep1.dat:
../inputs/grep1.dat:int
../inputs/grep1.dat:_getopt_internal (argc, argv, optstring, longopts, longind, long_only)
../inputs/grep1.dat:     int argc;
../inputs/grep1.dat:     char *const *argv;
../inputs/grep1.dat:     const char *optstring;
../inputs/grep1.dat:     const struct option *longopts;
../inputs/grep1.dat:     int *longind;
../inputs/grep1.dat:     int long_only;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int option_index;
../inputs/grep1.dat:
../inputs/grep1.dat:  optarg = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Initialize the internal data when the first call is made.
../inputs/grep1.dat:     Start processing options with ARGV-element 1 (since ARGV-element 0
../inputs/grep1.dat:     is the program name); the sequence of previously skipped
../inputs/grep1.dat:     non-option ARGV-elements is empty.  */
../inputs/grep1.dat:
../inputs/grep1.dat:  if (optind == 0)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      first_nonopt = last_nonopt = optind = 1;
../inputs/grep1.dat:
../inputs/grep1.dat:      nextchar = NULL;
../inputs/grep1.dat:
../inputs/grep1.dat:      /* Determine how to handle the ordering of options and nonoptions.  */
../inputs/grep1.dat:
../inputs/grep1.dat:      if (optstring[0] == '-')
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  ordering = RETURN_IN_ORDER;
../inputs/grep1.dat:	  ++optstring;
../inputs/grep1.dat:	}
../inputs/grep1.dat:      else if (optstring[0] == '+')
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  ordering = REQUIRE_ORDER;
../inputs/grep1.dat:	  ++optstring;
../inputs/grep1.dat:	}
../inputs/grep1.dat:      else if (getenv ("POSIXLY_CORRECT") != NULL)
../inputs/grep1.dat:	ordering = REQUIRE_ORDER;
../inputs/grep1.dat:      else
../inputs/grep1.dat:	ordering = PERMUTE;
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  if (nextchar == NULL || *nextchar == '\0')
../inputs/grep1.dat:    {
../inputs/grep1.dat:      if (ordering == PERMUTE)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  /* If we have just processed some options following some non-options,
../inputs/grep1.dat:	     exchange them so that the options come first.  */
../inputs/grep1.dat:
../inputs/grep1.dat:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
../inputs/grep1.dat:	    exchange ((char **) argv);
../inputs/grep1.dat:	  else if (last_nonopt != optind)
../inputs/grep1.dat:	    first_nonopt = optind;
../inputs/grep1.dat:
../inputs/grep1.dat:	  /* Now skip any additional non-options
../inputs/grep1.dat:	     and extend the range of non-options previously skipped.  */
../inputs/grep1.dat:
../inputs/grep1.dat:	  while (optind < argc
../inputs/grep1.dat:		 && (argv[optind][0] != '-' || argv[optind][1] == '\0')
../inputs/grep1.dat:#ifdef GETOPT_COMPAT
../inputs/grep1.dat:		 && (longopts == NULL
../inputs/grep1.dat:		     || argv[optind][0] != '+' || argv[optind][1] == '\0')
../inputs/grep1.dat:#endif				/* GETOPT_COMPAT */
../inputs/grep1.dat:		 )
../inputs/grep1.dat:	    optind++;
../inputs/grep1.dat:	  last_nonopt = optind;
../inputs/grep1.dat:	}
../inputs/grep1.dat:
../inputs/grep1.dat:      /* Special ARGV-element `--' means premature end of options.
../inputs/grep1.dat:	 Skip it like a null option,
../inputs/grep1.dat:	 then exchange with previous non-options as if it were an option,
../inputs/grep1.dat:	 then skip everything else like a non-option.  */
../inputs/grep1.dat:
../inputs/grep1.dat:      if (optind != argc && !strcmp (argv[optind], "--"))
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  optind++;
../inputs/grep1.dat:
../inputs/grep1.dat:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
../inputs/grep1.dat:	    exchange ((char **) argv);
../inputs/grep1.dat:	  else if (first_nonopt == last_nonopt)
../inputs/grep1.dat:	    first_nonopt = optind;
../inputs/grep1.dat:	  last_nonopt = argc;
../inputs/grep1.dat:
../inputs/grep1.dat:	  optind = argc;
../inputs/grep1.dat:	}
../inputs/grep1.dat:
../inputs/grep1.dat:      /* If we have done all the ARGV-elements, stop the scan
../inputs/grep1.dat:	 and back over any non-options that we skipped and permuted.  */
../inputs/grep1.dat:
../inputs/grep1.dat:      if (optind == argc)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  /* Set the next-arg-index to point at the non-options
../inputs/grep1.dat:	     that we previously skipped, so the caller will digest them.  */
../inputs/grep1.dat:	  if (first_nonopt != last_nonopt)
../inputs/grep1.dat:	    optind = first_nonopt;
../inputs/grep1.dat:	  return EOF;
../inputs/grep1.dat:	}
../inputs/grep1.dat:
../inputs/grep1.dat:      /* If we have come to a non-option and did not permute it,
../inputs/grep1.dat:	 either stop the scan or describe it to the caller and pass it by.  */
../inputs/grep1.dat:
../inputs/grep1.dat:      if ((argv[optind][0] != '-' || argv[optind][1] == '\0')
../inputs/grep1.dat:#ifdef GETOPT_COMPAT
../inputs/grep1.dat:	  && (longopts == NULL
../inputs/grep1.dat:	      || argv[optind][0] != '+' || argv[optind][1] == '\0')
../inputs/grep1.dat:#endif				/* GETOPT_COMPAT */
../inputs/grep1.dat:	  )
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  if (ordering == REQUIRE_ORDER)
../inputs/grep1.dat:	    return EOF;
../inputs/grep1.dat:	  optarg = argv[optind++];
../inputs/grep1.dat:	  return 1;
../inputs/grep1.dat:	}
../inputs/grep1.dat:
../inputs/grep1.dat:      /* We have found another option-ARGV-element.
../inputs/grep1.dat:	 Start decoding its characters.  */
../inputs/grep1.dat:
../inputs/grep1.dat:      nextchar = (argv[optind] + 1
../inputs/grep1.dat:		  + (longopts != NULL && argv[optind][1] == '-'));
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  if (longopts != NULL
../inputs/grep1.dat:      && ((argv[optind][0] == '-'
../inputs/grep1.dat:	   && (argv[optind][1] == '-' || long_only))
../inputs/grep1.dat:#ifdef GETOPT_COMPAT
../inputs/grep1.dat:	  || argv[optind][0] == '+'
../inputs/grep1.dat:#endif				/* GETOPT_COMPAT */
../inputs/grep1.dat:	  ))
../inputs/grep1.dat:    {
../inputs/grep1.dat:      const struct option *p;
../inputs/grep1.dat:      char *s = nextchar;
../inputs/grep1.dat:      int exact = 0;
../inputs/grep1.dat:      int ambig = 0;
../inputs/grep1.dat:      const struct option *pfound = NULL;
../inputs/grep1.dat:      int indfound;
../inputs/grep1.dat:
../inputs/grep1.dat:      while (*s && *s != '=')
../inputs/grep1.dat:	s++;
../inputs/grep1.dat:
../inputs/grep1.dat:      /* Test all options for either exact match or abbreviated matches.  */
../inputs/grep1.dat:      for (p = longopts, option_index = 0; p->name;
../inputs/grep1.dat:	   p++, option_index++)
../inputs/grep1.dat:	if (!strncmp (p->name, nextchar, s - nextchar))
../inputs/grep1.dat:	  {
../inputs/grep1.dat:	    if (s - nextchar == strlen (p->name))
../inputs/grep1.dat:	      {
../inputs/grep1.dat:		/* Exact match found.  */
../inputs/grep1.dat:		pfound = p;
../inputs/grep1.dat:		indfound = option_index;
../inputs/grep1.dat:		exact = 1;
../inputs/grep1.dat:		break;
../inputs/grep1.dat:	      }
../inputs/grep1.dat:	    else if (pfound == NULL)
../inputs/grep1.dat:	      {
../inputs/grep1.dat:		/* First nonexact match found.  */
../inputs/grep1.dat:		pfound = p;
../inputs/grep1.dat:		indfound = option_index;
../inputs/grep1.dat:	      }
../inputs/grep1.dat:	    else
../inputs/grep1.dat:	      /* Second nonexact match found.  */
../inputs/grep1.dat:	      ambig = 1;
../inputs/grep1.dat:	  }
../inputs/grep1.dat:
../inputs/grep1.dat:      if (ambig && !exact)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  if (opterr)
../inputs/grep1.dat:	    fprintf (stderr, "%s: option `%s' is ambiguous\n",
../inputs/grep1.dat:		     argv[0], argv[optind]);
../inputs/grep1.dat:	  nextchar += strlen (nextchar);
../inputs/grep1.dat:	  optind++;
../inputs/grep1.dat:	  return '?';
../inputs/grep1.dat:	}
../inputs/grep1.dat:
../inputs/grep1.dat:      if (pfound != NULL)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  option_index = indfound;
../inputs/grep1.dat:	  optind++;
../inputs/grep1.dat:	  if (*s)
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      /* Don't test has_arg with >, because some C compilers don't
../inputs/grep1.dat:		 allow it to be used on enums.  */
../inputs/grep1.dat:	      if (pfound->has_arg)
../inputs/grep1.dat:		optarg = s + 1;
../inputs/grep1.dat:	      else
../inputs/grep1.dat:		{
../inputs/grep1.dat:		  if (opterr)
../inputs/grep1.dat:		    {
../inputs/grep1.dat:		      if (argv[optind - 1][1] == '-')
../inputs/grep1.dat:			/* --option */
../inputs/grep1.dat:			fprintf (stderr,
../inputs/grep1.dat:				 "%s: option `--%s' doesn't allow an argument\n",
../inputs/grep1.dat:				 argv[0], pfound->name);
../inputs/grep1.dat:		      else
../inputs/grep1.dat:			/* +option or -option */
../inputs/grep1.dat:			fprintf (stderr,
../inputs/grep1.dat:			     "%s: option `%c%s' doesn't allow an argument\n",
../inputs/grep1.dat:			     argv[0], argv[optind - 1][0], pfound->name);
../inputs/grep1.dat:		    }
../inputs/grep1.dat:		  nextchar += strlen (nextchar);
../inputs/grep1.dat:		  return '?';
../inputs/grep1.dat:		}
../inputs/grep1.dat:	    }
../inputs/grep1.dat:	  else if (pfound->has_arg == 1)
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      if (optind < argc)
../inputs/grep1.dat:		optarg = argv[optind++];
../inputs/grep1.dat:	      else
../inputs/grep1.dat:		{
../inputs/grep1.dat:		  if (opterr)
../inputs/grep1.dat:		    fprintf (stderr, "%s: option `%s' requires an argument\n",
../inputs/grep1.dat:			     argv[0], argv[optind - 1]);
../inputs/grep1.dat:		  nextchar += strlen (nextchar);
../inputs/grep1.dat:		  return optstring[0] == ':' ? ':' : '?';
../inputs/grep1.dat:		}
../inputs/grep1.dat:	    }
../inputs/grep1.dat:	  nextchar += strlen (nextchar);
../inputs/grep1.dat:	  if (longind != NULL)
../inputs/grep1.dat:	    *longind = option_index;
../inputs/grep1.dat:	  if (pfound->flag)
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      *(pfound->flag) = pfound->val;
../inputs/grep1.dat:	      return 0;
../inputs/grep1.dat:	    }
../inputs/grep1.dat:	  return pfound->val;
../inputs/grep1.dat:	}
../inputs/grep1.dat:      /* Can't find it as a long option.  If this is not getopt_long_only,
../inputs/grep1.dat:	 or the option starts with '--' or is not a valid short
../inputs/grep1.dat:	 option, then it's an error.
../inputs/grep1.dat:	 Otherwise interpret it as a short option.  */
../inputs/grep1.dat:      if (!long_only || argv[optind][1] == '-'
../inputs/grep1.dat:#ifdef GETOPT_COMPAT
../inputs/grep1.dat:	  || argv[optind][0] == '+'
../inputs/grep1.dat:#endif				/* GETOPT_COMPAT */
../inputs/grep1.dat:	  || my_index (optstring, *nextchar) == NULL)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  if (opterr)
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      if (argv[optind][1] == '-')
../inputs/grep1.dat:		/* --option */
../inputs/grep1.dat:		fprintf (stderr, "%s: unrecognized option `--%s'\n",
../inputs/grep1.dat:			 argv[0], nextchar);
../inputs/grep1.dat:	      else
../inputs/grep1.dat:		/* +option or -option */
../inputs/grep1.dat:		fprintf (stderr, "%s: unrecognized option `%c%s'\n",
../inputs/grep1.dat:			 argv[0], argv[optind][0], nextchar);
../inputs/grep1.dat:	    }
../inputs/grep1.dat:	  nextchar = (char *) "";
../inputs/grep1.dat:	  optind++;
../inputs/grep1.dat:	  return '?';
../inputs/grep1.dat:	}
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Look at and handle the next option-character.  */
../inputs/grep1.dat:
../inputs/grep1.dat:  {
../inputs/grep1.dat:    char c = *nextchar++;
../inputs/grep1.dat:    char *temp = my_index (optstring, c);
../inputs/grep1.dat:
../inputs/grep1.dat:    /* Increment `optind' when we start to process its last character.  */
../inputs/grep1.dat:    if (*nextchar == '\0')
../inputs/grep1.dat:      ++optind;
../inputs/grep1.dat:
../inputs/grep1.dat:    if (temp == NULL || c == ':')
../inputs/grep1.dat:      {
../inputs/grep1.dat:	if (opterr)
../inputs/grep1.dat:	  {
../inputs/grep1.dat:#if 0
../inputs/grep1.dat:	    if (c < 040 || c >= 0177)
../inputs/grep1.dat:	      fprintf (stderr, "%s: unrecognized option, character code 0%o\n",
../inputs/grep1.dat:		       argv[0], c);
../inputs/grep1.dat:	    else
../inputs/grep1.dat:	      fprintf (stderr, "%s: unrecognized option `-%c'\n", argv[0], c);
../inputs/grep1.dat:#else
../inputs/grep1.dat:	    /* 1003.2 specifies the format of this message.  */
../inputs/grep1.dat:	    fprintf (stderr, "%s: illegal option -- %c\n", argv[0], c);
../inputs/grep1.dat:#endif
../inputs/grep1.dat:	  }
../inputs/grep1.dat:	optopt = c;
../inputs/grep1.dat:	return '?';
../inputs/grep1.dat:      }
../inputs/grep1.dat:    if (temp[1] == ':')
../inputs/grep1.dat:      {
../inputs/grep1.dat:	if (temp[2] == ':')
../inputs/grep1.dat:	  {
../inputs/grep1.dat:	    /* This is an option that accepts an argument optionally.  */
../inputs/grep1.dat:	    if (*nextchar != '\0')
../inputs/grep1.dat:	      {
../inputs/grep1.dat:		optarg = nextchar;
../inputs/grep1.dat:		optind++;
../inputs/grep1.dat:	      }
../inputs/grep1.dat:	    else
../inputs/grep1.dat:	      optarg = 0;
../inputs/grep1.dat:	    nextchar = NULL;
../inputs/grep1.dat:	  }
../inputs/grep1.dat:	else
../inputs/grep1.dat:	  {
../inputs/grep1.dat:	    /* This is an option that requires an argument.  */
../inputs/grep1.dat:	    if (*nextchar != '\0')
../inputs/grep1.dat:	      {
../inputs/grep1.dat:		optarg = nextchar;
../inputs/grep1.dat:		/* If we end this ARGV-element by taking the rest as an arg,
../inputs/grep1.dat:		   we must advance to the next element now.  */
../inputs/grep1.dat:		optind++;
../inputs/grep1.dat:	      }
../inputs/grep1.dat:	    else if (optind == argc)
../inputs/grep1.dat:	      {
../inputs/grep1.dat:		if (opterr)
../inputs/grep1.dat:		  {
../inputs/grep1.dat:#if 0
../inputs/grep1.dat:		    fprintf (stderr, "%s: option `-%c' requires an argument\n",
../inputs/grep1.dat:			     argv[0], c);
../inputs/grep1.dat:#else
../inputs/grep1.dat:		    /* 1003.2 specifies the format of this message.  */
../inputs/grep1.dat:		    fprintf (stderr, "%s: option requires an argument -- %c\n",
../inputs/grep1.dat:			     argv[0], c);
../inputs/grep1.dat:#endif
../inputs/grep1.dat:		  }
../inputs/grep1.dat:		optopt = c;
../inputs/grep1.dat:		if (optstring[0] == ':')
../inputs/grep1.dat:		  c = ':';
../inputs/grep1.dat:		else
../inputs/grep1.dat:		  c = '?';
../inputs/grep1.dat:	      }
../inputs/grep1.dat:	    else
../inputs/grep1.dat:	      /* We already incremented `optind' once;
../inputs/grep1.dat:		 increment it again when taking next ARGV-elt as argument.  */
../inputs/grep1.dat:	      optarg = argv[optind++];
../inputs/grep1.dat:	    nextchar = NULL;
../inputs/grep1.dat:	  }
../inputs/grep1.dat:      }
../inputs/grep1.dat:    return c;
../inputs/grep1.dat:  }
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:int
../inputs/grep1.dat:getopt (argc, argv, optstring)
../inputs/grep1.dat:     int argc;
../inputs/grep1.dat:     char *const *argv;
../inputs/grep1.dat:     const char *optstring;
../inputs/grep1.dat:{
../inputs/grep1.dat:  return _getopt_internal (argc, argv, optstring,
../inputs/grep1.dat:			   (const struct option *) 0,
../inputs/grep1.dat:			   (int *) 0,
../inputs/grep1.dat:			   0);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:#endif	/* _LIBC or not __GNU_LIBRARY__.  */
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef TEST
../inputs/grep1.dat:
../inputs/grep1.dat:/* Compile with -DTEST to make an executable for use in testing
../inputs/grep1.dat:   the above definition of `getopt'.  */
../inputs/grep1.dat:
../inputs/grep1.dat:int
../inputs/grep1.dat:main (argc, argv)
../inputs/grep1.dat:     int argc;
../inputs/grep1.dat:     char **argv;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int c;
../inputs/grep1.dat:  int digit_optind = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:  while (1)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      int this_option_optind = optind ? optind : 1;
../inputs/grep1.dat:
../inputs/grep1.dat:      c = getopt (argc, argv, "abc:d:0123456789");
../inputs/grep1.dat:      if (c == EOF)
../inputs/grep1.dat:	break;
../inputs/grep1.dat:
../inputs/grep1.dat:      switch (c)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	case '0':
../inputs/grep1.dat:	case '1':
../inputs/grep1.dat:	case '2':
../inputs/grep1.dat:	case '3':
../inputs/grep1.dat:	case '4':
../inputs/grep1.dat:	case '5':
../inputs/grep1.dat:	case '6':
../inputs/grep1.dat:	case '7':
../inputs/grep1.dat:	case '8':
../inputs/grep1.dat:	case '9':
../inputs/grep1.dat:	  if (digit_optind != 0 && digit_optind != this_option_optind)
../inputs/grep1.dat:	    printf ("digits occur in two different argv-elements.\n");
../inputs/grep1.dat:	  digit_optind = this_option_optind;
../inputs/grep1.dat:	  printf ("option %c\n", c);
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:
../inputs/grep1.dat:	case 'a':
../inputs/grep1.dat:	  printf ("option a\n");
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:
../inputs/grep1.dat:	case 'b':
../inputs/grep1.dat:	  printf ("option b\n");
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:
../inputs/grep1.dat:	case 'c':
../inputs/grep1.dat:	  printf ("option c with value `%s'\n", optarg);
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:
../inputs/grep1.dat:	case '?':
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:
../inputs/grep1.dat:	default:
../inputs/grep1.dat:	  printf ("?? getopt returned character code 0%o ??\n", c);
../inputs/grep1.dat:	}
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  if (optind < argc)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      printf ("non-option ARGV-elements: ");
../inputs/grep1.dat:      while (optind < argc)
../inputs/grep1.dat:	printf ("%s ", argv[optind++]);
../inputs/grep1.dat:      printf ("\n");
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  exit (0);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:#endif /* TEST */
../inputs/grep1.dat:/* Extended regular expression matching and search library,
../inputs/grep1.dat:   version 0.12.
../inputs/grep1.dat:   (Implements POSIX draft P10003.2/D11.2, except for
../inputs/grep1.dat:   internationalization features.)
../inputs/grep1.dat:
../inputs/grep1.dat:   Copyright (C) 1993 Free Software Foundation, Inc.
../inputs/grep1.dat:
../inputs/grep1.dat:   This program is free software; you can redistribute it and/or modify
../inputs/grep1.dat:   it under the terms of the GNU General Public License as published by
../inputs/grep1.dat:   the Free Software Foundation; either version 2, or (at your option)
../inputs/grep1.dat:   any later version.
../inputs/grep1.dat:
../inputs/grep1.dat:   This program is distributed in the hope that it will be useful,
../inputs/grep1.dat:   but WITHOUT ANY WARRANTY; without even the implied warranty of
../inputs/grep1.dat:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
../inputs/grep1.dat:   GNU General Public License for more details.
../inputs/grep1.dat:
../inputs/grep1.dat:   You should have received a copy of the GNU General Public License
../inputs/grep1.dat:   along with this program; if not, write to the Free Software
../inputs/grep1.dat:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
../inputs/grep1.dat:
../inputs/grep1.dat:/* AIX requires this to be the first thing in the file. */
../inputs/grep1.dat:#if defined (_AIX) && !defined (REGEX_MALLOC)
../inputs/grep1.dat:  #pragma alloca
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:#define _GNU_SOURCE
../inputs/grep1.dat:
../inputs/grep1.dat:#if flag_systypes==0
../inputs/grep1.dat:#define flag_systypes 1
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef HAVE_CONFIG_H
../inputs/grep1.dat:#if flag_config==0
../inputs/grep1.dat:#define flag_config 1
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:/* The `emacs' switch turns on certain matching commands
../inputs/grep1.dat:   that make sense only in Emacs. */
../inputs/grep1.dat:#ifdef emacs
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Emacs uses `NULL' as a predicate.  */
../inputs/grep1.dat:#undef NULL
../inputs/grep1.dat:
../inputs/grep1.dat:#else  /* not emacs */
../inputs/grep1.dat:
../inputs/grep1.dat:/* We used to test for `BSTRING' here, but only GCC and Emacs define
../inputs/grep1.dat:   `BSTRING', as far as I know, and neither of them use this code.  */
../inputs/grep1.dat:#if HAVE_STRING_H || STDC_HEADERS
../inputs/grep1.dat:#if flag_string==0
../inputs/grep1.dat:#define flag_string 1
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#ifndef bcmp
../inputs/grep1.dat:#define bcmp(s1, s2, n)	memcmp ((s1), (s2), (n))
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#ifndef bcopy
../inputs/grep1.dat:#define bcopy(s, d, n)	memcpy ((d), (s), (n))
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#ifndef bzero
../inputs/grep1.dat:#define bzero(s, n)	memset ((s), 0, (n))
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#else
../inputs/grep1.dat:#if flag_strings==0
../inputs/grep1.dat:#define flag_strings 1
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef STDC_HEADERS
../inputs/grep1.dat:#if flag_stdlib==0 
../inputs/grep1.dat:#define flag_stdlib 1
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#else
../inputs/grep1.dat:char *malloc ();
../inputs/grep1.dat:char *realloc ();
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Define the syntax stuff for \<, \>, etc.  */
../inputs/grep1.dat:
../inputs/grep1.dat:/* This must be nonzero for the wordchar and notwordchar pattern
../inputs/grep1.dat:   commands in re_match_2.  */
../inputs/grep1.dat:#ifndef Sword 
../inputs/grep1.dat:#define Sword 1
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef SYNTAX_TABLE
../inputs/grep1.dat:
../inputs/grep1.dat:extern char *re_syntax_table;
../inputs/grep1.dat:
../inputs/grep1.dat:#else /* not SYNTAX_TABLE */
../inputs/grep1.dat:
../inputs/grep1.dat:/* How many characters in the character set.  */
../inputs/grep1.dat:#define CHAR_SET_SIZE 256
../inputs/grep1.dat:
../inputs/grep1.dat:static char re_syntax_table[CHAR_SET_SIZE];
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:init_syntax_once ()
../inputs/grep1.dat:{
../inputs/grep1.dat:   register int c;
../inputs/grep1.dat:   static int done = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:   if (done)
../inputs/grep1.dat:     return;
../inputs/grep1.dat:
../inputs/grep1.dat:   bzero (re_syntax_table, sizeof re_syntax_table);
../inputs/grep1.dat:
../inputs/grep1.dat:   for (c = 'a'; c <= 'z'; c++)
../inputs/grep1.dat:     re_syntax_table[c] = Sword;
../inputs/grep1.dat:
../inputs/grep1.dat:   for (c = 'A'; c <= 'Z'; c++)
../inputs/grep1.dat:     re_syntax_table[c] = Sword;
../inputs/grep1.dat:
../inputs/grep1.dat:   for (c = '0'; c <= '9'; c++)
../inputs/grep1.dat:     re_syntax_table[c] = Sword;
../inputs/grep1.dat:
../inputs/grep1.dat:   re_syntax_table['_'] = Sword;
../inputs/grep1.dat:
../inputs/grep1.dat:   done = 1;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:#endif /* not SYNTAX_TABLE */
../inputs/grep1.dat:
../inputs/grep1.dat:#define SYNTAX(c) re_syntax_table[c]
../inputs/grep1.dat:
../inputs/grep1.dat:#endif /* not emacs */
../inputs/grep1.dat:
../inputs/grep1.dat:/* Get the interface, including the syntax bits.  */
../inputs/grep1.dat:
../inputs/grep1.dat:/* isalpha etc. are used for the character classes.  */
../inputs/grep1.dat:
../inputs/grep1.dat:/* Jim Meyering writes:
../inputs/grep1.dat:
../inputs/grep1.dat:   "... Some ctype macros are valid only for character codes that
../inputs/grep1.dat:   isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
../inputs/grep1.dat:   using /bin/cc or gcc but without giving an ansi option).  So, all
../inputs/grep1.dat:   ctype uses should be through macros like ISPRINT...  If
../inputs/grep1.dat:   STDC_HEADERS is defined, then autoconf has verified that the ctype
../inputs/grep1.dat:   macros don't need to be guarded with references to isascii. ...
../inputs/grep1.dat:   Defining isascii to 1 should let any compiler worth its salt
../inputs/grep1.dat:   eliminate the && through constant folding."  */
../inputs/grep1.dat:#if ! defined (isascii) || defined (STDC_HEADERS)
../inputs/grep1.dat:#undef isascii
../inputs/grep1.dat:#define isascii(c) 1
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef isblank
../inputs/grep1.dat:#define ISBLANK(c) (isascii (c) && isblank (c))
../inputs/grep1.dat:#else
../inputs/grep1.dat:#define ISBLANK(c) ((c) == ' ' || (c) == '\t')
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#ifdef isgraph
../inputs/grep1.dat:#define ISGRAPH(c) (isascii (c) && isgraph (c))
../inputs/grep1.dat:#else
../inputs/grep1.dat:#define ISGRAPH(c) (isascii (c) && isprint (c) && !isspace (c))
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:#define ISPRINT(c) (isascii (c) && isprint (c))
../inputs/grep1.dat:#define ISDIGIT(c) (isascii (c) && isdigit (c))
../inputs/grep1.dat:#define ISALNUM(c) (isascii (c) && isalnum (c))
../inputs/grep1.dat:#define ISALPHA(c) (isascii (c) && isalpha (c))
../inputs/grep1.dat:#define ISCNTRL(c) (isascii (c) && iscntrl (c))
../inputs/grep1.dat:#define ISLOWER(c) (isascii (c) && islower (c))
../inputs/grep1.dat:#define ISPUNCT(c) (isascii (c) && ispunct (c))
../inputs/grep1.dat:#define ISSPACE(c) (isascii (c) && isspace (c))
../inputs/grep1.dat:#define ISUPPER(c) (isascii (c) && isupper (c))
../inputs/grep1.dat:#define ISXDIGIT(c) (isascii (c) && isxdigit (c))
../inputs/grep1.dat:
../inputs/grep1.dat:#ifndef NULL
../inputs/grep1.dat:#define NULL 0
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:/* We remove any previous definition of `SIGN_EXTEND_CHAR',
../inputs/grep1.dat:   since ours (we hope) works properly with all combinations of
../inputs/grep1.dat:   machines, compilers, `char' and `unsigned char' argument types.
../inputs/grep1.dat:   (Per Bothner suggested the basic approach.)  */
../inputs/grep1.dat:#undef SIGN_EXTEND_CHAR
../inputs/grep1.dat:#if __STDC__
../inputs/grep1.dat:#define SIGN_EXTEND_CHAR(c) ((signed char) (c))
../inputs/grep1.dat:#else  /* not __STDC__ */
../inputs/grep1.dat:/* As in Harbison and Steele.  */
../inputs/grep1.dat:#define SIGN_EXTEND_CHAR(c) ((((unsigned char) (c)) ^ 128) - 128)
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:/* Should we use malloc or alloca?  If REGEX_MALLOC is not defined, we
../inputs/grep1.dat:   use `alloca' instead of `malloc'.  This is because using malloc in
../inputs/grep1.dat:   re_search* or re_match* could cause memory leaks when C-g is used in
../inputs/grep1.dat:   Emacs; also, malloc is slower and causes storage fragmentation.  On
../inputs/grep1.dat:   the other hand, malloc is more portable, and easier to debug.  
../inputs/grep1.dat:   
../inputs/grep1.dat:   Because we sometimes use alloca, some routines have to be macros,
../inputs/grep1.dat:   not functions -- `alloca'-allocated space disappears at the end of the
../inputs/grep1.dat:   function it is called in.  */
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef REGEX_MALLOC
../inputs/grep1.dat:
../inputs/grep1.dat:#define REGEX_ALLOCATE malloc
../inputs/grep1.dat:#define REGEX_REALLOCATE(source, osize, nsize) realloc (source, nsize)
../inputs/grep1.dat:
../inputs/grep1.dat:#else /* not REGEX_MALLOC  */
../inputs/grep1.dat:
../inputs/grep1.dat:/* Emacs already defines alloca, sometimes.  */
../inputs/grep1.dat:#ifndef alloca
../inputs/grep1.dat:
../inputs/grep1.dat:/* Make alloca work the best possible way.  */
../inputs/grep1.dat:#ifdef __GNUC__
../inputs/grep1.dat:#define alloca __builtin_alloca
../inputs/grep1.dat:#else /* not __GNUC__ */
../inputs/grep1.dat:#if HAVE_ALLOCA_H
../inputs/grep1.dat:#if flag_alloca==0
../inputs/grep1.dat:#define flag_alloca 1
../inputs/grep1.dat:#endif 
../inputs/grep1.dat:#else /* not __GNUC__ or HAVE_ALLOCA_H */
../inputs/grep1.dat:#ifndef _AIX /* Already did AIX, up at the top.  */
../inputs/grep1.dat:char *alloca ();
../inputs/grep1.dat:#endif /* not _AIX */
../inputs/grep1.dat:#endif /* not HAVE_ALLOCA_H */ 
../inputs/grep1.dat:#endif /* not __GNUC__ */
../inputs/grep1.dat:
../inputs/grep1.dat:#endif /* not alloca */
../inputs/grep1.dat:
../inputs/grep1.dat:#define REGEX_ALLOCATE alloca
../inputs/grep1.dat:
../inputs/grep1.dat:/* Assumes a `char *destination' variable.  */
../inputs/grep1.dat:#define REGEX_REALLOCATE(source, osize, nsize)				\
../inputs/grep1.dat:  (destination = (char *) alloca (nsize),				\
../inputs/grep1.dat:   bcopy (source, destination, osize),					\
../inputs/grep1.dat:   destination)
../inputs/grep1.dat:
../inputs/grep1.dat:#endif /* not REGEX_MALLOC */
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* True if `size1' is non-NULL and PTR is pointing anywhere inside
../inputs/grep1.dat:   `string1' or just past its end.  This works if PTR is NULL, which is
../inputs/grep1.dat:   a good thing.  */
../inputs/grep1.dat:#define FIRST_STRING_P(ptr) 					\
../inputs/grep1.dat:  (size1 && string1 <= (ptr) && (ptr) <= string1 + size1)
../inputs/grep1.dat:
../inputs/grep1.dat:/* (Re)Allocate N items of type T using malloc, or fail.  */
../inputs/grep1.dat:#define TALLOC(n, t) ((t *) malloc ((n) * sizeof (t)))
../inputs/grep1.dat:#define RETALLOC(addr, n, t) ((addr) = (t *) realloc (addr, (n) * sizeof (t)))
../inputs/grep1.dat:#define REGEX_TALLOC(n, t) ((t *) REGEX_ALLOCATE ((n) * sizeof (t)))
../inputs/grep1.dat:
../inputs/grep1.dat:#define BYTEWIDTH 8 /* In bits.  */
../inputs/grep1.dat:
../inputs/grep1.dat:#define STREQ(s1, s2) ((strcmp (s1, s2) == 0))
../inputs/grep1.dat:
../inputs/grep1.dat:#undef MAX               /****** added later *******/
../inputs/grep1.dat:#define MAX(a, b) ((a) > (b) ? (a) : (b))
../inputs/grep1.dat:#define MIN(a, b) ((a) < (b) ? (a) : (b))
../inputs/grep1.dat:
../inputs/grep1.dat:typedef char boolean;
../inputs/grep1.dat:#define false 0
../inputs/grep1.dat:#define true 1
../inputs/grep1.dat:
../inputs/grep1.dat:/* These are the command codes that appear in compiled regular
../inputs/grep1.dat:   expressions.  Some opcodes are followed by argument bytes.  A
../inputs/grep1.dat:   command code can specify any interpretation whatsoever for its
../inputs/grep1.dat:   arguments.  Zero bytes may appear in the compiled regular expression.
../inputs/grep1.dat:
../inputs/grep1.dat:   The value of `exactn' is needed in search.c (search_buffer) in Emacs.
../inputs/grep1.dat:   So regex.h defines a symbol `RE_EXACTN_VALUE' to be 1; the value of
../inputs/grep1.dat:   `exactn' we use here must also be 1.  */
../inputs/grep1.dat:
../inputs/grep1.dat:typedef enum
../inputs/grep1.dat:{
../inputs/grep1.dat:  no_op = 0,
../inputs/grep1.dat:
../inputs/grep1.dat:        /* Followed by one byte giving n, then by n literal bytes.  */
../inputs/grep1.dat:  exactn = 1,
../inputs/grep1.dat:
../inputs/grep1.dat:        /* Matches any (more or less) character.  */
../inputs/grep1.dat:  anychar,
../inputs/grep1.dat:
../inputs/grep1.dat:        /* Matches any one char belonging to specified set.  First
../inputs/grep1.dat:           following byte is number of bitmap bytes.  Then come bytes
../inputs/grep1.dat:           for a bitmap saying which chars are in.  Bits in each byte
../inputs/grep1.dat:           are ordered low-bit-first.  A character is in the set if its
../inputs/grep1.dat:           bit is 1.  A character too large to have a bit in the map is
../inputs/grep1.dat:           automatically not in the set.  */
../inputs/grep1.dat:  charset,
../inputs/grep1.dat:
../inputs/grep1.dat:        /* Same parameters as charset, but match any character that is
../inputs/grep1.dat:           not one of those specified.  */
../inputs/grep1.dat:  charset_not,
../inputs/grep1.dat:
../inputs/grep1.dat:        /* Start remembering the text that is matched, for storing in a
../inputs/grep1.dat:           register.  Followed by one byte with the register number, in
../inputs/grep1.dat:           the range 0 to one less than the pattern buffer's re_nsub
../inputs/grep1.dat:           field.  Then followed by one byte with the number of groups
../inputs/grep1.dat:           inner to this one.  (This last has to be part of the
../inputs/grep1.dat:           start_memory only because we need it in the on_failure_jump
../inputs/grep1.dat:           of re_match_2.)  */
../inputs/grep1.dat:  start_memory,
../inputs/grep1.dat:
../inputs/grep1.dat:        /* Stop remembering the text that is matched and store it in a
../inputs/grep1.dat:           memory register.  Followed by one byte with the register
../inputs/grep1.dat:           number, in the range 0 to one less than `re_nsub' in the
../inputs/grep1.dat:           pattern buffer, and one byte with the number of inner groups,
../inputs/grep1.dat:           just like `start_memory'.  (We need the number of inner
../inputs/grep1.dat:           groups here because we don't have any easy way of finding the
../inputs/grep1.dat:           corresponding start_memory when we're at a stop_memory.)  */
../inputs/grep1.dat:  stop_memory,
../inputs/grep1.dat:
../inputs/grep1.dat:        /* Match a duplicate of something remembered. Followed by one
../inputs/grep1.dat:           byte containing the register number.  */
../inputs/grep1.dat:  duplicate,
../inputs/grep1.dat:
../inputs/grep1.dat:        /* Fail unless at beginning of line.  */
../inputs/grep1.dat:  begline,
../inputs/grep1.dat:
../inputs/grep1.dat:        /* Fail unless at end of line.  */
../inputs/grep1.dat:  endline,
../inputs/grep1.dat:
../inputs/grep1.dat:        /* Succeeds if at beginning of buffer (if emacs) or at beginning
../inputs/grep1.dat:           of string to be matched (if not).  */
../inputs/grep1.dat:  begbuf,
../inputs/grep1.dat:
../inputs/grep1.dat:        /* Analogously, for end of buffer/string.  */
../inputs/grep1.dat:  endbuf,
../inputs/grep1.dat: 
../inputs/grep1.dat:        /* Followed by two byte relative address to which to jump.  */
../inputs/grep1.dat:  jump, 
../inputs/grep1.dat:
../inputs/grep1.dat:	/* Same as jump, but marks the end of an alternative.  */
../inputs/grep1.dat:  jump_past_alt,
../inputs/grep1.dat:
../inputs/grep1.dat:        /* Followed by two-byte relative address of place to resume at
../inputs/grep1.dat:           in case of failure.  */
../inputs/grep1.dat:  on_failure_jump,
../inputs/grep1.dat:	
../inputs/grep1.dat:        /* Like on_failure_jump, but pushes a placeholder instead of the
../inputs/grep1.dat:           current string position when executed.  */
../inputs/grep1.dat:  on_failure_keep_string_jump,
../inputs/grep1.dat:  
../inputs/grep1.dat:        /* Throw away latest failure point and then jump to following
../inputs/grep1.dat:           two-byte relative address.  */
../inputs/grep1.dat:  pop_failure_jump,
../inputs/grep1.dat:
../inputs/grep1.dat:        /* Change to pop_failure_jump if know won't have to backtrack to
../inputs/grep1.dat:           match; otherwise change to jump.  This is used to jump
../inputs/grep1.dat:           back to the beginning of a repeat.  If what follows this jump
../inputs/grep1.dat:           clearly won't match what the repeat does, such that we can be
../inputs/grep1.dat:           sure that there is no use backtracking out of repetitions
../inputs/grep1.dat:           already matched, then we change it to a pop_failure_jump.
../inputs/grep1.dat:           Followed by two-byte address.  */
../inputs/grep1.dat:  maybe_pop_jump,
../inputs/grep1.dat:
../inputs/grep1.dat:        /* Jump to following two-byte address, and push a dummy failure
../inputs/grep1.dat:           point. This failure point will be thrown away if an attempt
../inputs/grep1.dat:           is made to use it for a failure.  A `+' construct makes this
../inputs/grep1.dat:           before the first repeat.  Also used as an intermediary kind
../inputs/grep1.dat:           of jump when compiling an alternative.  */
../inputs/grep1.dat:  dummy_failure_jump,
../inputs/grep1.dat:
../inputs/grep1.dat:	/* Push a dummy failure point and continue.  Used at the end of
../inputs/grep1.dat:	   alternatives.  */
../inputs/grep1.dat:  push_dummy_failure,
../inputs/grep1.dat:
../inputs/grep1.dat:        /* Followed by two-byte relative address and two-byte number n.
../inputs/grep1.dat:           After matching N times, jump to the address upon failure.  */
../inputs/grep1.dat:  succeed_n,
../inputs/grep1.dat:
../inputs/grep1.dat:        /* Followed by two-byte relative address, and two-byte number n.
../inputs/grep1.dat:           Jump to the address N times, then fail.  */
../inputs/grep1.dat:  jump_n,
../inputs/grep1.dat:
../inputs/grep1.dat:        /* Set the following two-byte relative address to the
../inputs/grep1.dat:           bytes of number.  */
../inputs/grep1.dat:  set_number_at,
../inputs/grep1.dat:
../inputs/grep1.dat:  wordchar,	/* Matches any word-constituent character.  */
../inputs/grep1.dat:  notwordchar,	/* Matches any char that is not a word-constituent.  */
../inputs/grep1.dat:
../inputs/grep1.dat:  wordbeg,	/* Succeeds if at word beginning.  */
../inputs/grep1.dat:  wordend,	/* Succeeds if at word end.  */
../inputs/grep1.dat:
../inputs/grep1.dat:  wordbound,	/* Succeeds if at a word boundary.  */
../inputs/grep1.dat:  notwordbound	/* Succeeds if not at a word boundary.  */
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef emacs
../inputs/grep1.dat:  ,before_dot,	/* Succeeds if before point.  */
../inputs/grep1.dat:  at_dot,	/* Succeeds if at point.  */
../inputs/grep1.dat:  after_dot,	/* Succeeds if after point.  */
../inputs/grep1.dat:
../inputs/grep1.dat:	/* Matches any character whose syntax is specified.  Followed by
../inputs/grep1.dat:           a byte which contains a syntax code, e.g., Sword.  */
../inputs/grep1.dat:  syntaxspec,
../inputs/grep1.dat:
../inputs/grep1.dat:	/* Matches any character whose syntax is not that specified.  */
../inputs/grep1.dat:  notsyntaxspec
../inputs/grep1.dat:#endif /* emacs */
../inputs/grep1.dat:} re_opcode_t;
../inputs/grep1.dat:
../inputs/grep1.dat:/* Common operations on the compiled pattern.  */
../inputs/grep1.dat:
../inputs/grep1.dat:/* Store NUMBER in two contiguous bytes starting at DESTINATION.  */
../inputs/grep1.dat:
../inputs/grep1.dat:#define STORE_NUMBER(destination, number)				\
../inputs/grep1.dat:  do {									\
../inputs/grep1.dat:    (destination)[0] = (number) & 0377;					\
../inputs/grep1.dat:    (destination)[1] = (number) >> 8;					\
../inputs/grep1.dat:  } while (0)
../inputs/grep1.dat:
../inputs/grep1.dat:/* Same as STORE_NUMBER, except increment DESTINATION to
../inputs/grep1.dat:   the byte after where the number is stored.  Therefore, DESTINATION
../inputs/grep1.dat:   must be an lvalue.  */
../inputs/grep1.dat:
../inputs/grep1.dat:#define STORE_NUMBER_AND_INCR(destination, number)			\
../inputs/grep1.dat:  do {									\
../inputs/grep1.dat:    STORE_NUMBER (destination, number);					\
../inputs/grep1.dat:    (destination) += 2;							\
../inputs/grep1.dat:  } while (0)
../inputs/grep1.dat:
../inputs/grep1.dat:/* Put into DESTINATION a number stored in two contiguous bytes starting
../inputs/grep1.dat:   at SOURCE.  */
../inputs/grep1.dat:
../inputs/grep1.dat:#define EXTRACT_NUMBER(destination, source)				\
../inputs/grep1.dat:  do {									\
../inputs/grep1.dat:    (destination) = *(source) & 0377;					\
../inputs/grep1.dat:    (destination) += SIGN_EXTEND_CHAR (*((source) + 1)) << 8;		\
../inputs/grep1.dat:  } while (0)
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef DEBUG
../inputs/grep1.dat:static void
../inputs/grep1.dat:extract_number (dest, source)
../inputs/grep1.dat:    int *dest;
../inputs/grep1.dat:    unsigned char *source;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int temp = SIGN_EXTEND_CHAR (*(source + 1)); 
../inputs/grep1.dat:  *dest = *source & 0377;
../inputs/grep1.dat:  *dest += temp << 8;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:#ifndef EXTRACT_MACROS /* To debug the macros.  */
../inputs/grep1.dat:#undef EXTRACT_NUMBER
../inputs/grep1.dat:#define EXTRACT_NUMBER(dest, src) extract_number (&dest, src)
../inputs/grep1.dat:#endif /* not EXTRACT_MACROS */
../inputs/grep1.dat:
../inputs/grep1.dat:#endif /* DEBUG */
../inputs/grep1.dat:
../inputs/grep1.dat:/* Same as EXTRACT_NUMBER, except increment SOURCE to after the number.
../inputs/grep1.dat:   SOURCE must be an lvalue.  */
../inputs/grep1.dat:
../inputs/grep1.dat:#define EXTRACT_NUMBER_AND_INCR(destination, source)			\
../inputs/grep1.dat:  do {									\
../inputs/grep1.dat:    EXTRACT_NUMBER (destination, source);				\
../inputs/grep1.dat:    (source) += 2; 							\
../inputs/grep1.dat:  } while (0)
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef DEBUG
../inputs/grep1.dat:static void
../inputs/grep1.dat:extract_number_and_incr (destination, source)
../inputs/grep1.dat:    int *destination;
../inputs/grep1.dat:    unsigned char **source;
../inputs/grep1.dat:{ 
../inputs/grep1.dat:  extract_number (destination, *source);
../inputs/grep1.dat:  *source += 2;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:#ifndef EXTRACT_MACROS
../inputs/grep1.dat:#undef EXTRACT_NUMBER_AND_INCR
../inputs/grep1.dat:#define EXTRACT_NUMBER_AND_INCR(dest, src) \
../inputs/grep1.dat:  extract_number_and_incr (&dest, &src)
../inputs/grep1.dat:#endif /* not EXTRACT_MACROS */
../inputs/grep1.dat:
../inputs/grep1.dat:#endif /* DEBUG */
../inputs/grep1.dat:
../inputs/grep1.dat:/* If DEBUG is defined, Regex prints many voluminous messages about what
../inputs/grep1.dat:   it is doing (if the variable `debug' is nonzero).  If linked with the
../inputs/grep1.dat:   main program in `iregex.c', you can enter patterns and strings
../inputs/grep1.dat:   interactively.  And if linked with the main program in `main.c' and
../inputs/grep1.dat:   the other test files, you can run the already-written tests.  */
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef DEBUG
../inputs/grep1.dat:
../inputs/grep1.dat:/* We use standard I/O for debugging.  */
../inputs/grep1.dat:
../inputs/grep1.dat:/* It is useful to test things that ``must'' be true when debugging.  */
../inputs/grep1.dat:
../inputs/grep1.dat:static int debug = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:#define DEBUG_STATEMENT(e) e
../inputs/grep1.dat:#define DEBUG_PRINT1(x) if (debug) printf (x)
../inputs/grep1.dat:#define DEBUG_PRINT2(x1, x2) if (debug) printf (x1, x2)
../inputs/grep1.dat:#define DEBUG_PRINT3(x1, x2, x3) if (debug) printf (x1, x2, x3)
../inputs/grep1.dat:#define DEBUG_PRINT4(x1, x2, x3, x4) if (debug) printf (x1, x2, x3, x4)
../inputs/grep1.dat:#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e) 				\
../inputs/grep1.dat:  if (debug) print_partial_compiled_pattern (s, e)
../inputs/grep1.dat:#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)			\
../inputs/grep1.dat:  if (debug) print_double_string (w, s1, sz1, s2, sz2)
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:extern void printchar ();
../inputs/grep1.dat:
../inputs/grep1.dat:/* Print the fastmap in human-readable form.  */
../inputs/grep1.dat:
../inputs/grep1.dat:void
../inputs/grep1.dat:print_fastmap (fastmap)
../inputs/grep1.dat:    char *fastmap;
../inputs/grep1.dat:{
../inputs/grep1.dat:  unsigned was_a_range = 0;
../inputs/grep1.dat:  unsigned i = 0;  
../inputs/grep1.dat:  
../inputs/grep1.dat:  while (i < (1 << BYTEWIDTH))
../inputs/grep1.dat:    {
../inputs/grep1.dat:      if (fastmap[i++])
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  was_a_range = 0;
../inputs/grep1.dat:          printchar (i - 1);
../inputs/grep1.dat:          while (i < (1 << BYTEWIDTH)  &&  fastmap[i])
../inputs/grep1.dat:            {
../inputs/grep1.dat:              was_a_range = 1;
../inputs/grep1.dat:              i++;
../inputs/grep1.dat:            }
../inputs/grep1.dat:	  if (was_a_range)
../inputs/grep1.dat:            {
../inputs/grep1.dat:              printf ("-");
../inputs/grep1.dat:              printchar (i - 1);
../inputs/grep1.dat:            }
../inputs/grep1.dat:        }
../inputs/grep1.dat:    }
../inputs/grep1.dat:  putchar ('\n'); 
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Print a compiled pattern string in human-readable form, starting at
../inputs/grep1.dat:   the START pointer into it and ending just before the pointer END.  */
../inputs/grep1.dat:
../inputs/grep1.dat:void
../inputs/grep1.dat:print_partial_compiled_pattern (start, end)
../inputs/grep1.dat:    unsigned char *start;
../inputs/grep1.dat:    unsigned char *end;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int mcnt, mcnt2;
../inputs/grep1.dat:  unsigned char *p = start;
../inputs/grep1.dat:  unsigned char *pend = end;
../inputs/grep1.dat:
../inputs/grep1.dat:  if (start == NULL)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      printf ("(null)\n");
../inputs/grep1.dat:      return;
../inputs/grep1.dat:    }
../inputs/grep1.dat:    
../inputs/grep1.dat:  /* Loop over pattern commands.  */
../inputs/grep1.dat:  while (p < pend)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      printf ("%d:\t", p - start);
../inputs/grep1.dat:
../inputs/grep1.dat:      switch ((re_opcode_t) *p++)
../inputs/grep1.dat:	{
../inputs/grep1.dat:        case no_op:
../inputs/grep1.dat:          printf ("/no_op");
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:	case exactn:
../inputs/grep1.dat:	  mcnt = *p++;
../inputs/grep1.dat:          printf ("/exactn/%d", mcnt);
../inputs/grep1.dat:          do
../inputs/grep1.dat:	    {
../inputs/grep1.dat:              putchar ('/');
../inputs/grep1.dat:	      printchar (*p++);
../inputs/grep1.dat:            }
../inputs/grep1.dat:          while (--mcnt);
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:	case start_memory:
../inputs/grep1.dat:          mcnt = *p++;
../inputs/grep1.dat:          printf ("/start_memory/%d/%d", mcnt, *p++);
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:	case stop_memory:
../inputs/grep1.dat:          mcnt = *p++;
../inputs/grep1.dat:	  printf ("/stop_memory/%d/%d", mcnt, *p++);
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:	case duplicate:
../inputs/grep1.dat:	  printf ("/duplicate/%d", *p++);
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:
../inputs/grep1.dat:	case anychar:
../inputs/grep1.dat:	  printf ("/anychar");
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:
../inputs/grep1.dat:	case charset:
../inputs/grep1.dat:        case charset_not:
../inputs/grep1.dat:          {
../inputs/grep1.dat:            register int c, last = -100;
../inputs/grep1.dat:	    register int in_range = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:	    printf ("/charset [%s",
../inputs/grep1.dat:	            (re_opcode_t) *(p - 1) == charset_not ? "^" : "");
../inputs/grep1.dat:            
../inputs/grep1.dat:            assert (p + *p < pend);
../inputs/grep1.dat:
../inputs/grep1.dat:            for (c = 0; c < 256; c++)
../inputs/grep1.dat:	      if (c / 8 < *p
../inputs/grep1.dat:		  && (p[1 + (c/8)] & (1 << (c % 8))))
../inputs/grep1.dat:		{
../inputs/grep1.dat:		  /* Are we starting a range?  */
../inputs/grep1.dat:		  if (last + 1 == c && ! in_range)
../inputs/grep1.dat:		    {
../inputs/grep1.dat:		      putchar ('-');
../inputs/grep1.dat:		      in_range = 1;
../inputs/grep1.dat:		    }
../inputs/grep1.dat:		  /* Have we broken a range?  */
../inputs/grep1.dat:		  else if (last + 1 != c && in_range)
../inputs/grep1.dat:              {
../inputs/grep1.dat:		      printchar (last);
../inputs/grep1.dat:		      in_range = 0;
../inputs/grep1.dat:		    }
../inputs/grep1.dat:                
../inputs/grep1.dat:		  if (! in_range)
../inputs/grep1.dat:		    printchar (c);
../inputs/grep1.dat:
../inputs/grep1.dat:		  last = c;
../inputs/grep1.dat:              }
../inputs/grep1.dat:
../inputs/grep1.dat:	    if (in_range)
../inputs/grep1.dat:	      printchar (last);
../inputs/grep1.dat:
../inputs/grep1.dat:	    putchar (']');
../inputs/grep1.dat:
../inputs/grep1.dat:	    p += 1 + *p;
../inputs/grep1.dat:	  }
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:
../inputs/grep1.dat:	case begline:
../inputs/grep1.dat:	  printf ("/begline");
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:	case endline:
../inputs/grep1.dat:          printf ("/endline");
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:	case on_failure_jump:
../inputs/grep1.dat:          extract_number_and_incr (&mcnt, &p);
../inputs/grep1.dat:  	  printf ("/on_failure_jump to %d", p + mcnt - start);
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:	case on_failure_keep_string_jump:
../inputs/grep1.dat:          extract_number_and_incr (&mcnt, &p);
../inputs/grep1.dat:  	  printf ("/on_failure_keep_string_jump to %d", p + mcnt - start);
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:	case dummy_failure_jump:
../inputs/grep1.dat:          extract_number_and_incr (&mcnt, &p);
../inputs/grep1.dat:  	  printf ("/dummy_failure_jump to %d", p + mcnt - start);
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:	case push_dummy_failure:
../inputs/grep1.dat:          printf ("/push_dummy_failure");
../inputs/grep1.dat:          break;
../inputs/grep1.dat:          
../inputs/grep1.dat:        case maybe_pop_jump:
../inputs/grep1.dat:          extract_number_and_incr (&mcnt, &p);
../inputs/grep1.dat:  	  printf ("/maybe_pop_jump to %d", p + mcnt - start);
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:
../inputs/grep1.dat:        case pop_failure_jump:
../inputs/grep1.dat:	  extract_number_and_incr (&mcnt, &p);
../inputs/grep1.dat:  	  printf ("/pop_failure_jump to %d", p + mcnt - start);
../inputs/grep1.dat:	  break;          
../inputs/grep1.dat:          
../inputs/grep1.dat:        case jump_past_alt:
../inputs/grep1.dat:	  extract_number_and_incr (&mcnt, &p);
../inputs/grep1.dat:  	  printf ("/jump_past_alt to %d", p + mcnt - start);
../inputs/grep1.dat:	  break;          
../inputs/grep1.dat:          
../inputs/grep1.dat:        case jump:
../inputs/grep1.dat:	  extract_number_and_incr (&mcnt, &p);
../inputs/grep1.dat:  	  printf ("/jump to %d", p + mcnt - start);
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:
../inputs/grep1.dat:        case succeed_n: 
../inputs/grep1.dat:          extract_number_and_incr (&mcnt, &p);
../inputs/grep1.dat:          extract_number_and_incr (&mcnt2, &p);
../inputs/grep1.dat:	  printf ("/succeed_n to %d, %d times", p + mcnt - start, mcnt2);
../inputs/grep1.dat:          break;
../inputs/grep1.dat:        
../inputs/grep1.dat:        case jump_n: 
../inputs/grep1.dat:          extract_number_and_incr (&mcnt, &p);
../inputs/grep1.dat:          extract_number_and_incr (&mcnt2, &p);
../inputs/grep1.dat:	  printf ("/jump_n to %d, %d times", p + mcnt - start, mcnt2);
../inputs/grep1.dat:          break;
../inputs/grep1.dat:        
../inputs/grep1.dat:        case set_number_at: 
../inputs/grep1.dat:          extract_number_and_incr (&mcnt, &p);
../inputs/grep1.dat:          extract_number_and_incr (&mcnt2, &p);
../inputs/grep1.dat:	  printf ("/set_number_at location %d to %d", p + mcnt - start, mcnt2);
../inputs/grep1.dat:          break;
../inputs/grep1.dat:        
../inputs/grep1.dat:        case wordbound:
../inputs/grep1.dat:	  printf ("/wordbound");
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:
../inputs/grep1.dat:	case notwordbound:
../inputs/grep1.dat:	  printf ("/notwordbound");
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:	case wordbeg:
../inputs/grep1.dat:	  printf ("/wordbeg");
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:          
../inputs/grep1.dat:	case wordend:
../inputs/grep1.dat:	  printf ("/wordend");
../inputs/grep1.dat:          
../inputs/grep1.dat:#ifdef emacs
../inputs/grep1.dat:	case before_dot:
../inputs/grep1.dat:	  printf ("/before_dot");
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:	case at_dot:
../inputs/grep1.dat:	  printf ("/at_dot");
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:	case after_dot:
../inputs/grep1.dat:	  printf ("/after_dot");
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:	case syntaxspec:
../inputs/grep1.dat:          printf ("/syntaxspec");
../inputs/grep1.dat:	  mcnt = *p++;
../inputs/grep1.dat:	  printf ("/%d", mcnt);
../inputs/grep1.dat:          break;
../inputs/grep1.dat:	  
../inputs/grep1.dat:	case notsyntaxspec:
../inputs/grep1.dat:          printf ("/notsyntaxspec");
../inputs/grep1.dat:	  mcnt = *p++;
../inputs/grep1.dat:	  printf ("/%d", mcnt);
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:#endif /* emacs */
../inputs/grep1.dat:
../inputs/grep1.dat:	case wordchar:
../inputs/grep1.dat:	  printf ("/wordchar");
../inputs/grep1.dat:          break;
../inputs/grep1.dat:	  
../inputs/grep1.dat:	case notwordchar:
../inputs/grep1.dat:	  printf ("/notwordchar");
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:	case begbuf:
../inputs/grep1.dat:	  printf ("/begbuf");
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:	case endbuf:
../inputs/grep1.dat:	  printf ("/endbuf");
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:        default:
../inputs/grep1.dat:          printf ("?%d", *(p-1));
../inputs/grep1.dat:	}
../inputs/grep1.dat:
../inputs/grep1.dat:      putchar ('\n');
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  printf ("%d:\tend of pattern.\n", p - start);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:void
../inputs/grep1.dat:print_compiled_pattern (bufp)
../inputs/grep1.dat:    struct re_pattern_buffer *bufp;
../inputs/grep1.dat:{
../inputs/grep1.dat:  unsigned char *buffer = bufp->buffer;
../inputs/grep1.dat:
../inputs/grep1.dat:  print_partial_compiled_pattern (buffer, buffer + bufp->used);
../inputs/grep1.dat:  printf ("%d bytes used/%d bytes allocated.\n", bufp->used, bufp->allocated);
../inputs/grep1.dat:
../inputs/grep1.dat:  if (bufp->fastmap_accurate && bufp->fastmap)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      printf ("fastmap: ");
../inputs/grep1.dat:      print_fastmap (bufp->fastmap);
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  printf ("re_nsub: %d\t", bufp->re_nsub);
../inputs/grep1.dat:  printf ("regs_alloc: %d\t", bufp->regs_allocated);
../inputs/grep1.dat:  printf ("can_be_null: %d\t", bufp->can_be_null);
../inputs/grep1.dat:  printf ("newline_anchor: %d\n", bufp->newline_anchor);
../inputs/grep1.dat:  printf ("no_sub: %d\t", bufp->no_sub);
../inputs/grep1.dat:  printf ("not_bol: %d\t", bufp->not_bol);
../inputs/grep1.dat:  printf ("not_eol: %d\t", bufp->not_eol);
../inputs/grep1.dat:  printf ("syntax: %d\n", bufp->syntax);
../inputs/grep1.dat:  /* Perhaps we should print the translate table?  */
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:void
../inputs/grep1.dat:print_double_string (where, string1, size1, string2, size2)
../inputs/grep1.dat:    const char *where;
../inputs/grep1.dat:    const char *string1;
../inputs/grep1.dat:    const char *string2;
../inputs/grep1.dat:    int size1;
../inputs/grep1.dat:    int size2;
../inputs/grep1.dat:{
../inputs/grep1.dat:  unsigned this_char;
../inputs/grep1.dat:  
../inputs/grep1.dat:  if (where == NULL)
../inputs/grep1.dat:    printf ("(null)");
../inputs/grep1.dat:  else
../inputs/grep1.dat:    {
../inputs/grep1.dat:      if (FIRST_STRING_P (where))
../inputs/grep1.dat:        {
../inputs/grep1.dat:          for (this_char = where - string1; this_char < size1; this_char++)
../inputs/grep1.dat:            printchar (string1[this_char]);
../inputs/grep1.dat:
../inputs/grep1.dat:          where = string2;    
../inputs/grep1.dat:        }
../inputs/grep1.dat:
../inputs/grep1.dat:      for (this_char = where - string2; this_char < size2; this_char++)
../inputs/grep1.dat:        printchar (string2[this_char]);
../inputs/grep1.dat:    }
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:#else /* not DEBUG */
../inputs/grep1.dat:
../inputs/grep1.dat:#undef assert
../inputs/grep1.dat:#define assert(e)
../inputs/grep1.dat:
../inputs/grep1.dat:#define DEBUG_STATEMENT(e)
../inputs/grep1.dat:#define DEBUG_PRINT1(x)
../inputs/grep1.dat:#define DEBUG_PRINT2(x1, x2)
../inputs/grep1.dat:#define DEBUG_PRINT3(x1, x2, x3)
../inputs/grep1.dat:#define DEBUG_PRINT4(x1, x2, x3, x4)
../inputs/grep1.dat:#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e)
../inputs/grep1.dat:#define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)
../inputs/grep1.dat:
../inputs/grep1.dat:#endif /* not DEBUG */
../inputs/grep1.dat:
../inputs/grep1.dat:/* Set by `re_set_syntax' to the current regexp syntax to recognize.  Can
../inputs/grep1.dat:   also be assigned to arbitrarily: each pattern buffer stores its own
../inputs/grep1.dat:   syntax, so it can be changed between regex compilations.  */
../inputs/grep1.dat:reg_syntax_t re_syntax_options = RE_SYNTAX_EMACS;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Specify the precise syntax of regexps for compilation.  This provides
../inputs/grep1.dat:   for compatibility for various utilities which historically have
../inputs/grep1.dat:   different, incompatible syntaxes.
../inputs/grep1.dat:
../inputs/grep1.dat:   The argument SYNTAX is a bit mask comprised of the various bits
../inputs/grep1.dat:   defined in regex.h.  We return the old syntax.  */
../inputs/grep1.dat:
../inputs/grep1.dat:reg_syntax_t
../inputs/grep1.dat:re_set_syntax (syntax)
../inputs/grep1.dat:    reg_syntax_t syntax;
../inputs/grep1.dat:{
../inputs/grep1.dat:  reg_syntax_t ret = re_syntax_options;
../inputs/grep1.dat:  
../inputs/grep1.dat:  re_syntax_options = syntax;
../inputs/grep1.dat:  return ret;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* This table gives an error message for each of the error codes listed
../inputs/grep1.dat:   in regex.h.  Obviously the order here has to be same as there.  */
../inputs/grep1.dat:
../inputs/grep1.dat:static const char *re_error_msg[] =
../inputs/grep1.dat:  { NULL,					/* REG_NOERROR */
../inputs/grep1.dat:    "No match",					/* REG_NOMATCH */
../inputs/grep1.dat:    "Invalid regular expression",		/* REG_BADPAT */
../inputs/grep1.dat:    "Invalid collation character",		/* REG_ECOLLATE */
../inputs/grep1.dat:    "Invalid character class name",		/* REG_ECTYPE */
../inputs/grep1.dat:    "Trailing backslash",			/* REG_EESCAPE */
../inputs/grep1.dat:    "Invalid back reference",			/* REG_ESUBREG */
../inputs/grep1.dat:    "Unmatched [ or [^",			/* REG_EBRACK */
../inputs/grep1.dat:    "Unmatched ( or \\(",			/* REG_EPAREN */
../inputs/grep1.dat:    "Unmatched \\{",				/* REG_EBRACE */
../inputs/grep1.dat:    "Invalid content of \\{\\}",		/* REG_BADBR */
../inputs/grep1.dat:    "Invalid range end",			/* REG_ERANGE */
../inputs/grep1.dat:    "Memory exhausted",				/* REG_ESPACE */
../inputs/grep1.dat:    "Invalid preceding regular expression",	/* REG_BADRPT */
../inputs/grep1.dat:    "Premature end of regular expression",	/* REG_EEND */
../inputs/grep1.dat:    "Regular expression too big",		/* REG_ESIZE */
../inputs/grep1.dat:    "Unmatched ) or \\)",			/* REG_ERPAREN */
../inputs/grep1.dat:  };
../inputs/grep1.dat:
../inputs/grep1.dat:/* Subroutine declarations and macros for regex_compile.  */
../inputs/grep1.dat:
../inputs/grep1.dat:static void store_op1 (), store_op2 ();
../inputs/grep1.dat:static void insert_op1 (), insert_op2 ();
../inputs/grep1.dat:static boolean at_begline_loc_p (), at_endline_loc_p ();
../inputs/grep1.dat:static boolean group_in_compile_stack ();
../inputs/grep1.dat:static reg_errcode_t compile_range ();
../inputs/grep1.dat:
../inputs/grep1.dat:/* Fetch the next character in the uncompiled pattern---translating it 
../inputs/grep1.dat:   if necessary.  Also cast from a signed character in the constant
../inputs/grep1.dat:   string passed to us by the user to an unsigned char that we can use
../inputs/grep1.dat:   as an array index (in, e.g., `translate').  */
../inputs/grep1.dat:#define PATFETCH(c)							\
../inputs/grep1.dat:  do {if (p == pend) return REG_EEND;					\
../inputs/grep1.dat:    c = (unsigned char) *p++;						\
../inputs/grep1.dat:    if (translate) c = translate[c]; 					\
../inputs/grep1.dat:  } while (0)
../inputs/grep1.dat:
../inputs/grep1.dat:/* Fetch the next character in the uncompiled pattern, with no
../inputs/grep1.dat:   translation.  */
../inputs/grep1.dat:#define PATFETCH_RAW(c)							\
../inputs/grep1.dat:  do {if (p == pend) return REG_EEND;					\
../inputs/grep1.dat:    c = (unsigned char) *p++; 						\
../inputs/grep1.dat:  } while (0)
../inputs/grep1.dat:
../inputs/grep1.dat:/* Go backwards one character in the pattern.  */
../inputs/grep1.dat:#define PATUNFETCH p--
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* If `translate' is non-null, return translate[D], else just D.  We
../inputs/grep1.dat:   cast the subscript to translate because some data is declared as
../inputs/grep1.dat:   `char *', to avoid warnings when a string constant is passed.  But
../inputs/grep1.dat:   when we use a character as a subscript we must make it unsigned.  */
../inputs/grep1.dat:#define TRANSLATE(d) (translate ? translate[(unsigned char) (d)] : (d))
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Macros for outputting the compiled pattern into `buffer'.  */
../inputs/grep1.dat:
../inputs/grep1.dat:/* If the buffer isn't allocated when it comes in, use this.  */
../inputs/grep1.dat:#define INIT_BUF_SIZE  32
../inputs/grep1.dat:
../inputs/grep1.dat:/* Make sure we have at least N more bytes of space in buffer.  */
../inputs/grep1.dat:#define GET_BUFFER_SPACE(n)						\
../inputs/grep1.dat:    while (b - bufp->buffer + (n) > bufp->allocated)			\
../inputs/grep1.dat:      EXTEND_BUFFER ()
../inputs/grep1.dat:
../inputs/grep1.dat:/* Make sure we have one more byte of buffer space and then add C to it.  */
../inputs/grep1.dat:#define BUF_PUSH(c)							\
../inputs/grep1.dat:  do {									\
../inputs/grep1.dat:    GET_BUFFER_SPACE (1);						\
../inputs/grep1.dat:    *b++ = (unsigned char) (c);						\
../inputs/grep1.dat:  } while (0)
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Ensure we have two more bytes of buffer space and then append C1 and C2.  */
../inputs/grep1.dat:#define BUF_PUSH_2(c1, c2)						\
../inputs/grep1.dat:  do {									\
../inputs/grep1.dat:    GET_BUFFER_SPACE (2);						\
../inputs/grep1.dat:    *b++ = (unsigned char) (c1);					\
../inputs/grep1.dat:    *b++ = (unsigned char) (c2);					\
../inputs/grep1.dat:  } while (0)
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* As with BUF_PUSH_2, except for three bytes.  */
../inputs/grep1.dat:#define BUF_PUSH_3(c1, c2, c3)						\
../inputs/grep1.dat:  do {									\
../inputs/grep1.dat:    GET_BUFFER_SPACE (3);						\
../inputs/grep1.dat:    *b++ = (unsigned char) (c1);					\
../inputs/grep1.dat:    *b++ = (unsigned char) (c2);					\
../inputs/grep1.dat:    *b++ = (unsigned char) (c3);					\
../inputs/grep1.dat:  } while (0)
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Store a jump with opcode OP at LOC to location TO.  We store a
../inputs/grep1.dat:   relative address offset by the three bytes the jump itself occupies.  */
../inputs/grep1.dat:#define STORE_JUMP(op, loc, to) \
../inputs/grep1.dat:  store_op1 (op, loc, (to) - (loc) - 3)
../inputs/grep1.dat:
../inputs/grep1.dat:/* Likewise, for a two-argument jump.  */
../inputs/grep1.dat:#define STORE_JUMP2(op, loc, to, arg) \
../inputs/grep1.dat:  store_op2 (op, loc, (to) - (loc) - 3, arg)
../inputs/grep1.dat:
../inputs/grep1.dat:/* Like `STORE_JUMP', but for inserting.  Assume `b' is the buffer end.  */
../inputs/grep1.dat:#define INSERT_JUMP(op, loc, to) \
../inputs/grep1.dat:  insert_op1 (op, loc, (to) - (loc) - 3, b)
../inputs/grep1.dat:
../inputs/grep1.dat:/* Like `STORE_JUMP2', but for inserting.  Assume `b' is the buffer end.  */
../inputs/grep1.dat:#define INSERT_JUMP2(op, loc, to, arg) \
../inputs/grep1.dat:  insert_op2 (op, loc, (to) - (loc) - 3, arg, b)
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* This is not an arbitrary limit: the arguments which represent offsets
../inputs/grep1.dat:   into the pattern are two bytes long.  So if 2^16 bytes turns out to
../inputs/grep1.dat:   be too small, many things would have to change.  */
../inputs/grep1.dat:#define MAX_BUF_SIZE (1L << 16)
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Extend the buffer by twice its current size via realloc and
../inputs/grep1.dat:   reset the pointers that pointed into the old block to point to the
../inputs/grep1.dat:   correct places in the new one.  If extending the buffer results in it
../inputs/grep1.dat:   being larger than MAX_BUF_SIZE, then flag memory exhausted.  */
../inputs/grep1.dat:#define EXTEND_BUFFER()							\
../inputs/grep1.dat:  do { 									\
../inputs/grep1.dat:    unsigned char *old_buffer = bufp->buffer;				\
../inputs/grep1.dat:    if (bufp->allocated == MAX_BUF_SIZE) 				\
../inputs/grep1.dat:      return REG_ESIZE;							\
../inputs/grep1.dat:    bufp->allocated <<= 1;						\
../inputs/grep1.dat:    if (bufp->allocated > MAX_BUF_SIZE)					\
../inputs/grep1.dat:      bufp->allocated = MAX_BUF_SIZE; 					\
../inputs/grep1.dat:    bufp->buffer = (unsigned char *) realloc (bufp->buffer, bufp->allocated);\
../inputs/grep1.dat:    if (bufp->buffer == NULL)						\
../inputs/grep1.dat:      return REG_ESPACE;						\
../inputs/grep1.dat:    /* If the buffer moved, move all the pointers into it.  */		\
../inputs/grep1.dat:    if (old_buffer != bufp->buffer)					\
../inputs/grep1.dat:      {									\
../inputs/grep1.dat:        b = (b - old_buffer) + bufp->buffer;				\
../inputs/grep1.dat:        begalt = (begalt - old_buffer) + bufp->buffer;			\
../inputs/grep1.dat:        if (fixup_alt_jump)						\
../inputs/grep1.dat:          fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;\
../inputs/grep1.dat:        if (laststart)							\
../inputs/grep1.dat:          laststart = (laststart - old_buffer) + bufp->buffer;		\
../inputs/grep1.dat:        if (pending_exact)						\
../inputs/grep1.dat:          pending_exact = (pending_exact - old_buffer) + bufp->buffer;	\
../inputs/grep1.dat:      }									\
../inputs/grep1.dat:  } while (0)
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Since we have one byte reserved for the register number argument to
../inputs/grep1.dat:   {start,stop}_memory, the maximum number of groups we can report
../inputs/grep1.dat:   things about is what fits in that byte.  */
../inputs/grep1.dat:#define MAX_REGNUM 255
../inputs/grep1.dat:
../inputs/grep1.dat:/* But patterns can have more than `MAX_REGNUM' registers.  We just
../inputs/grep1.dat:   ignore the excess.  */
../inputs/grep1.dat:typedef unsigned regnum_t;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Macros for the compile stack.  */
../inputs/grep1.dat:
../inputs/grep1.dat:/* Since offsets can go either forwards or backwards, this type needs to
../inputs/grep1.dat:   be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
../inputs/grep1.dat:typedef int pattern_offset_t;
../inputs/grep1.dat:
../inputs/grep1.dat:typedef struct
../inputs/grep1.dat:{
../inputs/grep1.dat:  pattern_offset_t begalt_offset;
../inputs/grep1.dat:  pattern_offset_t fixup_alt_jump;
../inputs/grep1.dat:  pattern_offset_t inner_group_offset;
../inputs/grep1.dat:  pattern_offset_t laststart_offset;  
../inputs/grep1.dat:  regnum_t regnum;
../inputs/grep1.dat:} compile_stack_elt_t;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:typedef struct
../inputs/grep1.dat:{
../inputs/grep1.dat:  compile_stack_elt_t *stack;
../inputs/grep1.dat:  unsigned size;
../inputs/grep1.dat:  unsigned avail;			/* Offset of next open position.  */
../inputs/grep1.dat:} compile_stack_type;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:#define INIT_COMPILE_STACK_SIZE 32
../inputs/grep1.dat:
../inputs/grep1.dat:#define COMPILE_STACK_EMPTY  (compile_stack.avail == 0)
../inputs/grep1.dat:#define COMPILE_STACK_FULL  (compile_stack.avail == compile_stack.size)
../inputs/grep1.dat:
../inputs/grep1.dat:/* The next available element.  */
../inputs/grep1.dat:#define COMPILE_STACK_TOP (compile_stack.stack[compile_stack.avail])
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Set the bit for character C in a list.  */
../inputs/grep1.dat:#define SET_LIST_BIT(c)                               \
../inputs/grep1.dat:  (b[((unsigned char) (c)) / BYTEWIDTH]               \
../inputs/grep1.dat:   |= 1 << (((unsigned char) c) % BYTEWIDTH))
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Get the next unsigned number in the uncompiled pattern.  */
../inputs/grep1.dat:#define GET_UNSIGNED_NUMBER(num) 					\
../inputs/grep1.dat:  { if (p != pend)							\
../inputs/grep1.dat:     {									\
../inputs/grep1.dat:       PATFETCH (c); 							\
../inputs/grep1.dat:       while (ISDIGIT (c)) 						\
../inputs/grep1.dat:         { 								\
../inputs/grep1.dat:           if (num < 0)							\
../inputs/grep1.dat:              num = 0;							\
../inputs/grep1.dat:           num = num * 10 + c - '0'; 					\
../inputs/grep1.dat:           if (p == pend) 						\
../inputs/grep1.dat:              break; 							\
../inputs/grep1.dat:           PATFETCH (c);						\
../inputs/grep1.dat:         } 								\
../inputs/grep1.dat:       } 								\
../inputs/grep1.dat:    }		
../inputs/grep1.dat:
../inputs/grep1.dat:#define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */
../inputs/grep1.dat:
../inputs/grep1.dat:#define IS_CHAR_CLASS(string)						\
../inputs/grep1.dat:   (STREQ (string, "alpha") || STREQ (string, "upper")			\
../inputs/grep1.dat:    || STREQ (string, "lower") || STREQ (string, "digit")		\
../inputs/grep1.dat:    || STREQ (string, "alnum") || STREQ (string, "xdigit")		\
../inputs/grep1.dat:    || STREQ (string, "space") || STREQ (string, "print")		\
../inputs/grep1.dat:    || STREQ (string, "punct") || STREQ (string, "graph")		\
../inputs/grep1.dat:    || STREQ (string, "cntrl") || STREQ (string, "blank"))
../inputs/grep1.dat:
../inputs/grep1.dat:/* `regex_compile' compiles PATTERN (of length SIZE) according to SYNTAX.
../inputs/grep1.dat:   Returns one of error codes defined in `regex.h', or zero for success.
../inputs/grep1.dat:
../inputs/grep1.dat:   Assumes the `allocated' (and perhaps `buffer') and `translate'
../inputs/grep1.dat:   fields are set in BUFP on entry.
../inputs/grep1.dat:
../inputs/grep1.dat:   If it succeeds, results are put in BUFP (if it returns an error, the
../inputs/grep1.dat:   contents of BUFP are undefined):
../inputs/grep1.dat:     `buffer' is the compiled pattern;
../inputs/grep1.dat:     `syntax' is set to SYNTAX;
../inputs/grep1.dat:     `used' is set to the length of the compiled pattern;
../inputs/grep1.dat:     `fastmap_accurate' is zero;
../inputs/grep1.dat:     `re_nsub' is the number of subexpressions in PATTERN;
../inputs/grep1.dat:     `not_bol' and `not_eol' are zero;
../inputs/grep1.dat:   
../inputs/grep1.dat:   The `fastmap' and `newline_anchor' fields are neither
../inputs/grep1.dat:   examined nor set.  */
../inputs/grep1.dat:
../inputs/grep1.dat:static reg_errcode_t
../inputs/grep1.dat:regex_compile (pattern, size, syntax, bufp)
../inputs/grep1.dat:     const char *pattern;
../inputs/grep1.dat:     int size;
../inputs/grep1.dat:     reg_syntax_t syntax;
../inputs/grep1.dat:     struct re_pattern_buffer *bufp;
../inputs/grep1.dat:{
../inputs/grep1.dat:  /* We fetch characters from PATTERN here.  Even though PATTERN is
../inputs/grep1.dat:     `char *' (i.e., signed), we declare these variables as unsigned, so
../inputs/grep1.dat:     they can be reliably used as array indices.  */
../inputs/grep1.dat:  register unsigned char c, c1;
../inputs/grep1.dat:  
../inputs/grep1.dat:  /* A random tempory spot in PATTERN.  */
../inputs/grep1.dat:  const char *p1;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Points to the end of the buffer, where we should append.  */
../inputs/grep1.dat:  register unsigned char *b;
../inputs/grep1.dat:  
../inputs/grep1.dat:  /* Keeps track of unclosed groups.  */
../inputs/grep1.dat:  compile_stack_type compile_stack;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Points to the current (ending) position in the pattern.  */
../inputs/grep1.dat:  const char *p = pattern;
../inputs/grep1.dat:  const char *pend = pattern + size;
../inputs/grep1.dat:  
../inputs/grep1.dat:  /* How to translate the characters in the pattern.  */
../inputs/grep1.dat:  char *translate = bufp->translate;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Address of the count-byte of the most recently inserted `exactn'
../inputs/grep1.dat:     command.  This makes it possible to tell if a new exact-match
../inputs/grep1.dat:     character can be added to that command or if the character requires
../inputs/grep1.dat:     a new `exactn' command.  */
../inputs/grep1.dat:  unsigned char *pending_exact = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Address of start of the most recently finished expression.
../inputs/grep1.dat:     This tells, e.g., postfix * where to find the start of its
../inputs/grep1.dat:     operand.  Reset at the beginning of groups and alternatives.  */
../inputs/grep1.dat:  unsigned char *laststart = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Address of beginning of regexp, or inside of last group.  */
../inputs/grep1.dat:  unsigned char *begalt;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Place in the uncompiled pattern (i.e., the {) to
../inputs/grep1.dat:     which to go back if the interval is invalid.  */
../inputs/grep1.dat:  const char *beg_interval;
../inputs/grep1.dat:                
../inputs/grep1.dat:  /* Address of the place where a forward jump should go to the end of
../inputs/grep1.dat:     the containing expression.  Each alternative of an `or' -- except the
../inputs/grep1.dat:     last -- ends with a forward jump of this sort.  */
../inputs/grep1.dat:  unsigned char *fixup_alt_jump = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Counts open-groups as they are encountered.  Remembered for the
../inputs/grep1.dat:     matching close-group on the compile stack, so the same register
../inputs/grep1.dat:     number is put in the stop_memory as the start_memory.  */
../inputs/grep1.dat:  regnum_t regnum = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef DEBUG
../inputs/grep1.dat:  DEBUG_PRINT1 ("\nCompiling pattern: ");
../inputs/grep1.dat:  if (debug)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      unsigned debug_count;
../inputs/grep1.dat:      
../inputs/grep1.dat:      for (debug_count = 0; debug_count < size; debug_count++)
../inputs/grep1.dat:        printchar (pattern[debug_count]);
../inputs/grep1.dat:      putchar ('\n');
../inputs/grep1.dat:    }
../inputs/grep1.dat:#endif /* DEBUG */
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Initialize the compile stack.  */
../inputs/grep1.dat:  compile_stack.stack = TALLOC (INIT_COMPILE_STACK_SIZE, compile_stack_elt_t);
../inputs/grep1.dat:  if (compile_stack.stack == NULL)
../inputs/grep1.dat:    return REG_ESPACE;
../inputs/grep1.dat:
../inputs/grep1.dat:  compile_stack.size = INIT_COMPILE_STACK_SIZE;
../inputs/grep1.dat:  compile_stack.avail = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Initialize the pattern buffer.  */
../inputs/grep1.dat:  bufp->syntax = syntax;
../inputs/grep1.dat:  bufp->fastmap_accurate = 0;
../inputs/grep1.dat:  bufp->not_bol = bufp->not_eol = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Set `used' to zero, so that if we return an error, the pattern
../inputs/grep1.dat:     printer (for debugging) will think there's no pattern.  We reset it
../inputs/grep1.dat:     at the end.  */
../inputs/grep1.dat:  bufp->used = 0;
../inputs/grep1.dat:  
../inputs/grep1.dat:  /* Always count groups, whether or not bufp->no_sub is set.  */
../inputs/grep1.dat:  bufp->re_nsub = 0;				
../inputs/grep1.dat:
../inputs/grep1.dat:#if !defined (emacs) && !defined (SYNTAX_TABLE)
../inputs/grep1.dat:  /* Initialize the syntax table.  */
../inputs/grep1.dat:   init_syntax_once ();
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:  if (bufp->allocated == 0)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      if (bufp->buffer)
../inputs/grep1.dat:	{ /* If zero allocated, but buffer is non-null, try to realloc
../inputs/grep1.dat:             enough space.  This loses if buffer's address is bogus, but
../inputs/grep1.dat:             that is the user's responsibility.  */
../inputs/grep1.dat:          RETALLOC (bufp->buffer, INIT_BUF_SIZE, unsigned char);
../inputs/grep1.dat:        }
../inputs/grep1.dat:      else
../inputs/grep1.dat:        { /* Caller did not allocate a buffer.  Do it for them.  */
../inputs/grep1.dat:          bufp->buffer = TALLOC (INIT_BUF_SIZE, unsigned char);
../inputs/grep1.dat:        }
../inputs/grep1.dat:      if (!bufp->buffer) return REG_ESPACE;
../inputs/grep1.dat:
../inputs/grep1.dat:      bufp->allocated = INIT_BUF_SIZE;
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  begalt = b = bufp->buffer;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Loop through the uncompiled pattern until we're at the end.  */
../inputs/grep1.dat:  while (p != pend)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      PATFETCH (c);
../inputs/grep1.dat:
../inputs/grep1.dat:      switch (c)
../inputs/grep1.dat:        {
../inputs/grep1.dat:        case '^':
../inputs/grep1.dat:          {
../inputs/grep1.dat:            if (   /* If at start of pattern, it's an operator.  */
../inputs/grep1.dat:                   p == pattern + 1
../inputs/grep1.dat:                   /* If context independent, it's an operator.  */
../inputs/grep1.dat:                || syntax & RE_CONTEXT_INDEP_ANCHORS
../inputs/grep1.dat:                   /* Otherwise, depends on what's come before.  */
../inputs/grep1.dat:                || at_begline_loc_p (pattern, p, syntax))
../inputs/grep1.dat:              BUF_PUSH (begline);
../inputs/grep1.dat:            else
../inputs/grep1.dat:              goto normal_char;
../inputs/grep1.dat:          }
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:        case '$':
../inputs/grep1.dat:          {
../inputs/grep1.dat:            if (   /* If at end of pattern, it's an operator.  */
../inputs/grep1.dat:                   p == pend 
../inputs/grep1.dat:                   /* If context independent, it's an operator.  */
../inputs/grep1.dat:                || syntax & RE_CONTEXT_INDEP_ANCHORS
../inputs/grep1.dat:                   /* Otherwise, depends on what's next.  */
../inputs/grep1.dat:                || at_endline_loc_p (p, pend, syntax))
../inputs/grep1.dat:               BUF_PUSH (endline);
../inputs/grep1.dat:             else
../inputs/grep1.dat:               goto normal_char;
../inputs/grep1.dat:           }
../inputs/grep1.dat:           break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:	case '+':
../inputs/grep1.dat:        case '?':
../inputs/grep1.dat:          if ((syntax & RE_BK_PLUS_QM)
../inputs/grep1.dat:              || (syntax & RE_LIMITED_OPS))
../inputs/grep1.dat:            goto normal_char;
../inputs/grep1.dat:        handle_plus:
../inputs/grep1.dat:        case '*':
../inputs/grep1.dat:          /* If there is no previous pattern... */
../inputs/grep1.dat:          if (!laststart)
../inputs/grep1.dat:            {
../inputs/grep1.dat:              if (syntax & RE_CONTEXT_INVALID_OPS)
../inputs/grep1.dat:                return REG_BADRPT;
../inputs/grep1.dat:              else if (!(syntax & RE_CONTEXT_INDEP_OPS))
../inputs/grep1.dat:                goto normal_char;
../inputs/grep1.dat:            }
../inputs/grep1.dat:
../inputs/grep1.dat:          {
../inputs/grep1.dat:            /* Are we optimizing this jump?  */
../inputs/grep1.dat:            boolean keep_string_p = false;
../inputs/grep1.dat:            
../inputs/grep1.dat:            /* 1 means zero (many) matches is allowed.  */
../inputs/grep1.dat:            char zero_times_ok = 0, many_times_ok = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:            /* If there is a sequence of repetition chars, collapse it
../inputs/grep1.dat:               down to just one (the right one).  We can't combine
../inputs/grep1.dat:               interval operators with these because of, e.g., `a{2}*',
../inputs/grep1.dat:               which should only match an even number of `a's.  */
../inputs/grep1.dat:
../inputs/grep1.dat:            for (;;)
../inputs/grep1.dat:              {
../inputs/grep1.dat:                zero_times_ok |= c != '+';
../inputs/grep1.dat:                many_times_ok |= c != '?';
../inputs/grep1.dat:
../inputs/grep1.dat:                if (p == pend)
../inputs/grep1.dat:                  break;
../inputs/grep1.dat:
../inputs/grep1.dat:                PATFETCH (c);
../inputs/grep1.dat:
../inputs/grep1.dat:                if (c == '*'
../inputs/grep1.dat:                    || (!(syntax & RE_BK_PLUS_QM) && (c == '+' || c == '?')))
../inputs/grep1.dat:                  ;
../inputs/grep1.dat:
../inputs/grep1.dat:                else if (syntax & RE_BK_PLUS_QM  &&  c == '\\')
../inputs/grep1.dat:                  {
../inputs/grep1.dat:                    if (p == pend) return REG_EESCAPE;
../inputs/grep1.dat:
../inputs/grep1.dat:                    PATFETCH (c1);
../inputs/grep1.dat:                    if (!(c1 == '+' || c1 == '?'))
../inputs/grep1.dat:                      {
../inputs/grep1.dat:                        PATUNFETCH;
../inputs/grep1.dat:                        PATUNFETCH;
../inputs/grep1.dat:                        break;
../inputs/grep1.dat:                      }
../inputs/grep1.dat:
../inputs/grep1.dat:                    c = c1;
../inputs/grep1.dat:                  }
../inputs/grep1.dat:                else
../inputs/grep1.dat:                  {
../inputs/grep1.dat:                    PATUNFETCH;
../inputs/grep1.dat:                    break;
../inputs/grep1.dat:                  }
../inputs/grep1.dat:
../inputs/grep1.dat:                /* If we get here, we found another repeat character.  */
../inputs/grep1.dat:               }
../inputs/grep1.dat:
../inputs/grep1.dat:            /* Star, etc. applied to an empty pattern is equivalent
../inputs/grep1.dat:               to an empty pattern.  */
../inputs/grep1.dat:            if (!laststart)  
../inputs/grep1.dat:              break;
../inputs/grep1.dat:
../inputs/grep1.dat:            /* Now we know whether or not zero matches is allowed
../inputs/grep1.dat:               and also whether or not two or more matches is allowed.  */
../inputs/grep1.dat:            if (many_times_ok)
../inputs/grep1.dat:              { /* More than one repetition is allowed, so put in at the
../inputs/grep1.dat:                   end a backward relative jump from `b' to before the next
../inputs/grep1.dat:                   jump we're going to put in below (which jumps from
../inputs/grep1.dat:                   laststart to after this jump).  
../inputs/grep1.dat:
../inputs/grep1.dat:                   But if we are at the `*' in the exact sequence `.*\n',
../inputs/grep1.dat:                   insert an unconditional jump backwards to the .,
../inputs/grep1.dat:                   instead of the beginning of the loop.  This way we only
../inputs/grep1.dat:                   push a failure point once, instead of every time
../inputs/grep1.dat:                   through the loop.  */
../inputs/grep1.dat:                assert (p - 1 > pattern);
../inputs/grep1.dat:
../inputs/grep1.dat:                /* Allocate the space for the jump.  */
../inputs/grep1.dat:                GET_BUFFER_SPACE (3);
../inputs/grep1.dat:
../inputs/grep1.dat:                /* We know we are not at the first character of the pattern,
../inputs/grep1.dat:                   because laststart was nonzero.  And we've already
../inputs/grep1.dat:                   incremented `p', by the way, to be the character after
../inputs/grep1.dat:                   the `*'.  Do we have to do something analogous here
../inputs/grep1.dat:                   for null bytes, because of RE_DOT_NOT_NULL?  */
../inputs/grep1.dat:                if (TRANSLATE (*(p - 2)) == TRANSLATE ('.')
../inputs/grep1.dat:		    && zero_times_ok
../inputs/grep1.dat:                    && p < pend && TRANSLATE (*p) == TRANSLATE ('\n')
../inputs/grep1.dat:                    && !(syntax & RE_DOT_NEWLINE))
../inputs/grep1.dat:                  { /* We have .*\n.  */
../inputs/grep1.dat:                    STORE_JUMP (jump, b, laststart);
../inputs/grep1.dat:                    keep_string_p = true;
../inputs/grep1.dat:                  }
../inputs/grep1.dat:                else
../inputs/grep1.dat:                  /* Anything else.  */
../inputs/grep1.dat:                  STORE_JUMP (maybe_pop_jump, b, laststart - 3);
../inputs/grep1.dat:
../inputs/grep1.dat:                /* We've added more stuff to the buffer.  */
../inputs/grep1.dat:                b += 3;
../inputs/grep1.dat:              }
../inputs/grep1.dat:
../inputs/grep1.dat:            /* On failure, jump from laststart to b + 3, which will be the
../inputs/grep1.dat:               end of the buffer after this jump is inserted.  */
../inputs/grep1.dat:            GET_BUFFER_SPACE (3);
../inputs/grep1.dat:            INSERT_JUMP (keep_string_p ? on_failure_keep_string_jump
../inputs/grep1.dat:                                       : on_failure_jump,
../inputs/grep1.dat:                         laststart, b + 3);
../inputs/grep1.dat:            pending_exact = 0;
../inputs/grep1.dat:            b += 3;
../inputs/grep1.dat:
../inputs/grep1.dat:            if (!zero_times_ok)
../inputs/grep1.dat:              {
../inputs/grep1.dat:                /* At least one repetition is required, so insert a
../inputs/grep1.dat:                   `dummy_failure_jump' before the initial
../inputs/grep1.dat:                   `on_failure_jump' instruction of the loop. This
../inputs/grep1.dat:                   effects a skip over that instruction the first time
../inputs/grep1.dat:                   we hit that loop.  */
../inputs/grep1.dat:                GET_BUFFER_SPACE (3);
../inputs/grep1.dat:                INSERT_JUMP (dummy_failure_jump, laststart, laststart + 6);
../inputs/grep1.dat:                b += 3;
../inputs/grep1.dat:              }
../inputs/grep1.dat:            }
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:	case '.':
../inputs/grep1.dat:          laststart = b;
../inputs/grep1.dat:          BUF_PUSH (anychar);
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:        case '[':
../inputs/grep1.dat:          {
../inputs/grep1.dat:            boolean had_char_class = false;
../inputs/grep1.dat:
../inputs/grep1.dat:            if (p == pend) return REG_EBRACK;
../inputs/grep1.dat:
../inputs/grep1.dat:            /* Ensure that we have enough space to push a charset: the
../inputs/grep1.dat:               opcode, the length count, and the bitset; 34 bytes in all.  */
../inputs/grep1.dat:	    GET_BUFFER_SPACE (34);
../inputs/grep1.dat:
../inputs/grep1.dat:            laststart = b;
../inputs/grep1.dat:
../inputs/grep1.dat:            /* We test `*p == '^' twice, instead of using an if
../inputs/grep1.dat:               statement, so we only need one BUF_PUSH.  */
../inputs/grep1.dat:            BUF_PUSH (*p == '^' ? charset_not : charset); 
../inputs/grep1.dat:            if (*p == '^')
../inputs/grep1.dat:              p++;
../inputs/grep1.dat:
../inputs/grep1.dat:            /* Remember the first position in the bracket expression.  */
../inputs/grep1.dat:            p1 = p;
../inputs/grep1.dat:
../inputs/grep1.dat:            /* Push the number of bytes in the bitmap.  */
../inputs/grep1.dat:            BUF_PUSH ((1 << BYTEWIDTH) / BYTEWIDTH);
../inputs/grep1.dat:
../inputs/grep1.dat:            /* Clear the whole map.  */
../inputs/grep1.dat:            bzero (b, (1 << BYTEWIDTH) / BYTEWIDTH);
../inputs/grep1.dat:
../inputs/grep1.dat:            /* charset_not matches newline according to a syntax bit.  */
../inputs/grep1.dat:            if ((re_opcode_t) b[-2] == charset_not
../inputs/grep1.dat:                && (syntax & RE_HAT_LISTS_NOT_NEWLINE))
../inputs/grep1.dat:              SET_LIST_BIT ('\n');
../inputs/grep1.dat:
../inputs/grep1.dat:            /* Read in characters and ranges, setting map bits.  */
../inputs/grep1.dat:            for (;;)
../inputs/grep1.dat:              {
../inputs/grep1.dat:                if (p == pend) return REG_EBRACK;
../inputs/grep1.dat:
../inputs/grep1.dat:                PATFETCH (c);
../inputs/grep1.dat:
../inputs/grep1.dat:                /* \ might escape characters inside [...] and [^...].  */
../inputs/grep1.dat:                if ((syntax & RE_BACKSLASH_ESCAPE_IN_LISTS) && c == '\\')
../inputs/grep1.dat:                  {
../inputs/grep1.dat:                    if (p == pend) return REG_EESCAPE;
../inputs/grep1.dat:
../inputs/grep1.dat:                    PATFETCH (c1);
../inputs/grep1.dat:                    SET_LIST_BIT (c1);
../inputs/grep1.dat:                    continue;
../inputs/grep1.dat:                  }
../inputs/grep1.dat:
../inputs/grep1.dat:                /* Could be the end of the bracket expression.  If it's
../inputs/grep1.dat:                   not (i.e., when the bracket expression is `[]' so
../inputs/grep1.dat:                   far), the ']' character bit gets set way below.  */
../inputs/grep1.dat:                if (c == ']' && p != p1 + 1)
../inputs/grep1.dat:                  break;
../inputs/grep1.dat:
../inputs/grep1.dat:                /* Look ahead to see if it's a range when the last thing
../inputs/grep1.dat:                   was a character class.  */
../inputs/grep1.dat:                if (had_char_class && c == '-' && *p != ']')
../inputs/grep1.dat:                  return REG_ERANGE;
../inputs/grep1.dat:
../inputs/grep1.dat:                /* Look ahead to see if it's a range when the last thing
../inputs/grep1.dat:                   was a character: if this is a hyphen not at the
../inputs/grep1.dat:                   beginning or the end of a list, then it's the range
../inputs/grep1.dat:                   operator.  */
../inputs/grep1.dat:                if (c == '-' 
../inputs/grep1.dat:                    && !(p - 2 >= pattern && p[-2] == '[') 
../inputs/grep1.dat:                    && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^')
../inputs/grep1.dat:                    && *p != ']')
../inputs/grep1.dat:                  {
../inputs/grep1.dat:                    reg_errcode_t ret
../inputs/grep1.dat:                      = compile_range (&p, pend, translate, syntax, b);
../inputs/grep1.dat:                    if (ret != REG_NOERROR) return ret;
../inputs/grep1.dat:                  }
../inputs/grep1.dat:
../inputs/grep1.dat:                else if (p[0] == '-' && p[1] != ']')
../inputs/grep1.dat:                  { /* This handles ranges made up of characters only.  */
../inputs/grep1.dat:                    reg_errcode_t ret;
../inputs/grep1.dat:
../inputs/grep1.dat:		    /* Move past the `-'.  */
../inputs/grep1.dat:                    PATFETCH (c1);
../inputs/grep1.dat:                    
../inputs/grep1.dat:                    ret = compile_range (&p, pend, translate, syntax, b);
../inputs/grep1.dat:                    if (ret != REG_NOERROR) return ret;
../inputs/grep1.dat:                  }
../inputs/grep1.dat:
../inputs/grep1.dat:                /* See if we're at the beginning of a possible character
../inputs/grep1.dat:                   class.  */
../inputs/grep1.dat:
../inputs/grep1.dat:                else if (syntax & RE_CHAR_CLASSES && c == '[' && *p == ':')
../inputs/grep1.dat:                  { /* Leave room for the null.  */
../inputs/grep1.dat:                    char str[CHAR_CLASS_MAX_LENGTH + 1];
../inputs/grep1.dat:
../inputs/grep1.dat:                    PATFETCH (c);
../inputs/grep1.dat:                    c1 = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:                    /* If pattern is `[[:'.  */
../inputs/grep1.dat:                    if (p == pend) return REG_EBRACK;
../inputs/grep1.dat:
../inputs/grep1.dat:                    for (;;)
../inputs/grep1.dat:                      {
../inputs/grep1.dat:                        PATFETCH (c);
../inputs/grep1.dat:                        if (c == ':' || c == ']' || p == pend
../inputs/grep1.dat:                            || c1 == CHAR_CLASS_MAX_LENGTH)
../inputs/grep1.dat:                          break;
../inputs/grep1.dat:                        str[c1++] = c;
../inputs/grep1.dat:                      }
../inputs/grep1.dat:                    str[c1] = '\0';
../inputs/grep1.dat:
../inputs/grep1.dat:                    /* If isn't a word bracketed by `[:' and:`]':
../inputs/grep1.dat:                       undo the ending character, the letters, and leave 
../inputs/grep1.dat:                       the leading `:' and `[' (but set bits for them).  */
../inputs/grep1.dat:                    if (c == ':' && *p == ']')
../inputs/grep1.dat:                      {
../inputs/grep1.dat:                        int ch;
../inputs/grep1.dat:                        boolean is_alnum = STREQ (str, "alnum");
../inputs/grep1.dat:                        boolean is_alpha = STREQ (str, "alpha");
../inputs/grep1.dat:                        boolean is_blank = STREQ (str, "blank");
../inputs/grep1.dat:                        boolean is_cntrl = STREQ (str, "cntrl");
../inputs/grep1.dat:                        boolean is_digit = STREQ (str, "digit");
../inputs/grep1.dat:                        boolean is_graph = STREQ (str, "graph");
../inputs/grep1.dat:                        boolean is_lower = STREQ (str, "lower");
../inputs/grep1.dat:                        boolean is_print = STREQ (str, "print");
../inputs/grep1.dat:                        boolean is_punct = STREQ (str, "punct");
../inputs/grep1.dat:                        boolean is_space = STREQ (str, "space");
../inputs/grep1.dat:                        boolean is_upper = STREQ (str, "upper");
../inputs/grep1.dat:                        boolean is_xdigit = STREQ (str, "xdigit");
../inputs/grep1.dat:                        
../inputs/grep1.dat:                        if (!IS_CHAR_CLASS (str)) return REG_ECTYPE;
../inputs/grep1.dat:
../inputs/grep1.dat:                        /* Throw away the ] at the end of the character
../inputs/grep1.dat:                           class.  */
../inputs/grep1.dat:                        PATFETCH (c);					
../inputs/grep1.dat:
../inputs/grep1.dat:                        if (p == pend) return REG_EBRACK;
../inputs/grep1.dat:
../inputs/grep1.dat:                        for (ch = 0; ch < 1 << BYTEWIDTH; ch++)
../inputs/grep1.dat:                          {
../inputs/grep1.dat:                            if (   (is_alnum  && ISALNUM (ch))
../inputs/grep1.dat:                                || (is_alpha  && ISALPHA (ch))
../inputs/grep1.dat:                                || (is_blank  && ISBLANK (ch))
../inputs/grep1.dat:                                || (is_cntrl  && ISCNTRL (ch))
../inputs/grep1.dat:                                || (is_digit  && ISDIGIT (ch))
../inputs/grep1.dat:                                || (is_graph  && ISGRAPH (ch))
../inputs/grep1.dat:                                || (is_lower  && ISLOWER (ch))
../inputs/grep1.dat:                                || (is_print  && ISPRINT (ch))
../inputs/grep1.dat:                                || (is_punct  && ISPUNCT (ch))
../inputs/grep1.dat:                                || (is_space  && ISSPACE (ch))
../inputs/grep1.dat:                                || (is_upper  && ISUPPER (ch))
../inputs/grep1.dat:                                || (is_xdigit && ISXDIGIT (ch)))
../inputs/grep1.dat:                            SET_LIST_BIT (ch);
../inputs/grep1.dat:                          }
../inputs/grep1.dat:                        had_char_class = true;
../inputs/grep1.dat:                      }
../inputs/grep1.dat:                    else
../inputs/grep1.dat:                      {
../inputs/grep1.dat:                        c1++;
../inputs/grep1.dat:                        while (c1--)    
../inputs/grep1.dat:                          PATUNFETCH;
../inputs/grep1.dat:                        SET_LIST_BIT ('[');
../inputs/grep1.dat:                        SET_LIST_BIT (':');
../inputs/grep1.dat:                        had_char_class = false;
../inputs/grep1.dat:                      }
../inputs/grep1.dat:                  }
../inputs/grep1.dat:                else
../inputs/grep1.dat:                  {
../inputs/grep1.dat:                    had_char_class = false;
../inputs/grep1.dat:                    SET_LIST_BIT (c);
../inputs/grep1.dat:                  }
../inputs/grep1.dat:              }
../inputs/grep1.dat:
../inputs/grep1.dat:            /* Discard any (non)matching list bytes that are all 0 at the
../inputs/grep1.dat:               end of the map.  Decrease the map-length byte too.  */
../inputs/grep1.dat:            while ((int) b[-1] > 0 && b[b[-1] - 1] == 0) 
../inputs/grep1.dat:              b[-1]--; 
../inputs/grep1.dat:            b += b[-1];
../inputs/grep1.dat:          }
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:	case '(':
../inputs/grep1.dat:          if (syntax & RE_NO_BK_PARENS)
../inputs/grep1.dat:            goto handle_open;
../inputs/grep1.dat:          else
../inputs/grep1.dat:            goto normal_char;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:        case ')':
../inputs/grep1.dat:          if (syntax & RE_NO_BK_PARENS)
../inputs/grep1.dat:            goto handle_close;
../inputs/grep1.dat:          else
../inputs/grep1.dat:            goto normal_char;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:        case '\n':
../inputs/grep1.dat:          if (syntax & RE_NEWLINE_ALT)
../inputs/grep1.dat:            goto handle_alt;
../inputs/grep1.dat:          else
../inputs/grep1.dat:            goto normal_char;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:	case '|':
../inputs/grep1.dat:          if (syntax & RE_NO_BK_VBAR)
../inputs/grep1.dat:            goto handle_alt;
../inputs/grep1.dat:          else
../inputs/grep1.dat:            goto normal_char;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:        case '{':
../inputs/grep1.dat:           if (syntax & RE_INTERVALS && syntax & RE_NO_BK_BRACES)
../inputs/grep1.dat:             goto handle_interval;
../inputs/grep1.dat:           else
../inputs/grep1.dat:             goto normal_char;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:        case '\\':
../inputs/grep1.dat:          if (p == pend) return REG_EESCAPE;
../inputs/grep1.dat:
../inputs/grep1.dat:          /* Do not translate the character after the \, so that we can
../inputs/grep1.dat:             distinguish, e.g., \B from \b, even if we normally would
../inputs/grep1.dat:             translate, e.g., B to b.  */
../inputs/grep1.dat:          PATFETCH_RAW (c);
../inputs/grep1.dat:
../inputs/grep1.dat:          switch (c)
../inputs/grep1.dat:            {
../inputs/grep1.dat:            case '(':
../inputs/grep1.dat:              if (syntax & RE_NO_BK_PARENS)
../inputs/grep1.dat:                goto normal_backslash;
../inputs/grep1.dat:
../inputs/grep1.dat:            handle_open:
../inputs/grep1.dat:              bufp->re_nsub++;
../inputs/grep1.dat:              regnum++;
../inputs/grep1.dat:
../inputs/grep1.dat:              if (COMPILE_STACK_FULL)
../inputs/grep1.dat:                { 
../inputs/grep1.dat:                  RETALLOC (compile_stack.stack, compile_stack.size << 1,
../inputs/grep1.dat:                            compile_stack_elt_t);
../inputs/grep1.dat:                  if (compile_stack.stack == NULL) return REG_ESPACE;
../inputs/grep1.dat:
../inputs/grep1.dat:                  compile_stack.size <<= 1;
../inputs/grep1.dat:                }
../inputs/grep1.dat:
../inputs/grep1.dat:              /* These are the values to restore when we hit end of this
../inputs/grep1.dat:                 group.  They are all relative offsets, so that if the
../inputs/grep1.dat:                 whole pattern moves because of realloc, they will still
../inputs/grep1.dat:                 be valid.  */
../inputs/grep1.dat:              COMPILE_STACK_TOP.begalt_offset = begalt - bufp->buffer;
../inputs/grep1.dat:              COMPILE_STACK_TOP.fixup_alt_jump 
../inputs/grep1.dat:                = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
../inputs/grep1.dat:              COMPILE_STACK_TOP.laststart_offset = b - bufp->buffer;
../inputs/grep1.dat:              COMPILE_STACK_TOP.regnum = regnum;
../inputs/grep1.dat:
../inputs/grep1.dat:              /* We will eventually replace the 0 with the number of
../inputs/grep1.dat:                 groups inner to this one.  But do not push a
../inputs/grep1.dat:                 start_memory for groups beyond the last one we can
../inputs/grep1.dat:                 represent in the compiled pattern.  */
../inputs/grep1.dat:              if (regnum <= MAX_REGNUM)
../inputs/grep1.dat:                {
../inputs/grep1.dat:                  COMPILE_STACK_TOP.inner_group_offset = b - bufp->buffer + 2;
../inputs/grep1.dat:                  BUF_PUSH_3 (start_memory, regnum, 0);
../inputs/grep1.dat:                }
../inputs/grep1.dat:                
../inputs/grep1.dat:              compile_stack.avail++;
../inputs/grep1.dat:
../inputs/grep1.dat:              fixup_alt_jump = 0;
../inputs/grep1.dat:              laststart = 0;
../inputs/grep1.dat:              begalt = b;
../inputs/grep1.dat:	      /* If we've reached MAX_REGNUM groups, then this open
../inputs/grep1.dat:		 won't actually generate any code, so we'll have to
../inputs/grep1.dat:		 clear pending_exact explicitly.  */
../inputs/grep1.dat:	      pending_exact = 0;
../inputs/grep1.dat:              break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:            case ')':
../inputs/grep1.dat:              if (syntax & RE_NO_BK_PARENS) goto normal_backslash;
../inputs/grep1.dat:
../inputs/grep1.dat:              if (COMPILE_STACK_EMPTY)
../inputs/grep1.dat:                if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
../inputs/grep1.dat:                  goto normal_backslash;
../inputs/grep1.dat:                else
../inputs/grep1.dat:                  return REG_ERPAREN;
../inputs/grep1.dat:
../inputs/grep1.dat:            handle_close:
../inputs/grep1.dat:              if (fixup_alt_jump)
../inputs/grep1.dat:                { /* Push a dummy failure point at the end of the
../inputs/grep1.dat:                     alternative for a possible future
../inputs/grep1.dat:                     `pop_failure_jump' to pop.  See comments at
../inputs/grep1.dat:                     `push_dummy_failure' in `re_match_2'.  */
../inputs/grep1.dat:                  BUF_PUSH (push_dummy_failure);
../inputs/grep1.dat:                  
../inputs/grep1.dat:                  /* We allocated space for this jump when we assigned
../inputs/grep1.dat:                     to `fixup_alt_jump', in the `handle_alt' case below.  */
../inputs/grep1.dat:                  STORE_JUMP (jump_past_alt, fixup_alt_jump, b - 1);
../inputs/grep1.dat:                }
../inputs/grep1.dat:
../inputs/grep1.dat:              /* See similar code for backslashed left paren above.  */
../inputs/grep1.dat:              if (COMPILE_STACK_EMPTY)
../inputs/grep1.dat:                if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
../inputs/grep1.dat:                  goto normal_char;
../inputs/grep1.dat:                else
../inputs/grep1.dat:                  return REG_ERPAREN;
../inputs/grep1.dat:
../inputs/grep1.dat:              /* Since we just checked for an empty stack above, this
../inputs/grep1.dat:                 ``can't happen''.  */
../inputs/grep1.dat:              assert (compile_stack.avail != 0);
../inputs/grep1.dat:              {
../inputs/grep1.dat:                /* We don't just want to restore into `regnum', because
../inputs/grep1.dat:                   later groups should continue to be numbered higher,
../inputs/grep1.dat:                   as in `(ab)c(de)' -- the second group is #2.  */
../inputs/grep1.dat:                regnum_t this_group_regnum;
../inputs/grep1.dat:
../inputs/grep1.dat:                compile_stack.avail--;		
../inputs/grep1.dat:                begalt = bufp->buffer + COMPILE_STACK_TOP.begalt_offset;
../inputs/grep1.dat:                fixup_alt_jump
../inputs/grep1.dat:                  = COMPILE_STACK_TOP.fixup_alt_jump
../inputs/grep1.dat:                    ? bufp->buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1 
../inputs/grep1.dat:                    : 0;
../inputs/grep1.dat:                laststart = bufp->buffer + COMPILE_STACK_TOP.laststart_offset;
../inputs/grep1.dat:                this_group_regnum = COMPILE_STACK_TOP.regnum;
../inputs/grep1.dat:		/* If we've reached MAX_REGNUM groups, then this open
../inputs/grep1.dat:		   won't actually generate any code, so we'll have to
../inputs/grep1.dat:		   clear pending_exact explicitly.  */
../inputs/grep1.dat:		pending_exact = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:                /* We're at the end of the group, so now we know how many
../inputs/grep1.dat:                   groups were inside this one.  */
../inputs/grep1.dat:                if (this_group_regnum <= MAX_REGNUM)
../inputs/grep1.dat:                  {
../inputs/grep1.dat:                    unsigned char *inner_group_loc
../inputs/grep1.dat:                      = bufp->buffer + COMPILE_STACK_TOP.inner_group_offset;
../inputs/grep1.dat:                    
../inputs/grep1.dat:                    *inner_group_loc = regnum - this_group_regnum;
../inputs/grep1.dat:                    BUF_PUSH_3 (stop_memory, this_group_regnum,
../inputs/grep1.dat:                                regnum - this_group_regnum);
../inputs/grep1.dat:                  }
../inputs/grep1.dat:              }
../inputs/grep1.dat:              break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:            case '|':					/* `\|'.  */
../inputs/grep1.dat:              if (syntax & RE_LIMITED_OPS || syntax & RE_NO_BK_VBAR)
../inputs/grep1.dat:                goto normal_backslash;
../inputs/grep1.dat:            handle_alt:
../inputs/grep1.dat:              if (syntax & RE_LIMITED_OPS)
../inputs/grep1.dat:                goto normal_char;
../inputs/grep1.dat:
../inputs/grep1.dat:              /* Insert before the previous alternative a jump which
../inputs/grep1.dat:                 jumps to this alternative if the former fails.  */
../inputs/grep1.dat:              GET_BUFFER_SPACE (3);
../inputs/grep1.dat:              INSERT_JUMP (on_failure_jump, begalt, b + 6);
../inputs/grep1.dat:              pending_exact = 0;
../inputs/grep1.dat:              b += 3;
../inputs/grep1.dat:
../inputs/grep1.dat:              /* The alternative before this one has a jump after it
../inputs/grep1.dat:                 which gets executed if it gets matched.  Adjust that
../inputs/grep1.dat:                 jump so it will jump to this alternative's analogous
../inputs/grep1.dat:                 jump (put in below, which in turn will jump to the next
../inputs/grep1.dat:                 (if any) alternative's such jump, etc.).  The last such
../inputs/grep1.dat:                 jump jumps to the correct final destination.  A picture:
../inputs/grep1.dat:                          _____ _____ 
../inputs/grep1.dat:                          |   | |   |   
../inputs/grep1.dat:                          |   v |   v 
../inputs/grep1.dat:                         a | b   | c   
../inputs/grep1.dat:
../inputs/grep1.dat:                 If we are at `b', then fixup_alt_jump right now points to a
../inputs/grep1.dat:                 three-byte space after `a'.  We'll put in the jump, set
../inputs/grep1.dat:                 fixup_alt_jump to right after `b', and leave behind three
../inputs/grep1.dat:                 bytes which we'll fill in when we get to after `c'.  */
../inputs/grep1.dat:
../inputs/grep1.dat:              if (fixup_alt_jump)
../inputs/grep1.dat:                STORE_JUMP (jump_past_alt, fixup_alt_jump, b);
../inputs/grep1.dat:
../inputs/grep1.dat:              /* Mark and leave space for a jump after this alternative,
../inputs/grep1.dat:                 to be filled in later either by next alternative or
../inputs/grep1.dat:                 when know we're at the end of a series of alternatives.  */
../inputs/grep1.dat:              fixup_alt_jump = b;
../inputs/grep1.dat:              GET_BUFFER_SPACE (3);
../inputs/grep1.dat:              b += 3;
../inputs/grep1.dat:
../inputs/grep1.dat:              laststart = 0;
../inputs/grep1.dat:              begalt = b;
../inputs/grep1.dat:              break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:            case '{': 
../inputs/grep1.dat:              /* If \{ is a literal.  */
../inputs/grep1.dat:              if (!(syntax & RE_INTERVALS)
../inputs/grep1.dat:                     /* If we're at `\{' and it's not the open-interval 
../inputs/grep1.dat:                        operator.  */
../inputs/grep1.dat:                  || ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))
../inputs/grep1.dat:                  || (p - 2 == pattern  &&  p == pend))
../inputs/grep1.dat:                goto normal_backslash;
../inputs/grep1.dat:
../inputs/grep1.dat:            handle_interval:
../inputs/grep1.dat:              {
../inputs/grep1.dat:                /* If got here, then the syntax allows intervals.  */
../inputs/grep1.dat:
../inputs/grep1.dat:                /* At least (most) this many matches must be made.  */
../inputs/grep1.dat:                int lower_bound = -1, upper_bound = -1;
../inputs/grep1.dat:
../inputs/grep1.dat:                beg_interval = p - 1;
../inputs/grep1.dat:
../inputs/grep1.dat:                if (p == pend)
../inputs/grep1.dat:                  {
../inputs/grep1.dat:                    if (syntax & RE_NO_BK_BRACES)
../inputs/grep1.dat:                      goto unfetch_interval;
../inputs/grep1.dat:                    else
../inputs/grep1.dat:                      return REG_EBRACE;
../inputs/grep1.dat:                  }
../inputs/grep1.dat:
../inputs/grep1.dat:                GET_UNSIGNED_NUMBER (lower_bound);
../inputs/grep1.dat:
../inputs/grep1.dat:                if (c == ',')
../inputs/grep1.dat:                  {
../inputs/grep1.dat:                    GET_UNSIGNED_NUMBER (upper_bound);
../inputs/grep1.dat:                    if (upper_bound < 0) upper_bound = RE_DUP_MAX;
../inputs/grep1.dat:                  }
../inputs/grep1.dat:                else
../inputs/grep1.dat:                  /* Interval such as `{1}' => match exactly once. */
../inputs/grep1.dat:                  upper_bound = lower_bound;
../inputs/grep1.dat:
../inputs/grep1.dat:                if (lower_bound < 0 || upper_bound > RE_DUP_MAX
../inputs/grep1.dat:                    || lower_bound > upper_bound)
../inputs/grep1.dat:                  {
../inputs/grep1.dat:                    if (syntax & RE_NO_BK_BRACES)
../inputs/grep1.dat:                      goto unfetch_interval;
../inputs/grep1.dat:                    else 
../inputs/grep1.dat:                      return REG_BADBR;
../inputs/grep1.dat:                  }
../inputs/grep1.dat:
../inputs/grep1.dat:                if (!(syntax & RE_NO_BK_BRACES)) 
../inputs/grep1.dat:                  {
../inputs/grep1.dat:                    if (c != '\\') return REG_EBRACE;
../inputs/grep1.dat:
../inputs/grep1.dat:                    PATFETCH (c);
../inputs/grep1.dat:                  }
../inputs/grep1.dat:
../inputs/grep1.dat:                if (c != '}')
../inputs/grep1.dat:                  {
../inputs/grep1.dat:                    if (syntax & RE_NO_BK_BRACES)
../inputs/grep1.dat:                      goto unfetch_interval;
../inputs/grep1.dat:                    else 
../inputs/grep1.dat:                      return REG_BADBR;
../inputs/grep1.dat:                  }
../inputs/grep1.dat:
../inputs/grep1.dat:                /* We just parsed a valid interval.  */
../inputs/grep1.dat:
../inputs/grep1.dat:                /* If it's invalid to have no preceding re.  */
../inputs/grep1.dat:                if (!laststart)
../inputs/grep1.dat:                  {
../inputs/grep1.dat:                    if (syntax & RE_CONTEXT_INVALID_OPS)
../inputs/grep1.dat:                      return REG_BADRPT;
../inputs/grep1.dat:                    else if (syntax & RE_CONTEXT_INDEP_OPS)
../inputs/grep1.dat:                      laststart = b;
../inputs/grep1.dat:                    else
../inputs/grep1.dat:                      goto unfetch_interval;
../inputs/grep1.dat:                  }
../inputs/grep1.dat:
../inputs/grep1.dat:                /* If the upper bound is zero, don't want to succeed at
../inputs/grep1.dat:                   all; jump from `laststart' to `b + 3', which will be
../inputs/grep1.dat:                   the end of the buffer after we insert the jump.  */
../inputs/grep1.dat:                 if (upper_bound == 0)
../inputs/grep1.dat:                   {
../inputs/grep1.dat:                     GET_BUFFER_SPACE (3);
../inputs/grep1.dat:                     INSERT_JUMP (jump, laststart, b + 3);
../inputs/grep1.dat:                     b += 3;
../inputs/grep1.dat:                   }
../inputs/grep1.dat:
../inputs/grep1.dat:                 /* Otherwise, we have a nontrivial interval.  When
../inputs/grep1.dat:                    we're all done, the pattern will look like:
../inputs/grep1.dat:                      set_number_at <jump count> <upper bound>
../inputs/grep1.dat:                      set_number_at <succeed_n count> <lower bound>
../inputs/grep1.dat:                      succeed_n <after jump addr> <succed_n count>
../inputs/grep1.dat:                      <body of loop>
../inputs/grep1.dat:                      jump_n <succeed_n addr> <jump count>
../inputs/grep1.dat:                    (The upper bound and `jump_n' are omitted if
../inputs/grep1.dat:                    `upper_bound' is 1, though.)  */
../inputs/grep1.dat:                 else 
../inputs/grep1.dat:                   { /* If the upper bound is > 1, we need to insert
../inputs/grep1.dat:                        more at the end of the loop.  */
../inputs/grep1.dat:                     unsigned nbytes = 10 + (upper_bound > 1) * 10;
../inputs/grep1.dat:
../inputs/grep1.dat:                     GET_BUFFER_SPACE (nbytes);
../inputs/grep1.dat:
../inputs/grep1.dat:                     /* Initialize lower bound of the `succeed_n', even
../inputs/grep1.dat:                        though it will be set during matching by its
../inputs/grep1.dat:                        attendant `set_number_at' (inserted next),
../inputs/grep1.dat:                        because `re_compile_fastmap' needs to know.
../inputs/grep1.dat:                        Jump to the `jump_n' we might insert below.  */
../inputs/grep1.dat:                     INSERT_JUMP2 (succeed_n, laststart,
../inputs/grep1.dat:                                   b + 5 + (upper_bound > 1) * 5,
../inputs/grep1.dat:                                   lower_bound);
../inputs/grep1.dat:                     b += 5;
../inputs/grep1.dat:
../inputs/grep1.dat:                     /* Code to initialize the lower bound.  Insert 
../inputs/grep1.dat:                        before the `succeed_n'.  The `5' is the last two
../inputs/grep1.dat:                        bytes of this `set_number_at', plus 3 bytes of
../inputs/grep1.dat:                        the following `succeed_n'.  */
../inputs/grep1.dat:                     insert_op2 (set_number_at, laststart, 5, lower_bound, b);
../inputs/grep1.dat:                     b += 5;
../inputs/grep1.dat:
../inputs/grep1.dat:                     if (upper_bound > 1)
../inputs/grep1.dat:                       { /* More than one repetition is allowed, so
../inputs/grep1.dat:                            append a backward jump to the `succeed_n'
../inputs/grep1.dat:                            that starts this interval.
../inputs/grep1.dat:                            
../inputs/grep1.dat:                            When we've reached this during matching,
../inputs/grep1.dat:                            we'll have matched the interval once, so
../inputs/grep1.dat:                            jump back only `upper_bound - 1' times.  */
../inputs/grep1.dat:                         STORE_JUMP2 (jump_n, b, laststart + 5,
../inputs/grep1.dat:                                      upper_bound - 1);
../inputs/grep1.dat:                         b += 5;
../inputs/grep1.dat:
../inputs/grep1.dat:                         /* The location we want to set is the second
../inputs/grep1.dat:                            parameter of the `jump_n'; that is `b-2' as
../inputs/grep1.dat:                            an absolute address.  `laststart' will be
../inputs/grep1.dat:                            the `set_number_at' we're about to insert;
../inputs/grep1.dat:                            `laststart+3' the number to set, the source
../inputs/grep1.dat:                            for the relative address.  But we are
../inputs/grep1.dat:                            inserting into the middle of the pattern --
../inputs/grep1.dat:                            so everything is getting moved up by 5.
../inputs/grep1.dat:                            Conclusion: (b - 2) - (laststart + 3) + 5,
../inputs/grep1.dat:                            i.e., b - laststart.
../inputs/grep1.dat:                            
../inputs/grep1.dat:                            We insert this at the beginning of the loop
../inputs/grep1.dat:                            so that if we fail during matching, we'll
../inputs/grep1.dat:                            reinitialize the bounds.  */
../inputs/grep1.dat:                         insert_op2 (set_number_at, laststart, b - laststart,
../inputs/grep1.dat:                                     upper_bound - 1, b);
../inputs/grep1.dat:                         b += 5;
../inputs/grep1.dat:                       }
../inputs/grep1.dat:                   }
../inputs/grep1.dat:                pending_exact = 0;
../inputs/grep1.dat:                beg_interval = NULL;
../inputs/grep1.dat:              }
../inputs/grep1.dat:              break;
../inputs/grep1.dat:
../inputs/grep1.dat:            unfetch_interval:
../inputs/grep1.dat:              /* If an invalid interval, match the characters as literals.  */
../inputs/grep1.dat:               assert (beg_interval);
../inputs/grep1.dat:               p = beg_interval;
../inputs/grep1.dat:               beg_interval = NULL;
../inputs/grep1.dat:
../inputs/grep1.dat:               /* normal_char and normal_backslash need `c'.  */
../inputs/grep1.dat:               PATFETCH (c);	
../inputs/grep1.dat:
../inputs/grep1.dat:               if (!(syntax & RE_NO_BK_BRACES))
../inputs/grep1.dat:                 {
../inputs/grep1.dat:                   if (p > pattern  &&  p[-1] == '\\')
../inputs/grep1.dat:                     goto normal_backslash;
../inputs/grep1.dat:                 }
../inputs/grep1.dat:               goto normal_char;
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef emacs
../inputs/grep1.dat:            /* There is no way to specify the before_dot and after_dot
../inputs/grep1.dat:               operators.  rms says this is ok.  --karl  */
../inputs/grep1.dat:            case '=':
../inputs/grep1.dat:              BUF_PUSH (at_dot);
../inputs/grep1.dat:              break;
../inputs/grep1.dat:
../inputs/grep1.dat:            case 's':	
../inputs/grep1.dat:              laststart = b;
../inputs/grep1.dat:              PATFETCH (c);
../inputs/grep1.dat:              BUF_PUSH_2 (syntaxspec, syntax_spec_code[c]);
../inputs/grep1.dat:              break;
../inputs/grep1.dat:
../inputs/grep1.dat:            case 'S':
../inputs/grep1.dat:              laststart = b;
../inputs/grep1.dat:              PATFETCH (c);
../inputs/grep1.dat:              BUF_PUSH_2 (notsyntaxspec, syntax_spec_code[c]);
../inputs/grep1.dat:              break;
../inputs/grep1.dat:#endif /* emacs */
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:            case 'w':
../inputs/grep1.dat:              laststart = b;
../inputs/grep1.dat:              BUF_PUSH (wordchar);
../inputs/grep1.dat:              break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:            case 'W':
../inputs/grep1.dat:              laststart = b;
../inputs/grep1.dat:              BUF_PUSH (notwordchar);
../inputs/grep1.dat:              break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:            case '<':
../inputs/grep1.dat:              BUF_PUSH (wordbeg);
../inputs/grep1.dat:              break;
../inputs/grep1.dat:
../inputs/grep1.dat:            case '>':
../inputs/grep1.dat:              BUF_PUSH (wordend);
../inputs/grep1.dat:              break;
../inputs/grep1.dat:
../inputs/grep1.dat:            case 'b':
../inputs/grep1.dat:              BUF_PUSH (wordbound);
../inputs/grep1.dat:              break;
../inputs/grep1.dat:
../inputs/grep1.dat:            case 'B':
../inputs/grep1.dat:              BUF_PUSH (notwordbound);
../inputs/grep1.dat:              break;
../inputs/grep1.dat:
../inputs/grep1.dat:            case '`':
../inputs/grep1.dat:              BUF_PUSH (begbuf);
../inputs/grep1.dat:              break;
../inputs/grep1.dat:
../inputs/grep1.dat:            case '\'':
../inputs/grep1.dat:              BUF_PUSH (endbuf);
../inputs/grep1.dat:              break;
../inputs/grep1.dat:
../inputs/grep1.dat:            case '1': case '2': case '3': case '4': case '5':
../inputs/grep1.dat:            case '6': case '7': case '8': case '9':
../inputs/grep1.dat:              if (syntax & RE_NO_BK_REFS)
../inputs/grep1.dat:                goto normal_char;
../inputs/grep1.dat:
../inputs/grep1.dat:              c1 = c - '0';
../inputs/grep1.dat:
../inputs/grep1.dat:              if (c1 > regnum)
../inputs/grep1.dat:                return REG_ESUBREG;
../inputs/grep1.dat:
../inputs/grep1.dat:              /* Can't back reference to a subexpression if inside of it.  */
../inputs/grep1.dat:              if (group_in_compile_stack (compile_stack, c1))
../inputs/grep1.dat:                goto normal_char;
../inputs/grep1.dat:
../inputs/grep1.dat:              laststart = b;
../inputs/grep1.dat:              BUF_PUSH_2 (duplicate, c1);
../inputs/grep1.dat:              break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:            case '+':
../inputs/grep1.dat:            case '?':
../inputs/grep1.dat:              if (syntax & RE_BK_PLUS_QM)
../inputs/grep1.dat:                goto handle_plus;
../inputs/grep1.dat:              else
../inputs/grep1.dat:                goto normal_backslash;
../inputs/grep1.dat:
../inputs/grep1.dat:            default:
../inputs/grep1.dat:            normal_backslash:
../inputs/grep1.dat:              /* You might think it would be useful for \ to mean
../inputs/grep1.dat:                 not to translate; but if we don't translate it
../inputs/grep1.dat:                 it will never match anything.  */
../inputs/grep1.dat:              c = TRANSLATE (c);
../inputs/grep1.dat:              goto normal_char;
../inputs/grep1.dat:            }
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:	default:
../inputs/grep1.dat:        /* Expects the character in `c'.  */
../inputs/grep1.dat:	normal_char:
../inputs/grep1.dat:	      /* If no exactn currently being built.  */
../inputs/grep1.dat:          if (!pending_exact 
../inputs/grep1.dat:
../inputs/grep1.dat:              /* If last exactn not at current position.  */
../inputs/grep1.dat:              || pending_exact + *pending_exact + 1 != b
../inputs/grep1.dat:              
../inputs/grep1.dat:              /* We have only one byte following the exactn for the count.  */
../inputs/grep1.dat:	      || *pending_exact == (1 << BYTEWIDTH) - 1
../inputs/grep1.dat:
../inputs/grep1.dat:              /* If followed by a repetition operator.  */
../inputs/grep1.dat:              || *p == '*' || *p == '^'
../inputs/grep1.dat:	      || ((syntax & RE_BK_PLUS_QM)
../inputs/grep1.dat:		  ? *p == '\\' && (p[1] == '+' || p[1] == '?')
../inputs/grep1.dat:		  : (*p == '+' || *p == '?'))
../inputs/grep1.dat:	      || ((syntax & RE_INTERVALS)
../inputs/grep1.dat:                  && ((syntax & RE_NO_BK_BRACES)
../inputs/grep1.dat:		      ? *p == '{'
../inputs/grep1.dat:                      : (p[0] == '\\' && p[1] == '{'))))
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      /* Start building a new exactn.  */
../inputs/grep1.dat:              
../inputs/grep1.dat:              laststart = b;
../inputs/grep1.dat:
../inputs/grep1.dat:	      BUF_PUSH_2 (exactn, 0);
../inputs/grep1.dat:	      pending_exact = b - 1;
../inputs/grep1.dat:            }
../inputs/grep1.dat:            
../inputs/grep1.dat:	  BUF_PUSH (c);
../inputs/grep1.dat:          (*pending_exact)++;
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:        } /* switch (c) */
../inputs/grep1.dat:    } /* while p != pend */
../inputs/grep1.dat:
../inputs/grep1.dat:  
../inputs/grep1.dat:  /* Through the pattern now.  */
../inputs/grep1.dat:  
../inputs/grep1.dat:  if (fixup_alt_jump)
../inputs/grep1.dat:    STORE_JUMP (jump_past_alt, fixup_alt_jump, b);
../inputs/grep1.dat:
../inputs/grep1.dat:  if (!COMPILE_STACK_EMPTY) 
../inputs/grep1.dat:    return REG_EPAREN;
../inputs/grep1.dat:
../inputs/grep1.dat:  free (compile_stack.stack);
../inputs/grep1.dat:
../inputs/grep1.dat:  /* We have succeeded; set the length of the buffer.  */
../inputs/grep1.dat:  bufp->used = b - bufp->buffer;
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef DEBUG
../inputs/grep1.dat:  if (debug)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      DEBUG_PRINT1 ("\nCompiled pattern: \n");
../inputs/grep1.dat:      print_compiled_pattern (bufp);
../inputs/grep1.dat:    }
../inputs/grep1.dat:#endif /* DEBUG */
../inputs/grep1.dat:
../inputs/grep1.dat:  return REG_NOERROR;
../inputs/grep1.dat:} /* regex_compile */
../inputs/grep1.dat:
../inputs/grep1.dat:/* Subroutines for `regex_compile'.  */
../inputs/grep1.dat:
../inputs/grep1.dat:/* Store OP at LOC followed by two-byte integer parameter ARG.  */
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:store_op1 (op, loc, arg)
../inputs/grep1.dat:    re_opcode_t op;
../inputs/grep1.dat:    unsigned char *loc;
../inputs/grep1.dat:    int arg;
../inputs/grep1.dat:{
../inputs/grep1.dat:  *loc = (unsigned char) op;
../inputs/grep1.dat:  STORE_NUMBER (loc + 1, arg);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Like `store_op1', but" for 'two two-byte parameters ARG1 and ARG2.  */
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:store_op2 (op, loc, arg1, arg2)
../inputs/grep1.dat:    re_opcode_t op;
../inputs/grep1.dat:    unsigned char *loc;
../inputs/grep1.dat:    int arg1, arg2;
../inputs/grep1.dat:{
../inputs/grep1.dat:  *loc = (unsigned char) op;
../inputs/grep1.dat:  STORE_NUMBER (loc + 1, arg1);
../inputs/grep1.dat:  STORE_NUMBER (loc + 3, arg2);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Copy the bytes from LOC to END to open up three bytes of space at LOC
../inputs/grep1.dat:   for OP followed by two-byte integer parameter ARG.  */
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:insert_op1 (op, loc, arg, end)
../inputs/grep1.dat:    re_opcode_t op;
../inputs/grep1.dat:    unsigned char *loc;
../inputs/grep1.dat:    int arg;
../inputs/grep1.dat:    unsigned char *end;    
../inputs/grep1.dat:{
../inputs/grep1.dat:  register unsigned char *pfrom = end;
../inputs/grep1.dat:  register unsigned char *pto = end + 3;
../inputs/grep1.dat:
../inputs/grep1.dat:  while (pfrom != loc)
../inputs/grep1.dat:    *--pto = *--pfrom;
../inputs/grep1.dat:    
../inputs/grep1.dat:  store_op1 (op, loc, arg);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Like `insert_op1', but for two two-byte parameters ARG1 and ARG2.  */
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:insert_op2 (op, loc, arg1, arg2, end)
../inputs/grep1.dat:    re_opcode_t op;
../inputs/grep1.dat:    unsigned char *loc;
../inputs/grep1.dat:    int arg1, arg2;
../inputs/grep1.dat:    unsigned char *end;    
../inputs/grep1.dat:{
../inputs/grep1.dat:  register unsigned char *pfrom = end;
../inputs/grep1.dat:  register unsigned char *pto = end + 5;
../inputs/grep1.dat:
../inputs/grep1.dat:  while (pfrom != loc)
../inputs/grep1.dat:    *--pto = *--pfrom;
../inputs/grep1.dat:    
../inputs/grep1.dat:  store_op2 (op, loc, arg1, arg2);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* P points to just after a ^ in PATTERN.  Return true if that ^ comes
../inputs/grep1.dat:   after an alternative or a begin-subexpression.  We assume there is at
../inputs/grep1.dat:   least one character before the ^.  */
../inputs/grep1.dat:
../inputs/grep1.dat:static boolean
../inputs/grep1.dat:at_begline_loc_p (pattern, p, syntax)
../inputs/grep1.dat:    const char *pattern, *p;
../inputs/grep1.dat:    reg_syntax_t syntax;
../inputs/grep1.dat:{
../inputs/grep1.dat:  const char *prev = p - 2;
../inputs/grep1.dat:  boolean prev_prev_backslash = prev > pattern && prev[-1] == '\\';
../inputs/grep1.dat:  
../inputs/grep1.dat:  return
../inputs/grep1.dat:       /* After a subexpression?  */
../inputs/grep1.dat:       (*prev == '(' && (syntax & RE_NO_BK_PARENS || prev_prev_backslash))
../inputs/grep1.dat:       /* After an alternative?  */
../inputs/grep1.dat:    || (*prev == '|' && (syntax & RE_NO_BK_VBAR || prev_prev_backslash));
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* The dual of at_begline_loc_p.  This one is for $.  We assume there is
../inputs/grep1.dat:   at least one character after the $, i.e., `P < PEND'.  */
../inputs/grep1.dat:
../inputs/grep1.dat:static boolean
../inputs/grep1.dat:at_endline_loc_p (p, pend, syntax)
../inputs/grep1.dat:    const char *p, *pend;
../inputs/grep1.dat:    int syntax;
../inputs/grep1.dat:{
../inputs/grep1.dat:  const char *next = p;
../inputs/grep1.dat:  boolean next_backslash = *next == '\\';
../inputs/grep1.dat:  const char *next_next = p + 1 < pend ? p + 1 : NULL;
../inputs/grep1.dat:  
../inputs/grep1.dat:  return
../inputs/grep1.dat:       /* Before a subexpression?  */
../inputs/grep1.dat:       (syntax & RE_NO_BK_PARENS ? *next == ')'
../inputs/grep1.dat:        : next_backslash && next_next && *next_next == ')')
../inputs/grep1.dat:       /* Before an alternative?  */
../inputs/grep1.dat:    || (syntax & RE_NO_BK_VBAR ? *next == '|'
../inputs/grep1.dat:        : next_backslash && next_next && *next_next == '|');
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Returns true if REGNUM is in one of COMPILE_STACK's elements and 
../inputs/grep1.dat:   false if it's not.  */
../inputs/grep1.dat:
../inputs/grep1.dat:static boolean
../inputs/grep1.dat:group_in_compile_stack (compile_stack, regnum)
../inputs/grep1.dat:    compile_stack_type compile_stack;
../inputs/grep1.dat:    regnum_t regnum;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int this_element;
../inputs/grep1.dat:
../inputs/grep1.dat:  for (this_element = compile_stack.avail - 1;  
../inputs/grep1.dat:       this_element >= 0; 
../inputs/grep1.dat:       this_element--)
../inputs/grep1.dat:    if (compile_stack.stack[this_element].regnum == regnum)
../inputs/grep1.dat:      return true;
../inputs/grep1.dat:
../inputs/grep1.dat:  return false;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Read the ending character of a range (in a bracket expression) from the
../inputs/grep1.dat:   uncompiled pattern *P_PTR (which ends at PEND).  We assume the
../inputs/grep1.dat:   starting character is in `P[-2]'.  (`P[-1]' is the character `-'.)
../inputs/grep1.dat:   Then we set the translation of all bits between the starting and
../inputs/grep1.dat:   ending characters (inclusive) in the compiled pattern B.
../inputs/grep1.dat:   
../inputs/grep1.dat:   Return an error code.
../inputs/grep1.dat:   
../inputs/grep1.dat:   We use these short variable names so we can use the same macros as
../inputs/grep1.dat:   `regex_compile' itself.  */
../inputs/grep1.dat:
../inputs/grep1.dat:static reg_errcode_t
../inputs/grep1.dat:compile_range (p_ptr, pend, translate, syntax, b)
../inputs/grep1.dat:    const char **p_ptr, *pend;
../inputs/grep1.dat:    char *translate;
../inputs/grep1.dat:    reg_syntax_t syntax;
../inputs/grep1.dat:    unsigned char *b;
../inputs/grep1.dat:{
../inputs/grep1.dat:  unsigned this_char;
../inputs/grep1.dat:
../inputs/grep1.dat:  const char *p = *p_ptr;
../inputs/grep1.dat:  int range_start, range_end;
../inputs/grep1.dat:  
../inputs/grep1.dat:  if (p == pend)
../inputs/grep1.dat:    return REG_ERANGE;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Even though the pattern is a signed `char *', we need to fetch
../inputs/grep1.dat:     with unsigned char *'s; if the high bit of the pattern character
../inputs/grep1.dat:     is set, the range endpoints will be negative if we fetch using a
../inputs/grep1.dat:     signed char *.
../inputs/grep1.dat:
../inputs/grep1.dat:     We also want to fetch the endpoints without translating them; the 
../inputs/grep1.dat:     appropriate translation is done in the bit-setting loop below.  */
../inputs/grep1.dat:  range_start = ((unsigned char *) p)[-2];
../inputs/grep1.dat:  range_end   = ((unsigned char *) p)[0];
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Have to increment the pointer into the pattern string, so the
../inputs/grep1.dat:     caller isn't still at the ending character.  */
../inputs/grep1.dat:  (*p_ptr)++;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* If the start is after the end, the range is empty.  */
../inputs/grep1.dat:  if (range_start > range_end)
../inputs/grep1.dat:    return syntax & RE_NO_EMPTY_RANGES ? REG_ERANGE : REG_NOERROR;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Here we see why `this_char' has to be larger than an `unsigned
../inputs/grep1.dat:     char' -- the range is inclusive, so if `range_end' == 0xff
../inputs/grep1.dat:     (assuming 8-bit characters), we would otherwise go into an infinite
../inputs/grep1.dat:     loop, since all characters <= 0xff.  */
../inputs/grep1.dat:  for (this_char = range_start; this_char <= range_end; this_char++)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      SET_LIST_BIT (TRANSLATE (this_char));
../inputs/grep1.dat:    }
../inputs/grep1.dat:  
../inputs/grep1.dat:  return REG_NOERROR;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Failure stack declarations and macros; both re_compile_fastmap and
../inputs/grep1.dat:   re_match_2 use a failure stack.  These have to be macros because of
../inputs/grep1.dat:   REGEX_ALLOCATE.  */
../inputs/grep1.dat:   
../inputs/grep1.dat:
../inputs/grep1.dat:/* Number of failure points for which to initially allocate space
../inputs/grep1.dat:   when matching.  If this number is exceeded, we allocate more
../inputs/grep1.dat:   space, so it is not a hard limit.  */
../inputs/grep1.dat:#ifndef INIT_FAILURE_ALLOC
../inputs/grep1.dat:#define INIT_FAILURE_ALLOC 5
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:/* Roughly the maximum number of failure points on the stack.  Would be
../inputs/grep1.dat:   exactly that if always used MAX_FAILURE_SPACE each time we failed.
../inputs/grep1.dat:   This is a variable only so users of regex can assign to it; we never
../inputs/grep1.dat:   change it ourselves.  */
../inputs/grep1.dat:int re_max_failures = 2000;
../inputs/grep1.dat:
../inputs/grep1.dat:typedef const unsigned char *fail_stack_elt_t;
../inputs/grep1.dat:
../inputs/grep1.dat:typedef struct
../inputs/grep1.dat:{
../inputs/grep1.dat:  fail_stack_elt_t *stack;
../inputs/grep1.dat:  unsigned size;
../inputs/grep1.dat:  unsigned avail;			/* Offset of next open position.  */
../inputs/grep1.dat:} fail_stack_type;
../inputs/grep1.dat:
../inputs/grep1.dat:#define FAIL_STACK_EMPTY()     (fail_stack.avail == 0)
../inputs/grep1.dat:#define FAIL_STACK_PTR_EMPTY() (fail_stack_ptr->avail == 0)
../inputs/grep1.dat:#define FAIL_STACK_FULL()      (fail_stack.avail == fail_stack.size)
../inputs/grep1.dat:#define FAIL_STACK_TOP()       (fail_stack.stack[fail_stack.avail])
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Initialize `fail_stack'.  Do `return -2' if the alloc fails.  */
../inputs/grep1.dat:
../inputs/grep1.dat:#define INIT_FAIL_STACK()						\
../inputs/grep1.dat:  do {									\
../inputs/grep1.dat:    fail_stack.stack = (fail_stack_elt_t *)				\
../inputs/grep1.dat:      REGEX_ALLOCATE (INIT_FAILURE_ALLOC * sizeof (fail_stack_elt_t));	\
../inputs/grep1.dat:									\
../inputs/grep1.dat:    if (fail_stack.stack == NULL)					\
../inputs/grep1.dat:      return -2;							\
../inputs/grep1.dat:									\
../inputs/grep1.dat:    fail_stack.size = INIT_FAILURE_ALLOC;				\
../inputs/grep1.dat:    fail_stack.avail = 0;						\
../inputs/grep1.dat:  } while (0)
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Double the size of FAIL_STACK, up to approximately `re_max_failures' items.
../inputs/grep1.dat:
../inputs/grep1.dat:   Return 1 if succeeds, and 0 if either ran out of memory
../inputs/grep1.dat:   allocating space for it or it was already too large.  
../inputs/grep1.dat:   
../inputs/grep1.dat:   REGEX_REALLOCATE requires `destination' be declared.   */
../inputs/grep1.dat:
../inputs/grep1.dat:#define DOUBLE_FAIL_STACK(fail_stack)					\
../inputs/grep1.dat:  ((fail_stack).size > re_max_failures * MAX_FAILURE_ITEMS		\
../inputs/grep1.dat:   ? 0									\
../inputs/grep1.dat:   : ((fail_stack).stack = (fail_stack_elt_t *)				\
../inputs/grep1.dat:        REGEX_REALLOCATE ((fail_stack).stack, 				\
../inputs/grep1.dat:          (fail_stack).size * sizeof (fail_stack_elt_t),		\
../inputs/grep1.dat:          ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),	\
../inputs/grep1.dat:									\
../inputs/grep1.dat:      (fail_stack).stack == NULL					\
../inputs/grep1.dat:      ? 0								\
../inputs/grep1.dat:      : ((fail_stack).size <<= 1, 					\
../inputs/grep1.dat:         1)))
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Push PATTERN_OP on FAIL_STACK. 
../inputs/grep1.dat:
../inputs/grep1.dat:   Return 1 if was able to do so and 0 if ran out of memory allocating
../inputs/grep1.dat:   space to do so.  */
../inputs/grep1.dat:#define PUSH_PATTERN_OP(pattern_op, fail_stack)				\
../inputs/grep1.dat:  ((FAIL_STACK_FULL ()							\
../inputs/grep1.dat:    && !DOUBLE_FAIL_STACK (fail_stack))					\
../inputs/grep1.dat:    ? 0									\
../inputs/grep1.dat:    : ((fail_stack).stack[(fail_stack).avail++] = pattern_op,		\
../inputs/grep1.dat:       1))
../inputs/grep1.dat:
../inputs/grep1.dat:/* This pushes an item onto the failure stack.  Must be a four-byte
../inputs/grep1.dat:   value.  Assumes the variable `fail_stack'.  Probably should only
../inputs/grep1.dat:   be called from within `PUSH_FAILURE_POINT'.  */
../inputs/grep1.dat:#define PUSH_FAILURE_ITEM(item)						\
../inputs/grep1.dat:  fail_stack.stack[fail_stack.avail++] = (fail_stack_elt_t) item
../inputs/grep1.dat:
../inputs/grep1.dat:/* The complement operation.  Assumes `fail_stack' is nonempty.  */
../inputs/grep1.dat:#define POP_FAILURE_ITEM() fail_stack.stack[--fail_stack.avail]
../inputs/grep1.dat:
../inputs/grep1.dat:/* Used to omit pushing failure point id's when we're not debugging.  */
../inputs/grep1.dat:#ifdef DEBUG
../inputs/grep1.dat:#define DEBUG_PUSH PUSH_FAILURE_ITEM
../inputs/grep1.dat:#define DEBUG_POP(item_addr) *(item_addr) = POP_FAILURE_ITEM ()
../inputs/grep1.dat:#else
../inputs/grep1.dat:#define DEBUG_PUSH(item)
../inputs/grep1.dat:#define DEBUG_POP(item_addr)
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Push the information about the state we will need
../inputs/grep1.dat:   if we ever fail back to it.  
../inputs/grep1.dat:   
../inputs/grep1.dat:   Requires variables fail_stack, regstart, regend, reg_info, and
../inputs/grep1.dat:   num_regs be declared.  DOUBLE_FAIL_STACK requires `destination' be
../inputs/grep1.dat:   declared.
../inputs/grep1.dat:   
../inputs/grep1.dat:   Does `return FAILURE_CODE' if runs out of memory.  */
../inputs/grep1.dat:
../inputs/grep1.dat:#define PUSH_FAILURE_POINT(pattern_place, string_place, failure_code)	\
../inputs/grep1.dat:  do {									\
../inputs/grep1.dat:    char *destination;							\
../inputs/grep1.dat:    /* Must be int, so when we don't save any registers, the arithmetic	\
../inputs/grep1.dat:       of 0 + -1 isn't done as unsigned.  */				\
../inputs/grep1.dat:    int this_reg;							\
../inputs/grep1.dat:    									\
../inputs/grep1.dat:    DEBUG_STATEMENT (failure_id++);					\
../inputs/grep1.dat:    DEBUG_STATEMENT (nfailure_points_pushed++);				\
../inputs/grep1.dat:    DEBUG_PRINT2 ("\nPUSH_FAILURE_POINT #%u:\n", failure_id);		\
../inputs/grep1.dat:    DEBUG_PRINT2 ("  Before push, next avail: %d\n", (fail_stack).avail);\
../inputs/grep1.dat:    DEBUG_PRINT2 ("                     size: %d\n", (fail_stack).size);\
../inputs/grep1.dat:									\
../inputs/grep1.dat:    DEBUG_PRINT2 ("  slots needed: %d\n", NUM_FAILURE_ITEMS);		\
../inputs/grep1.dat:    DEBUG_PRINT2 ("     available: %d\n", REMAINING_AVAIL_SLOTS);	\
../inputs/grep1.dat:									\
../inputs/grep1.dat:    /* Ensure we have enough space allocated for what we will push.  */	\
../inputs/grep1.dat:    while (REMAINING_AVAIL_SLOTS < NUM_FAILURE_ITEMS)			\
../inputs/grep1.dat:      {									\
../inputs/grep1.dat:        if (!DOUBLE_FAIL_STACK (fail_stack))			\
../inputs/grep1.dat:          return failure_code;						\
../inputs/grep1.dat:									\
../inputs/grep1.dat:        DEBUG_PRINT2 ("\n  Doubled stack; size now: %d\n",		\
../inputs/grep1.dat:		       (fail_stack).size);				\
../inputs/grep1.dat:        DEBUG_PRINT2 ("  slots available: %d\n", REMAINING_AVAIL_SLOTS);\
../inputs/grep1.dat:      }									\
../inputs/grep1.dat:									\
../inputs/grep1.dat:    /* Push the info, starting with the registers.  */			\
../inputs/grep1.dat:    DEBUG_PRINT1 ("\n");						\
../inputs/grep1.dat:									\
../inputs/grep1.dat:    for (this_reg = lowest_active_reg; this_reg <= highest_active_reg;	\
../inputs/grep1.dat:         this_reg++)							\
../inputs/grep1.dat:      {									\
../inputs/grep1.dat:	DEBUG_PRINT2 ("  Pushing reg: %d\n", this_reg);			\
../inputs/grep1.dat:        DEBUG_STATEMENT (num_regs_pushed++);				\
../inputs/grep1.dat:									\
../inputs/grep1.dat:	DEBUG_PRINT2 ("    start: 0x%x\n", regstart[this_reg]);		\
../inputs/grep1.dat:        PUSH_FAILURE_ITEM (regstart[this_reg]);				\
../inputs/grep1.dat:                                                                        \
../inputs/grep1.dat:	DEBUG_PRINT2 ("    end: 0x%x\n", regend[this_reg]);		\
../inputs/grep1.dat:        PUSH_FAILURE_ITEM (regend[this_reg]);				\
../inputs/grep1.dat:									\
../inputs/grep1.dat:	DEBUG_PRINT2 ("    info: 0x%x\n      ", reg_info[this_reg]);	\
../inputs/grep1.dat:        DEBUG_PRINT2 (" match_null=%d",					\
../inputs/grep1.dat:                      REG_MATCH_NULL_STRING_P (reg_info[this_reg]));	\
../inputs/grep1.dat:        DEBUG_PRINT2 (" active=%d", IS_ACTIVE (reg_info[this_reg]));	\
../inputs/grep1.dat:        DEBUG_PRINT2 (" matched_something=%d",				\
../inputs/grep1.dat:                      MATCHED_SOMETHING (reg_info[this_reg]));		\
../inputs/grep1.dat:        DEBUG_PRINT2 (" ever_matched=%d",				\
../inputs/grep1.dat:                      EVER_MATCHED_SOMETHING (reg_info[this_reg]));	\
../inputs/grep1.dat:	DEBUG_PRINT1 ("\n");						\
../inputs/grep1.dat:        PUSH_FAILURE_ITEM (reg_info[this_reg].word);			\
../inputs/grep1.dat:      }									\
../inputs/grep1.dat:									\
../inputs/grep1.dat:    DEBUG_PRINT2 ("  Pushing  low active reg: %d\n", lowest_active_reg);\
../inputs/grep1.dat:    PUSH_FAILURE_ITEM (lowest_active_reg);				\
../inputs/grep1.dat:									\
../inputs/grep1.dat:    DEBUG_PRINT2 ("  Pushing high active reg: %d\n", highest_active_reg);\
../inputs/grep1.dat:    PUSH_FAILURE_ITEM (highest_active_reg);				\
../inputs/grep1.dat:									\
../inputs/grep1.dat:    DEBUG_PRINT2 ("  Pushing pattern 0x%x: ", pattern_place);		\
../inputs/grep1.dat:    DEBUG_PRINT_COMPILED_PATTERN (bufp, pattern_place, pend);		\
../inputs/grep1.dat:    PUSH_FAILURE_ITEM (pattern_place);					\
../inputs/grep1.dat:									\
../inputs/grep1.dat:    DEBUG_PRINT2 ("  Pushing string 0x%x: `", string_place);		\
../inputs/grep1.dat:    DEBUG_PRINT_DOUBLE_STRING (string_place, string1, size1, string2,   \
../inputs/grep1.dat:				 size2);				\
../inputs/grep1.dat:    DEBUG_PRINT1 ("'\n");						\
../inputs/grep1.dat:    PUSH_FAILURE_ITEM (string_place);					\
../inputs/grep1.dat:									\
../inputs/grep1.dat:    DEBUG_PRINT2 ("  Pushing failure id: %u\n", failure_id);		\
../inputs/grep1.dat:    DEBUG_PUSH (failure_id);						\
../inputs/grep1.dat:  } while (0)
../inputs/grep1.dat:
../inputs/grep1.dat:/* This is the number of items that are pushed and popped on the stack
../inputs/grep1.dat:   for each register.  */
../inputs/grep1.dat:#define NUM_REG_ITEMS  3
../inputs/grep1.dat:
../inputs/grep1.dat:/* Individual items aside from the registers.  */
../inputs/grep1.dat:#ifdef DEBUG
../inputs/grep1.dat:#else
../inputs/grep1.dat:#define NUM_NONREG_ITEMS 4
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:/* We push at most this many items on the stack.  */
../inputs/grep1.dat:#define MAX_FAILURE_ITEMS ((num_regs - 1) * NUM_REG_ITEMS + NUM_NONREG_ITEMS)
../inputs/grep1.dat:
../inputs/grep1.dat:/* We actually push this many items.  */
../inputs/grep1.dat:#define NUM_FAILURE_ITEMS						\
../inputs/grep1.dat:  ((highest_active_reg - lowest_active_reg + 1) * NUM_REG_ITEMS 	\
../inputs/grep1.dat:    + NUM_NONREG_ITEMS)
../inputs/grep1.dat:
../inputs/grep1.dat:/* How many items can still be added to the stack without overflowing it.  */
../inputs/grep1.dat:#define REMAINING_AVAIL_SLOTS ((fail_stack).size - (fail_stack).avail)
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Pops what PUSH_FAIL_STACK pushes.
../inputs/grep1.dat:
../inputs/grep1.dat:   We restore into the parameters, all of which should be lvalues:
../inputs/grep1.dat:     STR -- the saved data position.
../inputs/grep1.dat:     PAT -- the saved pattern position.
../inputs/grep1.dat:     LOW_REG, HIGH_REG -- the highest and lowest active registers.
../inputs/grep1.dat:     REGSTART, REGEND -- arrays of string positions.
../inputs/grep1.dat:     REG_INFO -- array of information about each subexpression.
../inputs/grep1.dat:   
../inputs/grep1.dat:   Also assumes the variables `fail_stack' and (if debugging), `bufp',
../inputs/grep1.dat:   `pend', `string1', `size1', `string2', and `size2'.  */
../inputs/grep1.dat:
../inputs/grep1.dat:#define POP_FAILURE_POINT(str, pat, low_reg, high_reg, regstart, regend, reg_info)\
../inputs/grep1.dat:{									\
../inputs/grep1.dat:  DEBUG_STATEMENT (fail_stack_elt_t failure_id;)			\
../inputs/grep1.dat:  int this_reg;								\
../inputs/grep1.dat:  const unsigned char *string_temp;					\
../inputs/grep1.dat:									\
../inputs/grep1.dat:  assert (!FAIL_STACK_EMPTY ());					\
../inputs/grep1.dat:									\
../inputs/grep1.dat:  /* Remove failure points and point to how many regs pushed.  */	\
../inputs/grep1.dat:  DEBUG_PRINT1 ("POP_FAILURE_POINT:\n");				\
../inputs/grep1.dat:  DEBUG_PRINT2 ("  Before pop, next avail: %d\n", fail_stack.avail);	\
../inputs/grep1.dat:  DEBUG_PRINT2 ("                    size: %d\n", fail_stack.size);	\
../inputs/grep1.dat:									\
../inputs/grep1.dat:  assert (fail_stack.avail >= NUM_NONREG_ITEMS);			\
../inputs/grep1.dat:									\
../inputs/grep1.dat:  DEBUG_POP (&failure_id);						\
../inputs/grep1.dat:  DEBUG_PRINT2 ("  Popping failure id: %u\n", failure_id);		\
../inputs/grep1.dat:									\
../inputs/grep1.dat:  /* If the saved string location is NULL, it came from an		\
../inputs/grep1.dat:     on_failure_keep_string_jump opcode, and we want to throw away the	\
../inputs/grep1.dat:     saved NULL, thus retaining our current position in the string.  */	\
../inputs/grep1.dat:  string_temp = POP_FAILURE_ITEM ();					\
../inputs/grep1.dat:  if (string_temp != NULL)						\
../inputs/grep1.dat:    str = (const char *) string_temp;					\
../inputs/grep1.dat:									\
../inputs/grep1.dat:  DEBUG_PRINT2 ("  Popping string 0x%x: `", str);			\
../inputs/grep1.dat:  DEBUG_PRINT_DOUBLE_STRING (str, string1, size1, string2, size2);	\
../inputs/grep1.dat:  DEBUG_PRINT1 ("'\n");							\
../inputs/grep1.dat:									\
../inputs/grep1.dat:  pat = (unsigned char *) POP_FAILURE_ITEM ();				\
../inputs/grep1.dat:  DEBUG_PRINT2 ("  Popping pattern 0x%x: ", pat);			\
../inputs/grep1.dat:  DEBUG_PRINT_COMPILED_PATTERN (bufp, pat, pend);			\
../inputs/grep1.dat:									\
../inputs/grep1.dat:  /* Restore register info.  */						\
../inputs/grep1.dat:  high_reg = (unsigned) POP_FAILURE_ITEM ();				\
../inputs/grep1.dat:  DEBUG_PRINT2 ("  Popping high active reg: %d\n", high_reg);		\
../inputs/grep1.dat:									\
../inputs/grep1.dat:  low_reg = (unsigned) POP_FAILURE_ITEM ();				\
../inputs/grep1.dat:  DEBUG_PRINT2 ("  Popping  low active reg: %d\n", low_reg);		\
../inputs/grep1.dat:									\
../inputs/grep1.dat:  for (this_reg = high_reg; this_reg >= low_reg; this_reg--)		\
../inputs/grep1.dat:    {									\
../inputs/grep1.dat:      DEBUG_PRINT2 ("    Popping reg: %d\n", this_reg);			\
../inputs/grep1.dat:									\
../inputs/grep1.dat:      reg_info[this_reg].word = POP_FAILURE_ITEM ();			\
../inputs/grep1.dat:      DEBUG_PRINT2 ("      info: 0x%x\n", reg_info[this_reg]);		\
../inputs/grep1.dat:									\
../inputs/grep1.dat:      regend[this_reg] = (const char *) POP_FAILURE_ITEM ();		\
../inputs/grep1.dat:      DEBUG_PRINT2 ("      end: 0x%x\n", regend[this_reg]);		\
../inputs/grep1.dat:									\
../inputs/grep1.dat:      regstart[this_reg] = (const char *) POP_FAILURE_ITEM ();		\
../inputs/grep1.dat:      DEBUG_PRINT2 ("      start: 0x%x\n", regstart[this_reg]);		\
../inputs/grep1.dat:    }									\
../inputs/grep1.dat:									\
../inputs/grep1.dat:  DEBUG_STATEMENT (nfailure_points_popped++);				\
../inputs/grep1.dat:} /* POP_FAILURE_POINT */
../inputs/grep1.dat:
../inputs/grep1.dat:/* re_compile_fastmap computes a ``fastmap'' for the compiled pattern in
../inputs/grep1.dat:   BUFP.  A fastmap records which of the (1 << BYTEWIDTH) possible
../inputs/grep1.dat:   characters can start a string that matches the pattern.  This fastmap
../inputs/grep1.dat:   is used by re_search to skip quickly over impossible starting points.
../inputs/grep1.dat:
../inputs/grep1.dat:   The caller must supply the address of a (1 << BYTEWIDTH)-byte data
../inputs/grep1.dat:   area as BUFP->fastmap.
../inputs/grep1.dat:   
../inputs/grep1.dat:   We set the `fastmap', `fastmap_accurate', and `can_be_null' fields in
../inputs/grep1.dat:   the pattern buffer.
../inputs/grep1.dat:
../inputs/grep1.dat:   Returns 0 if we succeed, -2 if an internal error.   */
../inputs/grep1.dat:
../inputs/grep1.dat:int
../inputs/grep1.dat:re_compile_fastmap (bufp)
../inputs/grep1.dat:     struct re_pattern_buffer *bufp;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int j, k;
../inputs/grep1.dat:  fail_stack_type fail_stack;
../inputs/grep1.dat:#ifndef REGEX_MALLOC
../inputs/grep1.dat:  char *destination;
../inputs/grep1.dat:#endif
../inputs/grep1.dat:  /* We don't push any register information onto the failure stack.  */
../inputs/grep1.dat:  unsigned num_regs = 0;
../inputs/grep1.dat:  
../inputs/grep1.dat:  register char *fastmap = bufp->fastmap;
../inputs/grep1.dat:  unsigned char *pattern = bufp->buffer;
../inputs/grep1.dat:  unsigned long size = bufp->used;
../inputs/grep1.dat:  const unsigned char *p = pattern;
../inputs/grep1.dat:  register unsigned char *pend = pattern + size;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Assume that each path through the pattern can be null until
../inputs/grep1.dat:     proven otherwise.  We set this false at the bottom of switch
../inputs/grep1.dat:     statement, to which we get only if a particular path doesn't
../inputs/grep1.dat:     match the empty string.  */
../inputs/grep1.dat:  boolean path_can_be_null = true;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* We aren't doing a `succeed_n' to begin with.  */
../inputs/grep1.dat:  boolean succeed_n_p = false;
../inputs/grep1.dat:
../inputs/grep1.dat:  assert (fastmap != NULL && p != NULL);
../inputs/grep1.dat:  
../inputs/grep1.dat:  INIT_FAIL_STACK ();
../inputs/grep1.dat:  bzero (fastmap, 1 << BYTEWIDTH);  /* Assume nothing's valid.  */
../inputs/grep1.dat:  bufp->fastmap_accurate = 1;	    /* It will be when we're done.  */
../inputs/grep1.dat:  bufp->can_be_null = 0;
../inputs/grep1.dat:      
../inputs/grep1.dat:  while (p != pend || !FAIL_STACK_EMPTY ())
../inputs/grep1.dat:    {
../inputs/grep1.dat:      if (p == pend)
../inputs/grep1.dat:        {
../inputs/grep1.dat:          bufp->can_be_null |= path_can_be_null;
../inputs/grep1.dat:          
../inputs/grep1.dat:          /* Reset for next path.  */
../inputs/grep1.dat:          path_can_be_null = true;
../inputs/grep1.dat:          
../inputs/grep1.dat:          p = fail_stack.stack[--fail_stack.avail];
../inputs/grep1.dat:	}
../inputs/grep1.dat:
../inputs/grep1.dat:      /* We should never be about to go beyond the end of the pattern.  */
../inputs/grep1.dat:      assert (p < pend);
../inputs/grep1.dat:      
../inputs/grep1.dat:#ifdef SWITCH_ENUM_BUG
../inputs/grep1.dat:      switch ((int) ((re_opcode_t) *p++))
../inputs/grep1.dat:#else
../inputs/grep1.dat:      switch ((re_opcode_t) *p++)
../inputs/grep1.dat:#endif
../inputs/grep1.dat:	{
../inputs/grep1.dat:
../inputs/grep1.dat:        /* I guess the idea here is to simply not bother with a fastmap
../inputs/grep1.dat:           if a backreference is used, since it's too hard to figure out
../inputs/grep1.dat:           the fastmap for the corresponding group.  Setting
../inputs/grep1.dat:           `can_be_null' stops `re_search_2' from using the fastmap, so
../inputs/grep1.dat:           that is all we do.  */
../inputs/grep1.dat:	case duplicate:
../inputs/grep1.dat:	  bufp->can_be_null = 1;
../inputs/grep1.dat:          return 0;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:      /* Following are the cases which match a character.  These end
../inputs/grep1.dat:         with `break'.  */
../inputs/grep1.dat:
../inputs/grep1.dat:	case exactn:
../inputs/grep1.dat:          fastmap[p[1]] = 1;
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:        case charset:
../inputs/grep1.dat:          for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
../inputs/grep1.dat:	    if (p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH)))
../inputs/grep1.dat:              fastmap[j] = 1;
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:	case charset_not:
../inputs/grep1.dat:	  /* Chars beyond end of map must be allowed.  */
../inputs/grep1.dat:	  for (j = *p * BYTEWIDTH; j < (1 << BYTEWIDTH); j++)
../inputs/grep1.dat:            fastmap[j] = 1;
../inputs/grep1.dat:
../inputs/grep1.dat:	  for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
../inputs/grep1.dat:	    if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))))
../inputs/grep1.dat:              fastmap[j] = 1;
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:	case wordchar:
../inputs/grep1.dat:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
../inputs/grep1.dat:	    if (SYNTAX (j) == Sword)
../inputs/grep1.dat:	      fastmap[j] = 1;
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:	case notwordchar:
../inputs/grep1.dat:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
../inputs/grep1.dat:	    if (SYNTAX (j) != Sword)
../inputs/grep1.dat:	      fastmap[j] = 1;
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:        case anychar:
../inputs/grep1.dat:          /* `.' matches anything ...  */
../inputs/grep1.dat:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
../inputs/grep1.dat:            fastmap[j] = 1;
../inputs/grep1.dat:
../inputs/grep1.dat:          /* ... except perhaps newline.  */
../inputs/grep1.dat:          if (!(bufp->syntax & RE_DOT_NEWLINE))
../inputs/grep1.dat:            fastmap['\n'] = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:          /* Return if we have already set `can_be_null'; if we have,
../inputs/grep1.dat:             then the fastmap is irrelevant.  Something's wrong here.  */
../inputs/grep1.dat:	  else if (bufp->can_be_null)
../inputs/grep1.dat:	    return 0;
../inputs/grep1.dat:
../inputs/grep1.dat:          /* Otherwise, have to check alternative paths.  */
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef emacs
../inputs/grep1.dat:        case syntaxspec:
../inputs/grep1.dat:	  k = *p++;
../inputs/grep1.dat:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
../inputs/grep1.dat:	    if (SYNTAX (j) == (enum syntaxcode) k)
../inputs/grep1.dat:	      fastmap[j] = 1;
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:	case notsyntaxspec:
../inputs/grep1.dat:	  k = *p++;
../inputs/grep1.dat:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
../inputs/grep1.dat:	    if (SYNTAX (j) != (enum syntaxcode) k)
../inputs/grep1.dat:	      fastmap[j] = 1;
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:      /* All cases after this match the empty string.  These end with
../inputs/grep1.dat:         `continue'.  */
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:	case before_dot:
../inputs/grep1.dat:	case at_dot:
../inputs/grep1.dat:	case after_dot:
../inputs/grep1.dat:          continue;
../inputs/grep1.dat:#endif /* not emacs */
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:        case no_op:
../inputs/grep1.dat:        case begline:
../inputs/grep1.dat:        case endline:
../inputs/grep1.dat:	case begbuf:
../inputs/grep1.dat:	case endbuf:
../inputs/grep1.dat:	case wordbound:
../inputs/grep1.dat:	case notwordbound:
../inputs/grep1.dat:	case wordbeg:
../inputs/grep1.dat:	case wordend:
../inputs/grep1.dat:        case push_dummy_failure:
../inputs/grep1.dat:          continue;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:	case jump_n:
../inputs/grep1.dat:        case pop_failure_jump:
../inputs/grep1.dat:	case maybe_pop_jump:
../inputs/grep1.dat:	case jump:
../inputs/grep1.dat:        case jump_past_alt:
../inputs/grep1.dat:	case dummy_failure_jump:
../inputs/grep1.dat:          EXTRACT_NUMBER_AND_INCR (j, p);
../inputs/grep1.dat:	  p += j;	
../inputs/grep1.dat:	  if (j > 0)
../inputs/grep1.dat:	    continue;
../inputs/grep1.dat:            
../inputs/grep1.dat:          /* Jump backward implies we just went through the body of a
../inputs/grep1.dat:             loop and matched nothing.  Opcode jumped to should be
../inputs/grep1.dat:             `on_failure_jump' or `succeed_n'.  Just treat it like an
../inputs/grep1.dat:             ordinary jump.  For a * loop, it has pushed its failure
../inputs/grep1.dat:             point already; if so, discard that as redundant.  */
../inputs/grep1.dat:          if ((re_opcode_t) *p != on_failure_jump
../inputs/grep1.dat:	      && (re_opcode_t) *p != succeed_n)
../inputs/grep1.dat:	    continue;
../inputs/grep1.dat:
../inputs/grep1.dat:          p++;
../inputs/grep1.dat:          EXTRACT_NUMBER_AND_INCR (j, p);
../inputs/grep1.dat:          p += j;		
../inputs/grep1.dat:	  
../inputs/grep1.dat:          /* If what's on the stack is where we are now, pop it.  */
../inputs/grep1.dat:          if (!FAIL_STACK_EMPTY () 
../inputs/grep1.dat:	      && fail_stack.stack[fail_stack.avail - 1] == p)
../inputs/grep1.dat:            fail_stack.avail--;
../inputs/grep1.dat:
../inputs/grep1.dat:          continue;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:        case on_failure_jump:
../inputs/grep1.dat:        case on_failure_keep_string_jump:
../inputs/grep1.dat:	handle_on_failure_jump:
../inputs/grep1.dat:          EXTRACT_NUMBER_AND_INCR (j, p);
../inputs/grep1.dat:
../inputs/grep1.dat:          /* For some patterns, e.g., `(a?)?', `p+j' here points to the
../inputs/grep1.dat:             end of the pattern.  We don't want to push such a point,
../inputs/grep1.dat:             since when we restore it above, entering the switch will
../inputs/grep1.dat:             increment `p' past the end of the pattern.  We don't need
../inputs/grep1.dat:             to push such a point since we obviously won't find any more
../inputs/grep1.dat:             fastmap entries beyond `pend'.  Such a pattern can match
../inputs/grep1.dat:             the null string, though.  */
../inputs/grep1.dat:          if (p + j < pend)
../inputs/grep1.dat:            {
../inputs/grep1.dat:              if (!PUSH_PATTERN_OP (p + j, fail_stack))
../inputs/grep1.dat:                return -2;
../inputs/grep1.dat:            }
../inputs/grep1.dat:          else
../inputs/grep1.dat:            bufp->can_be_null = 1;
../inputs/grep1.dat:
../inputs/grep1.dat:          if (succeed_n_p)
../inputs/grep1.dat:            {
../inputs/grep1.dat:              EXTRACT_NUMBER_AND_INCR (k, p);	/* Skip the n.  */
../inputs/grep1.dat:              succeed_n_p = false;
../inputs/grep1.dat:	    }
../inputs/grep1.dat:
../inputs/grep1.dat:          continue;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:	case succeed_n:
../inputs/grep1.dat:          /* Get to the number of times to succeed.  */
../inputs/grep1.dat:          p += 2;		
../inputs/grep1.dat:
../inputs/grep1.dat:          /* Increment p past the n for when k != 0.  */
../inputs/grep1.dat:          EXTRACT_NUMBER_AND_INCR (k, p);
../inputs/grep1.dat:          if (k == 0)
../inputs/grep1.dat:	    {
../inputs/grep1.dat:              p -= 4;
../inputs/grep1.dat:  	      succeed_n_p = true;  /* Spaghetti code alert.  */
../inputs/grep1.dat:              goto handle_on_failure_jump;
../inputs/grep1.dat:            }
../inputs/grep1.dat:          continue;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:	case set_number_at:
../inputs/grep1.dat:          p += 4;
../inputs/grep1.dat:          continue;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:	case start_memory:
../inputs/grep1.dat:        case stop_memory:
../inputs/grep1.dat:	  p += 2;
../inputs/grep1.dat:	  continue;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:	default:
../inputs/grep1.dat:          abort (); /* We have listed all the cases.  */
../inputs/grep1.dat:        } /* switch *p++ */
../inputs/grep1.dat:
../inputs/grep1.dat:      /* Getting here means we have found the possible starting
../inputs/grep1.dat:         characters for one path of the pattern -- and that the empty
../inputs/grep1.dat:         string does not match.  We need not follow this path further.
../inputs/grep1.dat:         Instead, look at the next alternative (remembered on the
../inputs/grep1.dat:         stack), or quit if no more.  The test at the top of the loop
../inputs/grep1.dat:         does these things.  */
../inputs/grep1.dat:      path_can_be_null = false;
../inputs/grep1.dat:      p = pend;
../inputs/grep1.dat:    } /* while p */
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Set `can_be_null' for the last path (also the first path, if the
../inputs/grep1.dat:     pattern is empty).  */
../inputs/grep1.dat:  bufp->can_be_null |= path_can_be_null;
../inputs/grep1.dat:  return 0;
../inputs/grep1.dat:} /* re_compile_fastmap */
../inputs/grep1.dat:
../inputs/grep1.dat:/* Set REGS to hold NUM_REGS registers, storing them in STARTS and
../inputs/grep1.dat:   ENDS.  Subsequent matches using PATTERN_BUFFER and REGS will use
../inputs/grep1.dat:   this memory for recording register information.  STARTS and ENDS
../inputs/grep1.dat:   must be allocated using the malloc library routine, and must each
../inputs/grep1.dat:   be at least NUM_REGS * sizeof (regoff_t) bytes long.
../inputs/grep1.dat:
../inputs/grep1.dat:   If NUM_REGS == 0, then subsequent matches should allocate their own
../inputs/grep1.dat:   register data.
../inputs/grep1.dat:
../inputs/grep1.dat:   Unless this function is called, the first search or match using
../inputs/grep1.dat:   PATTERN_BUFFER will allocate its own register data, without
../inputs/grep1.dat:   freeing the old data.  */
../inputs/grep1.dat:
../inputs/grep1.dat:void
../inputs/grep1.dat:re_set_registers (bufp, regs, num_regs, starts, ends)
../inputs/grep1.dat:    struct re_pattern_buffer *bufp;
../inputs/grep1.dat:    struct re_registers *regs;
../inputs/grep1.dat:    unsigned num_regs;
../inputs/grep1.dat:    regoff_t *starts, *ends;
../inputs/grep1.dat:{
../inputs/grep1.dat:  if (num_regs)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      bufp->regs_allocated = REGS_REALLOCATE;
../inputs/grep1.dat:      regs->num_regs = num_regs;
../inputs/grep1.dat:      regs->start = starts;
../inputs/grep1.dat:      regs->end = ends;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  else
../inputs/grep1.dat:    {
../inputs/grep1.dat:      bufp->regs_allocated = REGS_UNALLOCATED;
../inputs/grep1.dat:      regs->num_regs = 0;
../inputs/grep1.dat:      regs->start = regs->end = (regoff_t) 0;
../inputs/grep1.dat:    }
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Searching routines.  */
../inputs/grep1.dat:
../inputs/grep1.dat:/* Like re_search_2, below, but only one string is specified, and
../inputs/grep1.dat:   doesn't let you say where to stop matching. */
../inputs/grep1.dat:
../inputs/grep1.dat:int
../inputs/grep1.dat:re_search (bufp, string, size, startpos, range, regs)
../inputs/grep1.dat:     struct re_pattern_buffer *bufp;
../inputs/grep1.dat:     const char *string;
../inputs/grep1.dat:     int size, startpos, range;
../inputs/grep1.dat:     struct re_registers *regs;
../inputs/grep1.dat:{
../inputs/grep1.dat:  return re_search_2 (bufp, NULL, 0, string, size, startpos, range, 
../inputs/grep1.dat:		      regs, size);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Using the compiled pattern in BUFP->buffer, first tries to match the
../inputs/grep1.dat:   virtual concatenation of STRING1 and STRING2, starting first at index
../inputs/grep1.dat:   STARTPOS, then at STARTPOS + 1, and so on.
../inputs/grep1.dat:   
../inputs/grep1.dat:   STRING1 and STRING2 have length SIZE1 and SIZE2, respectively.
../inputs/grep1.dat:   
../inputs/grep1.dat:   RANGE is how far to scan while trying to match.  RANGE = 0 means try
../inputs/grep1.dat:   only at STARTPOS; in general, the last start tried is STARTPOS +
../inputs/grep1.dat:   RANGE.
../inputs/grep1.dat:   
../inputs/grep1.dat:   In REGS, return the indices of the virtual concatenation of STRING1
../inputs/grep1.dat:   and STRING2 that matched the entire BUFP->buffer and its contained
../inputs/grep1.dat:   subexpressions.
../inputs/grep1.dat:   
../inputs/grep1.dat:   Do not consider matching one past the index STOP in the virtual
../inputs/grep1.dat:   concatenation of STRING1 and STRING2.
../inputs/grep1.dat:
../inputs/grep1.dat:   We return either the position in the strings at which the match was
../inputs/grep1.dat:   found, -1 if no match, or -2 if error (such as failure
../inputs/grep1.dat:   stack overflow).  */
../inputs/grep1.dat:
../inputs/grep1.dat:int
../inputs/grep1.dat:re_search_2 (bufp, string1, size1, string2, size2, startpos, range, regs, stop)
../inputs/grep1.dat:     struct re_pattern_buffer *bufp;
../inputs/grep1.dat:     const char *string1, *string2;
../inputs/grep1.dat:     int size1, size2;
../inputs/grep1.dat:     int startpos;
../inputs/grep1.dat:     int range;
../inputs/grep1.dat:     struct re_registers *regs;
../inputs/grep1.dat:     int stop;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int val;
../inputs/grep1.dat:  register char *fastmap = bufp->fastmap;
../inputs/grep1.dat:  register char *translate = bufp->translate;
../inputs/grep1.dat:  int total_size = size1 + size2;
../inputs/grep1.dat:  int endpos = startpos + range;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Check for out-of-range STARTPOS.  */
../inputs/grep1.dat:  if (startpos < 0 || startpos > total_size)
../inputs/grep1.dat:    return -1;
../inputs/grep1.dat:    
../inputs/grep1.dat:  /* Fix up RANGE if it might eventually take us outside
../inputs/grep1.dat:     the virtual concatenation of STRING1 and STRING2.  */
../inputs/grep1.dat:  if (endpos < -1)
../inputs/grep1.dat:    range = -1 - startpos;
../inputs/grep1.dat:  else if (endpos > total_size)
../inputs/grep1.dat:    range = total_size - startpos;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* If the search isn't to be a backwards one, don't waste time in a
../inputs/grep1.dat:     search for a pattern that must be anchored.  */
../inputs/grep1.dat:  if (bufp->used > 0 && (re_opcode_t) bufp->buffer[0] == begbuf && range > 0)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      if (startpos > 0)
../inputs/grep1.dat:	return -1;
../inputs/grep1.dat:      else
../inputs/grep1.dat:	range = 1;
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Update the fastmap now if not correct already.  */
../inputs/grep1.dat:  if (fastmap && !bufp->fastmap_accurate)
../inputs/grep1.dat:    if (re_compile_fastmap (bufp) == -2)
../inputs/grep1.dat:      return -2;
../inputs/grep1.dat:  
../inputs/grep1.dat:  /* Loop through the string, looking for a place to start matching.  */
../inputs/grep1.dat:  for (;;)
../inputs/grep1.dat:    { 
../inputs/grep1.dat:      /* If a fastmap is supplied, skip quickly over characters that
../inputs/grep1.dat:         cannot be the start of a match.  If the pattern can match the
../inputs/grep1.dat:         null string, however, we don't need to skip characters; we want
../inputs/grep1.dat:         the first null string.  */
../inputs/grep1.dat:      if (fastmap && startpos < total_size && !bufp->can_be_null)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  if (range > 0)	/* Searching forwards.  */
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      register const char *d;
../inputs/grep1.dat:	      register int lim = 0;
../inputs/grep1.dat:	      int irange = range;
../inputs/grep1.dat:
../inputs/grep1.dat:              if (startpos < size1 && startpos + range >= size1)
../inputs/grep1.dat:                lim = range - (size1 - startpos);
../inputs/grep1.dat:
../inputs/grep1.dat:	      d = (startpos >= size1 ? string2 - size1 : string1) + startpos;
../inputs/grep1.dat:   
../inputs/grep1.dat:              /* Written out as an if-else to avoid testing `translate'
../inputs/grep1.dat:                 inside the loop.  */
../inputs/grep1.dat:	      if (translate)
../inputs/grep1.dat:                while (range > lim
../inputs/grep1.dat:                       && !fastmap[(unsigned char)
../inputs/grep1.dat:				   translate[(unsigned char) *d++]])
../inputs/grep1.dat:                  range--;
../inputs/grep1.dat:	      else
../inputs/grep1.dat:                while (range > lim && !fastmap[(unsigned char) *d++])
../inputs/grep1.dat:                  range--;
../inputs/grep1.dat:
../inputs/grep1.dat:	      startpos += irange - range;
../inputs/grep1.dat:	    }
../inputs/grep1.dat:	  else				/* Searching backwards.  */
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      register char c = (size1 == 0 || startpos >= size1
../inputs/grep1.dat:                                 ? string2[startpos - size1] 
../inputs/grep1.dat:                                 : string1[startpos]);
../inputs/grep1.dat:
../inputs/grep1.dat:	      if (!fastmap[(unsigned char) TRANSLATE (c)])
../inputs/grep1.dat:		goto advance;
../inputs/grep1.dat:	    }
../inputs/grep1.dat:	}
../inputs/grep1.dat:
../inputs/grep1.dat:      /* If can't match the null string, and that's all we have left, fail.  */
../inputs/grep1.dat:      if (range >= 0 && startpos == total_size && fastmap
../inputs/grep1.dat:          && !bufp->can_be_null)
../inputs/grep1.dat:	return -1;
../inputs/grep1.dat:
../inputs/grep1.dat:      val = re_match_2 (bufp, string1, size1, string2, size2,
../inputs/grep1.dat:	                startpos, regs, stop);
../inputs/grep1.dat:      if (val >= 0)
../inputs/grep1.dat:	return startpos;
../inputs/grep1.dat:        
../inputs/grep1.dat:      if (val == -2)
../inputs/grep1.dat:	return -2;
../inputs/grep1.dat:
../inputs/grep1.dat:    advance:
../inputs/grep1.dat:      if (!range) 
../inputs/grep1.dat:        break;
../inputs/grep1.dat:      else if (range > 0) 
../inputs/grep1.dat:        {
../inputs/grep1.dat:          range--; 
../inputs/grep1.dat:          startpos++;
../inputs/grep1.dat:        }
../inputs/grep1.dat:      else
../inputs/grep1.dat:        {
../inputs/grep1.dat:          range++; 
../inputs/grep1.dat:          startpos--;
../inputs/grep1.dat:        }
../inputs/grep1.dat:    }
../inputs/grep1.dat:  return -1;
../inputs/grep1.dat:} /* re_search_2 */
../inputs/grep1.dat:
../inputs/grep1.dat:/* Declarations and macros for re_match_2.  */
../inputs/grep1.dat:
../inputs/grep1.dat:static int bcmp_translate ();
../inputs/grep1.dat:static boolean alt_match_null_string_p (),
../inputs/grep1.dat:               common_op_match_null_string_p (),
../inputs/grep1.dat:               group_match_null_string_p ();
../inputs/grep1.dat:
../inputs/grep1.dat:/* Structure for per-register (a.k.a. per-group) information.
../inputs/grep1.dat:   This must not be longer than one word, because we push this value
../inputs/grep1.dat:   onto the failure stack.  Other register information, such as the
../inputs/grep1.dat:   starting and ending positions (which are addresses), and the list of
../inputs/grep1.dat:   inner groups (which is a bits list) are maintained in separate
../inputs/grep1.dat:   variables.  
../inputs/grep1.dat:   
../inputs/grep1.dat:   We are making a (strictly speaking) nonportable assumption here: that
../inputs/grep1.dat:   the compiler will pack our bit fields into something that fits into
../inputs/grep1.dat:   the type of `word', i.e., is something that fits into one item on the
../inputs/grep1.dat:   failure stack.  */
../inputs/grep1.dat:typedef union
../inputs/grep1.dat:{
../inputs/grep1.dat:  fail_stack_elt_t word;
../inputs/grep1.dat:  struct
../inputs/grep1.dat:  {
../inputs/grep1.dat:      /* This field is one if this group can match the empty string,
../inputs/grep1.dat:         zero if not.  If not yet determined,  `MATCH_NULL_UNSET_VALUE'.  */
../inputs/grep1.dat:#define MATCH_NULL_UNSET_VALUE 3
../inputs/grep1.dat:    unsigned match_null_string_p : 2;
../inputs/grep1.dat:    unsigned is_active : 1;
../inputs/grep1.dat:    unsigned matched_something : 1;
../inputs/grep1.dat:    unsigned ever_matched_something : 1;
../inputs/grep1.dat:  } bits;
../inputs/grep1.dat:} register_info_type;
../inputs/grep1.dat:
../inputs/grep1.dat:#define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)
../inputs/grep1.dat:#define IS_ACTIVE(R)  ((R).bits.is_active)
../inputs/grep1.dat:#define MATCHED_SOMETHING(R)  ((R).bits.matched_something)
../inputs/grep1.dat:#define EVER_MATCHED_SOMETHING(R)  ((R).bits.ever_matched_something)
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Call this when have matched a real character; it sets `matched' flags
../inputs/grep1.dat:   for the subexpressions which we are currently inside.  Also records
../inputs/grep1.dat:   that those subexprs have matched.  */
../inputs/grep1.dat:#define SET_REGS_MATCHED()						\
../inputs/grep1.dat:  do									\
../inputs/grep1.dat:    {									\
../inputs/grep1.dat:      unsigned r;							\
../inputs/grep1.dat:      for (r = lowest_active_reg; r <= highest_active_reg; r++)		\
../inputs/grep1.dat:        {								\
../inputs/grep1.dat:          MATCHED_SOMETHING (reg_info[r])				\
../inputs/grep1.dat:            = EVER_MATCHED_SOMETHING (reg_info[r])			\
../inputs/grep1.dat:            = 1;							\
../inputs/grep1.dat:        }								\
../inputs/grep1.dat:    }									\
../inputs/grep1.dat:  while (0)
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* This converts PTR, a pointer into one of the search strings `string1'
../inputs/grep1.dat:   and `string2' into an offset from the beginning of that string.  */
../inputs/grep1.dat:#define POINTER_TO_OFFSET(ptr)						\
../inputs/grep1.dat:  (FIRST_STRING_P (ptr) ? (ptr) - string1 : (ptr) - string2 + size1)
../inputs/grep1.dat:
../inputs/grep1.dat:/* Registers are set to a sentinel when they haven't yet matched.  */
../inputs/grep1.dat:#define REG_UNSET_VALUE ((char *) -1)
../inputs/grep1.dat:#define REG_UNSET(e) ((e) == REG_UNSET_VALUE)
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Macros for dealing with the split strings in re_match_2.  */
../inputs/grep1.dat:
../inputs/grep1.dat:#define MATCHING_IN_FIRST_STRING  (dend == end_match_1)
../inputs/grep1.dat:
../inputs/grep1.dat:/* Call before fetching a character with *d.  This switches over to
../inputs/grep1.dat:   string2 if necessary.  */
../inputs/grep1.dat:#define PREFETCH()							\
../inputs/grep1.dat:  while (d == dend)						    	\
../inputs/grep1.dat:    {									\
../inputs/grep1.dat:      /* End of string2 => fail.  */					\
../inputs/grep1.dat:      if (dend == end_match_2) 						\
../inputs/grep1.dat:        goto fail;							\
../inputs/grep1.dat:      /* End of string1 => advance to string2.  */ 			\
../inputs/grep1.dat:      d = string2;						        \
../inputs/grep1.dat:      dend = end_match_2;						\
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Test if at very beginning or at very end of the virtual concatenation
../inputs/grep1.dat:   of `string1' and `string2'.  If only one string, it's `string2'.  */
../inputs/grep1.dat:#define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)
../inputs/grep1.dat:#define AT_STRINGS_END(d) ((d) == end2)	
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Test if D points to a character which is word-constituent.  We have
../inputs/grep1.dat:   two special cases to check for: if past the end of string1, look at
../inputs/grep1.dat:   the first character in string2; and if before the beginning of
../inputs/grep1.dat:   string2, look at the last character in string1.  */
../inputs/grep1.dat:#define WORDCHAR_P(d)							\
../inputs/grep1.dat:  (SYNTAX ((d) == end1 ? *string2					\
../inputs/grep1.dat:           : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\
../inputs/grep1.dat:   == Sword)
../inputs/grep1.dat:
../inputs/grep1.dat:/* Test if the character before D and the one at D differ with respect
../inputs/grep1.dat:   to being word-constituent.  */
../inputs/grep1.dat:#define AT_WORD_BOUNDARY(d)						\
../inputs/grep1.dat:  (AT_STRINGS_BEG (d) || AT_STRINGS_END (d)				\
../inputs/grep1.dat:   || WORDCHAR_P (d - 1) != WORDCHAR_P (d))
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Free everything we malloc.  */
../inputs/grep1.dat:#ifdef REGEX_MALLOC
../inputs/grep1.dat:#define FREE_VAR(var) if (var) free (var); var = NULL
../inputs/grep1.dat:#define FREE_VARIABLES()						\
../inputs/grep1.dat:  do {									\
../inputs/grep1.dat:    FREE_VAR (fail_stack.stack);					\
../inputs/grep1.dat:    FREE_VAR (regstart);						\
../inputs/grep1.dat:    FREE_VAR (regend);							\
../inputs/grep1.dat:    FREE_VAR (old_regstart);						\
../inputs/grep1.dat:    FREE_VAR (old_regend);						\
../inputs/grep1.dat:    FREE_VAR (best_regstart);						\
../inputs/grep1.dat:    FREE_VAR (best_regend);						\
../inputs/grep1.dat:    FREE_VAR (reg_info);						\
../inputs/grep1.dat:    FREE_VAR (reg_dummy);						\
../inputs/grep1.dat:    FREE_VAR (reg_info_dummy);						\
../inputs/grep1.dat:  } while (0)
../inputs/grep1.dat:#else /* not REGEX_MALLOC */
../inputs/grep1.dat:/* Some MIPS systems (at least) want this to free alloca'd storage.  */
../inputs/grep1.dat:#define FREE_VARIABLES() alloca (0)
../inputs/grep1.dat:#endif /* not REGEX_MALLOC */
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* These values must meet several constraints.  They must not be valid
../inputs/grep1.dat:   register values; since we have a limit of 255 registers (because
../inputs/grep1.dat:   we use only one byte in the pattern for the register number), we can
../inputs/grep1.dat:   use numbers larger than 255.  They must differ by 1, because of
../inputs/grep1.dat:   NUM_FAILURE_ITEMS above.  And the value for the lowest register must
../inputs/grep1.dat:   be larger than the value for the highest register, so we do not try
../inputs/grep1.dat:   to actually save any registers when none are active.  */
../inputs/grep1.dat:#define NO_HIGHEST_ACTIVE_REG (1 << BYTEWIDTH)
../inputs/grep1.dat:#define NO_LOWEST_ACTIVE_REG (NO_HIGHEST_ACTIVE_REG + 1)
../inputs/grep1.dat:
../inputs/grep1.dat:/* Matching routines.  */
../inputs/grep1.dat:
../inputs/grep1.dat:#ifndef emacs   /* Emacs never uses this.  */
../inputs/grep1.dat:/* re_match is like re_match_2 except it takes only a single string.  */
../inputs/grep1.dat:
../inputs/grep1.dat:int
../inputs/grep1.dat:re_match (bufp, string, size, pos, regs)
../inputs/grep1.dat:     struct re_pattern_buffer *bufp;
../inputs/grep1.dat:     const char *string;
../inputs/grep1.dat:     int size, pos;
../inputs/grep1.dat:     struct re_registers *regs;
../inputs/grep1.dat: {
../inputs/grep1.dat:  return re_match_2 (bufp, NULL, 0, string, size, pos, regs, size); 
../inputs/grep1.dat:}
../inputs/grep1.dat:#endif /* not emacs */
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* re_match_2 matches the compiled pattern in BUFP against the
../inputs/grep1.dat:   the (virtual) concatenation of STRING1 and STRING2 (of length SIZE1
../inputs/grep1.dat:   and SIZE2, respectively).  We start matching at POS, and stop
../inputs/grep1.dat:   matching at STOP.
../inputs/grep1.dat:   
../inputs/grep1.dat:   If REGS is non-null and the `no_sub' field of BUFP is nonzero, we
../inputs/grep1.dat:   store offsets for the substring each group matched in REGS.  See the
../inputs/grep1.dat:   documentation for exactly how many groups we fill.
../inputs/grep1.dat:
../inputs/grep1.dat:   We return -1 if no match, -2 if an internal error (such as the
../inputs/grep1.dat:   failure stack overflowing).  Otherwise, we return the length of the
../inputs/grep1.dat:   matched substring.  */
../inputs/grep1.dat:
../inputs/grep1.dat:int
../inputs/grep1.dat:re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
../inputs/grep1.dat:     struct re_pattern_buffer *bufp;
../inputs/grep1.dat:     const char *string1, *string2;
../inputs/grep1.dat:     int size1, size2;
../inputs/grep1.dat:     int pos;
../inputs/grep1.dat:     struct re_registers *regs;
../inputs/grep1.dat:     int stop;
../inputs/grep1.dat:{
../inputs/grep1.dat:  /* General temporaries.  */
../inputs/grep1.dat:  int mcnt;
../inputs/grep1.dat:  unsigned char *p1;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Just past the end of the corresponding string.  */
../inputs/grep1.dat:  const char *end1, *end2;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Pointers into string1 and string2, just past the last characters in
../inputs/grep1.dat:     each to consider matching.  */
../inputs/grep1.dat:  const char *end_match_1, *end_match_2;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Where we are in the data, and the end of the current string.  */
../inputs/grep1.dat:  const char *d, *dend;
../inputs/grep1.dat:  
../inputs/grep1.dat:  /* Where we are in the pattern, and the end of the pattern.  */
../inputs/grep1.dat:  unsigned char *p = bufp->buffer;
../inputs/grep1.dat:  register unsigned char *pend = p + bufp->used;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* We use this to map every character in the string.  */
../inputs/grep1.dat:  char *translate = bufp->translate;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Failure point stack.  Each place that can handle a failure further
../inputs/grep1.dat:     down the line pushes a failure point on this stack.  It consists of
../inputs/grep1.dat:     restart, regend, and reg_info for all registers corresponding to
../inputs/grep1.dat:     the subexpressions we're currently inside, plus the number of such
../inputs/grep1.dat:     registers, and, finally, two char *'s.  The first char * is where
../inputs/grep1.dat:     to resume scanning the pattern; the second one is where to resume
../inputs/grep1.dat:     scanning the strings.  If the latter is zero, the failure point is
../inputs/grep1.dat:     a ``dummy''; if a failure happens and the failure point is a dummy,
../inputs/grep1.dat:     it gets discarded and the next next one is tried.  */
../inputs/grep1.dat:  fail_stack_type fail_stack;
../inputs/grep1.dat:#ifdef DEBUG
../inputs/grep1.dat:  static unsigned failure_id = 0;
../inputs/grep1.dat:  unsigned nfailure_points_pushed = 0, nfailure_points_popped = 0;
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:  /* We fill all the registers internally, independent of what we
../inputs/grep1.dat:     an element for register zero.  */
../inputs/grep1.dat:  unsigned num_regs = bufp->re_nsub + 1;
../inputs/grep1.dat:  
../inputs/grep1.dat:  /* The currently active registers.  */
../inputs/grep1.dat:  unsigned lowest_active_reg = NO_LOWEST_ACTIVE_REG;
../inputs/grep1.dat:  unsigned highest_active_reg = NO_HIGHEST_ACTIVE_REG;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Information on the contents of registers. These are pointers into
../inputs/grep1.dat:     the input strings; they record just what was matched (on this
../inputs/grep1.dat:     attempt) by a subexpression part of the pattern, that is, the
../inputs/grep1.dat:     regnum-th regstart pointer points to where in the pattern we began
../inputs/grep1.dat:     matching and the regnum-th regend points to right after where we
../inputs/grep1.dat:     stopped matching the regnum-th subexpression.  (The zeroth register
../inputs/grep1.dat:     keeps track of what the whole pattern matches.)  */
../inputs/grep1.dat:  const char **regstart, **regend;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* If a group that's operated upon by a repetition operator fails to
../inputs/grep1.dat:     match anything, then the register for its start will need to be
../inputs/grep1.dat:     restored because it will have been set to wherever in the string we
../inputs/grep1.dat:     are when we last see its open-group operator.  Similarly for a
../inputs/grep1.dat:     register's end.  */
../inputs/grep1.dat:  const char **old_regstart, **old_regend;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* The is_active field of reg_info helps us keep track of which (possibly
../inputs/grep1.dat:     nested) subexpressions we are currently in. The matched_something
../inputs/grep1.dat:     field of reg_info[reg_num] helps us tell whether or not we have
../inputs/grep1.dat:     matched any of the pattern so far this time through the reg_num-th
../inputs/grep1.dat:     subexpression.  These two fields get reset each time through any
../inputs/grep1.dat:     loop their register is in.  */
../inputs/grep1.dat:  register_info_type *reg_info; 
../inputs/grep1.dat:
../inputs/grep1.dat:  /* The following record the register info as found in the above
../inputs/grep1.dat:     variables when we find a match better than any we've seen before. 
../inputs/grep1.dat:     This happens as we backtrack through the failure points, which in
../inputs/grep1.dat:     turn happens only if we have not yet matched the entire string. */
../inputs/grep1.dat:  unsigned best_regs_set = false;
../inputs/grep1.dat:  const char **best_regstart, **best_regend;
../inputs/grep1.dat:  
../inputs/grep1.dat:  /* Logically, this is `best_regend[0]'.  But we don't want to have to
../inputs/grep1.dat:     allocate space for that if we're not allocating space for anything
../inputs/grep1.dat:     else (see below).  Also, we never need info about register 0 for
../inputs/grep1.dat:     any of the other register vectors, and it seems rather a kludge to
../inputs/grep1.dat:     treat `best_regend' differently than the rest.  So we keep track of
../inputs/grep1.dat:     the end of the best match so far in a separate variable.  We
../inputs/grep1.dat:     initialize this to NULL so that when we backtrack the first time
../inputs/grep1.dat:     and need to test it, it's not garbage.  */
../inputs/grep1.dat:  const char *match_end = NULL;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Used when we pop values we don't care about.  */
../inputs/grep1.dat:  const char **reg_dummy;
../inputs/grep1.dat:  register_info_type *reg_info_dummy;
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef DEBUG
../inputs/grep1.dat:  /* Counts the total number of registers pushed.  */
../inputs/grep1.dat:  unsigned num_regs_pushed = 0; 	
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:  DEBUG_PRINT1 ("\n\nEntering re_match_2.\n");
../inputs/grep1.dat:  
../inputs/grep1.dat:  INIT_FAIL_STACK ();
../inputs/grep1.dat:  
../inputs/grep1.dat:  /* Do not bother to initialize all the register variables if there are
../inputs/grep1.dat:     no groups in the pattern, as it takes a fair amount of time.  If
../inputs/grep1.dat:     pattern), even though we never use it, since it simplifies the
../inputs/grep1.dat:     array indexing.  We should fix this.  */
../inputs/grep1.dat:  if (bufp->re_nsub)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      regstart = REGEX_TALLOC (num_regs, const char *);
../inputs/grep1.dat:      regend = REGEX_TALLOC (num_regs, const char *);
../inputs/grep1.dat:      old_regstart = REGEX_TALLOC (num_regs, const char *);
../inputs/grep1.dat:      old_regend = REGEX_TALLOC (num_regs, const char *);
../inputs/grep1.dat:      best_regstart = REGEX_TALLOC (num_regs, const char *);
../inputs/grep1.dat:      best_regend = REGEX_TALLOC (num_regs, const char *);
../inputs/grep1.dat:      reg_info = REGEX_TALLOC (num_regs, register_info_type);
../inputs/grep1.dat:      reg_dummy = REGEX_TALLOC (num_regs, const char *);
../inputs/grep1.dat:      reg_info_dummy = REGEX_TALLOC (num_regs, register_info_type);
../inputs/grep1.dat:
../inputs/grep1.dat:      if (!(regstart && regend && old_regstart && old_regend && reg_info 
../inputs/grep1.dat:            && best_regstart && best_regend && reg_dummy && reg_info_dummy)) 
../inputs/grep1.dat:        {
../inputs/grep1.dat:          FREE_VARIABLES ();
../inputs/grep1.dat:          return -2;
../inputs/grep1.dat:        }
../inputs/grep1.dat:    }
../inputs/grep1.dat:#ifdef REGEX_MALLOC
../inputs/grep1.dat:  else
../inputs/grep1.dat:    {
../inputs/grep1.dat:      /* We must initialize all our variables to NULL, so that
../inputs/grep1.dat:         `FREE_VARIABLES' doesn't try to free them.  */
../inputs/grep1.dat:      regstart = regend = old_regstart = old_regend = best_regstart
../inputs/grep1.dat:        = best_regend = reg_dummy = NULL;
../inputs/grep1.dat:      reg_info = reg_info_dummy = (register_info_type *) NULL;
../inputs/grep1.dat:    }
../inputs/grep1.dat:#endif /* REGEX_MALLOC */
../inputs/grep1.dat:
../inputs/grep1.dat:  /* The starting position is bogus.  */
../inputs/grep1.dat:  if (pos < 0 || pos > size1 + size2)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      FREE_VARIABLES ();
../inputs/grep1.dat:      return -1;
../inputs/grep1.dat:    }
../inputs/grep1.dat:    
../inputs/grep1.dat:  /* Initialize subexpression text positions to -1 to mark ones that no
../inputs/grep1.dat:     start_memory/stop_memory has been seen for. Also initialize the
../inputs/grep1.dat:     register information struct.  */
../inputs/grep1.dat:  for (mcnt = 1; mcnt < num_regs; mcnt++)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      regstart[mcnt] = regend[mcnt] 
../inputs/grep1.dat:        = old_regstart[mcnt] = old_regend[mcnt] = REG_UNSET_VALUE;
../inputs/grep1.dat:        
../inputs/grep1.dat:      REG_MATCH_NULL_STRING_P (reg_info[mcnt]) = MATCH_NULL_UNSET_VALUE;
../inputs/grep1.dat:      IS_ACTIVE (reg_info[mcnt]) = 0;
../inputs/grep1.dat:      MATCHED_SOMETHING (reg_info[mcnt]) = 0;
../inputs/grep1.dat:      EVER_MATCHED_SOMETHING (reg_info[mcnt]) = 0;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  
../inputs/grep1.dat:  /* We move `string1' into `string2' if the latter's empty -- but not if
../inputs/grep1.dat:     `string1' is null.  */
../inputs/grep1.dat:  if (size2 == 0 && string1 != NULL)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      string2 = string1;
../inputs/grep1.dat:      size2 = size1;
../inputs/grep1.dat:      string1 = 0;
../inputs/grep1.dat:      size1 = 0;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  end1 = string1 + size1;
../inputs/grep1.dat:  end2 = string2 + size2;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Compute where to stop matching, within the two strings.  */
../inputs/grep1.dat:  if (stop <= size1)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      end_match_1 = string1 + stop;
../inputs/grep1.dat:      end_match_2 = string2;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  else
../inputs/grep1.dat:    {
../inputs/grep1.dat:      end_match_1 = end1;
../inputs/grep1.dat:      end_match_2 = string2 + stop - size1;
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  /* `p' scans through the pattern as `d' scans through the data. 
../inputs/grep1.dat:     `dend' is the end of the input string that `d' points within.  `d'
../inputs/grep1.dat:     is advanced into the following input string whenever necessary, but
../inputs/grep1.dat:     this happens before fetching; therefore, at the beginning of the
../inputs/grep1.dat:     loop, `d' can be pointing at the end of a string, but it cannot
../inputs/grep1.dat:     equal `string2'.  */
../inputs/grep1.dat:  if (size1 > 0 && pos <= size1)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      d = string1 + pos;
../inputs/grep1.dat:      dend = end_match_1;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  else
../inputs/grep1.dat:    {
../inputs/grep1.dat:      d = string2 + pos - size1;
../inputs/grep1.dat:      dend = end_match_2;
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  DEBUG_PRINT1 ("The compiled pattern is: ");
../inputs/grep1.dat:  DEBUG_PRINT_COMPILED_PATTERN (bufp, p, pend);
../inputs/grep1.dat:  DEBUG_PRINT1 ("The string to match is: `");
../inputs/grep1.dat:  DEBUG_PRINT_DOUBLE_STRING (d, string1, size1, string2, size2);
../inputs/grep1.dat:  DEBUG_PRINT1 ("'\n");
../inputs/grep1.dat:  
../inputs/grep1.dat:  /* This loops over pattern commands.  It exits by returning from the
../inputs/grep1.dat:     function if the match is complete, or it drops through if the match
../inputs/grep1.dat:     fails at this starting point in the input data.  */
../inputs/grep1.dat:  for (;;)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      DEBUG_PRINT2 ("\n0x%x: ", p);
../inputs/grep1.dat:
../inputs/grep1.dat:      if (p == pend)
../inputs/grep1.dat:	{ /* End of pattern means we might have succeeded.  */
../inputs/grep1.dat:          DEBUG_PRINT1 ("end of pattern ... ");
../inputs/grep1.dat:          
../inputs/grep1.dat:	  /* If we haven't matched the entire string, and we want the
../inputs/grep1.dat:             longest match, try backtracking.  */
../inputs/grep1.dat:          if (d != end_match_2)
../inputs/grep1.dat:	    {
../inputs/grep1.dat:              DEBUG_PRINT1 ("backtracking.\n");
../inputs/grep1.dat:              
../inputs/grep1.dat:              if (!FAIL_STACK_EMPTY ())
../inputs/grep1.dat:                { /* More failure points to try.  */
../inputs/grep1.dat:                  boolean same_str_p = (FIRST_STRING_P (match_end) 
../inputs/grep1.dat:	        	                == MATCHING_IN_FIRST_STRING);
../inputs/grep1.dat:
../inputs/grep1.dat:                  /* If exceeds best match so far, save it.  */
../inputs/grep1.dat:                  if (!best_regs_set
../inputs/grep1.dat:                      || (same_str_p && d > match_end)
../inputs/grep1.dat:                      || (!same_str_p && !MATCHING_IN_FIRST_STRING))
../inputs/grep1.dat:                    {
../inputs/grep1.dat:                      best_regs_set = true;
../inputs/grep1.dat:                      match_end = d;
../inputs/grep1.dat:                      
../inputs/grep1.dat:                      DEBUG_PRINT1 ("\nSAVING match as best so far.\n");
../inputs/grep1.dat:                      
../inputs/grep1.dat:                      for (mcnt = 1; mcnt < num_regs; mcnt++)
../inputs/grep1.dat:                        {
../inputs/grep1.dat:                          best_regstart[mcnt] = regstart[mcnt];
../inputs/grep1.dat:                          best_regend[mcnt] = regend[mcnt];
../inputs/grep1.dat:                        }
../inputs/grep1.dat:                    }
../inputs/grep1.dat:                  goto fail;	       
../inputs/grep1.dat:                }
../inputs/grep1.dat:
../inputs/grep1.dat:              /* If no failure points, don't restore garbage.  */
../inputs/grep1.dat:              else if (best_regs_set)   
../inputs/grep1.dat:                {
../inputs/grep1.dat:  	        restore_best_regs:
../inputs/grep1.dat:                  /* Restore best match.  It may happen that `dend ==
../inputs/grep1.dat:                     end_match_1' while the restored d is in string2.
../inputs/grep1.dat:                     For example, the pattern `x.*y.*z' against the
../inputs/grep1.dat:                     strings `x-' and `y-z-', if the two strings are
../inputs/grep1.dat:                     not consecutive in memory.  */
../inputs/grep1.dat:                  DEBUG_PRINT1 ("Restoring best registers.\n");
../inputs/grep1.dat:                  
../inputs/grep1.dat:                  d = match_end;
../inputs/grep1.dat:                  dend = ((d >= string1 && d <= end1)
../inputs/grep1.dat:		           ? end_match_1 : end_match_2);
../inputs/grep1.dat:
../inputs/grep1.dat:		  for (mcnt = 1; mcnt < num_regs; mcnt++)
../inputs/grep1.dat:		    {
../inputs/grep1.dat:		      regstart[mcnt] = best_regstart[mcnt];
../inputs/grep1.dat:		      regend[mcnt] = best_regend[mcnt];
../inputs/grep1.dat:		    }
../inputs/grep1.dat:                }
../inputs/grep1.dat:            } /* d != end_match_2 */
../inputs/grep1.dat:
../inputs/grep1.dat:          DEBUG_PRINT1 ("Accepting match.\n");
../inputs/grep1.dat:
../inputs/grep1.dat:          /* If caller wants register contents data back, do it.  */
../inputs/grep1.dat:          if (regs && !bufp->no_sub)
../inputs/grep1.dat:	    {
../inputs/grep1.dat:              /* Have the register data arrays been allocated?  */
../inputs/grep1.dat:              if (bufp->regs_allocated == REGS_UNALLOCATED)
../inputs/grep1.dat:                { /* No.  So allocate them with malloc.  We need one
../inputs/grep1.dat:                     extra element beyond `num_regs' for the `-1' marker
../inputs/grep1.dat:                     GNU code uses.  */
../inputs/grep1.dat:                  regs->num_regs = MAX (RE_NREGS, num_regs + 1);
../inputs/grep1.dat:                  regs->start = TALLOC (regs->num_regs, regoff_t);
../inputs/grep1.dat:                  regs->end = TALLOC (regs->num_regs, regoff_t);
../inputs/grep1.dat:                  if (regs->start == NULL || regs->end == NULL)
../inputs/grep1.dat:                    return -2;
../inputs/grep1.dat:                  bufp->regs_allocated = REGS_REALLOCATE;
../inputs/grep1.dat:                }
../inputs/grep1.dat:              else if (bufp->regs_allocated == REGS_REALLOCATE)
../inputs/grep1.dat:                { /* Yes.  If we need more elements than were already
../inputs/grep1.dat:                     allocated, reallocate them.  If we need fewer, just
../inputs/grep1.dat:                     leave it alone.  */
../inputs/grep1.dat:                  if (regs->num_regs < num_regs + 1)
../inputs/grep1.dat:                    {
../inputs/grep1.dat:                      regs->num_regs = num_regs + 1;
../inputs/grep1.dat:                      RETALLOC (regs->start, regs->num_regs, regoff_t);
../inputs/grep1.dat:                      RETALLOC (regs->end, regs->num_regs, regoff_t);
../inputs/grep1.dat:                      if (regs->start == NULL || regs->end == NULL)
../inputs/grep1.dat:                        return -2;
../inputs/grep1.dat:                    }
../inputs/grep1.dat:                }
../inputs/grep1.dat:              else
../inputs/grep1.dat:		{
../inputs/grep1.dat:		  /* These braces fend off a "empty body in an else-statement"
../inputs/grep1.dat:		     warning under GCC when assert expands to nothing.  */
../inputs/grep1.dat:		  assert (bufp->regs_allocated == REGS_FIXED);
../inputs/grep1.dat:		}
../inputs/grep1.dat:
../inputs/grep1.dat:              /* Convert the pointer data in `regstart' and `regend' to
../inputs/grep1.dat:                 indices.  Register zero has to be set differently,
../inputs/grep1.dat:                 since we haven't kept track of any info for it.  */
../inputs/grep1.dat:              if (regs->num_regs > 0)
../inputs/grep1.dat:                {
../inputs/grep1.dat:                  regs->start[0] = pos;
../inputs/grep1.dat:                  regs->end[0] = (MATCHING_IN_FIRST_STRING ? d - string1
../inputs/grep1.dat:			          : d - string2 + size1);
../inputs/grep1.dat:                }
../inputs/grep1.dat:              
../inputs/grep1.dat:              /* Go through the first `min (num_regs, regs->num_regs)'
../inputs/grep1.dat:                 registers, since that is all we initialized.  */
../inputs/grep1.dat:	      for (mcnt = 1; mcnt < MIN (num_regs, regs->num_regs); mcnt++)
../inputs/grep1.dat:		{
../inputs/grep1.dat:                  if (REG_UNSET (regstart[mcnt]) || REG_UNSET (regend[mcnt]))
../inputs/grep1.dat:                    regs->start[mcnt] = regs->end[mcnt] = -1;
../inputs/grep1.dat:                  else
../inputs/grep1.dat:                    {
../inputs/grep1.dat:		      regs->start[mcnt] = POINTER_TO_OFFSET (regstart[mcnt]);
../inputs/grep1.dat:                      regs->end[mcnt] = POINTER_TO_OFFSET (regend[mcnt]);
../inputs/grep1.dat:                    }
../inputs/grep1.dat:		}
../inputs/grep1.dat:              
../inputs/grep1.dat:              /* If the regs structure we return has more elements than
../inputs/grep1.dat:                 were in the pattern, set the extra elements to -1.  If
../inputs/grep1.dat:                 we (re)allocated the registers, this is the case,
../inputs/grep1.dat:                 because we always allocate enough to have at least one
../inputs/grep1.dat:                 -1 at the end.  */
../inputs/grep1.dat:              for (mcnt = num_regs; mcnt < regs->num_regs; mcnt++)
../inputs/grep1.dat:                regs->start[mcnt] = regs->end[mcnt] = -1;
../inputs/grep1.dat:	    } /* regs && !bufp->no_sub */
../inputs/grep1.dat:
../inputs/grep1.dat:          FREE_VARIABLES ();
../inputs/grep1.dat:          DEBUG_PRINT4 ("%u failure points pushed, %u popped (%u remain).\n",
../inputs/grep1.dat:                        nfailure_points_pushed, nfailure_points_popped,
../inputs/grep1.dat:                        nfailure_points_pushed - nfailure_points_popped);
../inputs/grep1.dat:          DEBUG_PRINT2 ("%u registers pushed.\n", num_regs_pushed);
../inputs/grep1.dat:
../inputs/grep1.dat:          mcnt = d - pos - (MATCHING_IN_FIRST_STRING 
../inputs/grep1.dat:			    ? string1 
../inputs/grep1.dat:			    : string2 - size1);
../inputs/grep1.dat:
../inputs/grep1.dat:          DEBUG_PRINT2 ("Returning %d from re_match_2.\n", mcnt);
../inputs/grep1.dat:
../inputs/grep1.dat:          return mcnt;
../inputs/grep1.dat:        }
../inputs/grep1.dat:
../inputs/grep1.dat:      /* Otherwise match next pattern command.  */
../inputs/grep1.dat:#ifdef SWITCH_ENUM_BUG
../inputs/grep1.dat:      switch ((int) ((re_opcode_t) *p++))
../inputs/grep1.dat:#else
../inputs/grep1.dat:      switch ((re_opcode_t) *p++)
../inputs/grep1.dat:#endif
../inputs/grep1.dat:	{
../inputs/grep1.dat:        /* Ignore these.  Used to ignore the n of succeed_n's which
../inputs/grep1.dat:           currently have n == 0.  */
../inputs/grep1.dat:        case no_op:
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING no_op.\n");
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:        /* Match the next n pattern characters exactly.  The following
../inputs/grep1.dat:           byte in the pattern defines n, and the n bytes after that
../inputs/grep1.dat:           are the characters to match.  */
../inputs/grep1.dat:	case exactn:
../inputs/grep1.dat:	  mcnt = *p++;
../inputs/grep1.dat:          DEBUG_PRINT2 ("EXECUTING exactn %d.\n", mcnt);
../inputs/grep1.dat:
../inputs/grep1.dat:          /* This is written out as an if-else so we don't waste time
../inputs/grep1.dat:             testing `translate' inside the loop.  */
../inputs/grep1.dat:          if (translate)
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      do
../inputs/grep1.dat:		{
../inputs/grep1.dat:		  PREFETCH ();
../inputs/grep1.dat:		  if (translate[(unsigned char) *d++] != (char) *p++)
../inputs/grep1.dat:                    goto fail;
../inputs/grep1.dat:		}
../inputs/grep1.dat:	      while (--mcnt);
../inputs/grep1.dat:	    }
../inputs/grep1.dat:	  else
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      do
../inputs/grep1.dat:		{
../inputs/grep1.dat:		  PREFETCH ();
../inputs/grep1.dat:		  if (*d++ != (char) *p++) goto fail;
../inputs/grep1.dat:		}
../inputs/grep1.dat:	      while (--mcnt);
../inputs/grep1.dat:	    }
../inputs/grep1.dat:	  SET_REGS_MATCHED ();
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:        /* Match any character except possibly a newline or a null.  */
../inputs/grep1.dat:	case anychar:
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING anychar.\n");
../inputs/grep1.dat:
../inputs/grep1.dat:          PREFETCH ();
../inputs/grep1.dat:
../inputs/grep1.dat:          if ((!(bufp->syntax & RE_DOT_NEWLINE) && TRANSLATE (*d) == '\n')
../inputs/grep1.dat:              || (bufp->syntax & RE_DOT_NOT_NULL && TRANSLATE (*d) == '\000'))
../inputs/grep1.dat:	    goto fail;
../inputs/grep1.dat:
../inputs/grep1.dat:          SET_REGS_MATCHED ();
../inputs/grep1.dat:          DEBUG_PRINT2 ("  Matched `%d'.\n", *d);
../inputs/grep1.dat:          d++;
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:	case charset:
../inputs/grep1.dat:	case charset_not:
../inputs/grep1.dat:	  {
../inputs/grep1.dat:	    register unsigned char c;
../inputs/grep1.dat:	    boolean not = (re_opcode_t) *(p - 1) == charset_not;
../inputs/grep1.dat:
../inputs/grep1.dat:            DEBUG_PRINT2 ("EXECUTING charset%s.\n", not ? "_not" : "");
../inputs/grep1.dat:
../inputs/grep1.dat:	    PREFETCH ();
../inputs/grep1.dat:	    c = TRANSLATE (*d); /* The character to match.  */
../inputs/grep1.dat:
../inputs/grep1.dat:            /* Cast to `unsigned' instead of `unsigned char' in case the
../inputs/grep1.dat:               bit list is a full 32 bytes long.  */
../inputs/grep1.dat:	    if (c < (unsigned) (*p * BYTEWIDTH)
../inputs/grep1.dat:		&& p[1 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
../inputs/grep1.dat:	      not = !not;
../inputs/grep1.dat:
../inputs/grep1.dat:	    p += 1 + *p;
../inputs/grep1.dat:
../inputs/grep1.dat:	    if (!not) goto fail;
../inputs/grep1.dat:            
../inputs/grep1.dat:	    SET_REGS_MATCHED ();
../inputs/grep1.dat:            d++;
../inputs/grep1.dat:	    break;
../inputs/grep1.dat:	  }
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:        /* The beginning of a group is represented by start_memory.
../inputs/grep1.dat:           The arguments are the register number in the next byte, and the
../inputs/grep1.dat:           number of groups inner to this one in the next.  The text
../inputs/grep1.dat:           matched within the group is recorded (in the internal
../inputs/grep1.dat:           registers data structure) under the register number.  */
../inputs/grep1.dat:        case start_memory:
../inputs/grep1.dat:	  DEBUG_PRINT3 ("EXECUTING start_memory %d (%d):\n", *p, p[1]);
../inputs/grep1.dat:
../inputs/grep1.dat:          /* Find out if this group can match the empty string.  */
../inputs/grep1.dat:	  p1 = p;		/* To send to group_match_null_string_p.  */
../inputs/grep1.dat:          
../inputs/grep1.dat:          if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)
../inputs/grep1.dat:            REG_MATCH_NULL_STRING_P (reg_info[*p]) 
../inputs/grep1.dat:              = group_match_null_string_p (&p1, pend, reg_info);
../inputs/grep1.dat:
../inputs/grep1.dat:          /* Save the position in the string where we were the last time
../inputs/grep1.dat:             we were at this open-group operator in case the group is
../inputs/grep1.dat:             operated upon by a repetition operator, e.g., with `(a*)*b'
../inputs/grep1.dat:             against `ab'; then we want to ignore where we are now in
../inputs/grep1.dat:             the string in case this attempt to match fails.  */
../inputs/grep1.dat:          old_regstart[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
../inputs/grep1.dat:                             ? REG_UNSET (regstart[*p]) ? d : regstart[*p]
../inputs/grep1.dat:                             : regstart[*p];
../inputs/grep1.dat:	  DEBUG_PRINT2 ("  old_regstart: %d\n", 
../inputs/grep1.dat:			 POINTER_TO_OFFSET (old_regstart[*p]));
../inputs/grep1.dat:
../inputs/grep1.dat:          regstart[*p] = d;
../inputs/grep1.dat:	  DEBUG_PRINT2 ("  regstart: %d\n", POINTER_TO_OFFSET (regstart[*p]));
../inputs/grep1.dat:
../inputs/grep1.dat:          IS_ACTIVE (reg_info[*p]) = 1;
../inputs/grep1.dat:          MATCHED_SOMETHING (reg_info[*p]) = 0;
../inputs/grep1.dat:          
../inputs/grep1.dat:          /* This is the new highest active register.  */
../inputs/grep1.dat:          highest_active_reg = *p;
../inputs/grep1.dat:          
../inputs/grep1.dat:          /* If nothing was active before, this is the new lowest active
../inputs/grep1.dat:             register.  */
../inputs/grep1.dat:          if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
../inputs/grep1.dat:            lowest_active_reg = *p;
../inputs/grep1.dat:
../inputs/grep1.dat:          /* Move past the register number and inner group count.  */
../inputs/grep1.dat:          p += 2;
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:        /* The stop_memory opcode represents the end of a group.  Its
../inputs/grep1.dat:           arguments are the same as start_memory's: the register
../inputs/grep1.dat:           number, and the number of inner groups.  */
../inputs/grep1.dat:	case stop_memory:
../inputs/grep1.dat:	  DEBUG_PRINT3 ("EXECUTING stop_memory %d (%d):\n", *p, p[1]);
../inputs/grep1.dat:             
../inputs/grep1.dat:          /* We need to save the string position the last time we were at
../inputs/grep1.dat:             this close-group operator in case the group is operated
../inputs/grep1.dat:             upon by a repetition operator, e.g., with `((a*)*(b*)*)*'
../inputs/grep1.dat:             against `aba'; then we want to ignore where we are now in
../inputs/grep1.dat:             the string in case this attempt to match fails.  */
../inputs/grep1.dat:          old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
../inputs/grep1.dat:                           ? REG_UNSET (regend[*p]) ? d : regend[*p]
../inputs/grep1.dat:			   : regend[*p];
../inputs/grep1.dat:	  DEBUG_PRINT2 ("      old_regend: %d\n", 
../inputs/grep1.dat:			 POINTER_TO_OFFSET (old_regend[*p]));
../inputs/grep1.dat:
../inputs/grep1.dat:          regend[*p] = d;
../inputs/grep1.dat:	  DEBUG_PRINT2 ("      regend: %d\n", POINTER_TO_OFFSET (regend[*p]));
../inputs/grep1.dat:
../inputs/grep1.dat:          /* This register isn't active anymore.  */
../inputs/grep1.dat:          IS_ACTIVE (reg_info[*p]) = 0;
../inputs/grep1.dat:          
../inputs/grep1.dat:          /* If this was the only register active, nothing is active
../inputs/grep1.dat:             anymore.  */
../inputs/grep1.dat:          if (lowest_active_reg == highest_active_reg)
../inputs/grep1.dat:            {
../inputs/grep1.dat:              lowest_active_reg = NO_LOWEST_ACTIVE_REG;
../inputs/grep1.dat:              highest_active_reg = NO_HIGHEST_ACTIVE_REG;
../inputs/grep1.dat:            }
../inputs/grep1.dat:          else
../inputs/grep1.dat:            { /* We must scan for the new highest active register, since
../inputs/grep1.dat:                 it isn't necessarily one less than now: consider
../inputs/grep1.dat:                 (a(b)c(d(e)f)g).  When group 3 ends, after the f), the
../inputs/grep1.dat:                 new highest active register is 1.  */
../inputs/grep1.dat:              unsigned char r = *p - 1;
../inputs/grep1.dat:              while (r > 0 && !IS_ACTIVE (reg_info[r]))
../inputs/grep1.dat:                r--;
../inputs/grep1.dat:              
../inputs/grep1.dat:              /* If we end up at register zero, that means that we saved
../inputs/grep1.dat:                 the registers as the result of an `on_failure_jump', not
../inputs/grep1.dat:                 a `start_memory', and we jumped to past the innermost
../inputs/grep1.dat:                 `stop_memory'.  For example, in ((.)*) we save
../inputs/grep1.dat:                 registers 1 and 2 as a result of the *, but when we pop
../inputs/grep1.dat:                 back to the second ), we are at the stop_memory 1.
../inputs/grep1.dat:                 Thus, nothing is active.  */
../inputs/grep1.dat:	      if (r == 0)
../inputs/grep1.dat:                {
../inputs/grep1.dat:                  lowest_active_reg = NO_LOWEST_ACTIVE_REG;
../inputs/grep1.dat:                  highest_active_reg = NO_HIGHEST_ACTIVE_REG;
../inputs/grep1.dat:                }
../inputs/grep1.dat:              else
../inputs/grep1.dat:                highest_active_reg = r;
../inputs/grep1.dat:            }
../inputs/grep1.dat:          
../inputs/grep1.dat:          /* If just failed to match something this time around with a
../inputs/grep1.dat:             group that's operated on by a repetition operator, try to
../inputs/grep1.dat:             force exit from the ``loop'', and restore the register
../inputs/grep1.dat:             information for this group that we had before trying this
../inputs/grep1.dat:             last match.  */
../inputs/grep1.dat:          if ((!MATCHED_SOMETHING (reg_info[*p])
../inputs/grep1.dat:               || (re_opcode_t) p[-3] == start_memory)
../inputs/grep1.dat:	      && (p + 2) < pend)              
../inputs/grep1.dat:            {
../inputs/grep1.dat:              boolean is_a_jump_n = false;
../inputs/grep1.dat:              
../inputs/grep1.dat:              p1 = p + 2;
../inputs/grep1.dat:              mcnt = 0;
../inputs/grep1.dat:              switch ((re_opcode_t) *p1++)
../inputs/grep1.dat:                {
../inputs/grep1.dat:                  case jump_n:
../inputs/grep1.dat:		    is_a_jump_n = true;
../inputs/grep1.dat:                  case pop_failure_jump:
../inputs/grep1.dat:		  case maybe_pop_jump:
../inputs/grep1.dat:		  case jump:
../inputs/grep1.dat:		  case dummy_failure_jump:
../inputs/grep1.dat:                    EXTRACT_NUMBER_AND_INCR (mcnt, p1);
../inputs/grep1.dat:		    if (is_a_jump_n)
../inputs/grep1.dat:		      p1 += 2;
../inputs/grep1.dat:                    break;
../inputs/grep1.dat:                  
../inputs/grep1.dat:                  default:
../inputs/grep1.dat:                    /* do nothing */ ;
../inputs/grep1.dat:                }
../inputs/grep1.dat:	      p1 += mcnt;
../inputs/grep1.dat:        
../inputs/grep1.dat:              /* If the next operation is a jump backwards in the pattern
../inputs/grep1.dat:	         to an on_failure_jump right before the start_memory
../inputs/grep1.dat:                 corresponding to this stop_memory, exit from the loop
../inputs/grep1.dat:                 by forcing a failure after pushing on the stack the
../inputs/grep1.dat:                 on_failure_jump's jump in the pattern, and d.  */
../inputs/grep1.dat:              if (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump
../inputs/grep1.dat:                  && (re_opcode_t) p1[3] == start_memory && p1[4] == *p)
../inputs/grep1.dat:		{
../inputs/grep1.dat:                  /* If this group ever matched anything, then restore
../inputs/grep1.dat:                     what its registers were before trying this last
../inputs/grep1.dat:                     failed match, e.g., with `(a*)*b' against `ab' for
../inputs/grep1.dat:                     regstart[1], and, e.g., with `((a*)*(b*)*)*'
../inputs/grep1.dat:                     against `aba' for regend[3].
../inputs/grep1.dat:                     
../inputs/grep1.dat:                     Also restore the registers for inner groups for,
../inputs/grep1.dat:                     e.g., `((a*)(b*))*' against `aba' (register 3 would
../inputs/grep1.dat:                     otherwise get trashed).  */
../inputs/grep1.dat:                     
../inputs/grep1.dat:                  if (EVER_MATCHED_SOMETHING (reg_info[*p]))
../inputs/grep1.dat:		    {
../inputs/grep1.dat:		      unsigned r; 
../inputs/grep1.dat:        
../inputs/grep1.dat:                      EVER_MATCHED_SOMETHING (reg_info[*p]) = 0;
../inputs/grep1.dat:                      
../inputs/grep1.dat:		      /* Restore this and inner groups' (if any) registers.  */
../inputs/grep1.dat:                      for (r = *p; r < *p + *(p + 1); r++)
../inputs/grep1.dat:                        {
../inputs/grep1.dat:                          regstart[r] = old_regstart[r];
../inputs/grep1.dat:
../inputs/grep1.dat:                          /* xx why this test?  */
../inputs/grep1.dat:                          if ((int) old_regend[r] >= (int) regstart[r])
../inputs/grep1.dat:                            regend[r] = old_regend[r];
../inputs/grep1.dat:                        }     
../inputs/grep1.dat:                    }
../inputs/grep1.dat:		  p1++;
../inputs/grep1.dat:                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
../inputs/grep1.dat:                  PUSH_FAILURE_POINT (p1 + mcnt, d, -2);
../inputs/grep1.dat:
../inputs/grep1.dat:                  goto fail;
../inputs/grep1.dat:                }
../inputs/grep1.dat:            }
../inputs/grep1.dat:          
../inputs/grep1.dat:          /* Move past the register number and the inner group count.  */
../inputs/grep1.dat:          p += 2;
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:	/* \<digit> has been turned into a `duplicate' command which is
../inputs/grep1.dat:           followed by the numeric value of <digit> as the register number.  */
../inputs/grep1.dat:        case duplicate:
../inputs/grep1.dat:	  {
../inputs/grep1.dat:	    register const char *d2, *dend2;
../inputs/grep1.dat:	    int regno = *p++;   /* Get which register to match against.  */
../inputs/grep1.dat:	    DEBUG_PRINT2 ("EXECUTING duplicate %d.\n", regno);
../inputs/grep1.dat:
../inputs/grep1.dat:	    /* Can't back reference a group which we've never matched.  */
../inputs/grep1.dat:            if (REG_UNSET (regstart[regno]) || REG_UNSET (regend[regno]))
../inputs/grep1.dat:              goto fail;
../inputs/grep1.dat:              
../inputs/grep1.dat:            /* Where in input to try to start matching.  */
../inputs/grep1.dat:            d2 = regstart[regno];
../inputs/grep1.dat:            
../inputs/grep1.dat:            /* Where to stop matching; if both the place to start and
../inputs/grep1.dat:               the place to stop matching are in the same string, then
../inputs/grep1.dat:               set to the place to stop, otherwise, for now have to use
../inputs/grep1.dat:               the end of the first string.  */
../inputs/grep1.dat:
../inputs/grep1.dat:            dend2 = ((FIRST_STRING_P (regstart[regno]) 
../inputs/grep1.dat:		      == FIRST_STRING_P (regend[regno]))
../inputs/grep1.dat:		     ? regend[regno] : end_match_1);
../inputs/grep1.dat:	    for (;;)
../inputs/grep1.dat:	      {
../inputs/grep1.dat:		/* If necessary, advance to next segment in register
../inputs/grep1.dat:                   contents.  */
../inputs/grep1.dat:		while (d2 == dend2)
../inputs/grep1.dat:		  {
../inputs/grep1.dat:		    if (dend2 == end_match_2) break;
../inputs/grep1.dat:		    if (dend2 == regend[regno]) break;
../inputs/grep1.dat:
../inputs/grep1.dat:                    /* End of string1 => advance to string2. */
../inputs/grep1.dat:                    d2 = string2;
../inputs/grep1.dat:                    dend2 = regend[regno];
../inputs/grep1.dat:		  }
../inputs/grep1.dat:		/* At end of register contents => success */
../inputs/grep1.dat:		if (d2 == dend2) break;
../inputs/grep1.dat:
../inputs/grep1.dat:		/* If necessary, advance to next segment in data.  */
../inputs/grep1.dat:		PREFETCH ();
../inputs/grep1.dat:
../inputs/grep1.dat:		/* How many characters left in this segment to match.  */
../inputs/grep1.dat:		mcnt = dend - d;
../inputs/grep1.dat:                
../inputs/grep1.dat:		/* Want how many consecutive characters we can match in
../inputs/grep1.dat:                   one shot, so, if necessary, adjust the count.  */
../inputs/grep1.dat:                if (mcnt > dend2 - d2)
../inputs/grep1.dat:		  mcnt = dend2 - d2;
../inputs/grep1.dat:                  
../inputs/grep1.dat:		/* Compare that many; failure if mismatch, else move
../inputs/grep1.dat:                   past them.  */
../inputs/grep1.dat:		if (translate 
../inputs/grep1.dat:                    ? bcmp_translate (d, d2, mcnt, translate) 
../inputs/grep1.dat:                    : bcmp (d, d2, mcnt))
../inputs/grep1.dat:		  goto fail;
../inputs/grep1.dat:		d += mcnt, d2 += mcnt;
../inputs/grep1.dat:	      }
../inputs/grep1.dat:	  }
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:        /* begline matches the empty string at the beginning of the string
../inputs/grep1.dat:           (unless `not_bol' is set in `bufp'), and, if
../inputs/grep1.dat:           `newline_anchor' is set, after newlines.  */
../inputs/grep1.dat:	case begline:
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING begline.\n");
../inputs/grep1.dat:          
../inputs/grep1.dat:          if (AT_STRINGS_BEG (d))
../inputs/grep1.dat:            {
../inputs/grep1.dat:              if (!bufp->not_bol) break;
../inputs/grep1.dat:            }
../inputs/grep1.dat:          else if (d[-1] == '\n' && bufp->newline_anchor)
../inputs/grep1.dat:            {
../inputs/grep1.dat:              break;
../inputs/grep1.dat:            }
../inputs/grep1.dat:          /* In all other cases, we fail.  */
../inputs/grep1.dat:          goto fail;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:        /* endline is the dual of begline.  */
../inputs/grep1.dat:	case endline:
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING endline.\n");
../inputs/grep1.dat:
../inputs/grep1.dat:          if (AT_STRINGS_END (d))
../inputs/grep1.dat:            {
../inputs/grep1.dat:              if (!bufp->not_eol) break;
../inputs/grep1.dat:            }
../inputs/grep1.dat:          
../inputs/grep1.dat:          /* We have to ``prefetch'' the next character.  */
../inputs/grep1.dat:          else if ((d == end1 ? *string2 : *d) == '\n'
../inputs/grep1.dat:                   && bufp->newline_anchor)
../inputs/grep1.dat:            {
../inputs/grep1.dat:              break;
../inputs/grep1.dat:            }
../inputs/grep1.dat:          goto fail;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:	/* Match at the very beginning of the data.  */
../inputs/grep1.dat:        case begbuf:
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING begbuf.\n");
../inputs/grep1.dat:          if (AT_STRINGS_BEG (d))
../inputs/grep1.dat:            break;
../inputs/grep1.dat:          goto fail;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:	/* Match at the very end of the data.  */
../inputs/grep1.dat:        case endbuf:
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING endbuf.\n");
../inputs/grep1.dat:	  if (AT_STRINGS_END (d))
../inputs/grep1.dat:	    break;
../inputs/grep1.dat:          goto fail;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:        /* on_failure_keep_string_jump is used to optimize `.*\n'.  It
../inputs/grep1.dat:           pushes NULL as the value for the string on the stack.  Then
../inputs/grep1.dat:           `pop_failure_point' will keep the current value for the
../inputs/grep1.dat:           string, instead of restoring it.  To see why, consider
../inputs/grep1.dat:           matching `foo\nbar' against `.*\n'.  The .* matches the foo;
../inputs/grep1.dat:           then the . fails against the \n.  But the next thing we want
../inputs/grep1.dat:           to do is match the \n against the \n; if we restored the
../inputs/grep1.dat:           string value, we would be back at the foo.
../inputs/grep1.dat:           
../inputs/grep1.dat:           Because this is used only in specific cases, we don't need to
../inputs/grep1.dat:           check all the things that `on_failure_jump' does, to make
../inputs/grep1.dat:           sure the right things get saved on the stack.  Hence we don't
../inputs/grep1.dat:           share its code.  The only reason to push anything on the
../inputs/grep1.dat:           stack at all is that otherwise we would have to change
../inputs/grep1.dat:           `anychar's code to do something besides goto fail in this
../inputs/grep1.dat:           case; that seems worse than this.  */
../inputs/grep1.dat:        case on_failure_keep_string_jump:
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING on_failure_keep_string_jump");
../inputs/grep1.dat:          
../inputs/grep1.dat:          EXTRACT_NUMBER_AND_INCR (mcnt, p);
../inputs/grep1.dat:          DEBUG_PRINT3 (" %d (to 0x%x):\n", mcnt, p + mcnt);
../inputs/grep1.dat:
../inputs/grep1.dat:          PUSH_FAILURE_POINT (p + mcnt, NULL, -2);
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:	/* Uses of on_failure_jump:
../inputs/grep1.dat:        
../inputs/grep1.dat:           Each alternative starts with an on_failure_jump that points
../inputs/grep1.dat:           to the beginning of the next alternative.  Each alternative
../inputs/grep1.dat:           except the last ends with a jump that in effect jumps past
../inputs/grep1.dat:           the rest of the alternatives.  (They really jump to the
../inputs/grep1.dat:           ending jump of the following alternative, because tensioning
../inputs/grep1.dat:           these jumps is a hassle.)
../inputs/grep1.dat:
../inputs/grep1.dat:           Repeats start with an on_failure_jump that points past both
../inputs/grep1.dat:           the repetition text and either the following jump or
../inputs/grep1.dat:           pop_failure_jump back to this on_failure_jump.  */
../inputs/grep1.dat:	case on_failure_jump:
../inputs/grep1.dat:        on_failure:
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING on_failure_jump");
../inputs/grep1.dat:
../inputs/grep1.dat:          EXTRACT_NUMBER_AND_INCR (mcnt, p);
../inputs/grep1.dat:          DEBUG_PRINT3 (" %d (to 0x%x)", mcnt, p + mcnt);
../inputs/grep1.dat:
../inputs/grep1.dat:          /* If this on_failure_jump comes right before a group (i.e.,
../inputs/grep1.dat:             the original * applied to a group), save the information
../inputs/grep1.dat:             for that group and all inner ones, so that if we fail back
../inputs/grep1.dat:             to this point, the group's information will be correct.
../inputs/grep1.dat:             For example, in \(a*\)*\1, we need the preceding group,
../inputs/grep1.dat:             and in \(\(a*\)b*\)\2, we need the inner group.  */
../inputs/grep1.dat:
../inputs/grep1.dat:          /* We can't use `p' to check ahead because we push
../inputs/grep1.dat:             a failure point to `p + mcnt' after we do this.  */
../inputs/grep1.dat:          p1 = p;
../inputs/grep1.dat:
../inputs/grep1.dat:          /* We need to skip no_op's before we look for the
../inputs/grep1.dat:             start_memory in case this on_failure_jump is happening as
../inputs/grep1.dat:             the result of a completed succeed_n, as in \(a\)\{1,3\}b\1
../inputs/grep1.dat:             against aba.  */
../inputs/grep1.dat:          while (p1 < pend && (re_opcode_t) *p1 == no_op)
../inputs/grep1.dat:            p1++;
../inputs/grep1.dat:
../inputs/grep1.dat:          if (p1 < pend && (re_opcode_t) *p1 == start_memory)
../inputs/grep1.dat:            {
../inputs/grep1.dat:              /* We have a new highest active register now.  This will
../inputs/grep1.dat:                 get reset at the start_memory we are about to get to,
../inputs/grep1.dat:                 but we will have saved all the registers relevant to
../inputs/grep1.dat:                 this repetition op, as described above.  */
../inputs/grep1.dat:              highest_active_reg = *(p1 + 1) + *(p1 + 2);
../inputs/grep1.dat:              if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
../inputs/grep1.dat:                lowest_active_reg = *(p1 + 1);
../inputs/grep1.dat:            }
../inputs/grep1.dat:
../inputs/grep1.dat:          DEBUG_PRINT1 (":\n");
../inputs/grep1.dat:          PUSH_FAILURE_POINT (p + mcnt, d, -2);
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:        /* A smart repeat ends with `maybe_pop_jump'.
../inputs/grep1.dat:	   We change it to either `pop_failure_jump' or `jump'.  */
../inputs/grep1.dat:        case maybe_pop_jump:
../inputs/grep1.dat:          EXTRACT_NUMBER_AND_INCR (mcnt, p);
../inputs/grep1.dat:          DEBUG_PRINT2 ("EXECUTING maybe_pop_jump %d.\n", mcnt);
../inputs/grep1.dat:          {
../inputs/grep1.dat:	    register unsigned char *p2 = p;
../inputs/grep1.dat:
../inputs/grep1.dat:            /* Compare the beginning of the repeat with what in the
../inputs/grep1.dat:               pattern follows its end. If we can establish that there
../inputs/grep1.dat:               is nothing that they would both match, i.e., that we
../inputs/grep1.dat:               would have to backtrack because of (as in, e.g., `a*a')
../inputs/grep1.dat:               then we can change to pop_failure_jump, because we'll
../inputs/grep1.dat:               never have to backtrack.
../inputs/grep1.dat:               
../inputs/grep1.dat:               This is not true in the case of alternatives: in
../inputs/grep1.dat:               `(a|ab)*' we do need to backtrack to the `ab' alternative
../inputs/grep1.dat:               (e.g., if the string was `ab').  But instead of trying to
../inputs/grep1.dat:               detect that here, the alternative has put on a dummy
../inputs/grep1.dat:               failure point which is what we will end up popping.  */
../inputs/grep1.dat:
../inputs/grep1.dat:	    /* Skip over open/close-group commands.  */
../inputs/grep1.dat:	    while (p2 + 2 < pend
../inputs/grep1.dat:		   && ((re_opcode_t) *p2 == stop_memory
../inputs/grep1.dat:		       || (re_opcode_t) *p2 == start_memory))
../inputs/grep1.dat:	      p2 += 3;			/* Skip over args, too.  */
../inputs/grep1.dat:
../inputs/grep1.dat:            /* If we're at the end of the pattern, we can change.  */
../inputs/grep1.dat:            if (p2 == pend)
../inputs/grep1.dat:	      {
../inputs/grep1.dat:		/* Consider what happens when matching ":\(.*\)"
../inputs/grep1.dat:		   against ":/".  I don't really understand this code
../inputs/grep1.dat:		   yet.  */
../inputs/grep1.dat:  	        p[-3] = (unsigned char) pop_failure_jump;
../inputs/grep1.dat:                DEBUG_PRINT1
../inputs/grep1.dat:                  ("  End of pattern: change to `pop_failure_jump'.\n");
../inputs/grep1.dat:              }
../inputs/grep1.dat:
../inputs/grep1.dat:            else if ((re_opcode_t) *p2 == exactn
../inputs/grep1.dat:		     || (bufp->newline_anchor && (re_opcode_t) *p2 == endline))
../inputs/grep1.dat:	      {
../inputs/grep1.dat:		register unsigned char c
../inputs/grep1.dat:                  = *p2 == (unsigned char) endline ? '\n' : p2[2];
../inputs/grep1.dat:		p1 = p + mcnt;
../inputs/grep1.dat:
../inputs/grep1.dat:                /* p1[0] ... p1[2] are the `on_failure_jump' corresponding
../inputs/grep1.dat:                   to the `maybe_finalize_jump' of this case.  Examine what 
../inputs/grep1.dat:                   follows.  */
../inputs/grep1.dat:                if ((re_opcode_t) p1[3] == exactn && p1[5] != c)
../inputs/grep1.dat:                  {
../inputs/grep1.dat:  		    p[-3] = (unsigned char) pop_failure_jump;
../inputs/grep1.dat:                    DEBUG_PRINT3 ("  %c != %c => pop_failure_jump.\n",
../inputs/grep1.dat:                                  c, p1[5]);
../inputs/grep1.dat:                  }
../inputs/grep1.dat:                  
../inputs/grep1.dat:		else if ((re_opcode_t) p1[3] == charset
../inputs/grep1.dat:			 || (re_opcode_t) p1[3] == charset_not)
../inputs/grep1.dat:		  {
../inputs/grep1.dat:		    int not = (re_opcode_t) p1[3] == charset_not;
../inputs/grep1.dat:                    
../inputs/grep1.dat:		    if (c < (unsigned char) (p1[4] * BYTEWIDTH)
../inputs/grep1.dat:			&& p1[5 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
../inputs/grep1.dat:		      not = !not;
../inputs/grep1.dat:
../inputs/grep1.dat:                    /* `not' is equal to 1 if c would match, which means
../inputs/grep1.dat:                        that we can't change to pop_failure_jump.  */
../inputs/grep1.dat:		    if (!not)
../inputs/grep1.dat:                      {
../inputs/grep1.dat:  		        p[-3] = (unsigned char) pop_failure_jump;
../inputs/grep1.dat:                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
../inputs/grep1.dat:                      }
../inputs/grep1.dat:		  }
../inputs/grep1.dat:	      }
../inputs/grep1.dat:	  }
../inputs/grep1.dat:	  p -= 2;		/* Point at relative address again.  */
../inputs/grep1.dat:	  if ((re_opcode_t) p[-1] != pop_failure_jump)
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      p[-1] = (unsigned char) jump;
../inputs/grep1.dat:              DEBUG_PRINT1 ("  Match => jump.\n");
../inputs/grep1.dat:	      goto unconditional_jump;
../inputs/grep1.dat:	    }
../inputs/grep1.dat:        /* Note fall through.  */
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:	/* The end of a simple repeat has a pop_failure_jump back to
../inputs/grep1.dat:           its matching on_failure_jump, where the latter will push a
../inputs/grep1.dat:           failure point.  The pop_failure_jump takes off failure
../inputs/grep1.dat:           points put on by this pop_failure_jump's matching
../inputs/grep1.dat:           on_failure_jump; we got through the pattern to here from the
../inputs/grep1.dat:           matching on_failure_jump, so didn't fail.  */
../inputs/grep1.dat:        case pop_failure_jump:
../inputs/grep1.dat:          {
../inputs/grep1.dat:            /* We need to pass separate storage for the lowest and
../inputs/grep1.dat:               highest registers, even though we don't care about the
../inputs/grep1.dat:               actual values.  Otherwise, we will restore only one
../inputs/grep1.dat:               register from the stack, since lowest will == highest in
../inputs/grep1.dat:               `pop_failure_point'.  */
../inputs/grep1.dat:            unsigned dummy_low_reg, dummy_high_reg;
../inputs/grep1.dat:            unsigned char *pdummy;
../inputs/grep1.dat:            const char *sdummy;
../inputs/grep1.dat:
../inputs/grep1.dat:            DEBUG_PRINT1 ("EXECUTING pop_failure_jump.\n");
../inputs/grep1.dat:            POP_FAILURE_POINT (sdummy, pdummy,
../inputs/grep1.dat:                               dummy_low_reg, dummy_high_reg,
../inputs/grep1.dat:                               reg_dummy, reg_dummy, reg_info_dummy);
../inputs/grep1.dat:          }
../inputs/grep1.dat:          /* Note fall through.  */
../inputs/grep1.dat:
../inputs/grep1.dat:          
../inputs/grep1.dat:        /* Unconditionally jump (without popping any failure points).  */
../inputs/grep1.dat:        case jump:
../inputs/grep1.dat:	unconditional_jump:
../inputs/grep1.dat:	  EXTRACT_NUMBER_AND_INCR (mcnt, p);	/* Get the amount to jump.  */
../inputs/grep1.dat:          DEBUG_PRINT2 ("EXECUTING jump %d ", mcnt);
../inputs/grep1.dat:	  p += mcnt;				/* Do the jump.  */
../inputs/grep1.dat:          DEBUG_PRINT2 ("(to 0x%x).\n", p);
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:
../inputs/grep1.dat:	
../inputs/grep1.dat:        /* We need this opcode so we can detect where alternatives end
../inputs/grep1.dat:           in `group_match_null_string_p' et al.  */
../inputs/grep1.dat:        case jump_past_alt:
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING jump_past_alt.\n");
../inputs/grep1.dat:          goto unconditional_jump;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:        /* Normally, the on_failure_jump pushes a failure point, which
../inputs/grep1.dat:           then gets popped at pop_failure_jump.  We will end up at
../inputs/grep1.dat:           pop_failure_jump, also, and with a pattern of, say, `a+', we
../inputs/grep1.dat:           are skipping over the on_failure_jump, so we have to push
../inputs/grep1.dat:           something meaningless for pop_failure_jump to pop.  */
../inputs/grep1.dat:        case dummy_failure_jump:
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING dummy_failure_jump.\n");
../inputs/grep1.dat:          /* It doesn't matter what we push for the string here.  What
../inputs/grep1.dat:             the code at `fail' tests is the value for the pattern.  */
../inputs/grep1.dat:          PUSH_FAILURE_POINT (0, 0, -2);
../inputs/grep1.dat:          goto unconditional_jump;
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:        /* At the end of an alternative, we need to push a dummy failure
../inputs/grep1.dat:           point in case we are followed by a `pop_failure_jump', because
../inputs/grep1.dat:           we don't want the failure point for the alternative to be
../inputs/grep1.dat:           popped.  For example, matching `(a|ab)*' against `aab'
../inputs/grep1.dat:           requires that we match the `ab' alternative.  */
../inputs/grep1.dat:        case push_dummy_failure:
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING push_dummy_failure.\n");
../inputs/grep1.dat:          /* See comments just above at `dummy_failure_jump' about the
../inputs/grep1.dat:             two zeroes.  */
../inputs/grep1.dat:          PUSH_FAILURE_POINT (0, 0, -2);
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:        /* Have to succeed matching what follows at least n times.
../inputs/grep1.dat:           After that, handle like `on_failure_jump'.  */
../inputs/grep1.dat:        case succeed_n: 
../inputs/grep1.dat:          EXTRACT_NUMBER (mcnt, p + 2);
../inputs/grep1.dat:          DEBUG_PRINT2 ("EXECUTING succeed_n %d.\n", mcnt);
../inputs/grep1.dat:
../inputs/grep1.dat:          assert (mcnt >= 0);
../inputs/grep1.dat:          /* Originally, this is how many times we HAVE to succeed.  */
../inputs/grep1.dat:          if (mcnt > 0)
../inputs/grep1.dat:            {
../inputs/grep1.dat:               mcnt--;
../inputs/grep1.dat:	       p += 2;
../inputs/grep1.dat:               STORE_NUMBER_AND_INCR (p, mcnt);
../inputs/grep1.dat:               DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p, mcnt);
../inputs/grep1.dat:            }
../inputs/grep1.dat:	  else if (mcnt == 0)
../inputs/grep1.dat:            {
../inputs/grep1.dat:              DEBUG_PRINT2 ("  Setting two bytes from 0x%x to no_op.\n", p+2);
../inputs/grep1.dat:	      p[2] = (unsigned char) no_op;
../inputs/grep1.dat:              p[3] = (unsigned char) no_op;
../inputs/grep1.dat:              goto on_failure;
../inputs/grep1.dat:            }
../inputs/grep1.dat:          break;
../inputs/grep1.dat:        
../inputs/grep1.dat:        case jump_n: 
../inputs/grep1.dat:          EXTRACT_NUMBER (mcnt, p + 2);
../inputs/grep1.dat:          DEBUG_PRINT2 ("EXECUTING jump_n %d.\n", mcnt);
../inputs/grep1.dat:
../inputs/grep1.dat:          /* Originally, this is how many times we CAN jump.  */
../inputs/grep1.dat:          if (mcnt)
../inputs/grep1.dat:            {
../inputs/grep1.dat:               mcnt--;
../inputs/grep1.dat:               STORE_NUMBER (p + 2, mcnt);
../inputs/grep1.dat:	       goto unconditional_jump;	     
../inputs/grep1.dat:            }
../inputs/grep1.dat:          /* If don't have to jump any more, skip over the rest of command.  */
../inputs/grep1.dat:	  else      
../inputs/grep1.dat:	    p += 4;		     
../inputs/grep1.dat:          break;
../inputs/grep1.dat:        
../inputs/grep1.dat:	case set_number_at:
../inputs/grep1.dat:	  {
../inputs/grep1.dat:            DEBUG_PRINT1 ("EXECUTING set_number_at.\n");
../inputs/grep1.dat:
../inputs/grep1.dat:            EXTRACT_NUMBER_AND_INCR (mcnt, p);
../inputs/grep1.dat:            p1 = p + mcnt;
../inputs/grep1.dat:            EXTRACT_NUMBER_AND_INCR (mcnt, p);
../inputs/grep1.dat:            DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p1, mcnt);
../inputs/grep1.dat:	    STORE_NUMBER (p1, mcnt);
../inputs/grep1.dat:            break;
../inputs/grep1.dat:          }
../inputs/grep1.dat:
../inputs/grep1.dat:        case wordbound:
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING wordbound.\n");
../inputs/grep1.dat:          if (AT_WORD_BOUNDARY (d))
../inputs/grep1.dat:	    break;
../inputs/grep1.dat:          goto fail;
../inputs/grep1.dat:
../inputs/grep1.dat:	case notwordbound:
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING notwordbound.\n");
../inputs/grep1.dat:	  if (AT_WORD_BOUNDARY (d))
../inputs/grep1.dat:	    goto fail;
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:	case wordbeg:
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING wordbeg.\n");
../inputs/grep1.dat:	  if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))
../inputs/grep1.dat:	    break;
../inputs/grep1.dat:          goto fail;
../inputs/grep1.dat:
../inputs/grep1.dat:	case wordend:
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING wordend.\n");
../inputs/grep1.dat:	  if (!AT_STRINGS_BEG (d) && WORDCHAR_P (d - 1)
../inputs/grep1.dat:              && (!WORDCHAR_P (d) || AT_STRINGS_END (d)))
../inputs/grep1.dat:	    break;
../inputs/grep1.dat:          goto fail;
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef emacs
../inputs/grep1.dat:#ifdef emacs19
../inputs/grep1.dat:  	case before_dot:
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING before_dot.\n");
../inputs/grep1.dat: 	  if (PTR_CHAR_POS ((unsigned char *) d) >= point)
../inputs/grep1.dat:  	    goto fail;
../inputs/grep1.dat:  	  break;
../inputs/grep1.dat:  
../inputs/grep1.dat:  	case at_dot:
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING at_dot.\n");
../inputs/grep1.dat: 	  if (PTR_CHAR_POS ((unsigned char *) d) != point)
../inputs/grep1.dat:  	    goto fail;
../inputs/grep1.dat:  	  break;
../inputs/grep1.dat:  
../inputs/grep1.dat:  	case after_dot:
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING after_dot.\n");
../inputs/grep1.dat:          if (PTR_CHAR_POS ((unsigned char *) d) <= point)
../inputs/grep1.dat:  	    goto fail;
../inputs/grep1.dat:  	  break;
../inputs/grep1.dat:#else /* not emacs19 */
../inputs/grep1.dat:	case at_dot:
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING at_dot.\n");
../inputs/grep1.dat:	  if (PTR_CHAR_POS ((unsigned char *) d) + 1 != point)
../inputs/grep1.dat:	    goto fail;
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:#endif /* not emacs19 */
../inputs/grep1.dat:
../inputs/grep1.dat:	case syntaxspec:
../inputs/grep1.dat:          DEBUG_PRINT2 ("EXECUTING syntaxspec %d.\n", mcnt);
../inputs/grep1.dat:	  mcnt = *p++;
../inputs/grep1.dat:	  goto matchsyntax;
../inputs/grep1.dat:
../inputs/grep1.dat:        case wordchar:
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING Emacs wordchar.\n");
../inputs/grep1.dat:	  mcnt = (int) Sword;
../inputs/grep1.dat:        matchsyntax:
../inputs/grep1.dat:	  PREFETCH ();
../inputs/grep1.dat:	  if (SYNTAX (*d++) != (enum syntaxcode) mcnt)
../inputs/grep1.dat:            goto fail;
../inputs/grep1.dat:          SET_REGS_MATCHED ();
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:
../inputs/grep1.dat:	case notsyntaxspec:
../inputs/grep1.dat:          DEBUG_PRINT2 ("EXECUTING notsyntaxspec %d.\n", mcnt);
../inputs/grep1.dat:	  mcnt = *p++;
../inputs/grep1.dat:	  goto matchnotsyntax;
../inputs/grep1.dat:
../inputs/grep1.dat:        case notwordchar:
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING Emacs notwordchar.\n");
../inputs/grep1.dat:	  mcnt = (int) Sword;
../inputs/grep1.dat:        matchnotsyntax:
../inputs/grep1.dat:	  PREFETCH ();
../inputs/grep1.dat:	  if (SYNTAX (*d++) == (enum syntaxcode) mcnt)
../inputs/grep1.dat:            goto fail;
../inputs/grep1.dat:	  SET_REGS_MATCHED ();
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:#else /* not emacs */
../inputs/grep1.dat:	case wordchar:
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING non-Emacs wordchar.\n");
../inputs/grep1.dat:	  PREFETCH ();
../inputs/grep1.dat:          if (!WORDCHAR_P (d))
../inputs/grep1.dat:            goto fail;
../inputs/grep1.dat:	  SET_REGS_MATCHED ();
../inputs/grep1.dat:          d++;
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:	  
../inputs/grep1.dat:	case notwordchar:
../inputs/grep1.dat:          DEBUG_PRINT1 ("EXECUTING non-Emacs notwordchar.\n");
../inputs/grep1.dat:	  PREFETCH ();
../inputs/grep1.dat:	  if (WORDCHAR_P (d))
../inputs/grep1.dat:            goto fail;
../inputs/grep1.dat:          SET_REGS_MATCHED ();
../inputs/grep1.dat:          d++;
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:#endif /* not emacs */
../inputs/grep1.dat:          
../inputs/grep1.dat:        default:
../inputs/grep1.dat:          abort ();
../inputs/grep1.dat:	}
../inputs/grep1.dat:      continue;  /* Successfully executed one pattern command; keep going.  */
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:    /* We goto here if a matching operation fails. */
../inputs/grep1.dat:    fail:
../inputs/grep1.dat:      if (!FAIL_STACK_EMPTY ())
../inputs/grep1.dat:	{ /* A restart point is known.  Restore to that state.  */
../inputs/grep1.dat:          DEBUG_PRINT1 ("\nFAIL:\n");
../inputs/grep1.dat:          POP_FAILURE_POINT (d, p,
../inputs/grep1.dat:                             lowest_active_reg, highest_active_reg,
../inputs/grep1.dat:                             regstart, regend, reg_info);
../inputs/grep1.dat:
../inputs/grep1.dat:          /* If this failure point is a dummy, try the next one.  */
../inputs/grep1.dat:          if (!p)
../inputs/grep1.dat:	    goto fail;
../inputs/grep1.dat:
../inputs/grep1.dat:          /* If we failed to the end of the pattern, don't examine *p.  */
../inputs/grep1.dat:	  assert (p <= pend);
../inputs/grep1.dat:          if (p < pend)
../inputs/grep1.dat:            {
../inputs/grep1.dat:              boolean is_a_jump_n = false;
../inputs/grep1.dat:              
../inputs/grep1.dat:              /* If failed to a backwards jump that's part of a repetition
../inputs/grep1.dat:                 loop, need to pop this failure point and use the next one.  */
../inputs/grep1.dat:              switch ((re_opcode_t) *p)
../inputs/grep1.dat:                {
../inputs/grep1.dat:                case jump_n:
../inputs/grep1.dat:                  is_a_jump_n = true;
../inputs/grep1.dat:                case maybe_pop_jump:
../inputs/grep1.dat:                case pop_failure_jump:
../inputs/grep1.dat:                case jump:
../inputs/grep1.dat:                  p1 = p + 1;
../inputs/grep1.dat:                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
../inputs/grep1.dat:                  p1 += mcnt;	
../inputs/grep1.dat:
../inputs/grep1.dat:                  if ((is_a_jump_n && (re_opcode_t) *p1 == succeed_n)
../inputs/grep1.dat:                      || (!is_a_jump_n
../inputs/grep1.dat:                          && (re_opcode_t) *p1 == on_failure_jump))
../inputs/grep1.dat:                    goto fail;
../inputs/grep1.dat:                  break;
../inputs/grep1.dat:                default:
../inputs/grep1.dat:                  /* do nothing */ ;
../inputs/grep1.dat:                }
../inputs/grep1.dat:            }
../inputs/grep1.dat:
../inputs/grep1.dat:          if (d >= string1 && d <= end1)
../inputs/grep1.dat:	    dend = end_match_1;
../inputs/grep1.dat:        }
../inputs/grep1.dat:      else
../inputs/grep1.dat:        break;   /* Matching at this starting point really fails.  */
../inputs/grep1.dat:    } /* for (;;) */
../inputs/grep1.dat:
../inputs/grep1.dat:  if (best_regs_set)
../inputs/grep1.dat:    goto restore_best_regs;
../inputs/grep1.dat:
../inputs/grep1.dat:  FREE_VARIABLES ();
../inputs/grep1.dat:
../inputs/grep1.dat:  return -1;         			/* Failure to match.  */
../inputs/grep1.dat:} /* re_match_2 */
../inputs/grep1.dat:
../inputs/grep1.dat:/* Subroutine definitions for re_match_2.  */
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* We are passed P pointing to a register number after a start_memory.
../inputs/grep1.dat:   
../inputs/grep1.dat:   Return true if the pattern up to the corresponding stop_memory can
../inputs/grep1.dat:   match the empty string, and false otherwise.
../inputs/grep1.dat:   
../inputs/grep1.dat:   If we find the matching stop_memory, sets P to point to one past its number.
../inputs/grep1.dat:   Otherwise, sets P to an undefined byte less than or equal to END.
../inputs/grep1.dat:
../inputs/grep1.dat:   We don't handle duplicates properly (yet).  */
../inputs/grep1.dat:
../inputs/grep1.dat:static boolean
../inputs/grep1.dat:group_match_null_string_p (p, end, reg_info)
../inputs/grep1.dat:    unsigned char **p, *end;
../inputs/grep1.dat:    register_info_type *reg_info;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int mcnt;
../inputs/grep1.dat:  /* Point to after the args to the start_memory.  */
../inputs/grep1.dat:  unsigned char *p1 = *p + 2;
../inputs/grep1.dat:  
../inputs/grep1.dat:  while (p1 < end)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      /* Skip over opcodes that can match nothing, and return true or
../inputs/grep1.dat:	 false, as appropriate, when we get to one that can't, or to the
../inputs/grep1.dat:         matching stop_memory.  */
../inputs/grep1.dat:      
../inputs/grep1.dat:      switch ((re_opcode_t) *p1)
../inputs/grep1.dat:        {
../inputs/grep1.dat:        /* Could be either a loop or a series of alternatives.  */
../inputs/grep1.dat:        case on_failure_jump:
../inputs/grep1.dat:          p1++;
../inputs/grep1.dat:          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
../inputs/grep1.dat:          
../inputs/grep1.dat:          /* If the next operation is not a jump backwards in the
../inputs/grep1.dat:	     pattern.  */
../inputs/grep1.dat:
../inputs/grep1.dat:	  if (mcnt >= 0)
../inputs/grep1.dat:	    {
../inputs/grep1.dat:              /* Go through the on_failure_jumps of the alternatives,
../inputs/grep1.dat:                 seeing if any of the alternatives cannot match nothing.
../inputs/grep1.dat:                 The last alternative starts with only a jump,
../inputs/grep1.dat:                 whereas the rest start with on_failure_jump and end
../inputs/grep1.dat:                 with a jump, e.g., here is the pattern for `a|b|c':
../inputs/grep1.dat:
../inputs/grep1.dat:                 /on_failure_jump/0/6/exactn/1/a/jump_past_alt/0/6
../inputs/grep1.dat:                 /on_failure_jump/0/6/exactn/1/b/jump_past_alt/0/3
../inputs/grep1.dat:                 /exactn/1/c						
../inputs/grep1.dat:
../inputs/grep1.dat:                 So, we have to first go through the first (n-1)
../inputs/grep1.dat:                 alternatives and then deal with the last one separately.  */
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:              /* Deal with the first (n-1) alternatives, which start
../inputs/grep1.dat:                 with an on_failure_jump (see above) that jumps to right
../inputs/grep1.dat:                 past a jump_past_alt.  */
../inputs/grep1.dat:
../inputs/grep1.dat:              while ((re_opcode_t) p1[mcnt-3] == jump_past_alt)
../inputs/grep1.dat:                {
../inputs/grep1.dat:                  /* `mcnt' holds how many bytes long the alternative
../inputs/grep1.dat:                     is, including the ending `jump_past_alt' and
../inputs/grep1.dat:                     its number.  */
../inputs/grep1.dat:
../inputs/grep1.dat:                  if (!alt_match_null_string_p (p1, p1 + mcnt - 3, 
../inputs/grep1.dat:				                      reg_info))
../inputs/grep1.dat:                    return false;
../inputs/grep1.dat:
../inputs/grep1.dat:                  /* Move to right after this alternative, including the
../inputs/grep1.dat:		     jump_past_alt.  */
../inputs/grep1.dat:                  p1 += mcnt;	
../inputs/grep1.dat:
../inputs/grep1.dat:                  /* Break if it's the beginning of an n-th alternative
../inputs/grep1.dat:                     that doesn't begin with an on_failure_jump.  */
../inputs/grep1.dat:                  if ((re_opcode_t) *p1 != on_failure_jump)
../inputs/grep1.dat:                    break;
../inputs/grep1.dat:		
../inputs/grep1.dat:		  /* Still have to check that it's not an n-th
../inputs/grep1.dat:		     alternative that starts with an on_failure_jump.  */
../inputs/grep1.dat:		  p1++;
../inputs/grep1.dat:                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
../inputs/grep1.dat:                  if ((re_opcode_t) p1[mcnt-3] != jump_past_alt)
../inputs/grep1.dat:                    {
../inputs/grep1.dat:		      /* Get to the beginning of the n-th alternative.  */
../inputs/grep1.dat:                      p1 -= 3;
../inputs/grep1.dat:                      break;
../inputs/grep1.dat:                    }
../inputs/grep1.dat:                }
../inputs/grep1.dat:
../inputs/grep1.dat:              /* Deal with the last alternative: go back and get number
../inputs/grep1.dat:                 of the `jump_past_alt' just before it.  `mcnt' contains
../inputs/grep1.dat:                 the length of the alternative.  */
../inputs/grep1.dat:              EXTRACT_NUMBER (mcnt, p1 - 2);
../inputs/grep1.dat:
../inputs/grep1.dat:              if (!alt_match_null_string_p (p1, p1 + mcnt, reg_info))
../inputs/grep1.dat:                return false;
../inputs/grep1.dat:
../inputs/grep1.dat:              p1 += mcnt;	/* Get past the n-th alternative.  */
../inputs/grep1.dat:            } /* if mcnt > 0 */
../inputs/grep1.dat:          break;
../inputs/grep1.dat:
../inputs/grep1.dat:          
../inputs/grep1.dat:        case stop_memory:
../inputs/grep1.dat:	  assert (p1[1] == **p);
../inputs/grep1.dat:          *p = p1 + 2;
../inputs/grep1.dat:          return true;
../inputs/grep1.dat:
../inputs/grep1.dat:        
../inputs/grep1.dat:        default: 
../inputs/grep1.dat:          if (!common_op_match_null_string_p (&p1, end, reg_info))
../inputs/grep1.dat:            return false;
../inputs/grep1.dat:        }
../inputs/grep1.dat:    } /* while p1 < end */
../inputs/grep1.dat:
../inputs/grep1.dat:  return false;
../inputs/grep1.dat:} /* group_match_null_string_p */
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Similar to group_match_null_string_p, but doesn't deal with alternatives:
../inputs/grep1.dat:   It expects P to be the first byte of a single alternative and END one
../inputs/grep1.dat:   byte past the last. The alternative can contain groups.  */
../inputs/grep1.dat:   
../inputs/grep1.dat:static boolean
../inputs/grep1.dat:alt_match_null_string_p (p, end, reg_info)
../inputs/grep1.dat:    unsigned char *p, *end;
../inputs/grep1.dat:    register_info_type *reg_info;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int mcnt;
../inputs/grep1.dat:  unsigned char *p1 = p;
../inputs/grep1.dat:  
../inputs/grep1.dat:  while (p1 < end)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      /* Skip over opcodes that can match nothing, and break when we get 
../inputs/grep1.dat:         to one that can't.  */
../inputs/grep1.dat:      
../inputs/grep1.dat:      switch ((re_opcode_t) *p1)
../inputs/grep1.dat:        {
../inputs/grep1.dat:	/* It's a loop.  */
../inputs/grep1.dat:        case on_failure_jump:
../inputs/grep1.dat:          p1++;
../inputs/grep1.dat:          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
../inputs/grep1.dat:          p1 += mcnt;
../inputs/grep1.dat:          break;
../inputs/grep1.dat:          
../inputs/grep1.dat:	default: 
../inputs/grep1.dat:          if (!common_op_match_null_string_p (&p1, end, reg_info))
../inputs/grep1.dat:            return false;
../inputs/grep1.dat:        }
../inputs/grep1.dat:    }  /* while p1 < end */
../inputs/grep1.dat:
../inputs/grep1.dat:  return true;
../inputs/grep1.dat:} /* alt_match_null_string_p */
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Deals with the ops common to group_match_null_string_p and
../inputs/grep1.dat:   alt_match_null_string_p.  
../inputs/grep1.dat:   
../inputs/grep1.dat:   Sets P to one after the op and its arguments, if any.  */
../inputs/grep1.dat:
../inputs/grep1.dat:static boolean
../inputs/grep1.dat:common_op_match_null_string_p (p, end, reg_info)
../inputs/grep1.dat:    unsigned char **p, *end;
../inputs/grep1.dat:    register_info_type *reg_info;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int mcnt;
../inputs/grep1.dat:  boolean ret;
../inputs/grep1.dat:  int reg_no;
../inputs/grep1.dat:  unsigned char *p1 = *p;
../inputs/grep1.dat:
../inputs/grep1.dat:  switch ((re_opcode_t) *p1++)
../inputs/grep1.dat:    {
../inputs/grep1.dat:    case no_op:
../inputs/grep1.dat:    case begline:
../inputs/grep1.dat:    case endline:
../inputs/grep1.dat:    case begbuf:
../inputs/grep1.dat:    case endbuf:
../inputs/grep1.dat:    case wordbeg:
../inputs/grep1.dat:    case wordend:
../inputs/grep1.dat:    case wordbound:
../inputs/grep1.dat:    case notwordbound:
../inputs/grep1.dat:#ifdef emacs
../inputs/grep1.dat:    case before_dot:
../inputs/grep1.dat:    case at_dot:
../inputs/grep1.dat:    case after_dot:
../inputs/grep1.dat:#endif
../inputs/grep1.dat:      break;
../inputs/grep1.dat:
../inputs/grep1.dat:    case start_memory:
../inputs/grep1.dat:      reg_no = *p1;
../inputs/grep1.dat:      assert (reg_no > 0 && reg_no <= MAX_REGNUM);
../inputs/grep1.dat:      ret = group_match_null_string_p (&p1, end, reg_info);
../inputs/grep1.dat:      
../inputs/grep1.dat:      /* Have to set this here in case we're checking a group which
../inputs/grep1.dat:         contains a group and a back reference to it.  */
../inputs/grep1.dat:
../inputs/grep1.dat:      if (REG_MATCH_NULL_STRING_P (reg_info[reg_no]) == MATCH_NULL_UNSET_VALUE)
../inputs/grep1.dat:        REG_MATCH_NULL_STRING_P (reg_info[reg_no]) = ret;
../inputs/grep1.dat:
../inputs/grep1.dat:      if (!ret)
../inputs/grep1.dat:        return false;
../inputs/grep1.dat:      break;
../inputs/grep1.dat:          
../inputs/grep1.dat:    /* If this is an optimized succeed_n for zero times, make the jump.  */
../inputs/grep1.dat:    case jump:
../inputs/grep1.dat:      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
../inputs/grep1.dat:      if (mcnt >= 0)
../inputs/grep1.dat:        p1 += mcnt;
../inputs/grep1.dat:      else
../inputs/grep1.dat:        return false;
../inputs/grep1.dat:      break;
../inputs/grep1.dat:
../inputs/grep1.dat:    case succeed_n:
../inputs/grep1.dat:      /* Get to the number of times to succeed.  */
../inputs/grep1.dat:      p1 += 2;		
../inputs/grep1.dat:      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
../inputs/grep1.dat:
../inputs/grep1.dat:      if (mcnt == 0)
../inputs/grep1.dat:        {
../inputs/grep1.dat:          p1 -= 4;
../inputs/grep1.dat:          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
../inputs/grep1.dat:          p1 += mcnt;
../inputs/grep1.dat:        }
../inputs/grep1.dat:      else
../inputs/grep1.dat:        return false;
../inputs/grep1.dat:      break;
../inputs/grep1.dat:
../inputs/grep1.dat:    case duplicate: 
../inputs/grep1.dat:      if (!REG_MATCH_NULL_STRING_P (reg_info[*p1]))
../inputs/grep1.dat:        return false;
../inputs/grep1.dat:      break;
../inputs/grep1.dat:
../inputs/grep1.dat:    case set_number_at:
../inputs/grep1.dat:      p1 += 4;
../inputs/grep1.dat:
../inputs/grep1.dat:    default:
../inputs/grep1.dat:      /* All other opcodes mean we cannot match the empty string.  */
../inputs/grep1.dat:      return false;
../inputs/grep1.dat:  }
../inputs/grep1.dat:
../inputs/grep1.dat:  *p = p1;
../inputs/grep1.dat:  return true;
../inputs/grep1.dat:} /* common_op_match_null_string_p */
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Return zero if TRANSLATE[S1] and TRANSLATE[S2] are identical for LEN
../inputs/grep1.dat:   bytes; nonzero otherwise.  */
../inputs/grep1.dat:   
../inputs/grep1.dat:static int
../inputs/grep1.dat:bcmp_translate (s1, s2, len, translate)
../inputs/grep1.dat:     unsigned char *s1, *s2;
../inputs/grep1.dat:     register int len;
../inputs/grep1.dat:     char *translate;
../inputs/grep1.dat:{
../inputs/grep1.dat:  register unsigned char *p1 = s1, *p2 = s2;
../inputs/grep1.dat:  while (len)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      if (translate[*p1++] != translate[*p2++]) return 1;
../inputs/grep1.dat:      len--;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  return 0;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Entry points for GNU code.  */
../inputs/grep1.dat:
../inputs/grep1.dat:/* re_compile_pattern is the GNU regular expression compiler: it
../inputs/grep1.dat:   compiles PATTERN (of length SIZE) and puts the result in BUFP.
../inputs/grep1.dat:   Returns 0 if the pattern was valid, otherwise an error string.
../inputs/grep1.dat:   
../inputs/grep1.dat:   Assumes the `allocated' (and perhaps `buffer') and `translate' fields
../inputs/grep1.dat:   are set in BUFP on entry.
../inputs/grep1.dat:   
../inputs/grep1.dat:   We call regex_compile to do the actual compilation.  */
../inputs/grep1.dat:
../inputs/grep1.dat:const char *
../inputs/grep1.dat:re_compile_pattern (pattern, length, bufp)
../inputs/grep1.dat:     const char *pattern;
../inputs/grep1.dat:     int length;
../inputs/grep1.dat:     struct re_pattern_buffer *bufp;
../inputs/grep1.dat:{
../inputs/grep1.dat:  reg_errcode_t ret;
../inputs/grep1.dat:  
../inputs/grep1.dat:  /* GNU code is written to assume at least RE_NREGS registers will be set
../inputs/grep1.dat:     (and at least one extra will be -1).  */
../inputs/grep1.dat:  bufp->regs_allocated = REGS_UNALLOCATED;
../inputs/grep1.dat:  
../inputs/grep1.dat:  /* And GNU code determines whether or not to get register information
../inputs/grep1.dat:     by passing null for the REGS argument to re_match, etc., not by
../inputs/grep1.dat:     setting no_sub.  */
../inputs/grep1.dat:  bufp->no_sub = 0;
../inputs/grep1.dat:  
../inputs/grep1.dat:  /* Match anchors at newline.  */
../inputs/grep1.dat:  bufp->newline_anchor = 1;
../inputs/grep1.dat:  
../inputs/grep1.dat:  ret = regex_compile (pattern, length, re_syntax_options, bufp);
../inputs/grep1.dat:
../inputs/grep1.dat:  return re_error_msg[(int) ret];
../inputs/grep1.dat:}     
../inputs/grep1.dat:
../inputs/grep1.dat:/* Entry points compatible with 4.2 BSD regex library.  We don't define
../inputs/grep1.dat:   them if this is an Emacs or POSIX compilation.  */
../inputs/grep1.dat:
../inputs/grep1.dat:#if !defined (emacs) && !defined (_POSIX_SOURCE)
../inputs/grep1.dat:
../inputs/grep1.dat:/* BSD has one and only one pattern buffer.  */
../inputs/grep1.dat:static struct re_pattern_buffer re_comp_buf;
../inputs/grep1.dat:
../inputs/grep1.dat:char *
../inputs/grep1.dat:re_comp (s)
../inputs/grep1.dat:    const char *s;
../inputs/grep1.dat:{
../inputs/grep1.dat:  reg_errcode_t ret;
../inputs/grep1.dat:  
../inputs/grep1.dat:  if (!s)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      if (!re_comp_buf.buffer)
../inputs/grep1.dat:	return "No previous regular expression";
../inputs/grep1.dat:      return 0;
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  if (!re_comp_buf.buffer)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      re_comp_buf.buffer = (unsigned char *) malloc (200);
../inputs/grep1.dat:      if (re_comp_buf.buffer == NULL)
../inputs/grep1.dat:        return "Memory exhausted";
../inputs/grep1.dat:      re_comp_buf.allocated = 200;
../inputs/grep1.dat:
../inputs/grep1.dat:      re_comp_buf.fastmap = (char *) malloc (1 << BYTEWIDTH);
../inputs/grep1.dat:      if (re_comp_buf.fastmap == NULL)
../inputs/grep1.dat:	return "Memory exhausted";
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Since `re_exec' always passes NULL for the `regs' argument, we
../inputs/grep1.dat:     don't need to initialize the pattern buffer fields which affect it.  */
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Match anchors at newlines.  */
../inputs/grep1.dat:  re_comp_buf.newline_anchor = 1;
../inputs/grep1.dat:
../inputs/grep1.dat:  ret = regex_compile (s, strlen (s), re_syntax_options, &re_comp_buf);
../inputs/grep1.dat:  
../inputs/grep1.dat:  /* Yes, we're discarding `const' here.  */
../inputs/grep1.dat:  return (char *) re_error_msg[(int) ret];
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:int
../inputs/grep1.dat:re_exec (s)
../inputs/grep1.dat:    const char *s;
../inputs/grep1.dat:{
../inputs/grep1.dat:  const int len = strlen (s);
../inputs/grep1.dat:  return
../inputs/grep1.dat:    0 <= re_search (&re_comp_buf, s, len, 0, len, (struct re_registers *) 0);
../inputs/grep1.dat:}
../inputs/grep1.dat:#endif /* not emacs and not _POSIX_SOURCE */
../inputs/grep1.dat:
../inputs/grep1.dat:/* POSIX.2 functions.  Don't define these for Emacs.  */
../inputs/grep1.dat:
../inputs/grep1.dat:#ifndef emacs
../inputs/grep1.dat:
../inputs/grep1.dat:/* regcomp takes a regular expression as a string and compiles it.
../inputs/grep1.dat:
../inputs/grep1.dat:   PREG is a regex_t *.  We do not expect any fields to be initialized,
../inputs/grep1.dat:   since POSIX says we shouldn't.  Thus, we set
../inputs/grep1.dat:
../inputs/grep1.dat:     `buffer' to the compiled pattern;
../inputs/grep1.dat:     `used' to the length of the compiled pattern;
../inputs/grep1.dat:     `syntax' to RE_SYNTAX_POSIX_EXTENDED if the
../inputs/grep1.dat:       REG_EXTENDED bit in CFLAGS is set; otherwise, to
../inputs/grep1.dat:       RE_SYNTAX_POSIX_BASIC;
../inputs/grep1.dat:     `newline_anchor' to REG_NEWLINE being set in CFLAGS;
../inputs/grep1.dat:     `fastmap' and `fastmap_accurate' to zero;
../inputs/grep1.dat:     `re_nsub' to the number of subexpressions in PATTERN.
../inputs/grep1.dat:
../inputs/grep1.dat:   PATTERN is the address of the pattern string.
../inputs/grep1.dat:
../inputs/grep1.dat:   CFLAGS is a series of bits which affect compilation.
../inputs/grep1.dat:
../inputs/grep1.dat:     If REG_EXTENDED is set, we use POSIX extended syntax; otherwise, we
../inputs/grep1.dat:     use POSIX basic syntax.
../inputs/grep1.dat:
../inputs/grep1.dat:     If REG_NEWLINE is set, then . and [^...] don't match newline.
../inputs/grep1.dat:     Also, regexec will try a match beginning after every newline.
../inputs/grep1.dat:
../inputs/grep1.dat:     If REG_ICASE is set, then we considers upper- and lowercase
../inputs/grep1.dat:     versions of letters to be equivalent when matching.
../inputs/grep1.dat:
../inputs/grep1.dat:     If REG_NOSUB is set, then when PREG is passed to regexec, that
../inputs/grep1.dat:     routine will report only success or failure, and nothing about the
../inputs/grep1.dat:     registers.
../inputs/grep1.dat:
../inputs/grep1.dat:   It returns 0 if it succeeds, nonzero if it doesn't.  (See regex.h for
../inputs/grep1.dat:   the return codes and their meanings.)  */
../inputs/grep1.dat:
../inputs/grep1.dat:int
../inputs/grep1.dat:regcomp (preg, pattern, cflags)
../inputs/grep1.dat:    regex_t *preg;
../inputs/grep1.dat:    const char *pattern; 
../inputs/grep1.dat:    int cflags;
../inputs/grep1.dat:{
../inputs/grep1.dat:  reg_errcode_t ret;
../inputs/grep1.dat:  unsigned syntax
../inputs/grep1.dat:    = (cflags & REG_EXTENDED) ?
../inputs/grep1.dat:      RE_SYNTAX_POSIX_EXTENDED : RE_SYNTAX_POSIX_BASIC;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* regex_compile will allocate the space for the compiled pattern.  */
../inputs/grep1.dat:  preg->buffer = 0;
../inputs/grep1.dat:  preg->allocated = 0;
../inputs/grep1.dat:  preg->used = 0;
../inputs/grep1.dat:  
../inputs/grep1.dat:  /* Don't bother to use a fastmap when searching.  This simplifies the
../inputs/grep1.dat:     REG_NEWLINE case: if we used a fastmap, we'd have to put all the
../inputs/grep1.dat:     characters after newlines into the fastmap.  This way, we just try
../inputs/grep1.dat:     every character.  */
../inputs/grep1.dat:  preg->fastmap = 0;
../inputs/grep1.dat:  
../inputs/grep1.dat:  if (cflags & REG_ICASE)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      unsigned i;
../inputs/grep1.dat:      
../inputs/grep1.dat:      preg->translate = (char *) malloc (CHAR_SET_SIZE);
../inputs/grep1.dat:      if (preg->translate == NULL)
../inputs/grep1.dat:        return (int) REG_ESPACE;
../inputs/grep1.dat:
../inputs/grep1.dat:      /* Map uppercase characters to corresponding lowercase ones.  */
../inputs/grep1.dat:      for (i = 0; i < CHAR_SET_SIZE; i++)
../inputs/grep1.dat:        preg->translate[i] = ISUPPER (i) ? tolower (i) : i;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  else
../inputs/grep1.dat:    preg->translate = NULL;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* If REG_NEWLINE is set, newlines are treated differently.  */
../inputs/grep1.dat:  if (cflags & REG_NEWLINE)
../inputs/grep1.dat:    { /* REG_NEWLINE implies neither . nor [^...] match newline.  */
../inputs/grep1.dat:      syntax &= ~RE_DOT_NEWLINE;
../inputs/grep1.dat:      syntax |= RE_HAT_LISTS_NOT_NEWLINE;
../inputs/grep1.dat:      /* It also changes the matching behavior.  */
../inputs/grep1.dat:      preg->newline_anchor = 1;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  else
../inputs/grep1.dat:    preg->newline_anchor = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:  preg->no_sub = !!(cflags & REG_NOSUB);
../inputs/grep1.dat:
../inputs/grep1.dat:  /* POSIX says a null character in the pattern terminates it, so we 
../inputs/grep1.dat:     can use strlen here in compiling the pattern.  */
../inputs/grep1.dat:  ret = regex_compile (pattern, strlen (pattern), syntax, preg);
../inputs/grep1.dat:  
../inputs/grep1.dat:  /* POSIX doesn't distinguish between an unmatched open-group and an
../inputs/grep1.dat:     unmatched close-group: both are REG_EPAREN.  */
../inputs/grep1.dat:  if (ret == REG_ERPAREN) ret = REG_EPAREN;
../inputs/grep1.dat:  
../inputs/grep1.dat:  return (int) ret;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* regexec searches for a given pattern, specified by PREG, in the
../inputs/grep1.dat:   string STRING.
../inputs/grep1.dat:   
../inputs/grep1.dat:   If NMATCH is zero or REG_NOSUB was set in the cflags argument to
../inputs/grep1.dat:   `regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at
../inputs/grep1.dat:   least NMATCH elements, and we set them to the offsets of the
../inputs/grep1.dat:   corresponding matched substrings.
../inputs/grep1.dat:   
../inputs/grep1.dat:   EFLAGS specifies `execution flags' which affect matching: if
../inputs/grep1.dat:   REG_NOTBOL is set, then ^ does not match at the beginning of the
../inputs/grep1.dat:   string; if REG_NOTEOL is set, then $ does not match at the end.
../inputs/grep1.dat:   
../inputs/grep1.dat:   We return 0 if we find a match and REG_NOMATCH if not.  */
../inputs/grep1.dat:
../inputs/grep1.dat:int
../inputs/grep1.dat:regexec (preg, string, nmatch, pmatch, eflags)
../inputs/grep1.dat:    const regex_t *preg;
../inputs/grep1.dat:    const char *string; 
../inputs/grep1.dat:    size_t nmatch; 
../inputs/grep1.dat:    regmatch_t pmatch[]; 
../inputs/grep1.dat:    int eflags;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int ret;
../inputs/grep1.dat:  struct re_registers regs;
../inputs/grep1.dat:  regex_t private_preg;
../inputs/grep1.dat:  int len = strlen (string);
../inputs/grep1.dat:  boolean want_reg_info = !preg->no_sub && nmatch > 0;
../inputs/grep1.dat:
../inputs/grep1.dat:  private_preg = *preg;
../inputs/grep1.dat:  
../inputs/grep1.dat:  private_preg.not_bol = !!(eflags & REG_NOTBOL);
../inputs/grep1.dat:  private_preg.not_eol = !!(eflags & REG_NOTEOL);
../inputs/grep1.dat:  
../inputs/grep1.dat:  /* The user has told us exactly how many registers to return
../inputs/grep1.dat:     information about, via `nmatch'.  We have to pass that on to the
../inputs/grep1.dat:     matching routines.  */
../inputs/grep1.dat:  private_preg.regs_allocated = REGS_FIXED;
../inputs/grep1.dat:  
../inputs/grep1.dat:  if (want_reg_info)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      regs.num_regs = nmatch;
../inputs/grep1.dat:      regs.start = TALLOC (nmatch, regoff_t);
../inputs/grep1.dat:      regs.end = TALLOC (nmatch, regoff_t);
../inputs/grep1.dat:      if (regs.start == NULL || regs.end == NULL)
../inputs/grep1.dat:        return (int) REG_NOMATCH;
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Perform the searching operation.  */
../inputs/grep1.dat:  ret = re_search (&private_preg, string, len,
../inputs/grep1.dat:                   /* start: */ 0, /* range: */ len,
../inputs/grep1.dat:                   want_reg_info ? &regs : (struct re_registers *) 0);
../inputs/grep1.dat:  
../inputs/grep1.dat:  /* Copy the register information to the POSIX structure.  */
../inputs/grep1.dat:  if (want_reg_info)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      if (ret >= 0)
../inputs/grep1.dat:        {
../inputs/grep1.dat:          unsigned r;
../inputs/grep1.dat:
../inputs/grep1.dat:          for (r = 0; r < nmatch; r++)
../inputs/grep1.dat:            {
../inputs/grep1.dat:              pmatch[r].rm_so = regs.start[r];
../inputs/grep1.dat:              pmatch[r].rm_eo = regs.end[r];
../inputs/grep1.dat:            }
../inputs/grep1.dat:        }
../inputs/grep1.dat:
../inputs/grep1.dat:      /* If we needed the temporary register info, free the space now.  */
../inputs/grep1.dat:      free (regs.start);
../inputs/grep1.dat:      free (regs.end);
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  /* We want zero return to mean success, unlike `re_search'.  */
../inputs/grep1.dat:  return ret >= 0 ? (int) REG_NOERROR : (int) REG_NOMATCH;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Returns a message corresponding to an error code, ERRCODE, returned
../inputs/grep1.dat:   from either regcomp or regexec.   We don't use PREG here.  */
../inputs/grep1.dat:
../inputs/grep1.dat:size_t
../inputs/grep1.dat:regerror (errcode, preg, errbuf, errbuf_size)
../inputs/grep1.dat:    int errcode;
../inputs/grep1.dat:    const regex_t *preg;
../inputs/grep1.dat:    char *errbuf;
../inputs/grep1.dat:    size_t errbuf_size;
../inputs/grep1.dat:{
../inputs/grep1.dat:  const char *msg;
../inputs/grep1.dat:  size_t msg_size;
../inputs/grep1.dat:
../inputs/grep1.dat:  if (errcode < 0
../inputs/grep1.dat:      || errcode >= (sizeof (re_error_msg) / sizeof (re_error_msg[0])))
../inputs/grep1.dat:    /* Only error codes returned by the rest of the code should be passed 
../inputs/grep1.dat:       to this routine.  If we are given anything else, or if other regex
../inputs/grep1.dat:       code generates an invalid error code, then the program has a bug.
../inputs/grep1.dat:       Dump core so we can fix it.  */
../inputs/grep1.dat:    abort ();
../inputs/grep1.dat:
../inputs/grep1.dat:  msg = re_error_msg[errcode];
../inputs/grep1.dat:
../inputs/grep1.dat:  /* POSIX doesn't require that we do anything in this case, but why
../inputs/grep1.dat:     not be nice.  */
../inputs/grep1.dat:  if (! msg)
../inputs/grep1.dat:    msg = "Success";
../inputs/grep1.dat:
../inputs/grep1.dat:  
../inputs/grep1.dat:  if (errbuf_size != 0)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      if (msg_size > errbuf_size)
../inputs/grep1.dat:        {
../inputs/grep1.dat:          strncpy (errbuf, msg, errbuf_size - 1);
../inputs/grep1.dat:          errbuf[errbuf_size - 1] = 0;
../inputs/grep1.dat:        }
../inputs/grep1.dat:      else
../inputs/grep1.dat:        strcpy (errbuf, msg);
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  return msg_size;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Free dynamically allocated space used by PREG.  */
../inputs/grep1.dat:
../inputs/grep1.dat:void
../inputs/grep1.dat:regfree (preg)
../inputs/grep1.dat:    regex_t *preg;
../inputs/grep1.dat:{
../inputs/grep1.dat:  if (preg->buffer != NULL)
../inputs/grep1.dat:    free (preg->buffer);
../inputs/grep1.dat:  preg->buffer = NULL;
../inputs/grep1.dat:  
../inputs/grep1.dat:  preg->allocated = 0;
../inputs/grep1.dat:  preg->used = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:  if (preg->fastmap != NULL)
../inputs/grep1.dat:    free (preg->fastmap);
../inputs/grep1.dat:  preg->fastmap = NULL;
../inputs/grep1.dat:  preg->fastmap_accurate = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:  if (preg->translate != NULL)
../inputs/grep1.dat:    free (preg->translate);
../inputs/grep1.dat:  preg->translate = NULL;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:#endif /* not emacs  */
../inputs/grep1.dat:
../inputs/grep1.dat:/*
../inputs/grep1.dat:Local variables:
../inputs/grep1.dat:make-backup-files: t
../inputs/grep1.dat:version-control: t
../inputs/grep1.dat:trim-versions-without-asking: nil
../inputs/grep1.dat:End:
../inputs/grep1.dat:*/
../inputs/grep1.dat:/* dfa.c - deterministic extended regexp routines for GNU
../inputs/grep1.dat:   Copyright (C) 1988 Free Software Foundation, Inc.
../inputs/grep1.dat:
../inputs/grep1.dat:   This program is free software; you can redistribute it and/or modify
../inputs/grep1.dat:   it under the terms of the GNU General Public License as published by
../inputs/grep1.dat:   the Free Software Foundation; either version 2, or (at your option)
../inputs/grep1.dat:   any later version.
../inputs/grep1.dat:
../inputs/grep1.dat:   This program is distributed in the hope that it will be useful,
../inputs/grep1.dat:   but WITHOUT ANY WARRANTY; without even the implied warranty of
../inputs/grep1.dat:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
../inputs/grep1.dat:   GNU General Public License for more details.
../inputs/grep1.dat:
../inputs/grep1.dat:   You should have received a copy of the GNU General Public License
../inputs/grep1.dat:   along with this program; if not, write to the Free Software
../inputs/grep1.dat:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
../inputs/grep1.dat:
../inputs/grep1.dat:/* Written June, 1988 by Mike Haertel
../inputs/grep1.dat:   Modified July, 1988 by Arthur David Olson to assist BMG speedups  */
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef STDC_HEADERS
../inputs/grep1.dat:#if flag_stdlib==0
../inputs/grep1.dat:#define flag_stdlib 1
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#else
../inputs/grep1.dat:#if flag_systypes==0 
../inputs/grep1.dat:#define flag_systypes 1
../inputs/grep1.dat:#endif
../inputs/grep1.dat:extern char *calloc(), *malloc(), *realloc();
../inputs/grep1.dat:extern void free();
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:#if defined(HAVE_STRING_H) || defined(STDC_HEADERS)
../inputs/grep1.dat:#if flag_string==0
../inputs/grep1.dat:#define flag_string 1
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#undef index
../inputs/grep1.dat:#define index strchr
../inputs/grep1.dat:#else
../inputs/grep1.dat:#if flag_strings==0
../inputs/grep1.dat:#define flag_strings 1
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:#ifndef isgraph
../inputs/grep1.dat:#define isgraph(C) (isprint(C) && !isspace(C))
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:#undef ISALPHA
../inputs/grep1.dat:#undef ISUPPER
../inputs/grep1.dat:#undef ISLOWER
../inputs/grep1.dat:#undef ISDIGIT
../inputs/grep1.dat:#undef ISXDIGIT
../inputs/grep1.dat:#undef ISSPACE
../inputs/grep1.dat:#undef ISPUNCT
../inputs/grep1.dat:#undef ISALNUM
../inputs/grep1.dat:#undef ISPRINT
../inputs/grep1.dat:#undef ISGRAPH
../inputs/grep1.dat:#undef ISCNTRL
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef isascii
../inputs/grep1.dat:#define ISALPHA(C) (isascii(C) && isalpha(C))
../inputs/grep1.dat:#define ISUPPER(C) (isascii(C) && isupper(C))
../inputs/grep1.dat:#define ISLOWER(C) (isascii(C) && islower(C))
../inputs/grep1.dat:#define ISDIGIT(C) (isascii(C) && isdigit(C))
../inputs/grep1.dat:#define ISXDIGIT(C) (isascii(C) && isxdigit(C))
../inputs/grep1.dat:#define ISSPACE(C) (isascii(C) && isspace(C))
../inputs/grep1.dat:#define ISPUNCT(C) (isascii(C) && ispunct(C))
../inputs/grep1.dat:#define ISALNUM(C) (isascii(C) && isalnum(C))
../inputs/grep1.dat:#define ISPRINT(C) (isascii(C) && isprint(C))
../inputs/grep1.dat:#define ISGRAPH(C) (isascii(C) && isgraph(C))
../inputs/grep1.dat:#define ISCNTRL(C) (isascii(C) && iscntrl(C))
../inputs/grep1.dat:#else
../inputs/grep1.dat:#define ISALPHA(C) isalpha(C)
../inputs/grep1.dat:#define ISUPPER(C) isupper(C)
../inputs/grep1.dat:#define ISLOWER(C) islower(C)
../inputs/grep1.dat:#define ISDIGIT(C) isdigit(C)
../inputs/grep1.dat:#define ISXDIGIT(C) isxdigit(C)
../inputs/grep1.dat:#define ISSPACE(C) isspace(C)
../inputs/grep1.dat:#define ISPUNCT(C) ispunct(C)
../inputs/grep1.dat:#define ISALNUM(C) isalnum(C)
../inputs/grep1.dat:#define ISPRINT(C) isprint(C)
../inputs/grep1.dat:#define ISGRAPH(C) isgraph(C)
../inputs/grep1.dat:#define ISCNTRL(C) iscntrl(C)
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:#if __STDC__
../inputs/grep1.dat:typedef void *ptr_t;
../inputs/grep1.dat:#else
../inputs/grep1.dat:typedef char *ptr_t;
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:static void	dfamust();
../inputs/grep1.dat:
../inputs/grep1.dat:static ptr_t
../inputs/grep1.dat:xcalloc(n, s)
../inputs/grep1.dat:     int n;
../inputs/grep1.dat:     size_t s;
../inputs/grep1.dat:{
../inputs/grep1.dat:  ptr_t r = calloc(n, s);
../inputs/grep1.dat:
../inputs/grep1.dat:  if (!r)
../inputs/grep1.dat:    dfaerror("Memory exhausted");
../inputs/grep1.dat:  return r;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static ptr_t
../inputs/grep1.dat:xmalloc_1(n)
../inputs/grep1.dat:     size_t n;
../inputs/grep1.dat:{
../inputs/grep1.dat:  ptr_t r = malloc(n);
../inputs/grep1.dat:
../inputs/grep1.dat:  assert(n != 0);
../inputs/grep1.dat:  if (!r)
../inputs/grep1.dat:    dfaerror("Memory exhausted");
../inputs/grep1.dat:  return r;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static ptr_t
../inputs/grep1.dat:xrealloc_1(p, n)
../inputs/grep1.dat:     ptr_t p;
../inputs/grep1.dat:     size_t n;
../inputs/grep1.dat:{
../inputs/grep1.dat:  ptr_t r = realloc(p, n);
../inputs/grep1.dat:
../inputs/grep1.dat:  assert(n != 0);
../inputs/grep1.dat:  if (!r)
../inputs/grep1.dat:    dfaerror("Memory exhausted");
../inputs/grep1.dat:  return r;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:#define CALLOC(p, t, n) ((p) = (t *) xcalloc((n), sizeof (t)))
../inputs/grep1.dat:#define MALLOC(p, t, n) ((p) = (t *) xmalloc_1((n) * sizeof (t)))
../inputs/grep1.dat:#define REALLOC(p, t, n) ((p) = (t *) xrealloc_1((ptr_t) (p), (n) * sizeof (t)))
../inputs/grep1.dat:
../inputs/grep1.dat:/* Reallocate an array of type t if nalloc is too small for index. */
../inputs/grep1.dat:#define REALLOC_IF_NECESSARY(p, t, nalloc, index) \
../inputs/grep1.dat:  if ((index) >= (nalloc))			  \
../inputs/grep1.dat:    {						  \
../inputs/grep1.dat:      while ((index) >= (nalloc))		  \
../inputs/grep1.dat:	(nalloc) *= 2;				  \
../inputs/grep1.dat:      REALLOC(p, t, nalloc);			  \
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef DEBUG
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:prtok(t)
../inputs/grep1.dat:     token t;
../inputs/grep1.dat:{
../inputs/grep1.dat:  char *s;
../inputs/grep1.dat:
../inputs/grep1.dat:  if (t < 0)
../inputs/grep1.dat:    fprintf(stderr, "END");
../inputs/grep1.dat:  else if (t < NOTCHAR)
../inputs/grep1.dat:    fprintf(stderr, "%c", t);
../inputs/grep1.dat:  else
../inputs/grep1.dat:    {
../inputs/grep1.dat:      switch (t)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	case EMPTY: s = "EMPTY"; break;
../inputs/grep1.dat:	case BACKREF: s = "BACKREF"; break;
../inputs/grep1.dat:	case BEGLINE: s = "BEGLINE"; break;
../inputs/grep1.dat:	case ENDLINE: s = "ENDLINE"; break;
../inputs/grep1.dat:	case BEGWORD: s = "BEGWORD"; break;
../inputs/grep1.dat:	case ENDWORD: s = "ENDWORD"; break;
../inputs/grep1.dat:	case LIMWORD: s = "LIMWORD"; break;
../inputs/grep1.dat:	case NOTLIMWORD: s = "NOTLIMWORD"; break;
../inputs/grep1.dat:	case QMARK: s = "QMARK"; break;
../inputs/grep1.dat:	case STAR: s = "STAR"; break;
../inputs/grep1.dat:	case PLUS: s = "PLUS"; break;
../inputs/grep1.dat:	case CAT: s = "CAT"; break;
../inputs/grep1.dat:	case OR: s = "OR"; break;
../inputs/grep1.dat:	case ORTOP: s = "ORTOP"; break;
../inputs/grep1.dat:	case LPAREN: s = "LPAREN"; break;
../inputs/grep1.dat:	case RPAREN: s = "RPAREN"; break;
../inputs/grep1.dat:	default: s = "CSET"; break;
../inputs/grep1.dat:	}
../inputs/grep1.dat:      fprintf(stderr, "%s", s);
../inputs/grep1.dat:    }
../inputs/grep1.dat:}
../inputs/grep1.dat:#endif /* DEBUG */
../inputs/grep1.dat:
../inputs/grep1.dat:/* Stuff pertaining to charclasses. */
../inputs/grep1.dat:
../inputs/grep1.dat:static int
../inputs/grep1.dat:tstbit(b, c)
../inputs/grep1.dat:     int b;
../inputs/grep1.dat:     charclass c;
../inputs/grep1.dat:{
../inputs/grep1.dat:  return c[b / INTBITS] & 1 << b % INTBITS;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:setbit(b, c)
../inputs/grep1.dat:     int b;
../inputs/grep1.dat:     charclass c;
../inputs/grep1.dat:{
../inputs/grep1.dat:  c[b / INTBITS] |= 1 << b % INTBITS;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:clrbit(b, c)
../inputs/grep1.dat:     int b;
../inputs/grep1.dat:     charclass c;
../inputs/grep1.dat:{
../inputs/grep1.dat:  c[b / INTBITS] &= ~(1 << b % INTBITS);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:copyset(src, dst)
../inputs/grep1.dat:     charclass src;
../inputs/grep1.dat:     charclass dst;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int i;
../inputs/grep1.dat:
../inputs/grep1.dat:  for (i = 0; i < CHARCLASS_INTS; ++i)
../inputs/grep1.dat:    dst[i] = src[i];
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:zeroset(s)
../inputs/grep1.dat:     charclass s;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int i;
../inputs/grep1.dat:
../inputs/grep1.dat:  for (i = 0; i < CHARCLASS_INTS; ++i)
../inputs/grep1.dat:    s[i] = 0;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:notset(s)
../inputs/grep1.dat:     charclass s;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int i;
../inputs/grep1.dat:
../inputs/grep1.dat:  for (i = 0; i < CHARCLASS_INTS; ++i)
../inputs/grep1.dat:    s[i] = ~s[i];
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static int
../inputs/grep1.dat:equal(s1, s2)
../inputs/grep1.dat:     charclass s1;
../inputs/grep1.dat:     charclass s2;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int i;
../inputs/grep1.dat:
../inputs/grep1.dat:  for (i = 0; i < CHARCLASS_INTS; ++i)
../inputs/grep1.dat:    if (s1[i] != s2[i])
../inputs/grep1.dat:      return 0;
../inputs/grep1.dat:  return 1;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* A pointer to the current dfa is kept here during parsing. */
../inputs/grep1.dat:static struct dfa *dfa;
../inputs/grep1.dat:
../inputs/grep1.dat:/* Find the index of charclass s in dfa->charclasses, or allocate a new charclass. */
../inputs/grep1.dat:static int
../inputs/grep1.dat:charclass_index(s)
../inputs/grep1.dat:     charclass s;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int i;
../inputs/grep1.dat:
../inputs/grep1.dat:  for (i = 0; i < dfa->cindex; ++i)
../inputs/grep1.dat:    if (equal(s, dfa->charclasses[i]))
../inputs/grep1.dat:      return i;
../inputs/grep1.dat:  REALLOC_IF_NECESSARY(dfa->charclasses, charclass, dfa->calloc, dfa->cindex);
../inputs/grep1.dat:  ++dfa->cindex;
../inputs/grep1.dat:  copyset(s, dfa->charclasses[i]);
../inputs/grep1.dat:  return i;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Syntax bits controlling the behavior of the lexical analyzer. */
../inputs/grep1.dat:static int syntax_bits, syntax_bits_set;
../inputs/grep1.dat:
../inputs/grep1.dat:/* Flag for case-folding letters into sets. */
../inputs/grep1.dat:static int case_fold;
../inputs/grep1.dat:
../inputs/grep1.dat:/* Entry point to set syntax options. */
../inputs/grep1.dat:void
../inputs/grep1.dat:dfasyntax(bits, fold)
../inputs/grep1.dat:     int bits;
../inputs/grep1.dat:     int fold;
../inputs/grep1.dat:{
../inputs/grep1.dat:  syntax_bits_set = 1;
../inputs/grep1.dat:  syntax_bits = bits;
../inputs/grep1.dat:  case_fold = fold;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Lexical analyzer.  All the dross that deals with the obnoxious
../inputs/grep1.dat:   GNU Regex syntax bits is located here.  The poor, suffering
../inputs/grep1.dat:   reader is referred to the GNU Regex documentation for the
../inputs/grep1.dat:   meaning of the @#%!@#%^!@ syntax bits. */
../inputs/grep1.dat:
../inputs/grep1.dat:static char *lexstart;		/* Pointer to beginning of input string. */
../inputs/grep1.dat:static char *lexptr;		/* Pointer to next input character. */
../inputs/grep1.dat:static lexleft;			/* Number of characters remaining. */
../inputs/grep1.dat:static token lasttok;		/* Previous token returned; initially END. */
../inputs/grep1.dat:static int laststart;		/* True if we're separated from beginning or (, |
../inputs/grep1.dat:				   only by zero-width characters. */
../inputs/grep1.dat:static int parens;		/* Count of outstanding left parens. */
../inputs/grep1.dat:static int minrep, maxrep;	/* Repeat counts for {m,n}. */
../inputs/grep1.dat:
../inputs/grep1.dat:/* Note that characters become unsigned here. */
../inputs/grep1.dat:#define FETCH(c, eoferr)   	      \
../inputs/grep1.dat:  {			   	      \
../inputs/grep1.dat:    if (! lexleft)	   	      \
../inputs/grep1.dat:      if (eoferr != 0)	   	      \
../inputs/grep1.dat:	dfaerror(eoferr);  	      \
../inputs/grep1.dat:      else		   	      \
../inputs/grep1.dat:	return END;	   	      \
../inputs/grep1.dat:    (c) = (unsigned char) *lexptr++;  \
../inputs/grep1.dat:    --lexleft;		   	      \
../inputs/grep1.dat:  }
../inputs/grep1.dat:
../inputs/grep1.dat:#define FUNC(F, P) static int F(c) int c; { return P(c); }
../inputs/grep1.dat:
../inputs/grep1.dat:FUNC(is_alpha, ISALPHA)
../inputs/grep1.dat:FUNC(is_upper, ISUPPER)
../inputs/grep1.dat:FUNC(is_lower, ISLOWER)
../inputs/grep1.dat:FUNC(is_digit, ISDIGIT)
../inputs/grep1.dat:FUNC(is_xdigit, ISXDIGIT)
../inputs/grep1.dat:FUNC(is_space, ISSPACE)
../inputs/grep1.dat:FUNC(is_punct, ISPUNCT)
../inputs/grep1.dat:FUNC(is_alnum, ISALNUM)
../inputs/grep1.dat:FUNC(is_print, ISPRINT)
../inputs/grep1.dat:FUNC(is_graph, ISGRAPH)
../inputs/grep1.dat:FUNC(is_cntrl, ISCNTRL)
../inputs/grep1.dat:
../inputs/grep1.dat:/* The following list maps the names of the Posix named character classes
../inputs/grep1.dat:   to predicate functions that determine whether a given character is in
../inputs/grep1.dat:   the class.  The leading [ has already been eaten by the lexical analyzer. */
../inputs/grep1.dat:static struct {
../inputs/grep1.dat:  char *name;
../inputs/grep1.dat:  int (*pred)();
../inputs/grep1.dat:} prednames[] = {
../inputs/grep1.dat:  ":alpha:]", is_alpha,
../inputs/grep1.dat:  ":upper:]", is_upper,
../inputs/grep1.dat:  ":lower:]", is_lower,
../inputs/grep1.dat:  ":digit:]", is_digit,
../inputs/grep1.dat:  ":xdigit:]", is_xdigit,
../inputs/grep1.dat:  ":space:]", is_space,
../inputs/grep1.dat:  ":punct:]", is_punct,
../inputs/grep1.dat:  ":alnum:]", is_alnum,
../inputs/grep1.dat:  ":print:]", is_print,
../inputs/grep1.dat:  ":graph:]", is_graph,
../inputs/grep1.dat:  ":cntrl:]", is_cntrl,
../inputs/grep1.dat:  0
../inputs/grep1.dat:};
../inputs/grep1.dat:
../inputs/grep1.dat:static int
../inputs/grep1.dat:looking_at(s)
../inputs/grep1.dat:     char *s;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int len;
../inputs/grep1.dat:
../inputs/grep1.dat:  len = strlen(s);
../inputs/grep1.dat:  if (lexleft < len)
../inputs/grep1.dat:    return 0;
../inputs/grep1.dat:  return strncmp(s, lexptr, len) == 0;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static token
../inputs/grep1.dat:lex()
../inputs/grep1.dat:{
../inputs/grep1.dat:  token c, c1, c2;
../inputs/grep1.dat:  int backslash = 0, invert;
../inputs/grep1.dat:  charclass ccl;
../inputs/grep1.dat:  int i;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Basic plan: We fetch a character.  If it's a backslash,
../inputs/grep1.dat:     we set the backslash flag and go through the loop again.
../inputs/grep1.dat:     On the plus side, this avoids having a duplicate of the
../inputs/grep1.dat:     main switch inside the backslash case.  On the minus side,
../inputs/grep1.dat:     it means that just about every case begins with
../inputs/grep1.dat:     "if (backslash) ...".  */
../inputs/grep1.dat:  for (i = 0; i < 2; ++i)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      FETCH(c, 0);
../inputs/grep1.dat:      switch (c)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	case '\\':
../inputs/grep1.dat:	  if (backslash)
../inputs/grep1.dat:	    goto normal_char;
../inputs/grep1.dat:	  if (lexleft == 0)
../inputs/grep1.dat:	    dfaerror("Unfinished \\ escape");
../inputs/grep1.dat:	  backslash = 1;
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:
../inputs/grep1.dat:	case '^':
../inputs/grep1.dat:	  if (backslash)
../inputs/grep1.dat:	    goto normal_char;
../inputs/grep1.dat:	  if (syntax_bits & RE_CONTEXT_INDEP_ANCHORS
../inputs/grep1.dat:	      || lasttok == END
../inputs/grep1.dat:	      || lasttok == LPAREN
../inputs/grep1.dat:	      || lasttok == OR)
../inputs/grep1.dat:	    return lasttok = BEGLINE;
../inputs/grep1.dat:	  goto normal_char;
../inputs/grep1.dat:
../inputs/grep1.dat:	case '$':
../inputs/grep1.dat:	  if (backslash)
../inputs/grep1.dat:	    goto normal_char;
../inputs/grep1.dat:	  if (syntax_bits & RE_CONTEXT_INDEP_ANCHORS
../inputs/grep1.dat:	      || lexleft == 0
../inputs/grep1.dat:	      || (syntax_bits & RE_NO_BK_PARENS
../inputs/grep1.dat:		  ? lexleft > 0 && *lexptr == ')'
../inputs/grep1.dat:		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == ')')
../inputs/grep1.dat:	      || (syntax_bits & RE_NO_BK_VBAR
../inputs/grep1.dat:		  ? lexleft > 0 && *lexptr == '|'
../inputs/grep1.dat:		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == '|')
../inputs/grep1.dat:	      || ((syntax_bits & RE_NEWLINE_ALT)
../inputs/grep1.dat:	          && lexleft > 0 && *lexptr == '\n'))
../inputs/grep1.dat:	    return lasttok = ENDLINE;
../inputs/grep1.dat:	  goto normal_char;
../inputs/grep1.dat:
../inputs/grep1.dat:	case '1':
../inputs/grep1.dat:	case '2':
../inputs/grep1.dat:	case '3':
../inputs/grep1.dat:	case '4':
../inputs/grep1.dat:	case '5':
../inputs/grep1.dat:	case '6':
../inputs/grep1.dat:	case '7':
../inputs/grep1.dat:	case '8':
../inputs/grep1.dat:	case '9':
../inputs/grep1.dat:	  if (backslash && !(syntax_bits & RE_NO_BK_REFS))
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      laststart = 0;
../inputs/grep1.dat:	      return lasttok = BACKREF;
../inputs/grep1.dat:	    }
../inputs/grep1.dat:	  goto normal_char;
../inputs/grep1.dat:
../inputs/grep1.dat:	case '<':
../inputs/grep1.dat:	  if (backslash)
../inputs/grep1.dat:	    return lasttok = BEGWORD;
../inputs/grep1.dat:	  goto normal_char;
../inputs/grep1.dat:
../inputs/grep1.dat:	case '>':
../inputs/grep1.dat:	  if (backslash)
../inputs/grep1.dat:	    return lasttok = ENDWORD;
../inputs/grep1.dat:	  goto normal_char;
../inputs/grep1.dat:
../inputs/grep1.dat:	case 'b':
../inputs/grep1.dat:	  if (backslash)
../inputs/grep1.dat:	    return lasttok = LIMWORD;
../inputs/grep1.dat:	  goto normal_char;
../inputs/grep1.dat:
../inputs/grep1.dat:	case 'B':
../inputs/grep1.dat:	  if (backslash)
../inputs/grep1.dat:	    return lasttok = NOTLIMWORD;
../inputs/grep1.dat:	  goto normal_char;
../inputs/grep1.dat:
../inputs/grep1.dat:	case '?':
../inputs/grep1.dat:	  if (syntax_bits & RE_LIMITED_OPS)
../inputs/grep1.dat:	    goto normal_char;
../inputs/grep1.dat:	  if (backslash != ((syntax_bits & RE_BK_PLUS_QM) != 0))
../inputs/grep1.dat:	    goto normal_char;
../inputs/grep1.dat:	  if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)
../inputs/grep1.dat:	    goto normal_char;
../inputs/grep1.dat:	  return lasttok = QMARK;
../inputs/grep1.dat:
../inputs/grep1.dat:	case '*':
../inputs/grep1.dat:	  if (backslash)
../inputs/grep1.dat:	    goto normal_char;
../inputs/grep1.dat:	  if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)
../inputs/grep1.dat:	    goto normal_char;
../inputs/grep1.dat:	  return lasttok = STAR;
../inputs/grep1.dat:
../inputs/grep1.dat:	case '+':
../inputs/grep1.dat:	  if (syntax_bits & RE_LIMITED_OPS)
../inputs/grep1.dat:	    goto normal_char;
../inputs/grep1.dat:	  if (backslash != ((syntax_bits & RE_BK_PLUS_QM) != 0))
../inputs/grep1.dat:	    goto normal_char;
../inputs/grep1.dat:	  if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)
../inputs/grep1.dat:	    goto normal_char;
../inputs/grep1.dat:	  return lasttok = PLUS;
../inputs/grep1.dat:
../inputs/grep1.dat:	case '{':
../inputs/grep1.dat:	  if (!(syntax_bits & RE_INTERVALS))
../inputs/grep1.dat:	    goto normal_char;
../inputs/grep1.dat:	  if (backslash != ((syntax_bits & RE_NO_BK_BRACES) == 0))
../inputs/grep1.dat:	    goto normal_char;
../inputs/grep1.dat:	  minrep = maxrep = 0;
../inputs/grep1.dat:	  /* Cases:
../inputs/grep1.dat:	     {M} - exact count
../inputs/grep1.dat:	     {M,} - minimum count, maximum is infinity
../inputs/grep1.dat:	     {,M} - 0 through M
../inputs/grep1.dat:	     {M,N} - M through N */
../inputs/grep1.dat:	  FETCH(c, "unfinished repeat count");
../inputs/grep1.dat:	  if (ISDIGIT(c))
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      minrep = c - '0';
../inputs/grep1.dat:	      for (;;)
../inputs/grep1.dat:		{
../inputs/grep1.dat:		  FETCH(c, "unfinished repeat count");
../inputs/grep1.dat:		  if (!ISDIGIT(c))
../inputs/grep1.dat:		    break;
../inputs/grep1.dat:		  minrep = 10 * minrep + c - '0';
../inputs/grep1.dat:		}
../inputs/grep1.dat:	    }
../inputs/grep1.dat:	  else if (c != ',')
../inputs/grep1.dat:	    dfaerror("malformed repeat count");
../inputs/grep1.dat:	  if (c == ',')
../inputs/grep1.dat:	    for (;;)
../inputs/grep1.dat:	      {
../inputs/grep1.dat:		FETCH(c, "unfinished repeat count");
../inputs/grep1.dat:		if (!ISDIGIT(c))
../inputs/grep1.dat:		  break;
../inputs/grep1.dat:		maxrep = 10 * maxrep + c - '0';
../inputs/grep1.dat:	      }
../inputs/grep1.dat:	  else
../inputs/grep1.dat:	    maxrep = minrep;
../inputs/grep1.dat:	  if (!(syntax_bits & RE_NO_BK_BRACES))
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      if (c != '\\')
../inputs/grep1.dat:		dfaerror("malformed repeat count");
../inputs/grep1.dat:	      FETCH(c, "unfinished repeat count");
../inputs/grep1.dat:	    }
../inputs/grep1.dat:	  if (c != '}')
../inputs/grep1.dat:	    dfaerror("malformed repeat count");
../inputs/grep1.dat:	  laststart = 0;
../inputs/grep1.dat:	  return lasttok = REPMN;
../inputs/grep1.dat:
../inputs/grep1.dat:	case '|':
../inputs/grep1.dat:	  if (syntax_bits & RE_LIMITED_OPS)
../inputs/grep1.dat:	    goto normal_char;
../inputs/grep1.dat:	  if (backslash != ((syntax_bits & RE_NO_BK_VBAR) == 0))
../inputs/grep1.dat:	    goto normal_char;
../inputs/grep1.dat:	  laststart = 1;
../inputs/grep1.dat:	  return lasttok = OR;
../inputs/grep1.dat:
../inputs/grep1.dat:	case '\n':
../inputs/grep1.dat:	  if (syntax_bits & RE_LIMITED_OPS
../inputs/grep1.dat:	      || backslash
../inputs/grep1.dat:	      || !(syntax_bits & RE_NEWLINE_ALT))
../inputs/grep1.dat:	    goto normal_char;
../inputs/grep1.dat:	  laststart = 1;
../inputs/grep1.dat:	  return lasttok = OR;
../inputs/grep1.dat:
../inputs/grep1.dat:	case '(':
../inputs/grep1.dat:	  if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))
../inputs/grep1.dat:	    goto normal_char;
../inputs/grep1.dat:	  ++parens;
../inputs/grep1.dat:	  laststart = 1;
../inputs/grep1.dat:	  return lasttok = LPAREN;
../inputs/grep1.dat:
../inputs/grep1.dat:	case ')':
../inputs/grep1.dat:	  if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))
../inputs/grep1.dat:	    goto normal_char;
../inputs/grep1.dat:	  if (parens == 0 && syntax_bits & RE_UNMATCHED_RIGHT_PAREN_ORD)
../inputs/grep1.dat:	    goto normal_char;
../inputs/grep1.dat:	  --parens;
../inputs/grep1.dat:	  laststart = 0;
../inputs/grep1.dat:	  return lasttok = RPAREN;
../inputs/grep1.dat:
../inputs/grep1.dat:	case '.':
../inputs/grep1.dat:	  if (backslash)
../inputs/grep1.dat:	    goto normal_char;
../inputs/grep1.dat:	  zeroset(ccl);
../inputs/grep1.dat:	  notset(ccl);
../inputs/grep1.dat:	  if (!(syntax_bits & RE_DOT_NEWLINE))
../inputs/grep1.dat:	    clrbit('\n', ccl);
../inputs/grep1.dat:	  if (syntax_bits & RE_DOT_NOT_NULL)
../inputs/grep1.dat:	    clrbit('\0', ccl);
../inputs/grep1.dat:	  laststart = 0;
../inputs/grep1.dat:	  return lasttok = CSET + charclass_index(ccl);
../inputs/grep1.dat:
../inputs/grep1.dat:	case 'w':
../inputs/grep1.dat:	case 'W':
../inputs/grep1.dat:	  if (!backslash)
../inputs/grep1.dat:	    goto normal_char;
../inputs/grep1.dat:	  zeroset(ccl);
../inputs/grep1.dat:	  for (c2 = 0; c2 < NOTCHAR; ++c2)
../inputs/grep1.dat:	    if (ISALNUM(c2))
../inputs/grep1.dat:	      setbit(c2, ccl);
../inputs/grep1.dat:	  if (c == 'W')
../inputs/grep1.dat:	    notset(ccl);
../inputs/grep1.dat:	  laststart = 0;
../inputs/grep1.dat:	  return lasttok = CSET + charclass_index(ccl);
../inputs/grep1.dat:	
../inputs/grep1.dat:	case '[':
../inputs/grep1.dat:	  if (backslash)
../inputs/grep1.dat:	    goto normal_char;
../inputs/grep1.dat:	  zeroset(ccl);
../inputs/grep1.dat:	  FETCH(c, "Unbalanced [");
../inputs/grep1.dat:	  if (c == '^')
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      FETCH(c, "Unbalanced [");
../inputs/grep1.dat:	      invert = 1;
../inputs/grep1.dat:	    }
../inputs/grep1.dat:	  else
../inputs/grep1.dat:	    invert = 0;
../inputs/grep1.dat:	  do
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      /* Nobody ever said this had to be fast. :-)
../inputs/grep1.dat:		 Note that if we're looking at some other [:...:]
../inputs/grep1.dat:		 construct, we just treat it as a bunch of ordinary
../inputs/grep1.dat:		 characters.  We can do this because we assume
../inputs/grep1.dat:		 regex has checked for syntax errors before
../inputs/grep1.dat:		 dfa is ever called. */
../inputs/grep1.dat:	      if (c == '[' && (syntax_bits & RE_CHAR_CLASSES))
../inputs/grep1.dat:		for (c1 = 0; prednames[c1].name; ++c1)
../inputs/grep1.dat:		  if (looking_at(prednames[c1].name))
../inputs/grep1.dat:		    {
../inputs/grep1.dat:		      for (c2 = 0; c2 < NOTCHAR; ++c2)
../inputs/grep1.dat:			if ((*prednames[c1].pred)(c2))
../inputs/grep1.dat:			  setbit(c2, ccl);
../inputs/grep1.dat:		      lexptr += strlen(prednames[c1].name);
../inputs/grep1.dat:		      lexleft -= strlen(prednames[c1].name);
../inputs/grep1.dat:		      FETCH(c1, "Unbalanced [");
../inputs/grep1.dat:		      goto skip;
../inputs/grep1.dat:		    }
../inputs/grep1.dat:	      if (c == '\\' && (syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))
../inputs/grep1.dat:		FETCH(c, "Unbalanced [");
../inputs/grep1.dat:	      FETCH(c1, "Unbalanced [");
../inputs/grep1.dat:	      if (c1 == '-')
../inputs/grep1.dat:		{
../inputs/grep1.dat:		  FETCH(c2, "Unbalanced [");
../inputs/grep1.dat:		  if (c2 == ']')
../inputs/grep1.dat:		    {
../inputs/grep1.dat:		      /* In the case [x-], the - is an ordinary hyphen,
../inputs/grep1.dat:			 which is left in c1, the lookahead character. */
../inputs/grep1.dat:		      --lexptr;
../inputs/grep1.dat:		      ++lexleft;
../inputs/grep1.dat:		      c2 = c;
../inputs/grep1.dat:		    }
../inputs/grep1.dat:		  else
../inputs/grep1.dat:		    {
../inputs/grep1.dat:		      if (c2 == '\\'
../inputs/grep1.dat:			  && (syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))
../inputs/grep1.dat:			FETCH(c2, "Unbalanced [");
../inputs/grep1.dat:		      FETCH(c1, "Unbalanced [");
../inputs/grep1.dat:		    }
../inputs/grep1.dat:		}
../inputs/grep1.dat:	      else
../inputs/grep1.dat:		c2 = c;
../inputs/grep1.dat:	      while (c <= c2)
../inputs/grep1.dat:		{
../inputs/grep1.dat:		  setbit(c, ccl);
../inputs/grep1.dat:		  if (case_fold)
../inputs/grep1.dat:		    if (ISUPPER(c))
../inputs/grep1.dat:		      setbit(tolower(c), ccl);
../inputs/grep1.dat:		    else if (ISLOWER(c))
../inputs/grep1.dat:		      setbit(toupper(c), ccl);
../inputs/grep1.dat:		  ++c;
../inputs/grep1.dat:		}
../inputs/grep1.dat:	    skip:
../inputs/grep1.dat:	      ;
../inputs/grep1.dat:	    }
../inputs/grep1.dat:	  while ((c = c1) != ']');
../inputs/grep1.dat:	  if (invert)
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      notset(ccl);
../inputs/grep1.dat:	      if (syntax_bits & RE_HAT_LISTS_NOT_NEWLINE)
../inputs/grep1.dat:		clrbit('\n', ccl);
../inputs/grep1.dat:	    }
../inputs/grep1.dat:	  laststart = 0;
../inputs/grep1.dat:	  return lasttok = CSET + charclass_index(ccl);
../inputs/grep1.dat:
../inputs/grep1.dat:	default:
../inputs/grep1.dat:	normal_char:
../inputs/grep1.dat:	  laststart = 0;
../inputs/grep1.dat:	  if (case_fold && ISALPHA(c))
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      zeroset(ccl);
../inputs/grep1.dat:	      setbit(c, ccl);
../inputs/grep1.dat:	      if (isupper(c))
../inputs/grep1.dat:		setbit(tolower(c), ccl);
../inputs/grep1.dat:	      else
../inputs/grep1.dat:		setbit(toupper(c), ccl);
../inputs/grep1.dat:	      return lasttok = CSET + charclass_index(ccl);
../inputs/grep1.dat:	    }
../inputs/grep1.dat:	  return c;
../inputs/grep1.dat:	}
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  /* The above loop should consume at most a backslash
../inputs/grep1.dat:     and some other character. */
../inputs/grep1.dat:  abort();
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Recursive descent parser for regular expressions. */
../inputs/grep1.dat:
../inputs/grep1.dat:static token tok;		/* Lookahead token. */
../inputs/grep1.dat:static depth;			/* Current depth of a hypothetical stack
../inputs/grep1.dat:				   holding deferred productions.  This is
../inputs/grep1.dat:				   used to determine the depth that will be
../inputs/grep1.dat:				   required of the real stack later on in
../inputs/grep1.dat:				   dfaanalyze(). */
../inputs/grep1.dat:
../inputs/grep1.dat:/* Add the given token to the parse tree, maintaining the depth count and
../inputs/grep1.dat:   updating the maximum depth if necessary. */
../inputs/grep1.dat:static void
../inputs/grep1.dat:addtok(t)
../inputs/grep1.dat:     token t;
../inputs/grep1.dat:{
../inputs/grep1.dat:  REALLOC_IF_NECESSARY(dfa->tokens, token, dfa->talloc, dfa->tindex);
../inputs/grep1.dat:  dfa->tokens[dfa->tindex++] = t;
../inputs/grep1.dat:
../inputs/grep1.dat:  switch (t)
../inputs/grep1.dat:    {
../inputs/grep1.dat:    case QMARK:
../inputs/grep1.dat:    case STAR:
../inputs/grep1.dat:    case PLUS:
../inputs/grep1.dat:      break;
../inputs/grep1.dat:
../inputs/grep1.dat:    case CAT:
../inputs/grep1.dat:    case OR:
../inputs/grep1.dat:    case ORTOP:
../inputs/grep1.dat:      --depth;
../inputs/grep1.dat:      break;
../inputs/grep1.dat:
../inputs/grep1.dat:    default:
../inputs/grep1.dat:      ++dfa->nleaves;
../inputs/grep1.dat:    case EMPTY:
../inputs/grep1.dat:      ++depth;
../inputs/grep1.dat:      break;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  if (depth > dfa->depth)
../inputs/grep1.dat:    dfa->depth = depth;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* The grammar understood by the parser is as follows.
../inputs/grep1.dat:
../inputs/grep1.dat:   regexp:
../inputs/grep1.dat:     regexp OR branch
../inputs/grep1.dat:     branch
../inputs/grep1.dat:
../inputs/grep1.dat:   branch:
../inputs/grep1.dat:     branch closure
../inputs/grep1.dat:     closure
../inputs/grep1.dat:
../inputs/grep1.dat:   closure:
../inputs/grep1.dat:     closure QMARK
../inputs/grep1.dat:     closure STAR
../inputs/grep1.dat:     closure PLUS
../inputs/grep1.dat:     atom
../inputs/grep1.dat:
../inputs/grep1.dat:   atom:
../inputs/grep1.dat:     <normal character>
../inputs/grep1.dat:     CSET
../inputs/grep1.dat:     BACKREF
../inputs/grep1.dat:     BEGLINE
../inputs/grep1.dat:     ENDLINE
../inputs/grep1.dat:     BEGWORD
../inputs/grep1.dat:     ENDWORD
../inputs/grep1.dat:     LIMWORD
../inputs/grep1.dat:     NOTLIMWORD
../inputs/grep1.dat:     <empty>
../inputs/grep1.dat:
../inputs/grep1.dat:   The parser builds a parse tree in postfix form in an array of tokens. */
../inputs/grep1.dat:
../inputs/grep1.dat:#if __STDC__
../inputs/grep1.dat:static void regexp(int);
../inputs/grep1.dat:#else
../inputs/grep1.dat:static void regexp();
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:atom()
../inputs/grep1.dat:{
../inputs/grep1.dat:  if ((tok >= 0 && tok < NOTCHAR) || tok >= CSET || tok == BACKREF
../inputs/grep1.dat:      || tok == BEGLINE || tok == ENDLINE || tok == BEGWORD
../inputs/grep1.dat:      || tok == ENDWORD || tok == LIMWORD || tok == NOTLIMWORD)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      addtok(tok);
../inputs/grep1.dat:      tok = lex();
../inputs/grep1.dat:    }
../inputs/grep1.dat:  else if (tok == LPAREN)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      tok = lex();
../inputs/grep1.dat:      regexp(0);
../inputs/grep1.dat:      if (tok != RPAREN)
../inputs/grep1.dat:	dfaerror("Unbalanced (");
../inputs/grep1.dat:      tok = lex();
../inputs/grep1.dat:    }
../inputs/grep1.dat:  else
../inputs/grep1.dat:    addtok(EMPTY);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Return the number of tokens in the given subexpression. */
../inputs/grep1.dat:static int
../inputs/grep1.dat:nsubtoks(tindex)
../inputs/grep1.dat:{
../inputs/grep1.dat:  int ntoks1;
../inputs/grep1.dat:
../inputs/grep1.dat:  switch (dfa->tokens[tindex - 1])
../inputs/grep1.dat:    {
../inputs/grep1.dat:    default:
../inputs/grep1.dat:      return 1;
../inputs/grep1.dat:    case QMARK:
../inputs/grep1.dat:    case STAR:
../inputs/grep1.dat:    case PLUS:
../inputs/grep1.dat:      return 1 + nsubtoks(tindex - 1);
../inputs/grep1.dat:    case CAT:
../inputs/grep1.dat:    case OR:
../inputs/grep1.dat:    case ORTOP:
../inputs/grep1.dat:      ntoks1 = nsubtoks(tindex - 1);
../inputs/grep1.dat:      return 1 + ntoks1 + nsubtoks(tindex - 1 - ntoks1);
../inputs/grep1.dat:    }
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Copy the given subexpression to the top of the tree. */
../inputs/grep1.dat:static void
../inputs/grep1.dat:copytoks(tindex, ntokens)
../inputs/grep1.dat:     int tindex, ntokens;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int i;
../inputs/grep1.dat:
../inputs/grep1.dat:  for (i = 0; i < ntokens; ++i)
../inputs/grep1.dat:    addtok(dfa->tokens[tindex + i]);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:closure()
../inputs/grep1.dat:{
../inputs/grep1.dat:  int tindex, ntokens, i;
../inputs/grep1.dat:
../inputs/grep1.dat:  atom();
../inputs/grep1.dat:  while (tok == QMARK || tok == STAR || tok == PLUS || tok == REPMN)
../inputs/grep1.dat:    if (tok == REPMN)
../inputs/grep1.dat:      {
../inputs/grep1.dat:	ntokens = nsubtoks(dfa->tindex);
../inputs/grep1.dat:	tindex = dfa->tindex - ntokens;
../inputs/grep1.dat:	if (maxrep == 0)
../inputs/grep1.dat:	  addtok(PLUS);
../inputs/grep1.dat:	if (minrep == 0)
../inputs/grep1.dat:	  addtok(QMARK);
../inputs/grep1.dat:	for (i = 1; i < minrep; ++i)
../inputs/grep1.dat:	  {
../inputs/grep1.dat:	    copytoks(tindex, ntokens);
../inputs/grep1.dat:	    addtok(CAT);
../inputs/grep1.dat:	  }
../inputs/grep1.dat:	for (; i < maxrep; ++i)
../inputs/grep1.dat:	  {
../inputs/grep1.dat:	    copytoks(tindex, ntokens);
../inputs/grep1.dat:	    addtok(QMARK);
../inputs/grep1.dat:	    addtok(CAT);
../inputs/grep1.dat:	  }
../inputs/grep1.dat:	tok = lex();
../inputs/grep1.dat:      }
../inputs/grep1.dat:    else
../inputs/grep1.dat:      {
../inputs/grep1.dat:	addtok(tok);
../inputs/grep1.dat:	tok = lex();
../inputs/grep1.dat:      }
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:branch()
../inputs/grep1.dat:{
../inputs/grep1.dat:  closure();
../inputs/grep1.dat:  while (tok != RPAREN && tok != OR && tok >= 0)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      closure();
../inputs/grep1.dat:      addtok(CAT);
../inputs/grep1.dat:    }
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:regexp(toplevel)
../inputs/grep1.dat:     int toplevel;
../inputs/grep1.dat:{
../inputs/grep1.dat:  branch();
../inputs/grep1.dat:  while (tok == OR)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      tok = lex();
../inputs/grep1.dat:      branch();
../inputs/grep1.dat:      if (toplevel)
../inputs/grep1.dat:	addtok(ORTOP);
../inputs/grep1.dat:      else
../inputs/grep1.dat:	addtok(OR);
../inputs/grep1.dat:    }
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Main entry point for the parser.  S is a string to be parsed, len is the
../inputs/grep1.dat:   the struct dfa to parse into. */
../inputs/grep1.dat:void
../inputs/grep1.dat:dfaparse(s, len, d)
../inputs/grep1.dat:     char *s;
../inputs/grep1.dat:     size_t len;
../inputs/grep1.dat:     struct dfa *d;
../inputs/grep1.dat:
../inputs/grep1.dat:{
../inputs/grep1.dat:  dfa = d;
../inputs/grep1.dat:  lexstart = lexptr = s;
../inputs/grep1.dat:  lexleft = len;
../inputs/grep1.dat:  lasttok = END;
../inputs/grep1.dat:  laststart = 1;
../inputs/grep1.dat:  parens = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:  if (! syntax_bits_set)
../inputs/grep1.dat:    dfaerror("No syntax specified");
../inputs/grep1.dat:
../inputs/grep1.dat:  tok = lex();
../inputs/grep1.dat:  depth = d->depth;
../inputs/grep1.dat:
../inputs/grep1.dat:  regexp(1);
../inputs/grep1.dat:
../inputs/grep1.dat:  if (tok != END)
../inputs/grep1.dat:    dfaerror("Unbalanced )");
../inputs/grep1.dat:
../inputs/grep1.dat:  addtok(END - d->nregexps);
../inputs/grep1.dat:  addtok(CAT);
../inputs/grep1.dat:
../inputs/grep1.dat:  if (d->nregexps)
../inputs/grep1.dat:    addtok(ORTOP);
../inputs/grep1.dat:
../inputs/grep1.dat:  ++d->nregexps;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Some primitives for operating on sets of positions. */
../inputs/grep1.dat:
../inputs/grep1.dat:/* Copy one set to another; the destination must be large enough. */
../inputs/grep1.dat:static void
../inputs/grep1.dat:copy(src, dst)
../inputs/grep1.dat:     position_set *src;
../inputs/grep1.dat:     position_set *dst;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int i;
../inputs/grep1.dat:
../inputs/grep1.dat:  for (i = 0; i < src->nelem; ++i)
../inputs/grep1.dat:    dst->elems[i] = src->elems[i];
../inputs/grep1.dat:  dst->nelem = src->nelem;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Insert a position in a set.  Position sets are maintained in sorted
../inputs/grep1.dat:   order according to index.  If position already exists in the set with
../inputs/grep1.dat:   the same index then their constraints are logically or'd together.
../inputs/grep1.dat:   S->elems must point to an array large enough to hold the resulting set. */
../inputs/grep1.dat:static void
../inputs/grep1.dat:insert(p, s)
../inputs/grep1.dat:     position p;
../inputs/grep1.dat:     position_set *s;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int i;
../inputs/grep1.dat:  position t1, t2;
../inputs/grep1.dat:
../inputs/grep1.dat:  for (i = 0; i < s->nelem && p.index < s->elems[i].index; ++i)
../inputs/grep1.dat:    ;
../inputs/grep1.dat:  if (i < s->nelem && p.index == s->elems[i].index)
../inputs/grep1.dat:    s->elems[i].constraint |= p.constraint;
../inputs/grep1.dat:  else
../inputs/grep1.dat:    {
../inputs/grep1.dat:      t1 = p;
../inputs/grep1.dat:      ++s->nelem;
../inputs/grep1.dat:      while (i < s->nelem)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  t2 = s->elems[i];
../inputs/grep1.dat:	  s->elems[i++] = t1;
../inputs/grep1.dat:	  t1 = t2;
../inputs/grep1.dat:	}
../inputs/grep1.dat:    }
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Merge two sets of positions into a third.  The result is exactly as if
../inputs/grep1.dat:   the positions of both sets were inserted into an initially empty set. */
../inputs/grep1.dat:static void
../inputs/grep1.dat:merge(s1, s2, m)
../inputs/grep1.dat:     position_set *s1;
../inputs/grep1.dat:     position_set *s2;
../inputs/grep1.dat:     position_set *m;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int i = 0, j = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:  m->nelem = 0;
../inputs/grep1.dat:  while (i < s1->nelem && j < s2->nelem)
../inputs/grep1.dat:    if (s1->elems[i].index > s2->elems[j].index)
../inputs/grep1.dat:      m->elems[m->nelem++] = s1->elems[i++];
../inputs/grep1.dat:    else if (s1->elems[i].index < s2->elems[j].index)
../inputs/grep1.dat:      m->elems[m->nelem++] = s2->elems[j++];
../inputs/grep1.dat:    else
../inputs/grep1.dat:      {
../inputs/grep1.dat:	m->elems[m->nelem] = s1->elems[i++];
../inputs/grep1.dat:	m->elems[m->nelem++].constraint |= s2->elems[j++].constraint;
../inputs/grep1.dat:      }
../inputs/grep1.dat:  while (i < s1->nelem)
../inputs/grep1.dat:    m->elems[m->nelem++] = s1->elems[i++];
../inputs/grep1.dat:  while (j < s2->nelem)
../inputs/grep1.dat:    m->elems[m->nelem++] = s2->elems[j++];
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Delete a position from a set. */
../inputs/grep1.dat:static void
../inputs/grep1.dat:delete(p, s)
../inputs/grep1.dat:     position p;
../inputs/grep1.dat:     position_set *s;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int i;
../inputs/grep1.dat:
../inputs/grep1.dat:  for (i = 0; i < s->nelem; ++i)
../inputs/grep1.dat:    if (p.index == s->elems[i].index)
../inputs/grep1.dat:      break;
../inputs/grep1.dat:  if (i < s->nelem)
../inputs/grep1.dat:    for (--s->nelem; i < s->nelem; ++i)
../inputs/grep1.dat:      s->elems[i] = s->elems[i + 1];
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Find the index of the state corresponding to the given position set with
../inputs/grep1.dat:   the given preceding context, or create a new state if there is no such
../inputs/grep1.dat:   state.  Newline and letter tell whether we got here on a newline or
../inputs/grep1.dat:   letter, respectively. */
../inputs/grep1.dat:static int
../inputs/grep1.dat:state_index(d, s, newline, letter)
../inputs/grep1.dat:     struct dfa *d;
../inputs/grep1.dat:     position_set *s;
../inputs/grep1.dat:     int newline;
../inputs/grep1.dat:     int letter;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int hash = 0;
../inputs/grep1.dat:  int constraint;
../inputs/grep1.dat:  int i, j;
../inputs/grep1.dat:
../inputs/grep1.dat:  newline = newline ? 1 : 0;
../inputs/grep1.dat:  letter = letter ? 1 : 0;
../inputs/grep1.dat:
../inputs/grep1.dat:  for (i = 0; i < s->nelem; ++i)
../inputs/grep1.dat:    hash ^= s->elems[i].index + s->elems[i].constraint;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Try to find a state that exactly matches the proposed one. */
../inputs/grep1.dat:  for (i = 0; i < d->sindex; ++i)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      if (hash != d->states[i].hash || s->nelem != d->states[i].elems.nelem
../inputs/grep1.dat:	  || newline != d->states[i].newline || letter != d->states[i].letter)
../inputs/grep1.dat:	continue;
../inputs/grep1.dat:      for (j = 0; j < s->nelem; ++j)
../inputs/grep1.dat:	if (s->elems[j].constraint
../inputs/grep1.dat:	    != d->states[i].elems.elems[j].constraint
../inputs/grep1.dat:	    || s->elems[j].index != d->states[i].elems.elems[j].index)
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:      if (j == s->nelem)
../inputs/grep1.dat:	return i;
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  /* We'll have to create a new state. */
../inputs/grep1.dat:  REALLOC_IF_NECESSARY(d->states, dfa_state, d->salloc, d->sindex);
../inputs/grep1.dat:  d->states[i].hash = hash;
../inputs/grep1.dat:  MALLOC(d->states[i].elems.elems, position, s->nelem);
../inputs/grep1.dat:  copy(s, &d->states[i].elems);
../inputs/grep1.dat:  d->states[i].newline = newline;
../inputs/grep1.dat:  d->states[i].letter = letter;
../inputs/grep1.dat:  d->states[i].backref = 0;
../inputs/grep1.dat:  d->states[i].constraint = 0;
../inputs/grep1.dat:  d->states[i].first_end = 0;
../inputs/grep1.dat:  for (j = 0; j < s->nelem; ++j)
../inputs/grep1.dat:    if (d->tokens[s->elems[j].index] < 0)
../inputs/grep1.dat:      {
../inputs/grep1.dat:	constraint = s->elems[j].constraint;
../inputs/grep1.dat:	if (SUCCEEDS_IN_CONTEXT(constraint, newline, 0, letter, 0)
../inputs/grep1.dat:	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 0, letter, 1)
../inputs/grep1.dat:	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 1, letter, 0)
../inputs/grep1.dat:	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 1, letter, 1))
../inputs/grep1.dat:	  d->states[i].constraint |= constraint;
../inputs/grep1.dat:	if (! d->states[i].first_end)
../inputs/grep1.dat:	  d->states[i].first_end = d->tokens[s->elems[j].index];
../inputs/grep1.dat:      }
../inputs/grep1.dat:    else if (d->tokens[s->elems[j].index] == BACKREF)
../inputs/grep1.dat:      {
../inputs/grep1.dat:	d->states[i].constraint = NO_CONSTRAINT;
../inputs/grep1.dat:	d->states[i].backref = 1;
../inputs/grep1.dat:      }
../inputs/grep1.dat:
../inputs/grep1.dat:  ++d->sindex;
../inputs/grep1.dat:
../inputs/grep1.dat:  return i;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Find the epsilon closure of a set of positions.  If any position of the set
../inputs/grep1.dat:   contains a symbol that matches the empty string in some context, replace
../inputs/grep1.dat:   that position with the elements of its follow labeled with an appropriate
../inputs/grep1.dat:   constraint.  Repeat exhaustively until no funny positions are left.
../inputs/grep1.dat:   S->elems must be large enough to hold the result. */
../inputs/grep1.dat:void
../inputs/grep1.dat:epsclosure(s, d)
../inputs/grep1.dat:     position_set *s;
../inputs/grep1.dat:     struct dfa *d;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int i, j;
../inputs/grep1.dat:  int *visited;
../inputs/grep1.dat:  position p, old;
../inputs/grep1.dat:
../inputs/grep1.dat:  MALLOC(visited, int, d->tindex);
../inputs/grep1.dat:  for (i = 0; i < d->tindex; ++i)
../inputs/grep1.dat:    visited[i] = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:  for (i = 0; i < s->nelem; ++i)
../inputs/grep1.dat:    if (d->tokens[s->elems[i].index] >= NOTCHAR
../inputs/grep1.dat:	&& d->tokens[s->elems[i].index] != BACKREF
../inputs/grep1.dat:	&& d->tokens[s->elems[i].index] < CSET)
../inputs/grep1.dat:      {
../inputs/grep1.dat:	old = s->elems[i];
../inputs/grep1.dat:	p.constraint = old.constraint;
../inputs/grep1.dat:	delete(s->elems[i], s);
../inputs/grep1.dat:	if (visited[old.index])
../inputs/grep1.dat:	  {
../inputs/grep1.dat:	    --i;
../inputs/grep1.dat:	    continue;
../inputs/grep1.dat:	  }
../inputs/grep1.dat:	visited[old.index] = 1;
../inputs/grep1.dat:	switch (d->tokens[old.index])
../inputs/grep1.dat:	  {
../inputs/grep1.dat:	  case BEGLINE:
../inputs/grep1.dat:	    p.constraint &= BEGLINE_CONSTRAINT;
../inputs/grep1.dat:	    break;
../inputs/grep1.dat:	  case ENDLINE:
../inputs/grep1.dat:	    p.constraint &= ENDLINE_CONSTRAINT;
../inputs/grep1.dat:	    break;
../inputs/grep1.dat:	  case BEGWORD:
../inputs/grep1.dat:	    p.constraint &= BEGWORD_CONSTRAINT;
../inputs/grep1.dat:	    break;
../inputs/grep1.dat:	  case ENDWORD:
../inputs/grep1.dat:	    p.constraint &= ENDWORD_CONSTRAINT;
../inputs/grep1.dat:	    break;
../inputs/grep1.dat:	  case LIMWORD:
../inputs/grep1.dat:	    p.constraint &= LIMWORD_CONSTRAINT;
../inputs/grep1.dat:	    break;
../inputs/grep1.dat:	  case NOTLIMWORD:
../inputs/grep1.dat:	    p.constraint &= NOTLIMWORD_CONSTRAINT;
../inputs/grep1.dat:	    break;
../inputs/grep1.dat:	  default:
../inputs/grep1.dat:	    break;
../inputs/grep1.dat:	  }
../inputs/grep1.dat:	for (j = 0; j < d->follows[old.index].nelem; ++j)
../inputs/grep1.dat:	  {
../inputs/grep1.dat:	    p.index = d->follows[old.index].elems[j].index;
../inputs/grep1.dat:	    insert(p, s);
../inputs/grep1.dat:	  }
../inputs/grep1.dat:	/* Force rescan to start at the beginning. */
../inputs/grep1.dat:	i = -1;
../inputs/grep1.dat:      }
../inputs/grep1.dat:
../inputs/grep1.dat:  free(visited);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Perform bottom-up analysis on the parse tree, computing various functions.
../inputs/grep1.dat:   Note that at this point, we're pretending constructs like \< are real
../inputs/grep1.dat:   characters rather than constraints on what can follow them.
../inputs/grep1.dat:
../inputs/grep1.dat:   Nullable:  A node is nullable if it is at the root of a regexp that can
../inputs/grep1.dat:   match the empty string.
../inputs/grep1.dat:   *  EMPTY leaves are nullable.
../inputs/grep1.dat:   * No other leaf is nullable.
../inputs/grep1.dat:   * A QMARK or STAR node is nullable.
../inputs/grep1.dat:   * A PLUS node is nullable if its argument is nullable.
../inputs/grep1.dat:   * A CAT node is nullable if both its arguments are nullable.
../inputs/grep1.dat:   * An OR node is nullable if either argument is nullable.
../inputs/grep1.dat:
../inputs/grep1.dat:   Firstpos:  The firstpos of a node is the set of positions (nonempty leaves)
../inputs/grep1.dat:   that could correspond to the first character of a string matching the
../inputs/grep1.dat:   regexp rooted at the given node.
../inputs/grep1.dat:   * EMPTY leaves have empty firstpos.
../inputs/grep1.dat:   * The firstpos of a nonempty leaf is that leaf itself.
../inputs/grep1.dat:   * The firstpos of a QMARK, STAR, or PLUS node is the firstpos of its
../inputs/grep1.dat:     argument.
../inputs/grep1.dat:   * The firstpos of a CAT node is the firstpos of the left argument, union
../inputs/grep1.dat:     the firstpos of the right if the left argument is nullable.
../inputs/grep1.dat:   * The firstpos of an OR node is the union of firstpos of each argument.
../inputs/grep1.dat:
../inputs/grep1.dat:   Lastpos:  The lastpos of a node is the set of positions that could
../inputs/grep1.dat:   correspond to the last character of a string matching the regexp at
../inputs/grep1.dat:   the given node.
../inputs/grep1.dat:   * EMPTY leaves have empty lastpos.
../inputs/grep1.dat:   * The lastpos of a nonempty leaf is that leaf itself.
../inputs/grep1.dat:   * The lastpos of a QMARK, STAR, or PLUS node is the lastpos of its
../inputs/grep1.dat:     argument.
../inputs/grep1.dat:   * The lastpos of a CAT node is the lastpos of its right argument, union
../inputs/grep1.dat:     the lastpos of the left if the right argument is nullable.
../inputs/grep1.dat:   * The lastpos of an OR node is the union of the lastpos of each argument.
../inputs/grep1.dat:
../inputs/grep1.dat:   Follow:  The follow of a position is the set of positions that could
../inputs/grep1.dat:   correspond to the character following a character matching the node in
../inputs/grep1.dat:   a string matching the regexp.  At this point we consider special symbols
../inputs/grep1.dat:   that match the empty string in some context to be just normal characters.
../inputs/grep1.dat:   Later, if we find that a special symbol is in a follow set, we will
../inputs/grep1.dat:   replace it with the elements of its follow, labeled with an appropriate
../inputs/grep1.dat:   constraint.
../inputs/grep1.dat:   * Every node in the firstpos of the argument of a STAR or PLUS node is in
../inputs/grep1.dat:     the follow of every node in the lastpos.
../inputs/grep1.dat:   * Every node in the firstpos of the second argument of a CAT node is in
../inputs/grep1.dat:     the follow of every node in the lastpos of the first argument.
../inputs/grep1.dat:
../inputs/grep1.dat:   Because of the postfix representation of the parse tree, the depth-first
../inputs/grep1.dat:   analysis is conveniently done by a linear scan with the aid of a stack.
../inputs/grep1.dat:   Sets are stored as arrays of the elements, obeying a stack-like allocation
../inputs/grep1.dat:   scheme; the number of elements in each set deeper in the stack can be
../inputs/grep1.dat:   used to determine the address of a particular set's array. */
../inputs/grep1.dat:void
../inputs/grep1.dat:dfaanalyze(d, searchflag)
../inputs/grep1.dat:     struct dfa *d;
../inputs/grep1.dat:     int searchflag;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int *nullable;		/* Nullable stack. */
../inputs/grep1.dat:  int *nfirstpos;		/* Element count stack for firstpos sets. */
../inputs/grep1.dat:  position *firstpos;		/* Array where firstpos elements are stored. */
../inputs/grep1.dat:  int *nlastpos;		/* Element count stack for lastpos sets. */
../inputs/grep1.dat:  position *lastpos;		/* Array where lastpos elements are stored. */
../inputs/grep1.dat:  int *nalloc;			/* Sizes of arrays allocated to follow sets. */
../inputs/grep1.dat:  position_set tmp;		/* Temporary set for merging sets. */
../inputs/grep1.dat:  position_set merged;		/* Result of merging sets. */
../inputs/grep1.dat:  int wants_newline;		/* True if some position wants newline info. */
../inputs/grep1.dat:  int *o_nullable;
../inputs/grep1.dat:  int *o_nfirst, *o_nlast;
../inputs/grep1.dat:  position *o_firstpos, *o_lastpos;
../inputs/grep1.dat:  int i, j;
../inputs/grep1.dat:  position *pos;
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef DEBUG
../inputs/grep1.dat:  fprintf(stderr, "dfaanalyze:\n");
../inputs/grep1.dat:  for (i = 0; i < d->tindex; ++i)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      fprintf(stderr, " %d:", i);
../inputs/grep1.dat:      prtok(d->tokens[i]);
../inputs/grep1.dat:    }
../inputs/grep1.dat:  putc('\n', stderr);
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:  d->searchflag = searchflag;
../inputs/grep1.dat:
../inputs/grep1.dat:  MALLOC(nullable, int, d->depth);
../inputs/grep1.dat:  o_nullable = nullable;
../inputs/grep1.dat:  MALLOC(nfirstpos, int, d->depth);
../inputs/grep1.dat:  o_nfirst = nfirstpos;
../inputs/grep1.dat:  MALLOC(firstpos, position, d->nleaves);
../inputs/grep1.dat:  o_firstpos = firstpos, firstpos += d->nleaves;
../inputs/grep1.dat:  MALLOC(nlastpos, int, d->depth);
../inputs/grep1.dat:  o_nlast = nlastpos;
../inputs/grep1.dat:  MALLOC(lastpos, position, d->nleaves);
../inputs/grep1.dat:  o_lastpos = lastpos, lastpos += d->nleaves;
../inputs/grep1.dat:  MALLOC(nalloc, int, d->tindex);
../inputs/grep1.dat:  for (i = 0; i < d->tindex; ++i)
../inputs/grep1.dat:    nalloc[i] = 0;
../inputs/grep1.dat:  MALLOC(merged.elems, position, d->nleaves);
../inputs/grep1.dat:
../inputs/grep1.dat:  CALLOC(d->follows, position_set, d->tindex);
../inputs/grep1.dat:
../inputs/grep1.dat:  for (i = 0; i < d->tindex; ++i)
../inputs/grep1.dat:#ifdef DEBUG
../inputs/grep1.dat:    {				/* Nonsyntactic #ifdef goo... */
../inputs/grep1.dat:#endif
../inputs/grep1.dat:    switch (d->tokens[i])
../inputs/grep1.dat:      {
../inputs/grep1.dat:      case EMPTY:
../inputs/grep1.dat:	/* The empty set is nullable. */
../inputs/grep1.dat:	*nullable++ = 1;
../inputs/grep1.dat:
../inputs/grep1.dat:	/* The firstpos and lastpos of the empty leaf are both empty. */
../inputs/grep1.dat:	*nfirstpos++ = *nlastpos++ = 0;
../inputs/grep1.dat:	break;
../inputs/grep1.dat:
../inputs/grep1.dat:      case STAR:
../inputs/grep1.dat:      case PLUS:
../inputs/grep1.dat:	/* Every element in the firstpos of the argument is in the follow
../inputs/grep1.dat:	   of every element in the lastpos. */
../inputs/grep1.dat:	tmp.nelem = nfirstpos[-1];
../inputs/grep1.dat:	tmp.elems = firstpos;
../inputs/grep1.dat:	pos = lastpos;
../inputs/grep1.dat:	for (j = 0; j < nlastpos[-1]; ++j)
../inputs/grep1.dat:	  {
../inputs/grep1.dat:	    merge(&tmp, &d->follows[pos[j].index], &merged);
../inputs/grep1.dat:	    REALLOC_IF_NECESSARY(d->follows[pos[j].index].elems, position,
../inputs/grep1.dat:				 nalloc[pos[j].index], merged.nelem - 1);
../inputs/grep1.dat:	    copy(&merged, &d->follows[pos[j].index]);
../inputs/grep1.dat:	  }
../inputs/grep1.dat:
../inputs/grep1.dat:      case QMARK:
../inputs/grep1.dat:	/* A QMARK or STAR node is automatically nullable. */
../inputs/grep1.dat:	if (d->tokens[i] != PLUS)
../inputs/grep1.dat:	  nullable[-1] = 1;
../inputs/grep1.dat:	break;
../inputs/grep1.dat:
../inputs/grep1.dat:      case CAT:
../inputs/grep1.dat:	/* Every element in the firstpos of the second argument is in the
../inputs/grep1.dat:	   follow of every element in the lastpos of the first argument. */
../inputs/grep1.dat:	tmp.nelem = nfirstpos[-1];
../inputs/grep1.dat:	tmp.elems = firstpos;
../inputs/grep1.dat:	pos = lastpos + nlastpos[-1];
../inputs/grep1.dat:	for (j = 0; j < nlastpos[-2]; ++j)
../inputs/grep1.dat:	  {
../inputs/grep1.dat:	    merge(&tmp, &d->follows[pos[j].index], &merged);
../inputs/grep1.dat:	    REALLOC_IF_NECESSARY(d->follows[pos[j].index].elems, position,
../inputs/grep1.dat:				 nalloc[pos[j].index], merged.nelem - 1);
../inputs/grep1.dat:	    copy(&merged, &d->follows[pos[j].index]);
../inputs/grep1.dat:	  }
../inputs/grep1.dat:
../inputs/grep1.dat:	/* The firstpos of a CAT node is the firstpos of the first argument,
../inputs/grep1.dat:	   union that of the second argument if the first is nullable. */
../inputs/grep1.dat:	if (nullable[-2])
../inputs/grep1.dat:	  nfirstpos[-2] += nfirstpos[-1];
../inputs/grep1.dat:	else
../inputs/grep1.dat:	  firstpos += nfirstpos[-1];
../inputs/grep1.dat:	--nfirstpos;
../inputs/grep1.dat:
../inputs/grep1.dat:	/* The lastpos of a CAT node is the lastpos of the second argument,
../inputs/grep1.dat:	   union that of the first argument if the second is nullable. */
../inputs/grep1.dat:	if (nullable[-1])
../inputs/grep1.dat:	  nlastpos[-2] += nlastpos[-1];
../inputs/grep1.dat:	else
../inputs/grep1.dat:	  {
../inputs/grep1.dat:	    pos = lastpos + nlastpos[-2];
../inputs/grep1.dat:	    for (j = nlastpos[-1] - 1; j >= 0; --j)
../inputs/grep1.dat:	      pos[j] = lastpos[j];
../inputs/grep1.dat:	    lastpos += nlastpos[-2];
../inputs/grep1.dat:	    nlastpos[-2] = nlastpos[-1];
../inputs/grep1.dat:	  }
../inputs/grep1.dat:	--nlastpos;
../inputs/grep1.dat:
../inputs/grep1.dat:	/* A CAT node is nullable if both arguments are nullable. */
../inputs/grep1.dat:	nullable[-2] = nullable[-1] && nullable[-2];
../inputs/grep1.dat:	--nullable;
../inputs/grep1.dat:	break;
../inputs/grep1.dat:
../inputs/grep1.dat:      case OR:
../inputs/grep1.dat:      case ORTOP:
../inputs/grep1.dat:	/* The firstpos is the union of the firstpos of each argument. */
../inputs/grep1.dat:	nfirstpos[-2] += nfirstpos[-1];
../inputs/grep1.dat:	--nfirstpos;
../inputs/grep1.dat:
../inputs/grep1.dat:	/* The lastpos is the union of the lastpos of each argument. */
../inputs/grep1.dat:	nlastpos[-2] += nlastpos[-1];
../inputs/grep1.dat:	--nlastpos;
../inputs/grep1.dat:
../inputs/grep1.dat:	/* An OR node is nullable if either argument is nullable. */
../inputs/grep1.dat:	nullable[-2] = nullable[-1] || nullable[-2];
../inputs/grep1.dat:	--nullable;
../inputs/grep1.dat:	break;
../inputs/grep1.dat:
../inputs/grep1.dat:      default:
../inputs/grep1.dat:	/* Anything else is a nonempty position.  (Note that special
../inputs/grep1.dat:	   constructs like \< are treated as nonempty strings here;
../inputs/grep1.dat:	   an "epsilon closure" effectively makes them nullable later.
../inputs/grep1.dat:	   Backreferences have to get a real position so we can detect
../inputs/grep1.dat:	   transitions on them later.  But they are nullable. */
../inputs/grep1.dat:	*nullable++ = d->tokens[i] == BACKREF;
../inputs/grep1.dat:
../inputs/grep1.dat:	/* This position is in its own firstpos and lastpos. */
../inputs/grep1.dat:	*nfirstpos++ = *nlastpos++ = 1;
../inputs/grep1.dat:	--firstpos, --lastpos;
../inputs/grep1.dat:	firstpos->index = lastpos->index = i;
../inputs/grep1.dat:	firstpos->constraint = lastpos->constraint = NO_CONSTRAINT;
../inputs/grep1.dat:
../inputs/grep1.dat:	/* Allocate the follow set for this position. */
../inputs/grep1.dat:	nalloc[i] = 1;
../inputs/grep1.dat:	MALLOC(d->follows[i].elems, position, nalloc[i]);
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      }
../inputs/grep1.dat:#ifdef DEBUG
../inputs/grep1.dat:    /* ... balance the above nonsyntactic #ifdef goo... */
../inputs/grep1.dat:      fprintf(stderr, "node %d:", i);
../inputs/grep1.dat:      prtok(d->tokens[i]);
../inputs/grep1.dat:      putc('\n', stderr);
../inputs/grep1.dat:      fprintf(stderr, nullable[-1] ? " nullable: yes\n" : " nullable: no\n");
../inputs/grep1.dat:      fprintf(stderr, " firstpos:");
../inputs/grep1.dat:      for (j = nfirstpos[-1] - 1; j >= 0; --j)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  fprintf(stderr, " %d:", firstpos[j].index);
../inputs/grep1.dat:	  prtok(d->tokens[firstpos[j].index]);
../inputs/grep1.dat:	}
../inputs/grep1.dat:      fprintf(stderr, "\n lastpos:");
../inputs/grep1.dat:      for (j = nlastpos[-1] - 1; j >= 0; --j)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  fprintf(stderr, " %d:", lastpos[j].index);
../inputs/grep1.dat:	  prtok(d->tokens[lastpos[j].index]);
../inputs/grep1.dat:	}
../inputs/grep1.dat:      putc('\n', stderr);
../inputs/grep1.dat:    }
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:  /* For each follow set that is the follow set of a real position, replace
../inputs/grep1.dat:     it with its epsilon closure. */
../inputs/grep1.dat:  for (i = 0; i < d->tindex; ++i)
../inputs/grep1.dat:    if (d->tokens[i] < NOTCHAR || d->tokens[i] == BACKREF
../inputs/grep1.dat:	|| d->tokens[i] >= CSET)
../inputs/grep1.dat:      {
../inputs/grep1.dat:#ifdef DEBUG
../inputs/grep1.dat:	fprintf(stderr, "follows(%d:", i);
../inputs/grep1.dat:	prtok(d->tokens[i]);
../inputs/grep1.dat:	fprintf(stderr, "):");
../inputs/grep1.dat:	for (j = d->follows[i].nelem - 1; j >= 0; --j)
../inputs/grep1.dat:	  {
../inputs/grep1.dat:	    fprintf(stderr, " %d:", d->follows[i].elems[j].index);
../inputs/grep1.dat:	    prtok(d->tokens[d->follows[i].elems[j].index]);
../inputs/grep1.dat:	  }
../inputs/grep1.dat:	putc('\n', stderr);
../inputs/grep1.dat:#endif
../inputs/grep1.dat:	copy(&d->follows[i], &merged);
../inputs/grep1.dat:	epsclosure(&merged, d);
../inputs/grep1.dat:	if (d->follows[i].nelem < merged.nelem)
../inputs/grep1.dat:	  REALLOC(d->follows[i].elems, position, merged.nelem);
../inputs/grep1.dat:	copy(&merged, &d->follows[i]);
../inputs/grep1.dat:      }
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Get the epsilon closure of the firstpos of the regexp.  The result will
../inputs/grep1.dat:     be the set of positions of state 0. */
../inputs/grep1.dat:  merged.nelem = 0;
../inputs/grep1.dat:  for (i = 0; i < nfirstpos[-1]; ++i)
../inputs/grep1.dat:    insert(firstpos[i], &merged);
../inputs/grep1.dat:  epsclosure(&merged, d);
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Check if any of the positions of state 0 will want newline context. */
../inputs/grep1.dat:  wants_newline = 0;
../inputs/grep1.dat:  for (i = 0; i < merged.nelem; ++i)
../inputs/grep1.dat:    if (PREV_NEWLINE_DEPENDENT(merged.elems[i].constraint))
../inputs/grep1.dat:      wants_newline = 1;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Build the initial state. */
../inputs/grep1.dat:  d->salloc = 1;
../inputs/grep1.dat:  d->sindex = 0;
../inputs/grep1.dat:  MALLOC(d->states, dfa_state, d->salloc);
../inputs/grep1.dat:  state_index(d, &merged, wants_newline, 0);
../inputs/grep1.dat:
../inputs/grep1.dat:  free(o_nullable);
../inputs/grep1.dat:  free(o_nfirst);
../inputs/grep1.dat:  free(o_firstpos);
../inputs/grep1.dat:  free(o_nlast);
../inputs/grep1.dat:  free(o_lastpos);
../inputs/grep1.dat:  free(nalloc);
../inputs/grep1.dat:  free(merged.elems);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Find, for each character, the transition out of state s of d, and store
../inputs/grep1.dat:   it in the appropriate slot of trans.
../inputs/grep1.dat:
../inputs/grep1.dat:   We divide the positions of s into groups (positions can appear in more
../inputs/grep1.dat:   than one group).  Each group is labeled with a set of characters that
../inputs/grep1.dat:   every position in the group matches (taking into account, if necessary,
../inputs/grep1.dat:   preceding context information of s).  For each group, find the union
../inputs/grep1.dat:   of the its elements' follows.  This set is the set of positions of the
../inputs/grep1.dat:   new state.  For each character in the group's label, set the transition
../inputs/grep1.dat:   on this character to be to a state corresponding to the set's positions,
../inputs/grep1.dat:   and its associated backward context information, if necessary.
../inputs/grep1.dat:
../inputs/grep1.dat:   0 in every state.
../inputs/grep1.dat:
../inputs/grep1.dat:   The collection of groups is constructed by building an equivalence-class
../inputs/grep1.dat:   partition of the positions of s.
../inputs/grep1.dat:
../inputs/grep1.dat:   For each position, find the set of characters C that it matches.  Eliminate
../inputs/grep1.dat:   any characters from C that fail on grounds of backward context.
../inputs/grep1.dat:
../inputs/grep1.dat:   Search through the groups, looking for a group whose label L has nonempty
../inputs/grep1.dat:   intersection with C.  If L - C is nonempty, create a new group labeled
../inputs/grep1.dat:   L - C and having the same positions as the current group, and set L to
../inputs/grep1.dat:   the intersection of L and C.  Insert the position in this group, set
../inputs/grep1.dat:   C = C - L, and resume scanning.
../inputs/grep1.dat:
../inputs/grep1.dat:   If after comparing with every group there are characters remaining in C,
../inputs/grep1.dat:   create a new group labeled with the characters of C and insert this
../inputs/grep1.dat:   position in that group. */
../inputs/grep1.dat:void
../inputs/grep1.dat:dfastate(s, d, trans)
../inputs/grep1.dat:     int s;
../inputs/grep1.dat:     struct dfa *d;
../inputs/grep1.dat:     int trans[];
../inputs/grep1.dat:{
../inputs/grep1.dat:  position_set grps[NOTCHAR];	/* As many as will ever be needed. */
../inputs/grep1.dat:  charclass labels[NOTCHAR];	/* Labels corresponding to the groups. */
../inputs/grep1.dat:  int ngrps = 0;		/* Number of groups actually used. */
../inputs/grep1.dat:  position pos;			/* Current position being considered. */
../inputs/grep1.dat:  charclass matches;		/* Set of matching characters. */
../inputs/grep1.dat:  int matchesf;			/* True if matches is nonempty. */
../inputs/grep1.dat:  charclass intersect;		/* Intersection with some label set. */
../inputs/grep1.dat:  int intersectf;		/* True if intersect is nonempty. */
../inputs/grep1.dat:  charclass leftovers;		/* Stuff in the label that didn't match. */
../inputs/grep1.dat:  int leftoversf;		/* True if leftovers is nonempty. */
../inputs/grep1.dat:  static charclass letters;	/* Set of characters considered letters. */
../inputs/grep1.dat:  static charclass newline;	/* Set of characters that aren't newline. */
../inputs/grep1.dat:  position_set follows;		/* Union of the follows of some group. */
../inputs/grep1.dat:  position_set tmp;		/* Temporary space for merging sets. */
../inputs/grep1.dat:  int state;			/* New state. */
../inputs/grep1.dat:  int wants_newline;		/* New state wants to know newline context. */
../inputs/grep1.dat:  int state_newline;		/* New state on a newline transition. */
../inputs/grep1.dat:  int wants_letter;		/* New state wants to know letter context. */
../inputs/grep1.dat:  int state_letter;		/* New state on a letter transition. */
../inputs/grep1.dat:  static initialized;		/* Flag for static initialization. */
../inputs/grep1.dat:  int i, j, k;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Initialize the set of letters, if necessary. */
../inputs/grep1.dat:  if (! initialized)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      initialized = 1;
../inputs/grep1.dat:      for (i = 0; i < NOTCHAR; ++i)
../inputs/grep1.dat:	if (ISALNUM(i))
../inputs/grep1.dat:	  setbit(i, letters);
../inputs/grep1.dat:      setbit('\n', newline);
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  zeroset(matches);
../inputs/grep1.dat:
../inputs/grep1.dat:  for (i = 0; i < d->states[s].elems.nelem; ++i)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      pos = d->states[s].elems.elems[i];
../inputs/grep1.dat:      if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR)
../inputs/grep1.dat:	setbit(d->tokens[pos.index], matches);
../inputs/grep1.dat:      else if (d->tokens[pos.index] >= CSET)
../inputs/grep1.dat:	copyset(d->charclasses[d->tokens[pos.index] - CSET], matches);
../inputs/grep1.dat:      else
../inputs/grep1.dat:	continue;
../inputs/grep1.dat:
../inputs/grep1.dat:      /* Some characters may need to be eliminated from matches because
../inputs/grep1.dat:	 they fail in the current context. */
../inputs/grep1.dat:      if (pos.constraint != 0xFF)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  if (! MATCHES_NEWLINE_CONTEXT(pos.constraint,
../inputs/grep1.dat:					 d->states[s].newline, 1))
../inputs/grep1.dat:	    clrbit('\n', matches);
../inputs/grep1.dat:	  if (! MATCHES_NEWLINE_CONTEXT(pos.constraint,
../inputs/grep1.dat:					 d->states[s].newline, 0))
../inputs/grep1.dat:	    for (j = 0; j < CHARCLASS_INTS; ++j)
../inputs/grep1.dat:	      matches[j] &= newline[j];
../inputs/grep1.dat:	  if (! MATCHES_LETTER_CONTEXT(pos.constraint,
../inputs/grep1.dat:					d->states[s].letter, 1))
../inputs/grep1.dat:	    for (j = 0; j < CHARCLASS_INTS; ++j)
../inputs/grep1.dat:	      matches[j] &= ~letters[j];
../inputs/grep1.dat:	  if (! MATCHES_LETTER_CONTEXT(pos.constraint,
../inputs/grep1.dat:					d->states[s].letter, 0))
../inputs/grep1.dat:	    for (j = 0; j < CHARCLASS_INTS; ++j)
../inputs/grep1.dat:	      matches[j] &= letters[j];
../inputs/grep1.dat:
../inputs/grep1.dat:	  /* If there are no characters left, there's no point in going on. */
../inputs/grep1.dat:	  for (j = 0; j < CHARCLASS_INTS && !matches[j]; ++j)
../inputs/grep1.dat:	    ;
../inputs/grep1.dat:	  if (j == CHARCLASS_INTS)
../inputs/grep1.dat:	    continue;
../inputs/grep1.dat:	}
../inputs/grep1.dat:
../inputs/grep1.dat:      for (j = 0; j < ngrps; ++j)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  /* If matches contains a single character only, and the current
../inputs/grep1.dat:	     group's label doesn't contain that character, go on to the
../inputs/grep1.dat:	     next group. */
../inputs/grep1.dat:	  if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR
../inputs/grep1.dat:	      && !tstbit(d->tokens[pos.index], labels[j]))
../inputs/grep1.dat:	    continue;
../inputs/grep1.dat:
../inputs/grep1.dat:	  /* Check if this group's label has a nonempty intersection with
../inputs/grep1.dat:	     matches. */
../inputs/grep1.dat:	  intersectf = 0;
../inputs/grep1.dat:	  for (k = 0; k < CHARCLASS_INTS; ++k)
../inputs/grep1.dat:	    (intersect[k] = matches[k] & labels[j][k]) ? intersectf = 1 : 0;
../inputs/grep1.dat:	  if (! intersectf)
../inputs/grep1.dat:	    continue;
../inputs/grep1.dat:
../inputs/grep1.dat:	  /* It does; now find the set differences both ways. */
../inputs/grep1.dat:	  leftoversf = matchesf = 0;
../inputs/grep1.dat:	  for (k = 0; k < CHARCLASS_INTS; ++k)
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      /* Even an optimizing compiler can't know this for sure. */
../inputs/grep1.dat:	      int match = matches[k], label = labels[j][k];
../inputs/grep1.dat:
../inputs/grep1.dat:	      (leftovers[k] = ~match & label) ? leftoversf = 1 : 0;
../inputs/grep1.dat:	      (matches[k] = match & ~label) ? matchesf = 1 : 0;
../inputs/grep1.dat:	    }
../inputs/grep1.dat:
../inputs/grep1.dat:	  /* If there were leftovers, create a new group labeled with them. */
../inputs/grep1.dat:	  if (leftoversf)
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      copyset(leftovers, labels[ngrps]);
../inputs/grep1.dat:	      copyset(intersect, labels[j]);
../inputs/grep1.dat:	      MALLOC(grps[ngrps].elems, position, d->nleaves);
../inputs/grep1.dat:	      copy(&grps[j], &grps[ngrps]);
../inputs/grep1.dat:	      ++ngrps;
../inputs/grep1.dat:	    }
../inputs/grep1.dat:
../inputs/grep1.dat:	  /* Put the position in the current group.  Note that there is no
../inputs/grep1.dat:	     reason to call insert() here. */
../inputs/grep1.dat:	  grps[j].elems[grps[j].nelem++] = pos;
../inputs/grep1.dat:
../inputs/grep1.dat:	  /* If every character matching the current position has been
../inputs/grep1.dat:	     accounted for, we're done. */
../inputs/grep1.dat:	  if (! matchesf)
../inputs/grep1.dat:	    break;
../inputs/grep1.dat:	}
../inputs/grep1.dat:
../inputs/grep1.dat:      /* If we've passed the last group, and there are still characters
../inputs/grep1.dat:	 unaccounted for, then we'll have to create a new group. */
../inputs/grep1.dat:      if (j == ngrps)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  copyset(matches, labels[ngrps]);
../inputs/grep1.dat:	  zeroset(matches);
../inputs/grep1.dat:	  MALLOC(grps[ngrps].elems, position, d->nleaves);
../inputs/grep1.dat:	  grps[ngrps].nelem = 1;
../inputs/grep1.dat:	  grps[ngrps].elems[0] = pos;
../inputs/grep1.dat:	  ++ngrps;
../inputs/grep1.dat:	}
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  MALLOC(follows.elems, position, d->nleaves);
../inputs/grep1.dat:  MALLOC(tmp.elems, position, d->nleaves);
../inputs/grep1.dat:
../inputs/grep1.dat:  /* If we are a searching matcher, the default transition is to a state
../inputs/grep1.dat:     containing the positions of state 0, otherwise the default transition
../inputs/grep1.dat:     is to fail miserably. */
../inputs/grep1.dat:  if (d->searchflag)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      wants_newline = 0;
../inputs/grep1.dat:      wants_letter = 0;
../inputs/grep1.dat:      for (i = 0; i < d->states[0].elems.nelem; ++i)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  if (PREV_NEWLINE_DEPENDENT(d->states[0].elems.elems[i].constraint))
../inputs/grep1.dat:	    wants_newline = 1;
../inputs/grep1.dat:	  if (PREV_LETTER_DEPENDENT(d->states[0].elems.elems[i].constraint))
../inputs/grep1.dat:	    wants_letter = 1;
../inputs/grep1.dat:	}
../inputs/grep1.dat:      copy(&d->states[0].elems, &follows);
../inputs/grep1.dat:      state = state_index(d, &follows, 0, 0);
../inputs/grep1.dat:      if (wants_newline)
../inputs/grep1.dat:	state_newline = state_index(d, &follows, 1, 0);
../inputs/grep1.dat:      else
../inputs/grep1.dat:	state_newline = state;
../inputs/grep1.dat:      if (wants_letter)
../inputs/grep1.dat:	state_letter = state_index(d, &follows, 0, 1);
../inputs/grep1.dat:      else
../inputs/grep1.dat:	state_letter = state;
../inputs/grep1.dat:      for (i = 0; i < NOTCHAR; ++i)
../inputs/grep1.dat:	if (i == '\n')
../inputs/grep1.dat:	  trans[i] = state_newline;
../inputs/grep1.dat:	else if (ISALNUM(i))
../inputs/grep1.dat:	  trans[i] = state_letter;
../inputs/grep1.dat:	else
../inputs/grep1.dat:	  trans[i] = state;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  else
../inputs/grep1.dat:    for (i = 0; i < NOTCHAR; ++i)
../inputs/grep1.dat:      trans[i] = -1;
../inputs/grep1.dat:
../inputs/grep1.dat:  for (i = 0; i < ngrps; ++i)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      follows.nelem = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:      /* Find the union of the follows of the positions of the group.
../inputs/grep1.dat:	 This is a hideously inefficient loop.  Fix it someday. */
../inputs/grep1.dat:      for (j = 0; j < grps[i].nelem; ++j)
../inputs/grep1.dat:	for (k = 0; k < d->follows[grps[i].elems[j].index].nelem; ++k)
../inputs/grep1.dat:	  insert(d->follows[grps[i].elems[j].index].elems[k], &follows);
../inputs/grep1.dat:
../inputs/grep1.dat:      /* If we are building a searching matcher, throw in the positions
../inputs/grep1.dat:	 of state 0 as well. */
../inputs/grep1.dat:      if (d->searchflag)
../inputs/grep1.dat:	for (j = 0; j < d->states[0].elems.nelem; ++j)
../inputs/grep1.dat:	  insert(d->states[0].elems.elems[j], &follows);
../inputs/grep1.dat:
../inputs/grep1.dat:      /* Find out if the new state will want any context information. */
../inputs/grep1.dat:      wants_newline = 0;
../inputs/grep1.dat:      if (tstbit('\n', labels[i]))
../inputs/grep1.dat:	for (j = 0; j < follows.nelem; ++j)
../inputs/grep1.dat:	  if (PREV_NEWLINE_DEPENDENT(follows.elems[j].constraint))
../inputs/grep1.dat:	    wants_newline = 1;
../inputs/grep1.dat:
../inputs/grep1.dat:      wants_letter = 0;
../inputs/grep1.dat:      for (j = 0; j < CHARCLASS_INTS; ++j)
../inputs/grep1.dat:	if (labels[i][j] & letters[j])
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:      if (j < CHARCLASS_INTS)
../inputs/grep1.dat:	for (j = 0; j < follows.nelem; ++j)
../inputs/grep1.dat:	  if (PREV_LETTER_DEPENDENT(follows.elems[j].constraint))
../inputs/grep1.dat:	    wants_letter = 1;
../inputs/grep1.dat:
../inputs/grep1.dat:      /* Find the state(s) corresponding to the union of the follows. */
../inputs/grep1.dat:      state = state_index(d, &follows, 0, 0);
../inputs/grep1.dat:      if (wants_newline)
../inputs/grep1.dat:	state_newline = state_index(d, &follows, 1, 0);
../inputs/grep1.dat:      else
../inputs/grep1.dat:	state_newline = state;
../inputs/grep1.dat:      if (wants_letter)
../inputs/grep1.dat:	state_letter = state_index(d, &follows, 0, 1);
../inputs/grep1.dat:      else
../inputs/grep1.dat:	state_letter = state;
../inputs/grep1.dat:
../inputs/grep1.dat:      /* Set the transitions for each character in the current label. */
../inputs/grep1.dat:      for (j = 0; j < CHARCLASS_INTS; ++j)
../inputs/grep1.dat:	for (k = 0; k < INTBITS; ++k)
../inputs/grep1.dat:	  if (labels[i][j] & 1 << k)
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      int c = j * INTBITS + k;
../inputs/grep1.dat:
../inputs/grep1.dat:	      if (c == '\n')
../inputs/grep1.dat:		trans[c] = state_newline;
../inputs/grep1.dat:	      else if (ISALNUM(c))
../inputs/grep1.dat:		trans[c] = state_letter;
../inputs/grep1.dat:	      else if (c < NOTCHAR)
../inputs/grep1.dat:		trans[c] = state;
../inputs/grep1.dat:	    }
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  for (i = 0; i < ngrps; ++i)
../inputs/grep1.dat:    free(grps[i].elems);
../inputs/grep1.dat:  free(follows.elems);
../inputs/grep1.dat:  free(tmp.elems);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Some routines for manipulating a compiled dfa's transition tables.
../inputs/grep1.dat:   Each state may or may not have a transition table; if it does, and it
../inputs/grep1.dat:   is a non-accepting state, then d->trans[state] points to its table.
../inputs/grep1.dat:   If it is an accepting state then d->fails[state] points to its table.
../inputs/grep1.dat:   If it has no table at all, then d->trans[state] is NULL.
../inputs/grep1.dat:   TODO: Improve this comment, get rid of the unnecessary redundancy. */
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:build_state(s, d)
../inputs/grep1.dat:     int s;
../inputs/grep1.dat:     struct dfa *d;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int *trans;			/* The new transition table. */
../inputs/grep1.dat:  int i;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Set an upper limit on the number of transition tables that will ever
../inputs/grep1.dat:     exist at once.  1024 is arbitrary.  The idea is that the frequently
../inputs/grep1.dat:     used transition tables will be quickly rebuilt, whereas the ones that
../inputs/grep1.dat:     were only needed once or twice will be cleared away. */
../inputs/grep1.dat:  if (d->trcount >= 1024)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      for (i = 0; i < d->tralloc; ++i)
../inputs/grep1.dat:	if (d->trans[i])
../inputs/grep1.dat:	  {
../inputs/grep1.dat:	    free((ptr_t) d->trans[i]);
../inputs/grep1.dat:	    d->trans[i] = NULL;
../inputs/grep1.dat:	  }
../inputs/grep1.dat:	else if (d->fails[i])
../inputs/grep1.dat:	  {
../inputs/grep1.dat:	    free((ptr_t) d->fails[i]);
../inputs/grep1.dat:	    d->fails[i] = NULL;
../inputs/grep1.dat:	  }
../inputs/grep1.dat:      d->trcount = 0;
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  ++d->trcount;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Set up the success bits for this state. */
../inputs/grep1.dat:  d->success[s] = 0;
../inputs/grep1.dat:  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 1, d->states[s].letter, 0,
../inputs/grep1.dat:      s, *d))
../inputs/grep1.dat:    d->success[s] |= 4;
../inputs/grep1.dat:  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 0, d->states[s].letter, 1,
../inputs/grep1.dat:      s, *d))
../inputs/grep1.dat:    d->success[s] |= 2;
../inputs/grep1.dat:  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 0, d->states[s].letter, 0,
../inputs/grep1.dat:      s, *d))
../inputs/grep1.dat:    d->success[s] |= 1;
../inputs/grep1.dat:
../inputs/grep1.dat:  MALLOC(trans, int, NOTCHAR);
../inputs/grep1.dat:  dfastate(s, d, trans);
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Now go through the new transition table, and make sure that the trans
../inputs/grep1.dat:     and fail arrays are allocated large enough to hold a pointer for the
../inputs/grep1.dat:     largest state mentioned in the table. */
../inputs/grep1.dat:  for (i = 0; i < NOTCHAR; ++i)
../inputs/grep1.dat:    if (trans[i] >= d->tralloc)
../inputs/grep1.dat:      {
../inputs/grep1.dat:	int oldalloc = d->tralloc;
../inputs/grep1.dat:
../inputs/grep1.dat:	while (trans[i] >= d->tralloc)
../inputs/grep1.dat:	  d->tralloc *= 2;
../inputs/grep1.dat:	REALLOC(d->realtrans, int *, d->tralloc + 1);
../inputs/grep1.dat:	d->trans = d->realtrans + 1;
../inputs/grep1.dat:	REALLOC(d->fails, int *, d->tralloc);
../inputs/grep1.dat:	REALLOC(d->success, int, d->tralloc);
../inputs/grep1.dat:	REALLOC(d->newlines, int, d->tralloc);
../inputs/grep1.dat:	while (oldalloc < d->tralloc)
../inputs/grep1.dat:	  {
../inputs/grep1.dat:	    d->trans[oldalloc] = NULL;
../inputs/grep1.dat:	    d->fails[oldalloc++] = NULL;
../inputs/grep1.dat:	  }
../inputs/grep1.dat:      }
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Keep the newline transition in a special place so we can use it as
../inputs/grep1.dat:     a sentinel. */
../inputs/grep1.dat:  d->newlines[s] = trans['\n'];
../inputs/grep1.dat:  trans['\n'] = -1;
../inputs/grep1.dat:
../inputs/grep1.dat:  if (ACCEPTING(s, *d))
../inputs/grep1.dat:    d->fails[s] = trans;
../inputs/grep1.dat:  else
../inputs/grep1.dat:    d->trans[s] = trans;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:build_state_zero(d)
../inputs/grep1.dat:     struct dfa *d;
../inputs/grep1.dat:{
../inputs/grep1.dat:  d->tralloc = 1;
../inputs/grep1.dat:  d->trcount = 0;
../inputs/grep1.dat:  CALLOC(d->realtrans, int *, d->tralloc + 1);
../inputs/grep1.dat:  d->trans = d->realtrans + 1;
../inputs/grep1.dat:  CALLOC(d->fails, int *, d->tralloc);
../inputs/grep1.dat:  MALLOC(d->success, int, d->tralloc);
../inputs/grep1.dat:  MALLOC(d->newlines, int, d->tralloc);
../inputs/grep1.dat:  build_state(0, d);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Search through a buffer looking for a match to the given struct dfa.
../inputs/grep1.dat:   Find the first occurrence of a string matching the regexp in the buffer,
../inputs/grep1.dat:   and the shortest possible version thereof.  Return a pointer to the first
../inputs/grep1.dat:   character after the match, or NULL if none is found.  Begin points to
../inputs/grep1.dat:   the beginning of the buffer, and end points to the first character after
../inputs/grep1.dat:   its end.  We store a newline in *end to act as a sentinel, so end had
../inputs/grep1.dat:   better point somewhere valid.  Newline is a flag indicating whether to
../inputs/grep1.dat:   allow newlines to be in the matching string.  If count is non-
../inputs/grep1.dat:   NULL it points to a place we're supposed to increment every time we
../inputs/grep1.dat:   see a newline.  Finally, if backref is non-NULL it points to a place
../inputs/grep1.dat:   where we're supposed to store a 1 if backreferencing happened and the
../inputs/grep1.dat:   match needs to be verified by a backtracking matcher.  Otherwise
../inputs/grep1.dat:   we store a 0 in *backref. */
../inputs/grep1.dat:char *
../inputs/grep1.dat:dfaexec(d, begin, end, newline, count, backref)
../inputs/grep1.dat:     struct dfa *d;
../inputs/grep1.dat:     char *begin;
../inputs/grep1.dat:     char *end;
../inputs/grep1.dat:     int newline;
../inputs/grep1.dat:     int *count;
../inputs/grep1.dat:     int *backref;
../inputs/grep1.dat:{
../inputs/grep1.dat:  register s, s1, tmp;		/* Current state. */
../inputs/grep1.dat:  register unsigned char *p;	/* Current input character. */
../inputs/grep1.dat:  register **trans, *t;		/* Copy of d->trans so it can be optimized
../inputs/grep1.dat:				   into a register. */
../inputs/grep1.dat:  static sbit[NOTCHAR];	/* Table for anding with d->success. */
../inputs/grep1.dat:  static sbit_init;
../inputs/grep1.dat:
../inputs/grep1.dat:  if (! sbit_init)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      int i;
../inputs/grep1.dat:
../inputs/grep1.dat:      sbit_init = 1;
../inputs/grep1.dat:      for (i = 0; i < NOTCHAR; ++i)
../inputs/grep1.dat:	if (i == '\n')
../inputs/grep1.dat:	  sbit[i] = 4;
../inputs/grep1.dat:	else if (ISALNUM(i))
../inputs/grep1.dat:	  sbit[i] = 2;
../inputs/grep1.dat:	else
../inputs/grep1.dat:	  sbit[i] = 1;
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  if (! d->tralloc)
../inputs/grep1.dat:    build_state_zero(d);
../inputs/grep1.dat:
../inputs/grep1.dat:  s = s1 = 0;
../inputs/grep1.dat:  p = (unsigned char *) begin;
../inputs/grep1.dat:  trans = d->trans;
../inputs/grep1.dat:  *end = '\n';
../inputs/grep1.dat:
../inputs/grep1.dat:  for (;;)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      /* The dreaded inner loop. */
../inputs/grep1.dat:      if ((t = trans[s]) != 0)
../inputs/grep1.dat:	do
../inputs/grep1.dat:	  {
../inputs/grep1.dat:	    s1 = t[*p++];
../inputs/grep1.dat:	    if (! (t = trans[s1]))
../inputs/grep1.dat:	      goto last_was_s;
../inputs/grep1.dat:	    s = t[*p++];
../inputs/grep1.dat:	  }
../inputs/grep1.dat:        while ((t = trans[s]) != 0);
../inputs/grep1.dat:      goto last_was_s1;
../inputs/grep1.dat:    last_was_s:
../inputs/grep1.dat:      tmp = s, s = s1, s1 = tmp;
../inputs/grep1.dat:    last_was_s1:
../inputs/grep1.dat:
../inputs/grep1.dat:      if (s >= 0 && p <= (unsigned char *) end && d->fails[s])
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  if (d->success[s] & sbit[*p])
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      if (backref)
../inputs/grep1.dat:		if (d->states[s].backref)
../inputs/grep1.dat:		  *backref = 1;
../inputs/grep1.dat:		else
../inputs/grep1.dat:		  *backref = 0;
../inputs/grep1.dat:	      return (char *) p;
../inputs/grep1.dat:	    }
../inputs/grep1.dat:
../inputs/grep1.dat:	  s1 = s;
../inputs/grep1.dat:	  s = d->fails[s][*p++];
../inputs/grep1.dat:	  continue;
../inputs/grep1.dat:	}
../inputs/grep1.dat:
../inputs/grep1.dat:      /* If the previous character was a newline, count it. */
../inputs/grep1.dat:      if (count && (char *) p <= end && p[-1] == '\n')
../inputs/grep1.dat:	++*count;
../inputs/grep1.dat:
../inputs/grep1.dat:      /* Check if we've run off the end of the buffer. */
../inputs/grep1.dat:      if ((char *) p > end)
../inputs/grep1.dat:	return NULL;
../inputs/grep1.dat:
../inputs/grep1.dat:      if (s >= 0)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  build_state(s, d);
../inputs/grep1.dat:	  trans = d->trans;
../inputs/grep1.dat:	  continue;
../inputs/grep1.dat:	}
../inputs/grep1.dat:
../inputs/grep1.dat:      if (p[-1] == '\n' && newline)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  s = d->newlines[s1];
../inputs/grep1.dat:	  continue;
../inputs/grep1.dat:	}
../inputs/grep1.dat:
../inputs/grep1.dat:      s = 0;
../inputs/grep1.dat:    }
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Initialize the components of a dfa that the other routines don't
../inputs/grep1.dat:   initialize for themselves. */
../inputs/grep1.dat:void
../inputs/grep1.dat:dfainit(d)
../inputs/grep1.dat:     struct dfa *d;
../inputs/grep1.dat:{
../inputs/grep1.dat:  d->calloc = 1;
../inputs/grep1.dat:  MALLOC(d->charclasses, charclass, d->calloc);
../inputs/grep1.dat:  d->cindex = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:  d->talloc = 1;
../inputs/grep1.dat:  MALLOC(d->tokens, token, d->talloc);
../inputs/grep1.dat:  d->tindex = d->depth = d->nleaves = d->nregexps = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:  d->searchflag = 0;
../inputs/grep1.dat:  d->tralloc = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:  d->musts = 0;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Parse and analyze a single string of the given length. */
../inputs/grep1.dat:void
../inputs/grep1.dat:dfacomp(s, len, d, searchflag)
../inputs/grep1.dat:     char *s;
../inputs/grep1.dat:     size_t len;
../inputs/grep1.dat:     struct dfa *d;
../inputs/grep1.dat:     int searchflag;
../inputs/grep1.dat:{
../inputs/grep1.dat:  if (case_fold)	/* dummy folding in service of dfamust() */
../inputs/grep1.dat:    {
../inputs/grep1.dat:      char *copy;
../inputs/grep1.dat:      int i;
../inputs/grep1.dat:
../inputs/grep1.dat:      copy = malloc(len);
../inputs/grep1.dat:      if (!copy)
../inputs/grep1.dat:	dfaerror("out of memory");
../inputs/grep1.dat:      
../inputs/grep1.dat:      /* This is a kludge. */
../inputs/grep1.dat:      case_fold = 0;
../inputs/grep1.dat:      for (i = 0; i < len; ++i)
../inputs/grep1.dat:	if (ISUPPER(s[i]))
../inputs/grep1.dat:	  copy[i] = tolower(s[i]);
../inputs/grep1.dat:	else
../inputs/grep1.dat:	  copy[i] = s[i];
../inputs/grep1.dat:
../inputs/grep1.dat:      dfainit(d);
../inputs/grep1.dat:      dfaparse(copy, len, d);
../inputs/grep1.dat:      free(copy);
../inputs/grep1.dat:      dfamust(d);
../inputs/grep1.dat:      d->cindex = d->tindex = d->depth = d->nleaves = d->nregexps = 0;
../inputs/grep1.dat:      case_fold = 1;
../inputs/grep1.dat:      dfaparse(s, len, d);
../inputs/grep1.dat:      dfaanalyze(d, searchflag);
../inputs/grep1.dat:    }
../inputs/grep1.dat:  else
../inputs/grep1.dat:    {
../inputs/grep1.dat:        dfainit(d);
../inputs/grep1.dat:        dfaparse(s, len, d);
../inputs/grep1.dat:	dfamust(d);
../inputs/grep1.dat:        dfaanalyze(d, searchflag);
../inputs/grep1.dat:    }
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Free the storage held by the components of a dfa. */
../inputs/grep1.dat:void
../inputs/grep1.dat:dfafree(d)
../inputs/grep1.dat:     struct dfa *d;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int i;
../inputs/grep1.dat:  struct dfamust *dm, *ndm;
../inputs/grep1.dat:
../inputs/grep1.dat:  free((ptr_t) d->charclasses);
../inputs/grep1.dat:  free((ptr_t) d->tokens);
../inputs/grep1.dat:  for (i = 0; i < d->sindex; ++i)
../inputs/grep1.dat:    free((ptr_t) d->states[i].elems.elems);
../inputs/grep1.dat:  free((ptr_t) d->states);
../inputs/grep1.dat:  for (i = 0; i < d->tindex; ++i)
../inputs/grep1.dat:    if (d->follows[i].elems)
../inputs/grep1.dat:      free((ptr_t) d->follows[i].elems);
../inputs/grep1.dat:  free((ptr_t) d->follows);
../inputs/grep1.dat:  for (i = 0; i < d->tralloc; ++i)
../inputs/grep1.dat:    if (d->trans[i])
../inputs/grep1.dat:      free((ptr_t) d->trans[i]);
../inputs/grep1.dat:    else if (d->fails[i])
../inputs/grep1.dat:      free((ptr_t) d->fails[i]);
../inputs/grep1.dat:  free((ptr_t) d->realtrans);
../inputs/grep1.dat:  free((ptr_t) d->fails);
../inputs/grep1.dat:  free((ptr_t) d->newlines);
../inputs/grep1.dat:  for (dm = d->musts; dm; dm = ndm)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      ndm = dm->next;
../inputs/grep1.dat:      free(dm->must);
../inputs/grep1.dat:      free((ptr_t) dm);
../inputs/grep1.dat:    }
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Having found the postfix representation of the regular expression,
../inputs/grep1.dat:   try to find a long sequence of characters that must appear in any line
../inputs/grep1.dat:   containing the r.e.
../inputs/grep1.dat:   Finding a "longest" sequence is beyond the scope here;
../inputs/grep1.dat:   we take an easy way out and hope for the best.
../inputs/grep1.dat:   (Take "(ab|a)b"--please.)
../inputs/grep1.dat:
../inputs/grep1.dat:   We do a bottom-up calculation of sequences of characters that must appear
../inputs/grep1.dat:   in matches of r.e.'s represented by trees rooted at the nodes of the postfix
../inputs/grep1.dat:   representation:
../inputs/grep1.dat:	sequences that must appear at the left of the match ("left")
../inputs/grep1.dat:	sequences that must appear at the right of the match ("right")
../inputs/grep1.dat:	lists of sequences that must appear somewhere in the match ("in")
../inputs/grep1.dat:	sequences that must constitute the match ("is")
../inputs/grep1.dat:
../inputs/grep1.dat:   When we get to the root of the tree, we use one of the longest of its
../inputs/grep1.dat:   calculated "in" sequences as our answer.  The sequence we find is returned in
../inputs/grep1.dat:   d->must (where "d" is the single argument passed to "dfamust");
../inputs/grep1.dat:   the length of the sequence is returned in d->mustn.
../inputs/grep1.dat:
../inputs/grep1.dat:   The sequences calculated for the various types of node (in pseudo ANSI c)
../inputs/grep1.dat:   are shown below.  "p" is the operand of unary operators (and the left-hand
../inputs/grep1.dat:   operand of binary operators); "q" is the right-hand operand of binary
../inputs/grep1.dat:   operators.
../inputs/grep1.dat:
../inputs/grep1.dat:   "ZERO" means "a zero-length sequence" below.
../inputs/grep1.dat:
../inputs/grep1.dat:	Type	left		right		is		in
../inputs/grep1.dat:	----	----		-----		--		--
../inputs/grep1.dat:	char c	# c		# c		# c		# c
../inputs/grep1.dat:	
../inputs/grep1.dat:	CSET	ZERO		ZERO		ZERO		ZERO
../inputs/grep1.dat:	
../inputs/grep1.dat:	STAR	ZERO		ZERO		ZERO		ZERO
../inputs/grep1.dat:
../inputs/grep1.dat:	QMARK	ZERO		ZERO		ZERO		ZERO
../inputs/grep1.dat:
../inputs/grep1.dat:	PLUS	p->left		p->right	ZERO		p->in
../inputs/grep1.dat:
../inputs/grep1.dat:	CAT	(p->is==ZERO)?	(q->is==ZERO)?	(p->is!=ZERO &&	p->in plus
../inputs/grep1.dat:		p->left :	q->right :	q->is!=ZERO) ?	q->in plus
../inputs/grep1.dat:		p->is##q->left	p->right##q->is	p->is##q->is :	p->right##q->left
../inputs/grep1.dat:						ZERO
../inputs/grep1.dat:					
../inputs/grep1.dat:	OR	longest common	longest common	(do p->is and	substrings common to
../inputs/grep1.dat:		leading		trailing	q->is have same	p->in and q->in
../inputs/grep1.dat:		(sub)sequence	(sub)sequence	length and	
../inputs/grep1.dat:		of p->left	of p->right	content) ?	
../inputs/grep1.dat:		and q->left	and q->right	p->is : NULL	
../inputs/grep1.dat:
../inputs/grep1.dat:   If there's anything else we recognize in the tree, all four sequences get set
../inputs/grep1.dat:   to zero-length sequences.  If there's something we don't recognize in the tree,
../inputs/grep1.dat:   we just return a zero-length sequence.
../inputs/grep1.dat:
../inputs/grep1.dat:   Break ties in favor of infrequent letters (choosing 'zzz' in preference to
../inputs/grep1.dat:   'aaa')?
../inputs/grep1.dat:
../inputs/grep1.dat:   And. . .is it here or someplace that we might ponder "optimizations" such as
../inputs/grep1.dat:	egrep 'psi|epsilon'	->	egrep 'psi'
../inputs/grep1.dat:	egrep 'pepsi|epsilon'	->	egrep 'epsi'
../inputs/grep1.dat:					(Yes, we now find "epsi" as a "string
../inputs/grep1.dat:					that must occur", but we might also
../inputs/grep1.dat:					simplify the *entire* r.e. being sought)
../inputs/grep1.dat:	grep '[c]'		->	grep 'c'
../inputs/grep1.dat:	grep '(ab|a)b'		->	grep 'ab'
../inputs/grep1.dat:	grep 'ab*'		->	grep 'a'
../inputs/grep1.dat:	grep 'a*b'		->	grep 'b'
../inputs/grep1.dat:
../inputs/grep1.dat:   There are several issues:
../inputs/grep1.dat:
../inputs/grep1.dat:   Is optimization easy (enough)?
../inputs/grep1.dat:
../inputs/grep1.dat:   Does optimization actually accomplish anything,
../inputs/grep1.dat:   or is the automaton you get from "psi|epsilon" (for example)
../inputs/grep1.dat:   the same as the one you get from "psi" (for example)?
../inputs/grep1.dat:  
../inputs/grep1.dat:   Are optimizable r.e.'s likely to be used in real-life situations
../inputs/grep1.dat:   (something like 'ab*' is probably unlikely; something like is
../inputs/grep1.dat:   'psi|epsilon' is likelier)? */
../inputs/grep1.dat:
../inputs/grep1.dat:static char *
../inputs/grep1.dat:icatalloc(old, new)
../inputs/grep1.dat:     char *old;
../inputs/grep1.dat:     char *new;
../inputs/grep1.dat:{
../inputs/grep1.dat:  char *result;
../inputs/grep1.dat:  int oldsize, newsize;
../inputs/grep1.dat:
../inputs/grep1.dat:  newsize = (new == NULL) ? 0 : strlen(new);
../inputs/grep1.dat:  if (old == NULL)
../inputs/grep1.dat:    oldsize = 0;
../inputs/grep1.dat:  else if (newsize == 0)
../inputs/grep1.dat:    return old;
../inputs/grep1.dat:  else	oldsize = strlen(old);
../inputs/grep1.dat:  if (old == NULL)
../inputs/grep1.dat:    result = (char *) malloc(newsize + 1);
../inputs/grep1.dat:  else
../inputs/grep1.dat:    result = (char *) realloc((void *) old, oldsize + newsize + 1);
../inputs/grep1.dat:  if (result != NULL && new != NULL)
../inputs/grep1.dat:    (void) strcpy(result + oldsize, new);
../inputs/grep1.dat:  return result;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static char *
../inputs/grep1.dat:icpyalloc(string)
../inputs/grep1.dat:     char *string;
../inputs/grep1.dat:{
../inputs/grep1.dat:  return icatalloc((char *) NULL, string);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static char *
../inputs/grep1.dat:istrstr(lookin, lookfor)
../inputs/grep1.dat:     char *lookin;
../inputs/grep1.dat:     char *lookfor;
../inputs/grep1.dat:{
../inputs/grep1.dat:  char *cp;
../inputs/grep1.dat:  int len;
../inputs/grep1.dat:
../inputs/grep1.dat:  len = strlen(lookfor);
../inputs/grep1.dat:  for (cp = lookin; *cp != '\0'; ++cp)
../inputs/grep1.dat:    if (strncmp(cp, lookfor, len) == 0)
../inputs/grep1.dat:      return cp;
../inputs/grep1.dat:  return NULL;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:ifree(cp)
../inputs/grep1.dat:     char *cp;
../inputs/grep1.dat:{
../inputs/grep1.dat:  if (cp != NULL)
../inputs/grep1.dat:    free(cp);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:freelist(cpp)
../inputs/grep1.dat:     char **cpp;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int i;
../inputs/grep1.dat:
../inputs/grep1.dat:  if (cpp == NULL)
../inputs/grep1.dat:    return;
../inputs/grep1.dat:  for (i = 0; cpp[i] != NULL; ++i)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      free(cpp[i]);
../inputs/grep1.dat:      cpp[i] = NULL;
../inputs/grep1.dat:    }
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static char **
../inputs/grep1.dat:enlist(cpp, new, len)
../inputs/grep1.dat:     char **cpp;
../inputs/grep1.dat:     char *new;
../inputs/grep1.dat:     int len;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int i, j;
../inputs/grep1.dat:
../inputs/grep1.dat:  if (cpp == NULL)
../inputs/grep1.dat:    return NULL;
../inputs/grep1.dat:  if ((new = icpyalloc(new)) == NULL)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      freelist(cpp);
../inputs/grep1.dat:      return NULL;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  new[len] = '\0';
../inputs/grep1.dat:  /* Is there already something in the list that's new (or longer)? */
../inputs/grep1.dat:  for (i = 0; cpp[i] != NULL; ++i)
../inputs/grep1.dat:    if (istrstr(cpp[i], new) != NULL)
../inputs/grep1.dat:      {
../inputs/grep1.dat:	free(new);
../inputs/grep1.dat:	return cpp;
../inputs/grep1.dat:      }
../inputs/grep1.dat:  /* Eliminate any obsoleted strings. */
../inputs/grep1.dat:  j = 0;
../inputs/grep1.dat:  while (cpp[j] != NULL)
../inputs/grep1.dat:    if (istrstr(new, cpp[j]) == NULL)
../inputs/grep1.dat:      ++j;
../inputs/grep1.dat:    else
../inputs/grep1.dat:      {
../inputs/grep1.dat:	free(cpp[j]);
../inputs/grep1.dat:	if (--i == j)
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:	cpp[j] = cpp[i];
../inputs/grep1.dat:	cpp[i] = NULL;
../inputs/grep1.dat:      }
../inputs/grep1.dat:  /* Add the new string. */
../inputs/grep1.dat:  cpp = (char **) realloc((char *) cpp, (i + 2) * sizeof *cpp);
../inputs/grep1.dat:  if (cpp == NULL)
../inputs/grep1.dat:    return NULL;
../inputs/grep1.dat:  cpp[i] = new;
../inputs/grep1.dat:  cpp[i + 1] = NULL;
../inputs/grep1.dat:  return cpp;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Given pointers to two strings, return a pointer to an allocated
../inputs/grep1.dat:   list of their distinct common substrings. Return NULL if something
../inputs/grep1.dat:   seems wild. */
../inputs/grep1.dat:static char **
../inputs/grep1.dat:comsubs(left, right)
../inputs/grep1.dat:     char *left;
../inputs/grep1.dat:     char *right;
../inputs/grep1.dat:{
../inputs/grep1.dat:  char **cpp;
../inputs/grep1.dat:  char *lcp;
../inputs/grep1.dat:  char *rcp;
../inputs/grep1.dat:  int i, len;
../inputs/grep1.dat:
../inputs/grep1.dat:  if (left == NULL || right == NULL)
../inputs/grep1.dat:    return NULL;
../inputs/grep1.dat:  cpp = (char **) malloc(sizeof *cpp);
../inputs/grep1.dat:  if (cpp == NULL)
../inputs/grep1.dat:    return NULL;
../inputs/grep1.dat:  cpp[0] = NULL;
../inputs/grep1.dat:  for (lcp = left; *lcp != '\0'; ++lcp)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      len = 0;
../inputs/grep1.dat:      rcp = index(right, *lcp);
../inputs/grep1.dat:      while (rcp != NULL)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  for (i = 1; lcp[i] != '\0' && lcp[i] == rcp[i]; ++i)
../inputs/grep1.dat:	    ;
../inputs/grep1.dat:	  if (i > len)
../inputs/grep1.dat:	    len = i;
../inputs/grep1.dat:	  rcp = index(rcp + 1, *lcp);
../inputs/grep1.dat:	}
../inputs/grep1.dat:      if (len == 0)
../inputs/grep1.dat:	continue;
../inputs/grep1.dat:      if ((cpp = enlist(cpp, lcp, len)) == NULL)
../inputs/grep1.dat:	break;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  return cpp;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static char **
../inputs/grep1.dat:addlists(old, new)
../inputs/grep1.dat:char **old;
../inputs/grep1.dat:char **new;
../inputs/grep1.dat:{
../inputs/grep1.dat:  int i;
../inputs/grep1.dat:
../inputs/grep1.dat:  if (old == NULL || new == NULL)
../inputs/grep1.dat:    return NULL;
../inputs/grep1.dat:  for (i = 0; new[i] != NULL; ++i)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      old = enlist(old, new[i], strlen(new[i]));
../inputs/grep1.dat:      if (old == NULL)
../inputs/grep1.dat:	break;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  return old;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Given two lists of substrings, return a new list giving substrings
../inputs/grep1.dat:   common to both. */
../inputs/grep1.dat:static char **
../inputs/grep1.dat:inboth(left, right)
../inputs/grep1.dat:     char **left;
../inputs/grep1.dat:     char **right;
../inputs/grep1.dat:{
../inputs/grep1.dat:  char **both;
../inputs/grep1.dat:  char **temp;
../inputs/grep1.dat:  int lnum, rnum;
../inputs/grep1.dat:
../inputs/grep1.dat:  if (left == NULL || right == NULL)
../inputs/grep1.dat:    return NULL;
../inputs/grep1.dat:  both = (char **) malloc(sizeof *both);
../inputs/grep1.dat:  if (both == NULL)
../inputs/grep1.dat:    return NULL;
../inputs/grep1.dat:  both[0] = NULL;
../inputs/grep1.dat:  for (lnum = 0; left[lnum] != NULL; ++lnum)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      for (rnum = 0; right[rnum] != NULL; ++rnum)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  temp = comsubs(left[lnum], right[rnum]);
../inputs/grep1.dat:	  if (temp == NULL)
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      freelist(both);
../inputs/grep1.dat:	      return NULL;
../inputs/grep1.dat:	    }
../inputs/grep1.dat:	  both = addlists(both, temp);
../inputs/grep1.dat:	  freelist(temp);
../inputs/grep1.dat:	  if (both == NULL)
../inputs/grep1.dat:	    return NULL;
../inputs/grep1.dat:	}
../inputs/grep1.dat:    }
../inputs/grep1.dat:  return both;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:typedef struct
../inputs/grep1.dat:{
../inputs/grep1.dat:  char **in;
../inputs/grep1.dat:  char *left;
../inputs/grep1.dat:  char *right;
../inputs/grep1.dat:  char *is;
../inputs/grep1.dat:} must;
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:resetmust(mp)
../inputs/grep1.dat:must *mp;
../inputs/grep1.dat:{
../inputs/grep1.dat:  mp->left[0] = mp->right[0] = mp->is[0] = '\0';
../inputs/grep1.dat:  freelist(mp->in);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:dfamust(dfa)
../inputs/grep1.dat:struct dfa *dfa;
../inputs/grep1.dat:{
../inputs/grep1.dat:  must *musts;
../inputs/grep1.dat:  must *mp;
../inputs/grep1.dat:  char *result;
../inputs/grep1.dat:  int ri;
../inputs/grep1.dat:  int i;
../inputs/grep1.dat:  int exact;
../inputs/grep1.dat:  token t;
../inputs/grep1.dat:  static must must0;
../inputs/grep1.dat:  struct dfamust *dm;
../inputs/grep1.dat:
../inputs/grep1.dat:  result = "";
../inputs/grep1.dat:  exact = 0;
../inputs/grep1.dat:  musts = (must *) malloc((dfa->tindex + 1) * sizeof *musts);
../inputs/grep1.dat:  if (musts == NULL)
../inputs/grep1.dat:    return;
../inputs/grep1.dat:  mp = musts;
../inputs/grep1.dat:  for (i = 0; i <= dfa->tindex; ++i)
../inputs/grep1.dat:    mp[i] = must0;
../inputs/grep1.dat:  for (i = 0; i <= dfa->tindex; ++i)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      mp[i].in = (char **) malloc(sizeof *mp[i].in);
../inputs/grep1.dat:      mp[i].left = malloc(2);
../inputs/grep1.dat:      mp[i].right = malloc(2);
../inputs/grep1.dat:      mp[i].is = malloc(2);
../inputs/grep1.dat:      if (mp[i].in == NULL || mp[i].left == NULL ||
../inputs/grep1.dat:	  mp[i].right == NULL || mp[i].is == NULL)
../inputs/grep1.dat:	goto done;
../inputs/grep1.dat:      mp[i].left[0] = mp[i].right[0] = mp[i].is[0] = '\0';
../inputs/grep1.dat:      mp[i].in[0] = NULL;
../inputs/grep1.dat:    }
../inputs/grep1.dat:#ifdef DEBUG
../inputs/grep1.dat:  fprintf(stderr, "dfamust:\n");
../inputs/grep1.dat:  for (i = 0; i < dfa->tindex; ++i)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      fprintf(stderr, " %d:", i);
../inputs/grep1.dat:      prtok(dfa->tokens[i]);
../inputs/grep1.dat:    }
../inputs/grep1.dat:  putc('\n', stderr);
../inputs/grep1.dat:#endif
../inputs/grep1.dat:  for (ri = 0; ri < dfa->tindex; ++ri)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      switch (t = dfa->tokens[ri])
../inputs/grep1.dat:	{
../inputs/grep1.dat:	case LPAREN:
../inputs/grep1.dat:	case RPAREN:
../inputs/grep1.dat:	  goto done;		/* "cannot happen" */
../inputs/grep1.dat:	case EMPTY:
../inputs/grep1.dat:	case BEGLINE:
../inputs/grep1.dat:	case ENDLINE:
../inputs/grep1.dat:	case BEGWORD:
../inputs/grep1.dat:	case ENDWORD:
../inputs/grep1.dat:	case LIMWORD:
../inputs/grep1.dat:	case NOTLIMWORD:
../inputs/grep1.dat:	case BACKREF:
../inputs/grep1.dat:	  resetmust(mp);
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:	case STAR:
../inputs/grep1.dat:	case QMARK:
../inputs/grep1.dat:	  if (mp <= musts)
../inputs/grep1.dat:	    goto done;		/* "cannot happen" */
../inputs/grep1.dat:	  --mp;
../inputs/grep1.dat:	  resetmust(mp);
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:	case OR:
../inputs/grep1.dat:	case ORTOP:
../inputs/grep1.dat:	  if (mp < &musts[2])
../inputs/grep1.dat:	    goto done;		/* "cannot happen" */
../inputs/grep1.dat:	  {
../inputs/grep1.dat:	    char **new;
../inputs/grep1.dat:	    must *lmp;
../inputs/grep1.dat:	    must *rmp;
../inputs/grep1.dat:	    int j, ln, rn, n;
../inputs/grep1.dat:
../inputs/grep1.dat:	    rmp = --mp;
../inputs/grep1.dat:	    lmp = --mp;
../inputs/grep1.dat:	    /* Guaranteed to be.  Unlikely, but. . . */
../inputs/grep1.dat:	    if (strcmp(lmp->is, rmp->is) != 0)
../inputs/grep1.dat:	      lmp->is[0] = '\0';
../inputs/grep1.dat:	    /* Left side--easy */
../inputs/grep1.dat:	    i = 0;
../inputs/grep1.dat:	    while (lmp->left[i] != '\0' && lmp->left[i] == rmp->left[i])
../inputs/grep1.dat:	      ++i;
../inputs/grep1.dat:	    lmp->left[i] = '\0';
../inputs/grep1.dat:	    /* Right side */
../inputs/grep1.dat:	    ln = strlen(lmp->right);
../inputs/grep1.dat:	    rn = strlen(rmp->right);
../inputs/grep1.dat:	    n = ln;
../inputs/grep1.dat:	    if (n > rn)
../inputs/grep1.dat:	      n = rn;
../inputs/grep1.dat:	    for (i = 0; i < n; ++i)
../inputs/grep1.dat:	      if (lmp->right[ln - i - 1] != rmp->right[rn - i - 1])
../inputs/grep1.dat:		break;
../inputs/grep1.dat:	    for (j = 0; j < i; ++j)
../inputs/grep1.dat:	      lmp->right[j] = lmp->right[(ln - i) + j];
../inputs/grep1.dat:	    lmp->right[j] = '\0';
../inputs/grep1.dat:	    new = inboth(lmp->in, rmp->in);
../inputs/grep1.dat:	    if (new == NULL)
../inputs/grep1.dat:	      goto done;
../inputs/grep1.dat:	    freelist(lmp->in);
../inputs/grep1.dat:	    free((char *) lmp->in);
../inputs/grep1.dat:	    lmp->in = new;
../inputs/grep1.dat:	  }
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:	case PLUS:
../inputs/grep1.dat:	  if (mp <= musts)
../inputs/grep1.dat:	    goto done;		/* "cannot happen" */
../inputs/grep1.dat:	  --mp;
../inputs/grep1.dat:	  mp->is[0] = '\0';
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:	case END:
../inputs/grep1.dat:	  if (mp != &musts[1])
../inputs/grep1.dat:	    goto done;		/* "cannot happen" */
../inputs/grep1.dat:	  for (i = 0; musts[0].in[i] != NULL; ++i)
../inputs/grep1.dat:	    if (strlen(musts[0].in[i]) > strlen(result))
../inputs/grep1.dat:	      result = musts[0].in[i];
../inputs/grep1.dat:	  if (strcmp(result, musts[0].is) == 0)
../inputs/grep1.dat:	    exact = 1;
../inputs/grep1.dat:	  goto done;
../inputs/grep1.dat:	case CAT:
../inputs/grep1.dat:	  if (mp < &musts[2])
../inputs/grep1.dat:	    goto done;		/* "cannot happen" */
../inputs/grep1.dat:	  {
../inputs/grep1.dat:	    must *lmp;
../inputs/grep1.dat:	    must *rmp;
../inputs/grep1.dat:
../inputs/grep1.dat:	    rmp = --mp;
../inputs/grep1.dat:	    lmp = --mp;
../inputs/grep1.dat:	    /* In.  Everything in left, plus everything in
../inputs/grep1.dat:	       right, plus catenation of
../inputs/grep1.dat:	       left's right and right's left. */
../inputs/grep1.dat:	    lmp->in = addlists(lmp->in, rmp->in);
../inputs/grep1.dat:	    if (lmp->in == NULL)
../inputs/grep1.dat:	      goto done;
../inputs/grep1.dat:	    if (lmp->right[0] != '\0' &&
../inputs/grep1.dat:		rmp->left[0] != '\0')
../inputs/grep1.dat:	      {
../inputs/grep1.dat:		char *tp;
../inputs/grep1.dat:
../inputs/grep1.dat:		tp = icpyalloc(lmp->right);
../inputs/grep1.dat:		if (tp == NULL)
../inputs/grep1.dat:		  goto done;
../inputs/grep1.dat:		tp = icatalloc(tp, rmp->left);
../inputs/grep1.dat:		if (tp == NULL)
../inputs/grep1.dat:		  goto done;
../inputs/grep1.dat:		lmp->in = enlist(lmp->in, tp,
../inputs/grep1.dat:				 strlen(tp));
../inputs/grep1.dat:		free(tp);
../inputs/grep1.dat:		if (lmp->in == NULL)
../inputs/grep1.dat:		  goto done;
../inputs/grep1.dat:	      }
../inputs/grep1.dat:	    /* Left-hand */
../inputs/grep1.dat:	    if (lmp->is[0] != '\0')
../inputs/grep1.dat:	      {
../inputs/grep1.dat:		lmp->left = icatalloc(lmp->left,
../inputs/grep1.dat:				      rmp->left);
../inputs/grep1.dat:		if (lmp->left == NULL)
../inputs/grep1.dat:		  goto done;
../inputs/grep1.dat:	      }
../inputs/grep1.dat:	    /* Right-hand */
../inputs/grep1.dat:	    if (rmp->is[0] == '\0')
../inputs/grep1.dat:	      lmp->right[0] = '\0';
../inputs/grep1.dat:	    lmp->right = icatalloc(lmp->right, rmp->right);
../inputs/grep1.dat:	    if (lmp->right == NULL)
../inputs/grep1.dat:	      goto done;
../inputs/grep1.dat:	    /* Guaranteed to be */
../inputs/grep1.dat:	    if (lmp->is[0] != '\0' && rmp->is[0] != '\0')
../inputs/grep1.dat:	      {
../inputs/grep1.dat:		lmp->is = icatalloc(lmp->is, rmp->is);
../inputs/grep1.dat:		if (lmp->is == NULL)
../inputs/grep1.dat:		  goto done;
../inputs/grep1.dat:	      }
../inputs/grep1.dat:	    else
../inputs/grep1.dat:	      lmp->is[0] = '\0';
../inputs/grep1.dat:	  }
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:	default:
../inputs/grep1.dat:	  if (t < END)
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      /* "cannot happen" */
../inputs/grep1.dat:	      goto done;
../inputs/grep1.dat:	    }
../inputs/grep1.dat:	  else if (t == '\0')
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      /* not on *my* shift */
../inputs/grep1.dat:	      goto done;
../inputs/grep1.dat:	    }
../inputs/grep1.dat:	  else if (t >= CSET)
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      /* easy enough */
../inputs/grep1.dat:	      resetmust(mp);
../inputs/grep1.dat:	    }
../inputs/grep1.dat:	  else
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      /* plain character */
../inputs/grep1.dat:	      resetmust(mp);
../inputs/grep1.dat:	      mp->is[0] = mp->left[0] = mp->right[0] = t;
../inputs/grep1.dat:	      mp->is[1] = mp->left[1] = mp->right[1] = '\0';
../inputs/grep1.dat:	      mp->in = enlist(mp->in, mp->is, 1);
../inputs/grep1.dat:	      if (mp->in == NULL)
../inputs/grep1.dat:		goto done;
../inputs/grep1.dat:	    }
../inputs/grep1.dat:	  break;
../inputs/grep1.dat:	}
../inputs/grep1.dat:#ifdef DEBUG
../inputs/grep1.dat:      fprintf(stderr, " node: %d:", ri);
../inputs/grep1.dat:      prtok(dfa->tokens[ri]);
../inputs/grep1.dat:      fprintf(stderr, "\n  in:");
../inputs/grep1.dat:      for (i = 0; mp->in[i]; ++i)
../inputs/grep1.dat:	fprintf(stderr, " \"%s\"", mp->in[i]);
../inputs/grep1.dat:      fprintf(stderr, "\n  is: \"%s\"\n", mp->is);
../inputs/grep1.dat:      fprintf(stderr, "  left: \"%s\"\n", mp->left);
../inputs/grep1.dat:      fprintf(stderr, "  right: \"%s\"\n", mp->right);
../inputs/grep1.dat:#endif
../inputs/grep1.dat:      ++mp;
../inputs/grep1.dat:    }
../inputs/grep1.dat: done:
../inputs/grep1.dat:  if (strlen(result))
../inputs/grep1.dat:    {
../inputs/grep1.dat:      dm = (struct dfamust *) malloc(sizeof (struct dfamust));
../inputs/grep1.dat:      dm->exact = exact;
../inputs/grep1.dat:      dm->must = malloc(strlen(result) + 1);
../inputs/grep1.dat:      strcpy(dm->must, result);
../inputs/grep1.dat:      dm->next = dfa->musts;
../inputs/grep1.dat:      dfa->musts = dm;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  mp = musts;
../inputs/grep1.dat:  for (i = 0; i <= dfa->tindex; ++i)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      freelist(mp[i].in);
../inputs/grep1.dat:      ifree((char *) mp[i].in);
../inputs/grep1.dat:      ifree(mp[i].left);
../inputs/grep1.dat:      ifree(mp[i].right);
../inputs/grep1.dat:      ifree(mp[i].is);
../inputs/grep1.dat:    }
../inputs/grep1.dat:  free((char *) mp);
../inputs/grep1.dat:}
../inputs/grep1.dat:/* kwset.c - search for any of a set of keywords.
../inputs/grep1.dat:   Copyright 1989 Free Software Foundation
../inputs/grep1.dat:		  Written August 1989 by Mike Haertel.
../inputs/grep1.dat:
../inputs/grep1.dat:   This program is free software; you can redistribute it and/or modify
../inputs/grep1.dat:   it under the terms of the GNU General Public License as published by
../inputs/grep1.dat:   the Free Software Foundation; either version 1, or (at your option)
../inputs/grep1.dat:   any later version.
../inputs/grep1.dat:
../inputs/grep1.dat:   This program is distributed in the hope that it will be useful,
../inputs/grep1.dat:   but WITHOUT ANY WARRANTY; without even the implied warranty of
../inputs/grep1.dat:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
../inputs/grep1.dat:   GNU General Public License for more details.
../inputs/grep1.dat:
../inputs/grep1.dat:   You should have received a copy of the GNU General Public License
../inputs/grep1.dat:   along with this program; if not, write to the Free Software
../inputs/grep1.dat:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
../inputs/grep1.dat:
../inputs/grep1.dat:   The author may be reached (Email) at the address mike@ai.mit.edu,
../inputs/grep1.dat:   or (US mail) as Mike Haertel c/o Free Software Foundation. */
../inputs/grep1.dat:
../inputs/grep1.dat:/* The algorithm implemented by these routines bears a startling resemblence
../inputs/grep1.dat:   to one discovered by Beate Commentz-Walter, although it is not identical.
../inputs/grep1.dat:   See "A String Matching Algorithm Fast on the Average," Technical Report,
../inputs/grep1.dat:   IBM-Germany, Scientific Center Heidelberg, Tiergartenstrasse 15, D-6900
../inputs/grep1.dat:   Heidelberg, Germany.  See also Aho, A.V., and M. Corasick, "Efficient
../inputs/grep1.dat:   String Matching:  An Aid to Bibliographic Search," CACM June 1975,
../inputs/grep1.dat:   Vol. 18, No. 6, which describes the failure function used below. */
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef STDC_HEADERS
../inputs/grep1.dat:#undef RE_DUP_MAX
../inputs/grep1.dat:#define flag_limits 1
../inputs/grep1.dat:#if flag_stdlib==0 
../inputs/grep1.dat:#define flag_stdlib 1
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#else
../inputs/grep1.dat:#define INT_MAX 2147483647
../inputs/grep1.dat:#define UCHAR_MAX 255
../inputs/grep1.dat:#ifdef __STDC__
../inputs/grep1.dat:#else
../inputs/grep1.dat:#if flag_systypes==0
../inputs/grep1.dat:#define flag_systypes 1
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#endif
../inputs/grep1.dat:extern char *malloc();
../inputs/grep1.dat:extern void free();
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef HAVE_MEMCHR
../inputs/grep1.dat:#if flag_string==0
../inputs/grep1.dat:#define flag_string 1
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#ifdef NEED_MEMORY_H
../inputs/grep1.dat:#if flag_memory==0
../inputs/grep1.dat:#define flag_memory 1
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#else
../inputs/grep1.dat:#ifdef __STDC__
../inputs/grep1.dat:extern void *memchr();
../inputs/grep1.dat:#else
../inputs/grep1.dat:extern char *memchr();
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef GREP
../inputs/grep1.dat:extern char *xmalloc();
../inputs/grep1.dat:#define malloc xmalloc
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:#define NCHAR (UCHAR_MAX + 1)
../inputs/grep1.dat:#define obstack_chunk_alloc malloc
../inputs/grep1.dat:#define obstack_chunk_free free
../inputs/grep1.dat:
../inputs/grep1.dat:/* Balanced tree of edges and labels leaving a given trie node. */
../inputs/grep1.dat:struct tree
../inputs/grep1.dat:{
../inputs/grep1.dat:  struct tree *llink;		/* Left link; MUST be first field. */
../inputs/grep1.dat:  struct tree *rlink;		/* Right link (to larger labels). */
../inputs/grep1.dat:  struct trie *trie;		/* Trie node pointed to by this edge. */
../inputs/grep1.dat:  unsigned char label;		/* Label on this edge. */
../inputs/grep1.dat:  char balance;			/* Difference in depths of subtrees. */
../inputs/grep1.dat:};
../inputs/grep1.dat:
../inputs/grep1.dat:/* Node of a trie representing a set of reversed keywords. */
../inputs/grep1.dat:struct trie
../inputs/grep1.dat:{
../inputs/grep1.dat:  unsigned int accepting;	/* Word index of accepted word, or zero. */
../inputs/grep1.dat:  struct tree *links;		/* Tree of edges leaving this node. */
../inputs/grep1.dat:  struct trie *parent;		/* Parent of this node. */
../inputs/grep1.dat:  struct trie *next;		/* List of all trie nodes in level order. */
../inputs/grep1.dat:  struct trie *fail;		/* Aho-Corasick failure function. */
../inputs/grep1.dat:  int depth;			/* Depth of this node from the root. */
../inputs/grep1.dat:  int shift;			/* Shift function for search failures. */
../inputs/grep1.dat:  int maxshift;			/* Max shift of self and descendents. */
../inputs/grep1.dat:};
../inputs/grep1.dat:
../inputs/grep1.dat:/* Structure returned opaquely to the caller, containing everything. */
../inputs/grep1.dat:struct kwset
../inputs/grep1.dat:{
../inputs/grep1.dat:  struct obstack obstack;	/* Obstack for node allocation. */
../inputs/grep1.dat:  int words;			/* Number of words in the trie. */
../inputs/grep1.dat:  struct trie *trie;		/* The trie itself. */
../inputs/grep1.dat:  int mind;			/* Minimum depth of an accepting node. */
../inputs/grep1.dat:  int maxd;			/* Maximum depth of any node. */
../inputs/grep1.dat:  unsigned char delta[NCHAR];	/* Delta table for rapid search. */
../inputs/grep1.dat:  struct trie *next[NCHAR];	/* Table of children of the root. */
../inputs/grep1.dat:  char *target;			/* Target string if there's only one. */
../inputs/grep1.dat:  int mind2;			/* Used in Boyer-Moore search for one string. */
../inputs/grep1.dat:  char *trans;			/* Character translation table. */
../inputs/grep1.dat:};
../inputs/grep1.dat:
../inputs/grep1.dat:/* Allocate and initialize a keyword set object, returning an opaque
../inputs/grep1.dat:   pointer to it.  Return NULL if memory is not available. */
../inputs/grep1.dat:kwset_t
../inputs/grep1.dat:kwsalloc(trans)
../inputs/grep1.dat:     char *trans;
../inputs/grep1.dat:{
../inputs/grep1.dat:  struct kwset *kwset;
../inputs/grep1.dat:
../inputs/grep1.dat:  kwset = (struct kwset *) malloc(sizeof (struct kwset));
../inputs/grep1.dat:  if (!kwset)
../inputs/grep1.dat:    return 0;
../inputs/grep1.dat:
../inputs/grep1.dat:  obstack_init(&kwset->obstack);
../inputs/grep1.dat:  kwset->words = 0;
../inputs/grep1.dat:  kwset->trie
../inputs/grep1.dat:    = (struct trie *) obstack_alloc(&kwset->obstack, sizeof (struct trie));
../inputs/grep1.dat:  if (!kwset->trie)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      kwsfree((kwset_t) kwset);
../inputs/grep1.dat:      return 0;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  kwset->trie->accepting = 0;
../inputs/grep1.dat:  kwset->trie->links = 0;
../inputs/grep1.dat:  kwset->trie->parent = 0;
../inputs/grep1.dat:  kwset->trie->next = 0;
../inputs/grep1.dat:  kwset->trie->fail = 0;
../inputs/grep1.dat:  kwset->trie->depth = 0;
../inputs/grep1.dat:  kwset->trie->shift = 0;
../inputs/grep1.dat:  kwset->mind = INT_MAX;
../inputs/grep1.dat:  kwset->maxd = -1;
../inputs/grep1.dat:  kwset->target = 0;
../inputs/grep1.dat:  kwset->trans = trans;
../inputs/grep1.dat:
../inputs/grep1.dat:  return (kwset_t) kwset;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Add the given string to the contents of the keyword set.  Return NULL
../inputs/grep1.dat:   for success, an error message otherwise. */
../inputs/grep1.dat:char *
../inputs/grep1.dat:kwsincr(kws, text, len)
../inputs/grep1.dat:     kwset_t kws;
../inputs/grep1.dat:     char *text;
../inputs/grep1.dat:     size_t len;
../inputs/grep1.dat:{
../inputs/grep1.dat:  struct kwset *kwset;
../inputs/grep1.dat:  register struct trie *trie;
../inputs/grep1.dat:  register unsigned char label;
../inputs/grep1.dat:  register struct tree *link;
../inputs/grep1.dat:  register int depth;
../inputs/grep1.dat:  struct tree *links[12];
../inputs/grep1.dat:  enum { L, R } dirs[12];
../inputs/grep1.dat:  struct tree *t, *r, *l, *rl, *lr;
../inputs/grep1.dat:
../inputs/grep1.dat:  kwset = (struct kwset *) kws;
../inputs/grep1.dat:  trie = kwset->trie;
../inputs/grep1.dat:  text += len;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Descend the trie (built of reversed keywords) character-by-character,
../inputs/grep1.dat:     installing new nodes when necessary. */
../inputs/grep1.dat:  while (len--)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      label = kwset->trans ? kwset->trans[(unsigned char) *--text] : *--text;
../inputs/grep1.dat:
../inputs/grep1.dat:      /* Descend the tree of outgoing links for this trie node,
../inputs/grep1.dat:	 looking for the current character and keeping track
../inputs/grep1.dat:	 of the path followed. */
../inputs/grep1.dat:      link = trie->links;
../inputs/grep1.dat:      links[0] = (struct tree *) &trie->links;
../inputs/grep1.dat:      dirs[0] = L;
../inputs/grep1.dat:      depth = 1;
../inputs/grep1.dat:
../inputs/grep1.dat:      while (link && label != link->label)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  links[depth] = link;
../inputs/grep1.dat:	  if (label < link->label)
../inputs/grep1.dat:	    dirs[depth++] = L, link = link->llink;
../inputs/grep1.dat:	  else
../inputs/grep1.dat:	    dirs[depth++] = R, link = link->rlink;
../inputs/grep1.dat:	}
../inputs/grep1.dat:
../inputs/grep1.dat:      /* The current character doesn't have an outgoing link at
../inputs/grep1.dat:	 this trie node, so build a new trie node and install
../inputs/grep1.dat:	 a link in the current trie node's tree. */
../inputs/grep1.dat:      if (!link)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  link = (struct tree *) obstack_alloc(&kwset->obstack,
../inputs/grep1.dat:					       sizeof (struct tree));
../inputs/grep1.dat:	  if (!link)
../inputs/grep1.dat:	    return "memory exhausted";
../inputs/grep1.dat:	  link->llink = 0;
../inputs/grep1.dat:	  link->rlink = 0;
../inputs/grep1.dat:	  link->trie = (struct trie *) obstack_alloc(&kwset->obstack,
../inputs/grep1.dat:						     sizeof (struct trie));
../inputs/grep1.dat:	  if (!link->trie)
../inputs/grep1.dat:	    return "memory exhausted";
../inputs/grep1.dat:	  link->trie->accepting = 0;
../inputs/grep1.dat:	  link->trie->links = 0;
../inputs/grep1.dat:	  link->trie->parent = trie;
../inputs/grep1.dat:	  link->trie->next = 0;
../inputs/grep1.dat:	  link->trie->fail = 0;
../inputs/grep1.dat:	  link->trie->depth = trie->depth + 1;
../inputs/grep1.dat:	  link->trie->shift = 0;
../inputs/grep1.dat:	  link->label = label;
../inputs/grep1.dat:	  link->balance = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:	  /* Install the new tree node in its parent. */
../inputs/grep1.dat:	  if (dirs[--depth] == L)
../inputs/grep1.dat:	    links[depth]->llink = link;
../inputs/grep1.dat:	  else
../inputs/grep1.dat:	    links[depth]->rlink = link;
../inputs/grep1.dat:
../inputs/grep1.dat:	  /* Back up the tree fixing the balance flags. */
../inputs/grep1.dat:	  while (depth && !links[depth]->balance)
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      if (dirs[depth] == L)
../inputs/grep1.dat:		--links[depth]->balance;
../inputs/grep1.dat:	      else
../inputs/grep1.dat:		++links[depth]->balance;
../inputs/grep1.dat:	      --depth;
../inputs/grep1.dat:	    }
../inputs/grep1.dat:
../inputs/grep1.dat:	  /* Rebalance the tree by pointer rotations if necessary. */
../inputs/grep1.dat:	  if (depth && ((dirs[depth] == L && --links[depth]->balance)
../inputs/grep1.dat:			|| (dirs[depth] == R && ++links[depth]->balance)))
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      switch (links[depth]->balance)
../inputs/grep1.dat:		{
../inputs/grep1.dat:		case (char) -2:
../inputs/grep1.dat:		  switch (dirs[depth + 1])
../inputs/grep1.dat:		    {
../inputs/grep1.dat:		    case L:
../inputs/grep1.dat:		      r = links[depth], t = r->llink, rl = t->rlink;
../inputs/grep1.dat:		      t->rlink = r, r->llink = rl;
../inputs/grep1.dat:		      t->balance = r->balance = 0;
../inputs/grep1.dat:		      break;
../inputs/grep1.dat:		    case R:
../inputs/grep1.dat:		      r = links[depth], l = r->llink, t = l->rlink;
../inputs/grep1.dat:		      rl = t->rlink, lr = t->llink;
../inputs/grep1.dat:		      t->llink = l, l->rlink = lr, t->rlink = r, r->llink = rl;
../inputs/grep1.dat:		      l->balance = t->balance != 1 ? 0 : -1;
../inputs/grep1.dat:		      r->balance = t->balance != (char) -1 ? 0 : 1;
../inputs/grep1.dat:		      t->balance = 0;
../inputs/grep1.dat:		      break;
../inputs/grep1.dat:		    }
../inputs/grep1.dat:		  break;
../inputs/grep1.dat:		case 2:
../inputs/grep1.dat:		  switch (dirs[depth + 1])
../inputs/grep1.dat:		    {
../inputs/grep1.dat:		    case R:
../inputs/grep1.dat:		      l = links[depth], t = l->rlink, lr = t->llink;
../inputs/grep1.dat:		      t->llink = l, l->rlink = lr;
../inputs/grep1.dat:		      t->balance = l->balance = 0;
../inputs/grep1.dat:		      break;
../inputs/grep1.dat:		    case L:
../inputs/grep1.dat:		      l = links[depth], r = l->rlink, t = r->llink;
../inputs/grep1.dat:		      lr = t->llink, rl = t->rlink;
../inputs/grep1.dat:		      t->llink = l, l->rlink = lr, t->rlink = r, r->llink = rl;
../inputs/grep1.dat:		      l->balance = t->balance != 1 ? 0 : -1;
../inputs/grep1.dat:		      r->balance = t->balance != (char) -1 ? 0 : 1;
../inputs/grep1.dat:		      t->balance = 0;
../inputs/grep1.dat:		      break;
../inputs/grep1.dat:		    }
../inputs/grep1.dat:		  break;
../inputs/grep1.dat:		}
../inputs/grep1.dat:
../inputs/grep1.dat:	      if (dirs[depth - 1] == L)
../inputs/grep1.dat:		links[depth - 1]->llink = t;
../inputs/grep1.dat:	      else
../inputs/grep1.dat:		links[depth - 1]->rlink = t;
../inputs/grep1.dat:	    }
../inputs/grep1.dat:	}
../inputs/grep1.dat:
../inputs/grep1.dat:      trie = link->trie;
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Mark the node we finally reached as accepting, encoding the
../inputs/grep1.dat:     index number of this word in the keyword set so far. */
../inputs/grep1.dat:  if (!trie->accepting)
../inputs/grep1.dat:    trie->accepting = 1 + 2 * kwset->words;
../inputs/grep1.dat:  ++kwset->words;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Keep track of the longest and shortest string of the keyword set. */
../inputs/grep1.dat:  if (trie->depth < kwset->mind)
../inputs/grep1.dat:    kwset->mind = trie->depth;
../inputs/grep1.dat:  if (trie->depth > kwset->maxd)
../inputs/grep1.dat:    kwset->maxd = trie->depth;
../inputs/grep1.dat:
../inputs/grep1.dat:  return 0;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Enqueue the trie nodes referenced from the given tree in the
../inputs/grep1.dat:   given queue. */
../inputs/grep1.dat:static void
../inputs/grep1.dat:enqueue(tree, last)
../inputs/grep1.dat:     struct tree *tree;
../inputs/grep1.dat:     struct trie **last;
../inputs/grep1.dat:{
../inputs/grep1.dat:  if (!tree)
../inputs/grep1.dat:    return;
../inputs/grep1.dat:  enqueue(tree->llink, last);
../inputs/grep1.dat:  enqueue(tree->rlink, last);
../inputs/grep1.dat:  (*last) = (*last)->next = tree->trie;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Compute the Aho-Corasick failure function for the trie nodes referenced
../inputs/grep1.dat:   from the given tree, given the failure function for their parent as
../inputs/grep1.dat:   well as a last resort failure node. */
../inputs/grep1.dat:static void
../inputs/grep1.dat:treefails(tree, fail, recourse)
../inputs/grep1.dat:     register struct tree *tree;
../inputs/grep1.dat:     struct trie *fail;
../inputs/grep1.dat:     struct trie *recourse;
../inputs/grep1.dat:{
../inputs/grep1.dat:  register struct tree *link;
../inputs/grep1.dat:
../inputs/grep1.dat:  if (!tree)
../inputs/grep1.dat:    return;
../inputs/grep1.dat:
../inputs/grep1.dat:  treefails(tree->llink, fail, recourse);
../inputs/grep1.dat:  treefails(tree->rlink, fail, recourse);
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Find, in the chain of fails going back to the root, the first
../inputs/grep1.dat:     node that has a descendent on the current label. */
../inputs/grep1.dat:  while (fail)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      link = fail->links;
../inputs/grep1.dat:      while (link && tree->label != link->label)
../inputs/grep1.dat:	if (tree->label < link->label)
../inputs/grep1.dat:	  link = link->llink;
../inputs/grep1.dat:	else
../inputs/grep1.dat:	  link = link->rlink;
../inputs/grep1.dat:      if (link)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  tree->trie->fail = link->trie;
../inputs/grep1.dat:	  return;
../inputs/grep1.dat:	}
../inputs/grep1.dat:      fail = fail->fail;
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  tree->trie->fail = recourse;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Set delta entries for the links of the given tree such that
../inputs/grep1.dat:   the preexisting delta value is larger than the current depth. */
../inputs/grep1.dat:static void
../inputs/grep1.dat:treedelta(tree, depth, delta)
../inputs/grep1.dat:     register struct tree *tree;
../inputs/grep1.dat:     register unsigned int depth;
../inputs/grep1.dat:     unsigned char delta[];
../inputs/grep1.dat:{
../inputs/grep1.dat:  if (!tree)
../inputs/grep1.dat:    return;
../inputs/grep1.dat:  treedelta(tree->llink, depth, delta);
../inputs/grep1.dat:  treedelta(tree->rlink, depth, delta);
../inputs/grep1.dat:  if (depth < delta[tree->label])
../inputs/grep1.dat:    delta[tree->label] = depth;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Return true if A has every label in B. */
../inputs/grep1.dat:static int
../inputs/grep1.dat:hasevery(a, b)
../inputs/grep1.dat:     register struct tree *a;
../inputs/grep1.dat:     register struct tree *b;
../inputs/grep1.dat:{
../inputs/grep1.dat:  if (!b)
../inputs/grep1.dat:    return 1;
../inputs/grep1.dat:  if (!hasevery(a, b->llink))
../inputs/grep1.dat:    return 0;
../inputs/grep1.dat:  if (!hasevery(a, b->rlink))
../inputs/grep1.dat:    return 0;
../inputs/grep1.dat:  while (a && b->label != a->label)
../inputs/grep1.dat:    if (b->label < a->label)
../inputs/grep1.dat:      a = a->llink;
../inputs/grep1.dat:    else
../inputs/grep1.dat:      a = a->rlink;
../inputs/grep1.dat:  return !!a;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Compute a vector, indexed by character code, of the trie nodes
../inputs/grep1.dat:   referenced from the given tree. */
../inputs/grep1.dat:static void
../inputs/grep1.dat:treenext(tree, next)
../inputs/grep1.dat:     struct tree *tree;
../inputs/grep1.dat:     struct trie *next[];
../inputs/grep1.dat:{
../inputs/grep1.dat:  if (!tree)
../inputs/grep1.dat:    return;
../inputs/grep1.dat:  treenext(tree->llink, next);
../inputs/grep1.dat:  treenext(tree->rlink, next);
../inputs/grep1.dat:  next[tree->label] = tree->trie;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Compute the shift for each trie node, as well as the delta
../inputs/grep1.dat:   table and next cache for the given keyword set. */
../inputs/grep1.dat:char *
../inputs/grep1.dat:kwsprep(kws)
../inputs/grep1.dat:     kwset_t kws;
../inputs/grep1.dat:{
../inputs/grep1.dat:  register struct kwset *kwset;
../inputs/grep1.dat:  register int i;
../inputs/grep1.dat:  register struct trie *curr, *fail;
../inputs/grep1.dat:  register char *trans;
../inputs/grep1.dat:  unsigned char delta[NCHAR];
../inputs/grep1.dat:  struct trie *last, *next[NCHAR];
../inputs/grep1.dat:
../inputs/grep1.dat:  kwset = (struct kwset *) kws;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Initial values for the delta table; will be changed later.  The
../inputs/grep1.dat:     delta entry for a given character is the smallest depth of any
../inputs/grep1.dat:     node at which an outgoing edge is labeled by that character. */
../inputs/grep1.dat:  if (kwset->mind < 256)
../inputs/grep1.dat:    for (i = 0; i < NCHAR; ++i)
../inputs/grep1.dat:      delta[i] = kwset->mind;
../inputs/grep1.dat:  else
../inputs/grep1.dat:    for (i = 0; i < NCHAR; ++i)
../inputs/grep1.dat:      delta[i] = 255;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Check if we can use the simple boyer-moore algorithm, instead
../inputs/grep1.dat:     of the hairy commentz-walter algorithm. */
../inputs/grep1.dat:  if (kwset->words == 1 && kwset->trans == 0)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      /* Looking for just one string.  Extract it from the trie. */
../inputs/grep1.dat:      kwset->target = obstack_alloc(&kwset->obstack, kwset->mind);
../inputs/grep1.dat:      for (i = kwset->mind - 1, curr = kwset->trie; i >= 0; --i)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  kwset->target[i] = curr->links->label;
../inputs/grep1.dat:	  curr = curr->links->trie;
../inputs/grep1.dat:	}
../inputs/grep1.dat:      /* Build the Boyer Moore delta.  Boy that's easy compared to CW. */
../inputs/grep1.dat:      for (i = 0; i < kwset->mind; ++i)
../inputs/grep1.dat:	delta[(unsigned char) kwset->target[i]] = kwset->mind - (i + 1);
../inputs/grep1.dat:      kwset->mind2 = kwset->mind;
../inputs/grep1.dat:      /* Find the minimal delta2 shift that we might make after
../inputs/grep1.dat:	 a backwards match has failed. */
../inputs/grep1.dat:      for (i = 0; i < kwset->mind - 1; ++i)
../inputs/grep1.dat:	if (kwset->target[i] == kwset->target[kwset->mind - 1])
../inputs/grep1.dat:	  kwset->mind2 = kwset->mind - (i + 1);
../inputs/grep1.dat:    }
../inputs/grep1.dat:  else
../inputs/grep1.dat:    {
../inputs/grep1.dat:      /* Traverse the nodes of the trie in level order, simultaneously
../inputs/grep1.dat:	 computing the delta table, failure function, and shift function. */
../inputs/grep1.dat:      for (curr = last = kwset->trie; curr; curr = curr->next)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  /* Enqueue the immediate descendents in the level order queue. */
../inputs/grep1.dat:	  enqueue(curr->links, &last);
../inputs/grep1.dat:
../inputs/grep1.dat:	  curr->shift = kwset->mind;
../inputs/grep1.dat:	  curr->maxshift = kwset->mind;
../inputs/grep1.dat:
../inputs/grep1.dat:	  /* Update the delta table for the descendents of this node. */
../inputs/grep1.dat:	  treedelta(curr->links, curr->depth, delta);
../inputs/grep1.dat:
../inputs/grep1.dat:	  /* Compute the failure function for the decendents of this node. */
../inputs/grep1.dat:	  treefails(curr->links, curr->fail, kwset->trie);
../inputs/grep1.dat:
../inputs/grep1.dat:	  /* Update the shifts at each node in the current node's chain
../inputs/grep1.dat:	     of fails back to the root. */
../inputs/grep1.dat:	  for (fail = curr->fail; fail; fail = fail->fail)
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      /* If the current node has some outgoing edge that the fail
../inputs/grep1.dat:		 doesn't, then the shift at the fail should be no larger
../inputs/grep1.dat:		 than the difference of their depths. */
../inputs/grep1.dat:	      if (!hasevery(fail->links, curr->links))
../inputs/grep1.dat:		if (curr->depth - fail->depth < fail->shift)
../inputs/grep1.dat:		  fail->shift = curr->depth - fail->depth;
../inputs/grep1.dat:
../inputs/grep1.dat:	      /* If the current node is accepting then the shift at the
../inputs/grep1.dat:		 fail and its descendents should be no larger than the
../inputs/grep1.dat:		 difference of their depths. */
../inputs/grep1.dat:	      if (curr->accepting && fail->maxshift > curr->depth - fail->depth)
../inputs/grep1.dat:		fail->maxshift = curr->depth - fail->depth;
../inputs/grep1.dat:	    }
../inputs/grep1.dat:	}
../inputs/grep1.dat:
../inputs/grep1.dat:      /* Traverse the trie in level order again, fixing up all nodes whose
../inputs/grep1.dat:	 shift exceeds their inherited maxshift. */
../inputs/grep1.dat:      for (curr = kwset->trie->next; curr; curr = curr->next)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  if (curr->maxshift > curr->parent->maxshift)
../inputs/grep1.dat:	    curr->maxshift = curr->parent->maxshift;
../inputs/grep1.dat:	  if (curr->shift > curr->maxshift)
../inputs/grep1.dat:	    curr->shift = curr->maxshift;
../inputs/grep1.dat:	}
../inputs/grep1.dat:
../inputs/grep1.dat:      /* Create a vector, indexed by character code, of the outgoing links
../inputs/grep1.dat:	 from the root node. */
../inputs/grep1.dat:      for (i = 0; i < NCHAR; ++i)
../inputs/grep1.dat:	next[i] = 0;
../inputs/grep1.dat:      treenext(kwset->trie->links, next);
../inputs/grep1.dat:
../inputs/grep1.dat:      if ((trans = kwset->trans) != 0)
../inputs/grep1.dat:	for (i = 0; i < NCHAR; ++i)
../inputs/grep1.dat:	  kwset->next[i] = next[(unsigned char) trans[i]];
../inputs/grep1.dat:      else
../inputs/grep1.dat:	for (i = 0; i < NCHAR; ++i)
../inputs/grep1.dat:	  kwset->next[i] = next[i];
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Fix things up for any translation table. */
../inputs/grep1.dat:  if ((trans = kwset->trans) != 0)
../inputs/grep1.dat:    for (i = 0; i < NCHAR; ++i)
../inputs/grep1.dat:      kwset->delta[i] = delta[(unsigned char) trans[i]];
../inputs/grep1.dat:  else
../inputs/grep1.dat:    for (i = 0; i < NCHAR; ++i)
../inputs/grep1.dat:      kwset->delta[i] = delta[i];
../inputs/grep1.dat:
../inputs/grep1.dat:  return 0;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:#define U(C) ((unsigned char) (C))
../inputs/grep1.dat:
../inputs/grep1.dat:/* Fast boyer-moore search. */
../inputs/grep1.dat:static char *
../inputs/grep1.dat:bmexec(kws, text, size)
../inputs/grep1.dat:     kwset_t kws;
../inputs/grep1.dat:     char *text;
../inputs/grep1.dat:     size_t size;
../inputs/grep1.dat:{
../inputs/grep1.dat:  struct kwset *kwset;
../inputs/grep1.dat:  register unsigned char *d1;
../inputs/grep1.dat:  register char *ep, *sp, *tp;
../inputs/grep1.dat:  register int d, gc, i, len, md2;
../inputs/grep1.dat:
../inputs/grep1.dat:  kwset = (struct kwset *) kws;
../inputs/grep1.dat:  len = kwset->mind;
../inputs/grep1.dat:
../inputs/grep1.dat:  if (len == 0)
../inputs/grep1.dat:    return text;
../inputs/grep1.dat:  if (len > size)
../inputs/grep1.dat:    return 0;
../inputs/grep1.dat:  if (len == 1)
../inputs/grep1.dat:    return memchr(text, kwset->target[0], size);
../inputs/grep1.dat:
../inputs/grep1.dat:  d1 = kwset->delta;
../inputs/grep1.dat:  sp = kwset->target + len;
../inputs/grep1.dat:  gc = U(sp[-2]);
../inputs/grep1.dat:  md2 = kwset->mind2;
../inputs/grep1.dat:  tp = text + len;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Significance of 12: 1 (initial offset) + 10 (skip loop) + 1 (md2). */
../inputs/grep1.dat:  if (size > 12 * len)
../inputs/grep1.dat:    /* 11 is not a bug, the initial offset happens only once. */
../inputs/grep1.dat:    for (ep = text + size - 11 * len;;)
../inputs/grep1.dat:      {
../inputs/grep1.dat:	while (tp <= ep)
../inputs/grep1.dat:	  {
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	    if (d == 0)
../inputs/grep1.dat:	      goto found;
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	    if (d == 0)
../inputs/grep1.dat:	      goto found;
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	    if (d == 0)
../inputs/grep1.dat:	      goto found;
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	    d = d1[U(tp[-1])], tp += d;
../inputs/grep1.dat:	  }
../inputs/grep1.dat:	break;
../inputs/grep1.dat:      found:
../inputs/grep1.dat:	if (U(tp[-2]) == gc)
../inputs/grep1.dat:	  {
../inputs/grep1.dat:	    for (i = 3; i <= len && U(tp[-i]) == U(sp[-i]); ++i)
../inputs/grep1.dat:	      ;
../inputs/grep1.dat:	    if (i > len)
../inputs/grep1.dat:	      return tp - len;
../inputs/grep1.dat:	  }
../inputs/grep1.dat:	tp += md2;
../inputs/grep1.dat:      }
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Now we have only a few characters left to search.  We
../inputs/grep1.dat:     carefully avoid ever producing an out-of-bounds pointer. */
../inputs/grep1.dat:  ep = text + size;
../inputs/grep1.dat:  d = d1[U(tp[-1])];
../inputs/grep1.dat:  while (d <= ep - tp)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      d = d1[U((tp += d)[-1])];
../inputs/grep1.dat:      if (d != 0)
../inputs/grep1.dat:	continue;
../inputs/grep1.dat:      if (tp[-2] == gc)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  for (i = 3; i <= len && U(tp[-i]) == U(sp[-i]); ++i)
../inputs/grep1.dat:	    ;
../inputs/grep1.dat:	  if (i > len)
../inputs/grep1.dat:	    return tp - len;
../inputs/grep1.dat:	}
../inputs/grep1.dat:      d = md2;
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  return 0;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Hairy multiple string search. */
../inputs/grep1.dat:static char *
../inputs/grep1.dat:cwexec(kws, text, len, kwsmatch)
../inputs/grep1.dat:     kwset_t kws;
../inputs/grep1.dat:     char *text;
../inputs/grep1.dat:     size_t len;
../inputs/grep1.dat:     struct kwsmatch *kwsmatch;
../inputs/grep1.dat:{
../inputs/grep1.dat:  struct kwset *kwset;
../inputs/grep1.dat:  struct trie **next, *trie, *accept;
../inputs/grep1.dat:  char *beg, *lim, *mch, *lmch;
../inputs/grep1.dat:  register unsigned char c, *delta;
../inputs/grep1.dat:  register int d;
../inputs/grep1.dat:  register char *end, *qlim;
../inputs/grep1.dat:  register struct tree *tree;
../inputs/grep1.dat:  register char *trans;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Initialize register copies and look for easy ways out. */
../inputs/grep1.dat:  kwset = (struct kwset *) kws;
../inputs/grep1.dat:  if (len < kwset->mind)
../inputs/grep1.dat:    return 0;
../inputs/grep1.dat:  next = kwset->next;
../inputs/grep1.dat:  delta = kwset->delta;
../inputs/grep1.dat:  trans = kwset->trans;
../inputs/grep1.dat:  lim = text + len;
../inputs/grep1.dat:  end = text;
../inputs/grep1.dat:  if ((d = kwset->mind) != 0)
../inputs/grep1.dat:    mch = 0;
../inputs/grep1.dat:  else
../inputs/grep1.dat:    {
../inputs/grep1.dat:      mch = text, accept = kwset->trie;
../inputs/grep1.dat:      goto match;
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  if (len >= 4 * kwset->mind)
../inputs/grep1.dat:    qlim = lim - 4 * kwset->mind;
../inputs/grep1.dat:  else
../inputs/grep1.dat:    qlim = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:  while (lim - end >= d)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      if (qlim && end <= qlim)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  end += d - 1;
../inputs/grep1.dat:	  while ((d = delta[c = *end]) && end < qlim)
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      end += d;
../inputs/grep1.dat:	      end += delta[(unsigned char) *end];
../inputs/grep1.dat:	      end += delta[(unsigned char) *end];
../inputs/grep1.dat:	    }
../inputs/grep1.dat:	  ++end;
../inputs/grep1.dat:	}
../inputs/grep1.dat:      else
../inputs/grep1.dat:	d = delta[c = (end += d)[-1]];
../inputs/grep1.dat:      if (d)
../inputs/grep1.dat:	continue;
../inputs/grep1.dat:      beg = end - 1;
../inputs/grep1.dat:      trie = next[c];
../inputs/grep1.dat:      if (trie->accepting)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  mch = beg;
../inputs/grep1.dat:	  accept = trie;
../inputs/grep1.dat:	}
../inputs/grep1.dat:      d = trie->shift;
../inputs/grep1.dat:      while (beg > text)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  c = trans ? trans[(unsigned char) *--beg] : *--beg;
../inputs/grep1.dat:	  tree = trie->links;
../inputs/grep1.dat:	  while (tree && c != tree->label)
../inputs/grep1.dat:	    if (c < tree->label)
../inputs/grep1.dat:	      tree = tree->llink;
../inputs/grep1.dat:	    else
../inputs/grep1.dat:	      tree = tree->rlink;
../inputs/grep1.dat:	  if (tree)
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      trie = tree->trie;
../inputs/grep1.dat:	      if (trie->accepting)
../inputs/grep1.dat:		{
../inputs/grep1.dat:		  mch = beg;
../inputs/grep1.dat:		  accept = trie;
../inputs/grep1.dat:		}
../inputs/grep1.dat:	    }
../inputs/grep1.dat:	  else
../inputs/grep1.dat:	    break;
../inputs/grep1.dat:	  d = trie->shift;
../inputs/grep1.dat:	}
../inputs/grep1.dat:      if (mch)
../inputs/grep1.dat:	goto match;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  return 0;
../inputs/grep1.dat:
../inputs/grep1.dat: match:
../inputs/grep1.dat:  /* Given a known match, find the longest possible match anchored
../inputs/grep1.dat:     at or before its starting point.  This is nearly a verbatim
../inputs/grep1.dat:     copy of the preceding main search loops. */
../inputs/grep1.dat:  if (lim - mch > kwset->maxd)
../inputs/grep1.dat:    lim = mch + kwset->maxd;
../inputs/grep1.dat:  lmch = 0;
../inputs/grep1.dat:  d = 1;
../inputs/grep1.dat:  while (lim - end >= d)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      if ((d = delta[c = (end += d)[-1]]) != 0)
../inputs/grep1.dat:	continue;
../inputs/grep1.dat:      beg = end - 1;
../inputs/grep1.dat:      if (!(trie = next[c]))
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  d = 1;
../inputs/grep1.dat:	  continue;
../inputs/grep1.dat:	}
../inputs/grep1.dat:      if (trie->accepting && beg <= mch)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  lmch = beg;
../inputs/grep1.dat:	  accept = trie;
../inputs/grep1.dat:	}
../inputs/grep1.dat:      d = trie->shift;
../inputs/grep1.dat:      while (beg > text)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  c = trans ? trans[(unsigned char) *--beg] : *--beg;
../inputs/grep1.dat:	  tree = trie->links;
../inputs/grep1.dat:	  while (tree && c != tree->label)
../inputs/grep1.dat:	    if (c < tree->label)
../inputs/grep1.dat:	      tree = tree->llink;
../inputs/grep1.dat:	    else
../inputs/grep1.dat:	      tree = tree->rlink;
../inputs/grep1.dat:	  if (tree)
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      trie = tree->trie;
../inputs/grep1.dat:	      if (trie->accepting && beg <= mch)
../inputs/grep1.dat:		{
../inputs/grep1.dat:		  lmch = beg;
../inputs/grep1.dat:		  accept = trie;
../inputs/grep1.dat:		}
../inputs/grep1.dat:	    }
../inputs/grep1.dat:	  else
../inputs/grep1.dat:	    break;
../inputs/grep1.dat:	  d = trie->shift;
../inputs/grep1.dat:	}
../inputs/grep1.dat:      if (lmch)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  mch = lmch;
../inputs/grep1.dat:	  goto match;
../inputs/grep1.dat:	}
../inputs/grep1.dat:      if (!d)
../inputs/grep1.dat:	d = 1;
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  if (kwsmatch)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      kwsmatch->index = accept->accepting / 2;
../inputs/grep1.dat:      kwsmatch->beg[0] = mch;
../inputs/grep1.dat:      kwsmatch->size[0] = accept->depth;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  return mch;
../inputs/grep1.dat:}
../inputs/grep1.dat:  
../inputs/grep1.dat:/* Search through the given text for a match of any member of the
../inputs/grep1.dat:   given keyword set.  Return a pointer to the first character of
../inputs/grep1.dat:   the matching substring, or NULL if no match is found.  If FOUNDLEN
../inputs/grep1.dat:   is non-NULL store in the referenced location the length of the
../inputs/grep1.dat:   matching substring.  Similarly, if FOUNDIDX is non-NULL, store
../inputs/grep1.dat:   in the referenced location the index number of the particular
../inputs/grep1.dat:   keyword matched. */
../inputs/grep1.dat:char *
../inputs/grep1.dat:kwsexec(kws, text, size, kwsmatch)
../inputs/grep1.dat:     kwset_t kws;
../inputs/grep1.dat:     char *text;
../inputs/grep1.dat:     size_t size;
../inputs/grep1.dat:     struct kwsmatch *kwsmatch;
../inputs/grep1.dat:{
../inputs/grep1.dat:  struct kwset *kwset;
../inputs/grep1.dat:  char *ret;
../inputs/grep1.dat:
../inputs/grep1.dat:  kwset = (struct kwset *) kws;
../inputs/grep1.dat:  if (kwset->words == 1 && kwset->trans == 0)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      ret = bmexec(kws, text, size);
../inputs/grep1.dat:      if (kwsmatch != 0 && ret != 0)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  kwsmatch->index = 0;
../inputs/grep1.dat:	  kwsmatch->beg[0] = ret;
../inputs/grep1.dat:	  kwsmatch->size[0] = kwset->mind;
../inputs/grep1.dat:	}
../inputs/grep1.dat:      return ret;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  else
../inputs/grep1.dat:    return cwexec(kws, text, size, kwsmatch);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Free the components of the given keyword set. */
../inputs/grep1.dat:void
../inputs/grep1.dat:kwsfree(kws)
../inputs/grep1.dat:     kwset_t kws;
../inputs/grep1.dat:{
../inputs/grep1.dat:  struct kwset *kwset;
../inputs/grep1.dat:
../inputs/grep1.dat:  kwset = (struct kwset *) kws;
../inputs/grep1.dat:  obstack_free(&kwset->obstack, 0);
../inputs/grep1.dat:  free(kws);
../inputs/grep1.dat:}
../inputs/grep1.dat:/* obstack.c - subroutines used implicitly by object stack macros
../inputs/grep1.dat:   Copyright (C) 1988, 1993 Free Software Foundation, Inc.
../inputs/grep1.dat:
../inputs/grep1.dat:This program is free software; you can redistribute it and/or modify it
../inputs/grep1.dat:under the terms of the GNU General Public License as published by the
../inputs/grep1.dat:Free Software Foundation; either version 2, or (at your option) any
../inputs/grep1.dat:later version.
../inputs/grep1.dat:
../inputs/grep1.dat:This program is distributed in the hope that it will be useful,
../inputs/grep1.dat:but WITHOUT ANY WARRANTY; without even the implied warranty of
../inputs/grep1.dat:MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
../inputs/grep1.dat:GNU General Public License for more details.
../inputs/grep1.dat:
../inputs/grep1.dat:You should have received a copy of the GNU General Public License
../inputs/grep1.dat:along with this program; if not, write to the Free Software
../inputs/grep1.dat:Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* This is just to get __GNU_LIBRARY__ defined.  */
../inputs/grep1.dat:
../inputs/grep1.dat:/* Comment out all this code if we are using the GNU C Library, and are not
../inputs/grep1.dat:   actually compiling the library itself.  This code is part of the GNU C
../inputs/grep1.dat:   and linking in this code is a waste when using the GNU C library
../inputs/grep1.dat:   (especially if it is a shared library).  Rather than having every GNU
../inputs/grep1.dat:   program understand `configure --with-gnu-libc' and omit the object files,
../inputs/grep1.dat:   it is simpler to just do this in the source for each such file.  */
../inputs/grep1.dat:
../inputs/grep1.dat:#if defined (_LIBC) || !defined (__GNU_LIBRARY__)
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef __STDC__
../inputs/grep1.dat:#define POINTER void *
../inputs/grep1.dat:#else
../inputs/grep1.dat:#define POINTER char *
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:/* Determine default alignment.  */
../inputs/grep1.dat:struct fooalign {char x; double d;};
../inputs/grep1.dat:#define DEFAULT_ALIGNMENT  \
../inputs/grep1.dat:  ((PTR_INT_TYPE) ((char *)&((struct fooalign *) 0)->d - (char *)0))
../inputs/grep1.dat:/* If malloc were really smart, it would round addresses to DEFAULT_ALIGNMENT.
../inputs/grep1.dat:   But in fact it might be less smart and round addresses to as much as
../inputs/grep1.dat:   DEFAULT_ROUNDING.  So we prepare for it to do that.  */
../inputs/grep1.dat:union fooround {long x; double d;};
../inputs/grep1.dat:#define DEFAULT_ROUNDING (sizeof (union fooround))
../inputs/grep1.dat:
../inputs/grep1.dat:/* When we copy a long block of data, this is the unit to do it with.
../inputs/grep1.dat:   On some machines, copying successive ints does not work;
../inputs/grep1.dat:   in such a case, redefine COPYING_UNIT to `long' (if that works)
../inputs/grep1.dat:   or `char' as a last resort.  */
../inputs/grep1.dat:#ifndef COPYING_UNIT
../inputs/grep1.dat:#define COPYING_UNIT int
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:/* The non-GNU-C macros copy the obstack into this global variable
../inputs/grep1.dat:   to avoid multiple evaluation.  */
../inputs/grep1.dat:
../inputs/grep1.dat:struct obstack *_obstack;
../inputs/grep1.dat:
../inputs/grep1.dat:/* Define a macro that either calls functions with the traditional malloc/free
../inputs/grep1.dat:   calling interface, or calls functions with the mmalloc/mfree interface
../inputs/grep1.dat:   (that adds an extra first argument), based on the state of use_extra_arg.
../inputs/grep1.dat:   For free, do not use ?:, since some compilers, like the MIPS compilers,
../inputs/grep1.dat:   do not allow (expr) ? void : void.  */
../inputs/grep1.dat:
../inputs/grep1.dat:#define CALL_CHUNKFUN(h, size) \
../inputs/grep1.dat:  (((h) -> use_extra_arg) \
../inputs/grep1.dat:   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
../inputs/grep1.dat:   : (*(h)->chunkfun) ((size)))
../inputs/grep1.dat:
../inputs/grep1.dat:#define CALL_FREEFUN(h, old_chunk) \
../inputs/grep1.dat:  do { \
../inputs/grep1.dat:    if ((h) -> use_extra_arg) \
../inputs/grep1.dat:      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
../inputs/grep1.dat:    else \
../inputs/grep1.dat:      (*(h)->freefun) ((old_chunk)); \
../inputs/grep1.dat:  } while (0)
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:/* Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).
../inputs/grep1.dat:   Objects start on multiples of ALIGNMENT (0 means use default).
../inputs/grep1.dat:   CHUNKFUN is the function to use to allocate chunks,
../inputs/grep1.dat:   and FREEFUN the function to free them.  */
../inputs/grep1.dat:
../inputs/grep1.dat:void
../inputs/grep1.dat:_obstack_begin (h, size, alignment, chunkfun, freefun)
../inputs/grep1.dat:     struct obstack *h;
../inputs/grep1.dat:     int size;
../inputs/grep1.dat:     int alignment;
../inputs/grep1.dat:     POINTER (*chunkfun) ();
../inputs/grep1.dat:     void (*freefun) ();
../inputs/grep1.dat:{
../inputs/grep1.dat:  register struct _obstack_chunk* chunk; /* points to new chunk */
../inputs/grep1.dat:
../inputs/grep1.dat:  if (alignment == 0)
../inputs/grep1.dat:    alignment = DEFAULT_ALIGNMENT;
../inputs/grep1.dat:  if (size == 0)
../inputs/grep1.dat:    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
../inputs/grep1.dat:    {
../inputs/grep1.dat:      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
../inputs/grep1.dat:	 Use the values for range checking, because if range checking is off,
../inputs/grep1.dat:	 the extra bytes won't be missed terribly, but if range checking is on
../inputs/grep1.dat:	 and we used a larger request, a whole extra 4096 bytes would be
../inputs/grep1.dat:	 allocated.
../inputs/grep1.dat:
../inputs/grep1.dat:	 These number are irrelevant to the new GNU malloc.  I suspect it is
../inputs/grep1.dat:	 less sensitive to the size of the request.  */
../inputs/grep1.dat:      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
../inputs/grep1.dat:		    + 4 + DEFAULT_ROUNDING - 1)
../inputs/grep1.dat:		   & ~(DEFAULT_ROUNDING - 1));
../inputs/grep1.dat:      size = 4096 - extra;
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
../inputs/grep1.dat:  h->freefun = freefun;
../inputs/grep1.dat:  h->chunk_size = size;
../inputs/grep1.dat:  h->alignment_mask = alignment - 1;
../inputs/grep1.dat:  h->use_extra_arg = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
../inputs/grep1.dat:  h->next_free = h->object_base = chunk->contents;
../inputs/grep1.dat:  h->chunk_limit = chunk->limit
../inputs/grep1.dat:    = (char *) chunk + h->chunk_size;
../inputs/grep1.dat:  chunk->prev = 0;
../inputs/grep1.dat:  /* The initial chunk now contains no empty object.  */
../inputs/grep1.dat:  h->maybe_empty_object = 0;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:void
../inputs/grep1.dat:_obstack_begin_1 (h, size, alignment, chunkfun, freefun, arg)
../inputs/grep1.dat:     struct obstack *h;
../inputs/grep1.dat:     int size;
../inputs/grep1.dat:     int alignment;
../inputs/grep1.dat:     POINTER (*chunkfun) ();
../inputs/grep1.dat:     void (*freefun) ();
../inputs/grep1.dat:     POINTER arg;
../inputs/grep1.dat:{
../inputs/grep1.dat:  register struct _obstack_chunk* chunk; /* points to new chunk */
../inputs/grep1.dat:
../inputs/grep1.dat:  if (alignment == 0)
../inputs/grep1.dat:    alignment = DEFAULT_ALIGNMENT;
../inputs/grep1.dat:  if (size == 0)
../inputs/grep1.dat:    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
../inputs/grep1.dat:    {
../inputs/grep1.dat:      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
../inputs/grep1.dat:	 Use the values for range checking, because if range checking is off,
../inputs/grep1.dat:	 the extra bytes won't be missed terribly, but if range checking is on
../inputs/grep1.dat:	 and we used a larger request, a whole extra 4096 bytes would be
../inputs/grep1.dat:	 allocated.
../inputs/grep1.dat:
../inputs/grep1.dat:	 These number are irrelevant to the new GNU malloc.  I suspect it is
../inputs/grep1.dat:	 less sensitive to the size of the request.  */
../inputs/grep1.dat:      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
../inputs/grep1.dat:		    + 4 + DEFAULT_ROUNDING - 1)
../inputs/grep1.dat:		   & ~(DEFAULT_ROUNDING - 1));
../inputs/grep1.dat:      size = 4096 - extra;
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
../inputs/grep1.dat:  h->freefun = freefun;
../inputs/grep1.dat:  h->chunk_size = size;
../inputs/grep1.dat:  h->alignment_mask = alignment - 1;
../inputs/grep1.dat:  h->extra_arg = arg;
../inputs/grep1.dat:  h->use_extra_arg = 1;
../inputs/grep1.dat:
../inputs/grep1.dat:  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
../inputs/grep1.dat:  h->next_free = h->object_base = chunk->contents;
../inputs/grep1.dat:  h->chunk_limit = chunk->limit
../inputs/grep1.dat:    = (char *) chunk + h->chunk_size;
../inputs/grep1.dat:  chunk->prev = 0;
../inputs/grep1.dat:  /* The initial chunk now contains no empty object.  */
../inputs/grep1.dat:  h->maybe_empty_object = 0;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Allocate a new current chunk for the obstack *H
../inputs/grep1.dat:   on the assumption that LENGTH bytes need to be added
../inputs/grep1.dat:   to the current object, or a new object of length LENGTH allocated.
../inputs/grep1.dat:   Copies any partial object from the end of the old chunk
../inputs/grep1.dat:   to the beginning of the new one.  */
../inputs/grep1.dat:
../inputs/grep1.dat:void
../inputs/grep1.dat:_obstack_newchunk (h, length)
../inputs/grep1.dat:     struct obstack *h;
../inputs/grep1.dat:     int length;
../inputs/grep1.dat:{
../inputs/grep1.dat:  register struct _obstack_chunk*	old_chunk = h->chunk;
../inputs/grep1.dat:  register struct _obstack_chunk*	new_chunk;
../inputs/grep1.dat:  register long	new_size;
../inputs/grep1.dat:  register int obj_size = h->next_free - h->object_base;
../inputs/grep1.dat:  register int i;
../inputs/grep1.dat:  int already;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Compute size for new chunk.  */
../inputs/grep1.dat:  new_size = (obj_size + length) + (obj_size >> 3) + 100;
../inputs/grep1.dat:  if (new_size < h->chunk_size)
../inputs/grep1.dat:    new_size = h->chunk_size;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Allocate and initialize the new chunk.  */
../inputs/grep1.dat:  new_chunk = h->chunk = CALL_CHUNKFUN (h, new_size);
../inputs/grep1.dat:  new_chunk->prev = old_chunk;
../inputs/grep1.dat:  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;
../inputs/grep1.dat:
../inputs/grep1.dat:  /* Move the existing object to the new chunk.
../inputs/grep1.dat:     Word at a time is fast and is safe if the object
../inputs/grep1.dat:     is sufficiently aligned.  */
../inputs/grep1.dat:  if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      for (i = obj_size / sizeof (COPYING_UNIT) - 1;
../inputs/grep1.dat:	   i >= 0; i--)
../inputs/grep1.dat:	((COPYING_UNIT *)new_chunk->contents)[i]
../inputs/grep1.dat:	  = ((COPYING_UNIT *)h->object_base)[i];
../inputs/grep1.dat:      /* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,
../inputs/grep1.dat:	 but that can cross a page boundary on a machine
../inputs/grep1.dat:	 which does not do strict alignment for COPYING_UNITS.  */
../inputs/grep1.dat:      already = obj_size / sizeof (COPYING_UNIT) * sizeof (COPYING_UNIT);
../inputs/grep1.dat:    }
../inputs/grep1.dat:  else
../inputs/grep1.dat:    already = 0;
../inputs/grep1.dat:  /* Copy remaining bytes one by one.  */
../inputs/grep1.dat:  for (i = already; i < obj_size; i++)
../inputs/grep1.dat:    new_chunk->contents[i] = h->object_base[i];
../inputs/grep1.dat:
../inputs/grep1.dat:  /* If the object just copied was the only data in OLD_CHUNK,
../inputs/grep1.dat:     free that chunk and remove it from the chain.
../inputs/grep1.dat:     But not if that chunk might contain an empty object.  */
../inputs/grep1.dat:  if (h->object_base == old_chunk->contents && ! h->maybe_empty_object)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      new_chunk->prev = old_chunk->prev;
../inputs/grep1.dat:      CALL_FREEFUN (h, old_chunk);
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  h->object_base = new_chunk->contents;
../inputs/grep1.dat:  h->next_free = h->object_base + obj_size;
../inputs/grep1.dat:  /* The new chunk certainly contains no empty object yet.  */
../inputs/grep1.dat:  h->maybe_empty_object = 0;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Return nonzero if object OBJ has been allocated from obstack H.
../inputs/grep1.dat:   This is here for debugging.
../inputs/grep1.dat:   If you use it in a program, you are probably losing.  */
../inputs/grep1.dat:
../inputs/grep1.dat:int
../inputs/grep1.dat:_obstack_allocated_p (h, obj)
../inputs/grep1.dat:     struct obstack *h;
../inputs/grep1.dat:     POINTER obj;
../inputs/grep1.dat:{
../inputs/grep1.dat:  register struct _obstack_chunk*  lp;	/* below addr of any objects in this chunk */
../inputs/grep1.dat:  register struct _obstack_chunk*  plp;	/* point to previous chunk if any */
../inputs/grep1.dat:
../inputs/grep1.dat:  lp = (h)->chunk;
../inputs/grep1.dat:  /* We use >= rather than > since the object cannot be exactly at
../inputs/grep1.dat:     the beginning of the chunk but might be an empty object exactly
../inputs/grep1.dat:     at the end of an adjacent chunk. */
../inputs/grep1.dat:  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
../inputs/grep1.dat:    {
../inputs/grep1.dat:      plp = lp->prev;
../inputs/grep1.dat:      lp = plp;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  return lp != 0;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* Free objects in obstack H, including OBJ and everything allocate
../inputs/grep1.dat:   more recently than OBJ.  If OBJ is zero, free everything in H.  */
../inputs/grep1.dat:
../inputs/grep1.dat:#undef obstack_free
../inputs/grep1.dat:
../inputs/grep1.dat:/* This function has two names with identical definitions.
../inputs/grep1.dat:   This is the first one, called from non-ANSI code.  */
../inputs/grep1.dat:
../inputs/grep1.dat:void
../inputs/grep1.dat:_obstack_free (h, obj)
../inputs/grep1.dat:     struct obstack *h;
../inputs/grep1.dat:     POINTER obj;
../inputs/grep1.dat:{
../inputs/grep1.dat:  register struct _obstack_chunk*  lp;	/* below addr of any objects in this chunk */
../inputs/grep1.dat:  register struct _obstack_chunk*  plp;	/* point to previous chunk if any */
../inputs/grep1.dat:
../inputs/grep1.dat:  lp = h->chunk;
../inputs/grep1.dat:  /* We use >= because there cannot be an object at the beginning of a chunk.
../inputs/grep1.dat:     But there can be an empty object at that address
../inputs/grep1.dat:     at the end of another chunk.  */
../inputs/grep1.dat:  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
../inputs/grep1.dat:    {
../inputs/grep1.dat:      plp = lp->prev;
../inputs/grep1.dat:      CALL_FREEFUN (h, lp);
../inputs/grep1.dat:      lp = plp;
../inputs/grep1.dat:      /* If we switch chunks, we can't tell whether the new current
../inputs/grep1.dat:	 chunk contains an empty object, so assume that it may.  */
../inputs/grep1.dat:      h->maybe_empty_object = 1;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  if (lp)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      h->object_base = h->next_free = (char *)(obj);
../inputs/grep1.dat:      h->chunk_limit = lp->limit;
../inputs/grep1.dat:      h->chunk = lp;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  else if (obj != 0)
../inputs/grep1.dat:    /* obj is not in any of the chunks! */
../inputs/grep1.dat:    abort ();
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:/* This function is used from ANSI code.  */
../inputs/grep1.dat:
../inputs/grep1.dat:void
../inputs/grep1.dat:obstack_free (h, obj)
../inputs/grep1.dat:     struct obstack *h;
../inputs/grep1.dat:     POINTER obj;
../inputs/grep1.dat:{
../inputs/grep1.dat:  register struct _obstack_chunk*  lp;	/* below addr of any objects in this chunk */
../inputs/grep1.dat:  register struct _obstack_chunk*  plp;	/* point to previous chunk if any */
../inputs/grep1.dat:
../inputs/grep1.dat:  lp = h->chunk;
../inputs/grep1.dat:  /* We use >= because there cannot be an object at the beginning of a chunk.
../inputs/grep1.dat:     But there can be an empty object at that address
../inputs/grep1.dat:     at the end of another chunk.  */
../inputs/grep1.dat:  while (lp != 0 && ((POINTER)lp >= obj || (POINTER)(lp)->limit < obj))
../inputs/grep1.dat:    {
../inputs/grep1.dat:      plp = lp->prev;
../inputs/grep1.dat:      CALL_FREEFUN (h, lp);
../inputs/grep1.dat:      lp = plp;
../inputs/grep1.dat:      /* If we switch chunks, we can't tell whether the new current
../inputs/grep1.dat:	 chunk contains an empty object, so assume that it may.  */
../inputs/grep1.dat:      h->maybe_empty_object = 1;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  if (lp)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      h->object_base = h->next_free = (char *)(obj);
../inputs/grep1.dat:      h->chunk_limit = lp->limit;
../inputs/grep1.dat:      h->chunk = lp;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  else if (obj != 0)
../inputs/grep1.dat:    /* obj is not in any of the chunks! */
../inputs/grep1.dat:    abort ();
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:#if 0
../inputs/grep1.dat:/* These are now turned off because the applications do not use it
../inputs/grep1.dat:   and it uses bcopy via obstack_grow, which causes trouble on sysV.  */
../inputs/grep1.dat:
../inputs/grep1.dat:/* Now define the functional versions of the obstack macros.
../inputs/grep1.dat:   Define them to simply use the corresponding macros to do the job.  */
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef __STDC__
../inputs/grep1.dat:/* These function definitions do not work with non-ANSI preprocessors;
../inputs/grep1.dat:   they won't pass through the macro names in parentheses.  */
../inputs/grep1.dat:
../inputs/grep1.dat:/* The function names appear in parentheses in order to prevent
../inputs/grep1.dat:   the macro-definitions of the names from being expanded there.  */
../inputs/grep1.dat:
../inputs/grep1.dat:POINTER (obstack_base) (obstack)
../inputs/grep1.dat:     struct obstack *obstack;
../inputs/grep1.dat:{
../inputs/grep1.dat:  return obstack_base (obstack);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:POINTER (obstack_next_free) (obstack)
../inputs/grep1.dat:     struct obstack *obstack;
../inputs/grep1.dat:{
../inputs/grep1.dat:  return obstack_next_free (obstack);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:int (obstack_object_size) (obstack)
../inputs/grep1.dat:     struct obstack *obstack;
../inputs/grep1.dat:{
../inputs/grep1.dat:  return obstack_object_size (obstack);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:int (obstack_room) (obstack)
../inputs/grep1.dat:     struct obstack *obstack;
../inputs/grep1.dat:{
../inputs/grep1.dat:  return obstack_room (obstack);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:void (obstack_grow) (obstack, pointer, length)
../inputs/grep1.dat:     struct obstack *obstack;
../inputs/grep1.dat:     POINTER pointer;
../inputs/grep1.dat:     int length;
../inputs/grep1.dat:{
../inputs/grep1.dat:  obstack_grow (obstack, pointer, length);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:void (obstack_grow0) (obstack, pointer, length)
../inputs/grep1.dat:     struct obstack *obstack;
../inputs/grep1.dat:     POINTER pointer;
../inputs/grep1.dat:     int length;
../inputs/grep1.dat:{
../inputs/grep1.dat:  obstack_grow0 (obstack, pointer, length);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:void (obstack_1grow) (obstack, character)
../inputs/grep1.dat:     struct obstack *obstack;
../inputs/grep1.dat:     int character;
../inputs/grep1.dat:{
../inputs/grep1.dat:  obstack_1grow (obstack, character);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:void (obstack_blank) (obstack, length)
../inputs/grep1.dat:     struct obstack *obstack;
../inputs/grep1.dat:     int length;
../inputs/grep1.dat:{
../inputs/grep1.dat:  obstack_blank (obstack, length);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:void (obstack_1grow_fast) (obstack, character)
../inputs/grep1.dat:     struct obstack *obstack;
../inputs/grep1.dat:     int character;
../inputs/grep1.dat:{
../inputs/grep1.dat:  obstack_1grow_fast (obstack, character);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:void (obstack_blank_fast) (obstack, length)
../inputs/grep1.dat:     struct obstack *obstack;
../inputs/grep1.dat:     int length;
../inputs/grep1.dat:{
../inputs/grep1.dat:  obstack_blank_fast (obstack, length);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:POINTER (obstack_finish) (obstack)
../inputs/grep1.dat:     struct obstack *obstack;
../inputs/grep1.dat:{
../inputs/grep1.dat:  return obstack_finish (obstack);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:POINTER (obstack_alloc) (obstack, length)
../inputs/grep1.dat:     struct obstack *obstack;
../inputs/grep1.dat:     int length;
../inputs/grep1.dat:{
../inputs/grep1.dat:  return obstack_alloc (obstack, length);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:POINTER (obstack_copy) (obstack, pointer, length)
../inputs/grep1.dat:     struct obstack *obstack;
../inputs/grep1.dat:     POINTER pointer;
../inputs/grep1.dat:     int length;
../inputs/grep1.dat:{
../inputs/grep1.dat:  return obstack_copy (obstack, pointer, length);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:POINTER (obstack_copy0) (obstack, pointer, length)
../inputs/grep1.dat:     struct obstack *obstack;
../inputs/grep1.dat:     POINTER pointer;
../inputs/grep1.dat:     int length;
../inputs/grep1.dat:{
../inputs/grep1.dat:  return obstack_copy0 (obstack, pointer, length);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:#endif /* __STDC__ */
../inputs/grep1.dat:
../inputs/grep1.dat:#endif /* 0 */
../inputs/grep1.dat:
../inputs/grep1.dat:#endif	/* _LIBC or not __GNU_LIBRARY__.  */
../inputs/grep1.dat:/* search.c - searching subroutines using dfa, kwset and regex for grep.
../inputs/grep1.dat:   Copyright (C) 1992 Free Software Foundation, Inc.
../inputs/grep1.dat:
../inputs/grep1.dat:   This program is free software; you can redistribute it and/or modify
../inputs/grep1.dat:   it under the terms of the GNU General Public License as published by
../inputs/grep1.dat:   the Free Software Foundation; either version 2, or (at your option)
../inputs/grep1.dat:   any later version.
../inputs/grep1.dat:
../inputs/grep1.dat:   This program is distributed in the hope that it will be useful,
../inputs/grep1.dat:   but WITHOUT ANY WARRANTY; without even the implied warranty of
../inputs/grep1.dat:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
../inputs/grep1.dat:   GNU General Public License for more details.
../inputs/grep1.dat:
../inputs/grep1.dat:   You should have received a copy of the GNU General Public License
../inputs/grep1.dat:   along with this program; if not, write to the Free Software
../inputs/grep1.dat:   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
../inputs/grep1.dat:
../inputs/grep1.dat:   Written August 1992 by Mike Haertel. */
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef STDC_HEADERS
../inputs/grep1.dat:#if flag_limits==0
../inputs/grep1.dat:#undef RE_DUP_MAX
../inputs/grep1.dat:#define flag_limits 1
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#if flag_stdlib==0
../inputs/grep1.dat:#define flag_stdlib 1
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#else
../inputs/grep1.dat:#define UCHAR_MAX 255
../inputs/grep1.dat:#if flag_systypes==0
../inputs/grep1.dat:#define flag_systypes 1
../inputs/grep1.dat:#endif
../inputs/grep1.dat:extern char *malloc();
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef HAVE_MEMCHR
../inputs/grep1.dat:#if flag_string==0
../inputs/grep1.dat:#define flag_string 1
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#ifdef NEED_MEMORY_H
../inputs/grep1.dat:#if flag_memory==0
../inputs/grep1.dat:#define flag_memory 1
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#else
../inputs/grep1.dat:#ifdef __STDC__
../inputs/grep1.dat:extern void *memchr();
../inputs/grep1.dat:#else
../inputs/grep1.dat:extern char *memchr();
../inputs/grep1.dat:#endif
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:#if defined(HAVE_STRING_H) || defined(STDC_HEADERS)
../inputs/grep1.dat:#undef bcopy
../inputs/grep1.dat:#define bcopy(s, d, n) memcpy((d), (s), (n))
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:#ifdef isascii
../inputs/grep1.dat:#define ISALNUM(C) (isascii(C) && isalnum(C))
../inputs/grep1.dat:#define ISUPPER(C) (isascii(C) && isupper(C))
../inputs/grep1.dat:#else
../inputs/grep1.dat:#define ISALNUM(C) isalnum(C)
../inputs/grep1.dat:#define ISUPPER(C) isupper(C)
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:#define TOLOWER(C) (ISUPPER(C) ? tolower(C) : (C))
../inputs/grep1.dat:
../inputs/grep1.dat:
../inputs/grep1.dat:#define NCHAR (UCHAR_MAX + 1)
../inputs/grep1.dat:
../inputs/grep1.dat:#if __STDC__
../inputs/grep1.dat:static void Gcompile(char *, size_t);
../inputs/grep1.dat:static void Ecompile(char *, size_t);
../inputs/grep1.dat:static char *EGexecute(char *, size_t, char **);
../inputs/grep1.dat:static void Fcompile(char *, size_t);
../inputs/grep1.dat:static char *Fexecute(char *, size_t, char **);
../inputs/grep1.dat:#else
../inputs/grep1.dat:static void Gcompile();
../inputs/grep1.dat:static void Ecompile();
../inputs/grep1.dat:static char *EGexecute();
../inputs/grep1.dat:static void Fcompile();
../inputs/grep1.dat:static char *Fexecute();
../inputs/grep1.dat:#endif
../inputs/grep1.dat:
../inputs/grep1.dat:/* Here is the matchers vector for the main program. */
../inputs/grep1.dat:struct matcher matchers[] = {
../inputs/grep1.dat:  { "default", Gcompile, EGexecute },
../inputs/grep1.dat:  { "grep", Gcompile, EGexecute },
../inputs/grep1.dat:  { "ggrep", Gcompile, EGexecute },
../inputs/grep1.dat:  { "egrep", Ecompile, EGexecute },
../inputs/grep1.dat:  { "posix-egrep", Ecompile, EGexecute },
../inputs/grep1.dat:  { "gegrep", Ecompile, EGexecute },
../inputs/grep1.dat:  { "fgrep", Fcompile, Fexecute },
../inputs/grep1.dat:  { "gfgrep", Fcompile, Fexecute },
../inputs/grep1.dat:  { 0, 0, 0 },
../inputs/grep1.dat:};
../inputs/grep1.dat:
../inputs/grep1.dat:/* For -w, we also consider _ to be word constituent.  */
../inputs/grep1.dat:#define WCHAR(C) (ISALNUM(C) || (C) == '_')
../inputs/grep1.dat:
../inputs/grep1.dat:/* DFA compiled regexp. */
../inputs/grep1.dat:static struct dfa dfa_1;
../inputs/grep1.dat:
../inputs/grep1.dat:/* Regex compiled regexp. */
../inputs/grep1.dat:static struct re_pattern_buffer regex;
../inputs/grep1.dat:
../inputs/grep1.dat:/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
../inputs/grep1.dat:   a list of strings, at least one of which is known to occur in
../inputs/grep1.dat:   any string matching the regexp. */
../inputs/grep1.dat:static kwset_t kwset;
../inputs/grep1.dat:
../inputs/grep1.dat:/* Last compiled fixed string known to exactly match the regexp.
../inputs/grep1.dat:   If kwsexec() returns < lastexact, then we don't need to
../inputs/grep1.dat:   call the regexp matcher at all. */
../inputs/grep1.dat:static int lastexact;
../inputs/grep1.dat:
../inputs/grep1.dat:void
../inputs/grep1.dat:dfaerror(mesg)
../inputs/grep1.dat:     char *mesg;
../inputs/grep1.dat:{
../inputs/grep1.dat:  fatal(mesg, 0);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:kwsinit()
../inputs/grep1.dat:{
../inputs/grep1.dat:  static char trans[NCHAR];
../inputs/grep1.dat:  int i;
../inputs/grep1.dat:
../inputs/grep1.dat:  if (match_icase)
../inputs/grep1.dat:    for (i = 0; i < NCHAR; ++i)
../inputs/grep1.dat:      trans[i] = TOLOWER(i);
../inputs/grep1.dat:
../inputs/grep1.dat:  if (!(kwset = kwsalloc(match_icase ? trans : (char *) 0)))
../inputs/grep1.dat:    fatal("memory exhausted", 0);
../inputs/grep1.dat:}  
../inputs/grep1.dat:
../inputs/grep1.dat:/* If the DFA turns out to have some set of fixed strings one of
../inputs/grep1.dat:   which must occur in the match, then we build a kwset matcher
../inputs/grep1.dat:   to find those strings, and thus quickly filter out impossible
../inputs/grep1.dat:   matches. */
../inputs/grep1.dat:static void
../inputs/grep1.dat:kwsmusts()
../inputs/grep1.dat:{
../inputs/grep1.dat:  struct dfamust *dm;
../inputs/grep1.dat:  char *err;
../inputs/grep1.dat:
../inputs/grep1.dat:  if (dfa_1.musts)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      kwsinit();
../inputs/grep1.dat:      /* First, we compile in the substrings known to be exact
../inputs/grep1.dat:	 matches.  The kwset matcher will return the index
../inputs/grep1.dat:	 of the matching string that it chooses. */
../inputs/grep1.dat:      for (dm = dfa_1.musts; dm; dm = dm->next)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  if (!dm->exact)
../inputs/grep1.dat:	    continue;
../inputs/grep1.dat:	  ++lastexact;
../inputs/grep1.dat:	  if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0)
../inputs/grep1.dat:	    fatal(err, 0);
../inputs/grep1.dat:	}
../inputs/grep1.dat:      /* Now, we compile the substrings that will require
../inputs/grep1.dat:	 the use of the regexp matcher.  */
../inputs/grep1.dat:      for (dm = dfa_1.musts; dm; dm = dm->next)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  if (dm->exact)
../inputs/grep1.dat:	    continue;
../inputs/grep1.dat:	  if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0)
../inputs/grep1.dat:	    fatal(err, 0);
../inputs/grep1.dat:	}
../inputs/grep1.dat:      if ((err = kwsprep(kwset)) != 0)
../inputs/grep1.dat:	fatal(err, 0);
../inputs/grep1.dat:    }
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:Gcompile(pattern, size)
../inputs/grep1.dat:     char *pattern;
../inputs/grep1.dat:     size_t size;
../inputs/grep1.dat:{
../inputs/grep1.dat:#ifdef __STDC__
../inputs/grep1.dat:  const
../inputs/grep1.dat:#endif
../inputs/grep1.dat:  char *err;
../inputs/grep1.dat:
../inputs/grep1.dat:  re_set_syntax(RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
../inputs/grep1.dat:  dfasyntax(RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE, match_icase);
../inputs/grep1.dat:
../inputs/grep1.dat:  if ((err = re_compile_pattern(pattern, size, &regex)) != 0)
../inputs/grep1.dat:    fatal(err, 0);
../inputs/grep1.dat:
../inputs/grep1.dat:  dfainit(&dfa_1);
../inputs/grep1.dat:
../inputs/grep1.dat:  /* In the match_words and match_lines cases, we use a different pattern
../inputs/grep1.dat:     for the DFA matcher that will quickly throw out cases that won't work.
../inputs/grep1.dat:     Then if DFA succeeds we do some hairy stuff using the regex matcher
../inputs/grep1.dat:     to decide whether the match should really count. */
../inputs/grep1.dat:  if (match_words || match_lines)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      /* In the whole-word case, we use the pattern:
../inputs/grep1.dat:	 (^|[^A-Za-z_])(userpattern)([^A-Za-z_]|$).
../inputs/grep1.dat:	 In the whole-line case, we use the pattern:
../inputs/grep1.dat:	 ^(userpattern)$.
../inputs/grep1.dat:	 BUG: Using [A-Za-z_] is locale-dependent!  */
../inputs/grep1.dat:
../inputs/grep1.dat:      char *n = malloc(size + 50);
../inputs/grep1.dat:      int i = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:      strcpy(n, "");
../inputs/grep1.dat:
../inputs/grep1.dat:      if (match_lines)
../inputs/grep1.dat:	strcpy(n, "^\\(");
../inputs/grep1.dat:      if (match_words)
../inputs/grep1.dat:	strcpy(n, "\\(^\\|[^0-9A-Za-z_]\\)\\(");
../inputs/grep1.dat:
../inputs/grep1.dat:      i = strlen(n);
../inputs/grep1.dat:      bcopy(pattern, n + i, size);
../inputs/grep1.dat:      i += size;
../inputs/grep1.dat:
../inputs/grep1.dat:      if (match_words)
../inputs/grep1.dat:	strcpy(n + i, "\\)\\([^0-9A-Za-z_]\\|$\\)");
../inputs/grep1.dat:      if (match_lines)
../inputs/grep1.dat:	strcpy(n + i, "\\)$");
../inputs/grep1.dat:
../inputs/grep1.dat:      i += strlen(n + i);
../inputs/grep1.dat:      dfacomp(n, i, &dfa_1, 1);
../inputs/grep1.dat:    }
../inputs/grep1.dat:  else
../inputs/grep1.dat:    dfacomp(pattern, size, &dfa_1, 1);
../inputs/grep1.dat:
../inputs/grep1.dat:  kwsmusts();
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:Ecompile(pattern, size)
../inputs/grep1.dat:     char *pattern;
../inputs/grep1.dat:     size_t size;
../inputs/grep1.dat:{
../inputs/grep1.dat:#ifdef __STDC__
../inputs/grep1.dat:  const
../inputs/grep1.dat:#endif
../inputs/grep1.dat:  char *err;
../inputs/grep1.dat:
../inputs/grep1.dat:  if (strcmp(matcher, "posix-egrep") == 0)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      re_set_syntax(RE_SYNTAX_POSIX_EGREP);
../inputs/grep1.dat:      dfasyntax(RE_SYNTAX_POSIX_EGREP, match_icase);
../inputs/grep1.dat:    }
../inputs/grep1.dat:  else
../inputs/grep1.dat:    {
../inputs/grep1.dat:      re_set_syntax(RE_SYNTAX_EGREP);
../inputs/grep1.dat:      dfasyntax(RE_SYNTAX_EGREP, match_icase);
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  if ((err = re_compile_pattern(pattern, size, &regex)) != 0)
../inputs/grep1.dat:    fatal(err, 0);
../inputs/grep1.dat:
../inputs/grep1.dat:  dfainit(&dfa_1);
../inputs/grep1.dat:
../inputs/grep1.dat:  /* In the match_words and match_lines cases, we use a different pattern
../inputs/grep1.dat:     for the DFA matcher that will quickly throw out cases that won't work.
../inputs/grep1.dat:     Then if DFA succeeds we do some hairy stuff using the regex matcher
../inputs/grep1.dat:     to decide whether the match should really count. */
../inputs/grep1.dat:  if (match_words || match_lines)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      /* In the whole-word case, we use the pattern:
../inputs/grep1.dat:	 (^|[^A-Za-z_])(userpattern)([^A-Za-z_]|$).
../inputs/grep1.dat:	 In the whole-line case, we use the pattern:
../inputs/grep1.dat:	 ^(userpattern)$.
../inputs/grep1.dat:	 BUG: Using [A-Za-z_] is locale-dependent!  */
../inputs/grep1.dat:
../inputs/grep1.dat:      char *n = malloc(size + 50);
../inputs/grep1.dat:      int i = 0;
../inputs/grep1.dat:
../inputs/grep1.dat:      strcpy(n, "");
../inputs/grep1.dat:
../inputs/grep1.dat:      if (match_lines)
../inputs/grep1.dat:	strcpy(n, "^(");
../inputs/grep1.dat:      if (match_words)
../inputs/grep1.dat:	strcpy(n, "(^|[^0-9A-Za-z_])(");
../inputs/grep1.dat:
../inputs/grep1.dat:      i = strlen(n);
../inputs/grep1.dat:      bcopy(pattern, n + i, size);
../inputs/grep1.dat:      i += size;
../inputs/grep1.dat:
../inputs/grep1.dat:      if (match_words)
../inputs/grep1.dat:	strcpy(n + i, ")([^0-9A-Za-z_]|$)");
../inputs/grep1.dat:      if (match_lines)
../inputs/grep1.dat:	strcpy(n + i, ")$");
../inputs/grep1.dat:
../inputs/grep1.dat:      i += strlen(n + i);
../inputs/grep1.dat:      dfacomp(n, i, &dfa_1, 1);
../inputs/grep1.dat:    }
../inputs/grep1.dat:  else
../inputs/grep1.dat:    dfacomp(pattern, size, &dfa_1, 1);
../inputs/grep1.dat:
../inputs/grep1.dat:  kwsmusts();
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static char *
../inputs/grep1.dat:EGexecute(buf, size, endp)
../inputs/grep1.dat:     char *buf;
../inputs/grep1.dat:     size_t size;
../inputs/grep1.dat:     char **endp;
../inputs/grep1.dat:{
../inputs/grep1.dat:  register char *buflim, *beg, *end, save;
../inputs/grep1.dat:  int backref, start, len;
../inputs/grep1.dat:  struct kwsmatch kwsm;
../inputs/grep1.dat:  static struct re_registers regs; /* This is static on account of a BRAIN-DEAD
../inputs/grep1.dat:				    Q@#%!# library interface in regex.c.  */
../inputs/grep1.dat:
../inputs/grep1.dat:  buflim = buf + size;
../inputs/grep1.dat:
../inputs/grep1.dat:  for (beg = end = buf; end < buflim; beg = end + 1)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      if (kwset)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  /* Find a possible match using the KWset matcher. */
../inputs/grep1.dat:	  beg = kwsexec(kwset, beg, buflim - beg, &kwsm);
../inputs/grep1.dat:	  if (!beg)
../inputs/grep1.dat:	    goto failure;
../inputs/grep1.dat:	  /* Narrow down to the line containing the candidate, and
../inputs/grep1.dat:	     run it through DFA. */
../inputs/grep1.dat:	  end = memchr(beg, '\n', buflim - beg);
../inputs/grep1.dat:	  if (!end)
../inputs/grep1.dat:	    end = buflim;
../inputs/grep1.dat:	  while (beg > buf && beg[-1] != '\n')
../inputs/grep1.dat:	    --beg;
../inputs/grep1.dat:	  save = *end;
../inputs/grep1.dat:	  if (kwsm.index < lastexact)
../inputs/grep1.dat:	    goto success;
../inputs/grep1.dat:	  if (!dfaexec(&dfa_1, beg, end, 0, (int *) 0, &backref))
../inputs/grep1.dat:	    {
../inputs/grep1.dat:	      *end = save;
../inputs/grep1.dat:	      continue;
../inputs/grep1.dat:	    }
../inputs/grep1.dat:	  *end = save;
../inputs/grep1.dat:	  /* Successful, no backreferences encountered. */
../inputs/grep1.dat:	  if (!backref)
../inputs/grep1.dat:	    goto success;
../inputs/grep1.dat:	}
../inputs/grep1.dat:      else
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  /* No good fixed strings; start with DFA. */
../inputs/grep1.dat:	  save = *buflim;
../inputs/grep1.dat:	  beg = dfaexec(&dfa_1, beg, buflim, 0, (int *) 0, &backref);
../inputs/grep1.dat:	  *buflim = save;
../inputs/grep1.dat:	  if (!beg)
../inputs/grep1.dat:	    goto failure;
../inputs/grep1.dat:	  /* Narrow down to the line we've found. */
../inputs/grep1.dat:	  end = memchr(beg, '\n', buflim - beg);
../inputs/grep1.dat:	  if (!end)
../inputs/grep1.dat:	    end = buflim;
../inputs/grep1.dat:	  while (beg > buf && beg[-1] != '\n')
../inputs/grep1.dat:	    --beg;
../inputs/grep1.dat:	  /* Successful, no backreferences encountered! */
../inputs/grep1.dat:	  if (!backref)
../inputs/grep1.dat:	    goto success;
../inputs/grep1.dat:	}
../inputs/grep1.dat:      /* If we've made it to this point, this means DFA has seen
../inputs/grep1.dat:	 a probable match, and we need to run it through Regex. */
../inputs/grep1.dat:      regex.not_eol = 0;
../inputs/grep1.dat:      if ((start = re_search(&regex, beg, end - beg, 0, end - beg, &regs)) >= 0)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  len = regs.end[0] - start;
../inputs/grep1.dat:	  if (!match_lines && !match_words || match_lines && len == end - beg)
../inputs/grep1.dat:	    goto success;
../inputs/grep1.dat:	  /* If -w, check if the match aligns with word boundaries.
../inputs/grep1.dat:	     We do this iteratively because:
../inputs/grep1.dat:	     (a) the line may contain more than one occurence of the pattern, and
../inputs/grep1.dat:	     (b) Several alternatives in the pattern might be valid at a given
../inputs/grep1.dat:	     point, and we may need to consider a shorter one to find a word
../inputs/grep1.dat:	     boundary. */
../inputs/grep1.dat:	  if (match_words)
../inputs/grep1.dat:	    while (start >= 0)
../inputs/grep1.dat:	      {
../inputs/grep1.dat:		if ((start == 0 || !WCHAR(beg[start - 1]))
../inputs/grep1.dat:		    && (len == end - beg || !WCHAR(beg[start + len])))
../inputs/grep1.dat:		  goto success;
../inputs/grep1.dat:		if (len > 0)
../inputs/grep1.dat:		  {
../inputs/grep1.dat:		    /* Try a shorter length anchored at the same place. */
../inputs/grep1.dat:		    --len;
../inputs/grep1.dat:		    regex.not_eol = 1;
../inputs/grep1.dat:		    len = re_match(&regex, beg, start + len, start, &regs);
../inputs/grep1.dat:		  }
../inputs/grep1.dat:		if (len <= 0)
../inputs/grep1.dat:		  {
../inputs/grep1.dat:		    /* Try looking further on. */
../inputs/grep1.dat:		    if (start == end - beg)
../inputs/grep1.dat:		      break;
../inputs/grep1.dat:		    ++start;
../inputs/grep1.dat:		    regex.not_eol = 0;
../inputs/grep1.dat:		    start = re_search(&regex, beg, end - beg,
../inputs/grep1.dat:				      start, end - beg - start, &regs);
../inputs/grep1.dat:		    len = regs.end[0] - start;
../inputs/grep1.dat:		  }
../inputs/grep1.dat:	      }
../inputs/grep1.dat:	}
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat: failure:
../inputs/grep1.dat:  return 0;
../inputs/grep1.dat:
../inputs/grep1.dat: success:
../inputs/grep1.dat:  *endp = end < buflim ? end + 1 : end;
../inputs/grep1.dat:  return beg;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static void
../inputs/grep1.dat:Fcompile(pattern, size)
../inputs/grep1.dat:     char *pattern;
../inputs/grep1.dat:     size_t size;
../inputs/grep1.dat:{
../inputs/grep1.dat:  char *beg, *lim, *err;
../inputs/grep1.dat:
../inputs/grep1.dat:  kwsinit();
../inputs/grep1.dat:  beg = pattern;
../inputs/grep1.dat:  do
../inputs/grep1.dat:    {
../inputs/grep1.dat:      for (lim = beg; lim < pattern + size && *lim != '\n'; ++lim)
../inputs/grep1.dat:	;
../inputs/grep1.dat:      if ((err = kwsincr(kwset, beg, lim - beg)) != 0)
../inputs/grep1.dat:	fatal(err, 0);
../inputs/grep1.dat:      if (lim < pattern + size)
../inputs/grep1.dat:	++lim;
../inputs/grep1.dat:      beg = lim;
../inputs/grep1.dat:    }
../inputs/grep1.dat:  while (beg < pattern + size);
../inputs/grep1.dat:
../inputs/grep1.dat:  if ((err = kwsprep(kwset)) != 0)
../inputs/grep1.dat:    fatal(err, 0);
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:static char *
../inputs/grep1.dat:Fexecute(buf, size, endp)
../inputs/grep1.dat:     char *buf;
../inputs/grep1.dat:     size_t size;
../inputs/grep1.dat:     char **endp;
../inputs/grep1.dat:{
../inputs/grep1.dat:  register char *beg, *try, *end;
../inputs/grep1.dat:  register size_t len;
../inputs/grep1.dat:  struct kwsmatch kwsmatch;
../inputs/grep1.dat:
../inputs/grep1.dat:  for (beg = buf; beg <= buf + size; ++beg)
../inputs/grep1.dat:    {
../inputs/grep1.dat:      if (!(beg = kwsexec(kwset, beg, buf + size - beg, &kwsmatch)))
../inputs/grep1.dat:	return 0;
../inputs/grep1.dat:      len = kwsmatch.size[0];
../inputs/grep1.dat:      if (match_lines)
../inputs/grep1.dat:	{
../inputs/grep1.dat:	  if (beg > buf && beg[-1] != '\n')
../inputs/grep1.dat:	    continue;
../inputs/grep1.dat:	  if (beg + len < buf + size && beg[len] != '\n')
../inputs/grep1.dat:	    continue;
../inputs/grep1.dat:	  goto success;
../inputs/grep1.dat:	}
../inputs/grep1.dat:      else if (match_words)
../inputs/grep1.dat:	for (try = beg; len && try;)
../inputs/grep1.dat:	  {
../inputs/grep1.dat:	    if (try > buf && WCHAR((unsigned char) try[-1]))
../inputs/grep1.dat:	      break;
../inputs/grep1.dat:	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
../inputs/grep1.dat:	      {
../inputs/grep1.dat:		try = kwsexec(kwset, beg, --len, &kwsmatch);
../inputs/grep1.dat:		len = kwsmatch.size[0];
../inputs/grep1.dat:	      }
../inputs/grep1.dat:	    else
../inputs/grep1.dat:	      goto success;
../inputs/grep1.dat:	  }
../inputs/grep1.dat:      else
../inputs/grep1.dat:	goto success;
../inputs/grep1.dat:    }
../inputs/grep1.dat:
../inputs/grep1.dat:  return 0;
../inputs/grep1.dat:
../inputs/grep1.dat: success:
../inputs/grep1.dat:  if ((end = memchr(beg + len, '\n', (buf + size) - (beg + len))) != 0)
../inputs/grep1.dat:    ++end;
../inputs/grep1.dat:  else
../inputs/grep1.dat:    end = buf + size;
../inputs/grep1.dat:  *endp = end;
../inputs/grep1.dat:  while (beg > buf && beg[-1] != '\n')
../inputs/grep1.dat:    --beg;
../inputs/grep1.dat:  return beg;
../inputs/grep1.dat:}
../inputs/grep1.dat:
../inputs/grep1.dat:if (out)
../inputs/grep1.dat:if (gout)
../inputs/grep1.dat:if (gsth)
../inputs/grep1.dat:if out
../inputs/grep1.dat:if gout
../inputs/grep1.dat:if agout
../inputs/grep1.dat:if agout end = buf + size;
../inputs/grep1.dat:if aout
../inputs/grep1.dat:if ag
../inputs/grep1.dat:if g
../inputs/grep1.dat:if a
../inputs/grep1.dat:
../inputs/grep1.dat:swswsif (out)
../inputs/grep1.dat:wwif (gout)
../inputs/grep1.dat:wssif (gsth)
../inputs/grep1.dat:wswswsif out
../inputs/grep1.dat:3if gout
../inputs/grep1.dat:wsif agout
../inputs/grep1.dat:3eif agout end = buf + size;
../inputs/grep1.dat:dseif aout
../inputs/grep1.dat:dsif ag
../inputs/grep1.dat:isxsif g
../inputs/grep1.dat:xxsxif awwsw
../inputs/grep1.dat:
../inputs/grep1.dat:swswsif (out)fvvfvf
../inputs/grep1.dat:wwif (gout)
../inputs/grep1.dat:wssif (gsth)
../inputs/grep1.dat:wswswsif outvfvf
../inputs/grep1.dat:3if goutfvf
../inputs/grep1.dat:wsif agoutvfv
../inputs/grep1.dat:3eif agoutvf end = buf + size;
../inputs/grep1.dat:dseif aoutvfv
../inputs/grep1.dat:dsif agvff
../inputs/grep1.dat:isxsif gvfv
../inputs/grep1.dat:xxsxif awwsw
../inputs/grep1.dat:
../inputs/grep1.dat:s  if (out)
../inputs/grep1.dat:    if (gout)
../inputs/grep1.dat: sds if (gsth)
../inputs/grep1.dat:  if out
../inputs/grep1.dat:dc if gout
../inputs/grep1.dat:dv if agout
../inputs/grep1.dat:argue if agout end = buf + size;
../inputs/grep1.dat:  if aout
../inputs/grep1.dat:          if ag
../inputs/grep1.dat:  argue if g
../inputs/grep1.dat: if a