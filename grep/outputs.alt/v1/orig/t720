   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#define STDC_HEADERS 1
#define HAVE_STRING_H 1
#define HAVE_SYS_PARAM_H 1
#define HAVE_UNISTD_H 1
#define HAVE_ALLOCA_H 1
#define HAVE_GETPAGESIZE 1
#define HAVE_MEMCHR 1
#define HAVE_STRERROR 1
#define HAVE_VALLOC 1
#define HAVE_WORKING_MMAP 1
#ifdef STDC_HEADERS
#if defined(STDC_HEADERS) || defined(HAVE_STRING_H)
#ifdef HAVE_UNISTD_H
#undef MAX
#define MAX(A,B) ((A) > (B) ? (A) : (B))
/* Provide missing ANSI features if necessary. */
#ifndef HAVE_STRERROR
#ifndef HAVE_MEMCHR
#if !defined(HAVE_VALLOC)
static size_t bufsalloc;	/* Allocated size of buffer save region. */
#if defined(HAVE_WORKING_MMAP)
#ifndef BUFSALLOC
      bufsalloc = MAX(8192, getpagesize());
      bufsalloc = BUFSALLOC;
#if defined(HAVE_WORKING_MMAP)
#if defined(HAVE_WORKING_MMAP)
#if defined(HAVE_WORKING_MMAP)
      maddr = mmap(maddr, bufalloc - bufsalloc, PROT_READ | PROT_WRITE,
		   MAP_PRIVATE | MAP_FIXED, bufdesc, bufoffset);
      /* You might thing this (or MADV_WILLNEED) would help,
      madvise(maddr, bufalloc - bufsalloc, MADV_SEQUENTIAL);
      /* Avoid matching the empty line at the end of the buffer. */
#define USAGE \
  "usage: %s [-[[AB] ]<num>] [-[CEFGVchilnqsvwx]] [-[ef]] <expr> [<files...>]\n"
  fprintf(stderr, USAGE, prog);
  while ((opt = getopt(argc, argv, "0123456789A:B:CEFGVX:bce:f:hiLlnqsvwxy"))
      case 'A':
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
/* NOTE!!!  AIX requires this to be the first thing in the file.
   Do not put ANYTHING before it!  */
#if !defined (__GNUC__) && defined (_AIX)
#ifdef HAVE_CONFIG_H
#if defined (HAVE_ALLOCA_H) || (defined(sparc) && (defined(sun) || (!defined(USG) && !defined(SVR4) && !defined(__svr4__))))
#ifndef _AIX
/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.  */
#if defined (_LIBC) || !defined (__GNU_LIBRARY__)
   to get __GNU_LIBRARY__ defined.  */
#ifdef	__GNU_LIBRARY__
/* If GETOPT_COMPAT is defined, `+' as well as `--' can introduce a
/* #define GETOPT_COMPAT */
   As `getopt' works, it permutes the elements of ARGV so that,
   Also, when `ordering' is RETURN_IN_ORDER,
   each non-option ARGV-element is returned here.  */
/* Index in ARGV of the next element to be scanned.
   how much of ARGV has been scanned so far.  */
   by advancing to the next ARGV-element.  */
/* Describe how to deal with options that follow non-option ARGV-elements.
   PERMUTE is the default.  We permute the contents of ARGV as we scan,
   to expect options and other ARGV-elements in any order and that care about
   the ordering of the two.  We describe each non-option ARGV-element
   `--' can cause `getopt' to return EOF with `optind' != ARGC.  */
#ifdef	__GNU_LIBRARY__
/* Avoid depending on library functions or files
/* Describe the part of ARGV that contains non-options that have
   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
/* Exchange two adjacent subsequences of ARGV.
   the new indices of the non-options in ARGV after they are moved.  */
  /* Interchange the two blocks of data in ARGV.  */
/* Scan elements of ARGV (whose length is ARGC) for option characters
   If an element of ARGV starts with '-', and is not exactly "-" or "--",
   resume the scan with the following option character or ARGV-element.
   Then `optind' is the index in ARGV of the first ARGV-element
   that is not an option.  (The ARGV-elements have been permuted
   so the following text in the same ARGV-element, or the text of the following
   ARGV-element, is returned in `optarg'.  Two colons mean an option that
   wants an optional arg; if there is text in the current ARGV-element,
   handling the non-option ARGV-elements.
   argument, it follows the option name in the same ARGV-element, separated
   from the option name by a `=', or else the in next ARGV-element.
   The elements of ARGV aren't really const, because we permute them.
     Start processing options with ARGV-element 1 (since ARGV-element 0
     non-option ARGV-elements is empty.  */
#ifdef GETOPT_COMPAT
#endif				/* GETOPT_COMPAT */
      /* Special ARGV-element `--' means premature end of options.
      /* If we have done all the ARGV-elements, stop the scan
#ifdef GETOPT_COMPAT
#endif				/* GETOPT_COMPAT */
      /* We have found another option-ARGV-element.
#ifdef GETOPT_COMPAT
#endif				/* GETOPT_COMPAT */
#ifdef GETOPT_COMPAT
#endif				/* GETOPT_COMPAT */
		/* If we end this ARGV-element by taking the rest as an arg,
		 increment it again when taking next ARGV-elt as argument.  */
#endif	/* _LIBC or not __GNU_LIBRARY__.  */
      printf ("non-option ARGV-elements: ");
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
/* AIX requires this to be the first thing in the file. */
#if defined (_AIX) && !defined (REGEX_MALLOC)
#ifdef HAVE_CONFIG_H
#if HAVE_STRING_H || STDC_HEADERS
#ifdef STDC_HEADERS
#ifdef SYNTAX_TABLE
#else /* not SYNTAX_TABLE */
#define CHAR_SET_SIZE 256
static char re_syntax_table[CHAR_SET_SIZE];
   for (c = 'A'; c <= 'Z'; c++)
#endif /* not SYNTAX_TABLE */
#define SYNTAX(c) re_syntax_table[c]
   isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
   STDC_HEADERS is defined, then autoconf has verified that the ctype
#if ! defined (isascii) || defined (STDC_HEADERS)
#define ISBLANK(c) (isascii (c) && isblank (c))
#define ISBLANK(c) ((c) == ' ' || (c) == '\t')
#define ISGRAPH(c) (isascii (c) && isgraph (c))
#define ISGRAPH(c) (isascii (c) && isprint (c) && !isspace (c))
#define ISALNUM(c) (isascii (c) && isalnum (c))
#define ISALPHA(c) (isascii (c) && isalpha (c))
#define ISSPACE(c) (isascii (c) && isspace (c))
/* We remove any previous definition of `SIGN_EXTEND_CHAR',
#undef SIGN_EXTEND_CHAR
#define SIGN_EXTEND_CHAR(c) ((signed char) (c))
/* As in Harbison and Steele.  */
#define SIGN_EXTEND_CHAR(c) ((((unsigned char) (c)) ^ 128) - 128)
/* Should we use malloc or alloca?  If REGEX_MALLOC is not defined, we
#ifdef REGEX_MALLOC
#define REGEX_ALLOCATE malloc
#define REGEX_REALLOCATE(source, osize, nsize) realloc (source, nsize)
#else /* not REGEX_MALLOC  */
#if HAVE_ALLOCA_H
#else /* not __GNUC__ or HAVE_ALLOCA_H */
#ifndef _AIX /* Already did AIX, up at the top.  */
#endif /* not _AIX */
#endif /* not HAVE_ALLOCA_H */ 
#define REGEX_ALLOCATE alloca
/* Assumes a `char *destination' variable.  */
#define REGEX_REALLOCATE(source, osize, nsize)				\
#endif /* not REGEX_MALLOC */
/* (Re)Allocate N items of type T using malloc, or fail.  */
#define TALLOC(n, t) ((t *) malloc ((n) * sizeof (t)))
#define RETALLOC(addr, n, t) ((addr) = (t *) realloc (addr, (n) * sizeof (t)))
#define REGEX_TALLOC(n, t) ((t *) REGEX_ALLOCATE ((n) * sizeof (t)))
#undef MAX               /****** added later *******/
#define MAX(a, b) ((a) > (b) ? (a) : (b))
   expressions.  Some opcodes are followed by argument bytes.  A
   So regex.h defines a symbol `RE_EXACTN_VALUE' to be 1; the value of
           are ordered low-bit-first.  A character is in the set if its
           bit is 1.  A character too large to have a bit in the map is
        /* Analogously, for end of buffer/string.  */
           is made to use it for a failure.  A `+' construct makes this
           before the first repeat.  Also used as an intermediary kind
           After matching N times, jump to the address upon failure.  */
/* Store NUMBER in two contiguous bytes starting at DESTINATION.  */
/* Same as STORE_NUMBER, except increment DESTINATION to
   the byte after where the number is stored.  Therefore, DESTINATION
#define STORE_NUMBER_AND_INCR(destination, number)			\
/* Put into DESTINATION a number stored in two contiguous bytes starting
#define EXTRACT_NUMBER(destination, source)				\
    (destination) += SIGN_EXTEND_CHAR (*((source) + 1)) << 8;		\
  int temp = SIGN_EXTEND_CHAR (*(source + 1)); 
#ifndef EXTRACT_MACROS /* To debug the macros.  */
#undef EXTRACT_NUMBER
#define EXTRACT_NUMBER(dest, src) extract_number (&dest, src)
#endif /* not EXTRACT_MACROS */
/* Same as EXTRACT_NUMBER, except increment SOURCE to after the number.
#define EXTRACT_NUMBER_AND_INCR(destination, source)			\
    EXTRACT_NUMBER (destination, source);				\
#ifndef EXTRACT_MACROS
#undef EXTRACT_NUMBER_AND_INCR
#define EXTRACT_NUMBER_AND_INCR(dest, src) \
#endif /* not EXTRACT_MACROS */
   interactively.  And if linked with the main program in `main.c' and
#define DEBUG_STATEMENT(e) e
#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e) 				\
   the START pointer into it and ending just before the pointer END.  */
		  /* Are we starting a range?  */
#define DEBUG_STATEMENT(e)
#define DEBUG_PRINT_COMPILED_PATTERN(p, s, e)
reg_syntax_t re_syntax_options = RE_SYNTAX_EMACS;
   The argument SYNTAX is a bit mask comprised of the various bits
    "No match",					/* REG_NOMATCH */
    "Invalid regular expression",		/* REG_BADPAT */
    "Invalid collation character",		/* REG_ECOLLATE */
    "Trailing backslash",			/* REG_EESCAPE */
    "Unmatched [ or [^",			/* REG_EBRACK */
    "Unmatched ( or \\(",			/* REG_EPAREN */
    "Unmatched \\{",				/* REG_EBRACE */
    "Invalid content of \\{\\}",		/* REG_BADBR */
    "Invalid range end",			/* REG_ERANGE */
    "Memory exhausted",				/* REG_ESPACE */
    "Invalid preceding regular expression",	/* REG_BADRPT */
    "Unmatched ) or \\)",			/* REG_ERPAREN */
   if necessary.  Also cast from a signed character in the constant
#define PATFETCH(c)							\
#define PATFETCH_RAW(c)							\
#define PATUNFETCH p--
#define TRANSLATE(d) (translate ? translate[(unsigned char) (d)] : (d))
#define GET_BUFFER_SPACE(n)						\
    GET_BUFFER_SPACE (1);						\
    GET_BUFFER_SPACE (2);						\
/* As with BUF_PUSH_2, except for three bytes.  */
    GET_BUFFER_SPACE (3);						\
/* Like `STORE_JUMP', but for inserting.  Assume `b' is the buffer end.  */
/* Like `STORE_JUMP2', but for inserting.  Assume `b' is the buffer end.  */
#define MAX_BUF_SIZE (1L << 16)
   being larger than MAX_BUF_SIZE, then flag memory exhausted.  */
    if (bufp->allocated == MAX_BUF_SIZE) 				\
    if (bufp->allocated > MAX_BUF_SIZE)					\
      bufp->allocated = MAX_BUF_SIZE; 					\
      return REG_ESPACE;						\
#define MAX_REGNUM 255
/* But patterns can have more than `MAX_REGNUM' registers.  We just
   be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
#define INIT_COMPILE_STACK_SIZE 32
#define COMPILE_STACK_EMPTY  (compile_stack.avail == 0)
#define COMPILE_STACK_FULL  (compile_stack.avail == compile_stack.size)
#define COMPILE_STACK_TOP (compile_stack.stack[compile_stack.avail])
       PATFETCH (c); 							\
           PATFETCH (c);						\
#define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */
#define IS_CHAR_CLASS(string)						\
/* `regex_compile' compiles PATTERN (of length SIZE) according to SYNTAX.
   Assumes the `allocated' (and perhaps `buffer') and `translate'
     `syntax' is set to SYNTAX;
     `re_nsub' is the number of subexpressions in PATTERN;
  /* We fetch characters from PATTERN here.  Even though PATTERN is
  /* A random tempory spot in PATTERN.  */
  /* Address of the count-byte of the most recently inserted `exactn'
  /* Address of start of the most recently finished expression.
  /* Address of beginning of regexp, or inside of last group.  */
  /* Address of the place where a forward jump should go to the end of
  compile_stack.stack = TALLOC (INIT_COMPILE_STACK_SIZE, compile_stack_elt_t);
    return REG_ESPACE;
  compile_stack.size = INIT_COMPILE_STACK_SIZE;
  /* Always count groups, whether or not bufp->no_sub is set.  */
#if !defined (emacs) && !defined (SYNTAX_TABLE)
          RETALLOC (bufp->buffer, INIT_BUF_SIZE, unsigned char);
          bufp->buffer = TALLOC (INIT_BUF_SIZE, unsigned char);
      if (!bufp->buffer) return REG_ESPACE;
      PATFETCH (c);
                || syntax & RE_CONTEXT_INDEP_ANCHORS
                || syntax & RE_CONTEXT_INDEP_ANCHORS
              if (syntax & RE_CONTEXT_INVALID_OPS)
                return REG_BADRPT;
            /* Are we optimizing this jump?  */
                PATFETCH (c);
                    if (p == pend) return REG_EESCAPE;
                    PATFETCH (c1);
                        PATUNFETCH;
                        PATUNFETCH;
                    PATUNFETCH;
                /* Allocate the space for the jump.  */
                GET_BUFFER_SPACE (3);
                   because laststart was nonzero.  And we've already
                if (TRANSLATE (*(p - 2)) == TRANSLATE ('.')
                    && p < pend && TRANSLATE (*p) == TRANSLATE ('\n')
                  /* Anything else.  */
            GET_BUFFER_SPACE (3);
                /* At least one repetition is required, so insert a
                GET_BUFFER_SPACE (3);
            if (p == pend) return REG_EBRACK;
	    GET_BUFFER_SPACE (34);
                && (syntax & RE_HAT_LISTS_NOT_NEWLINE))
                if (p == pend) return REG_EBRACK;
                PATFETCH (c);
                if ((syntax & RE_BACKSLASH_ESCAPE_IN_LISTS) && c == '\\')
                    if (p == pend) return REG_EESCAPE;
                    PATFETCH (c1);
                  return REG_ERANGE;
                    PATFETCH (c1);
                else if (syntax & RE_CHAR_CLASSES && c == '[' && *p == ':')
                    char str[CHAR_CLASS_MAX_LENGTH + 1];
                    PATFETCH (c);
                    if (p == pend) return REG_EBRACK;
                        PATFETCH (c);
                            || c1 == CHAR_CLASS_MAX_LENGTH)
                        if (!IS_CHAR_CLASS (str)) return REG_ECTYPE;
                        PATFETCH (c);					
                        if (p == pend) return REG_EBRACK;
                            if (   (is_alnum  && ISALNUM (ch))
                                || (is_alpha  && ISALPHA (ch))
                                || (is_blank  && ISBLANK (ch))
                                || (is_graph  && ISGRAPH (ch))
                                || (is_space  && ISSPACE (ch))
                          PATUNFETCH;
          if (syntax & RE_NO_BK_PARENS)
          if (syntax & RE_NO_BK_PARENS)
          if (syntax & RE_NEWLINE_ALT)
          if (syntax & RE_NO_BK_VBAR)
           if (syntax & RE_INTERVALS && syntax & RE_NO_BK_BRACES)
          if (p == pend) return REG_EESCAPE;
          PATFETCH_RAW (c);
              if (syntax & RE_NO_BK_PARENS)
              if (COMPILE_STACK_FULL)
                  RETALLOC (compile_stack.stack, compile_stack.size << 1,
                  if (compile_stack.stack == NULL) return REG_ESPACE;
              COMPILE_STACK_TOP.begalt_offset = begalt - bufp->buffer;
              COMPILE_STACK_TOP.fixup_alt_jump 
              COMPILE_STACK_TOP.laststart_offset = b - bufp->buffer;
              COMPILE_STACK_TOP.regnum = regnum;
              if (regnum <= MAX_REGNUM)
                  COMPILE_STACK_TOP.inner_group_offset = b - bufp->buffer + 2;
	      /* If we've reached MAX_REGNUM groups, then this open
              if (syntax & RE_NO_BK_PARENS) goto normal_backslash;
              if (COMPILE_STACK_EMPTY)
                if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
                  return REG_ERPAREN;
              if (COMPILE_STACK_EMPTY)
                if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
                  return REG_ERPAREN;
                begalt = bufp->buffer + COMPILE_STACK_TOP.begalt_offset;
                  = COMPILE_STACK_TOP.fixup_alt_jump
                    ? bufp->buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1 
                laststart = bufp->buffer + COMPILE_STACK_TOP.laststart_offset;
                this_group_regnum = COMPILE_STACK_TOP.regnum;
		/* If we've reached MAX_REGNUM groups, then this open
                if (this_group_regnum <= MAX_REGNUM)
                      = bufp->buffer + COMPILE_STACK_TOP.inner_group_offset;
              if (syntax & RE_LIMITED_OPS || syntax & RE_NO_BK_VBAR)
              GET_BUFFER_SPACE (3);
                 which gets executed if it gets matched.  Adjust that
                 jump jumps to the correct final destination.  A picture:
              GET_BUFFER_SPACE (3);
              if (!(syntax & RE_INTERVALS)
                  || ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))
                /* At least (most) this many matches must be made.  */
                    if (syntax & RE_NO_BK_BRACES)
                      return REG_EBRACE;
                    if (upper_bound < 0) upper_bound = RE_DUP_MAX;
                if (lower_bound < 0 || upper_bound > RE_DUP_MAX
                    if (syntax & RE_NO_BK_BRACES)
                      return REG_BADBR;
                if (!(syntax & RE_NO_BK_BRACES)) 
                    if (c != '\\') return REG_EBRACE;
                    PATFETCH (c);
                    if (syntax & RE_NO_BK_BRACES)
                      return REG_BADBR;
                    if (syntax & RE_CONTEXT_INVALID_OPS)
                      return REG_BADRPT;
                     GET_BUFFER_SPACE (3);
                     GET_BUFFER_SPACE (nbytes);
               PATFETCH (c);	
               if (!(syntax & RE_NO_BK_BRACES))
              PATFETCH (c);
              PATFETCH (c);
              c = TRANSLATE (c);
	      || ((syntax & RE_INTERVALS)
                  && ((syntax & RE_NO_BK_BRACES)
  if (!COMPILE_STACK_EMPTY) 
    return REG_EPAREN;
/* Store OP at LOC followed by two-byte integer parameter ARG.  */
/* Like `store_op1', but" for 'two two-byte parameters ARG1 and ARG2.  */
   for OP followed by two-byte integer parameter ARG.  */
/* Like `insert_op1', but for two two-byte parameters ARG1 and ARG2.  */
/* P points to just after a ^ in PATTERN.  Return true if that ^ comes
       /* After a subexpression?  */
       (*prev == '(' && (syntax & RE_NO_BK_PARENS || prev_prev_backslash))
       /* After an alternative?  */
    || (*prev == '|' && (syntax & RE_NO_BK_VBAR || prev_prev_backslash));
       (syntax & RE_NO_BK_PARENS ? *next == ')'
    || (syntax & RE_NO_BK_VBAR ? *next == '|'
/* Returns true if REGNUM is in one of COMPILE_STACK's elements and 
    return REG_ERANGE;
    return syntax & RE_NO_EMPTY_RANGES ? REG_ERANGE : REG_NOERROR;
      SET_LIST_BIT (TRANSLATE (this_char));
   REGEX_ALLOCATE.  */
#ifndef INIT_FAILURE_ALLOC
#define INIT_FAILURE_ALLOC 5
   exactly that if always used MAX_FAILURE_SPACE each time we failed.
#define FAIL_STACK_EMPTY()     (fail_stack.avail == 0)
#define FAIL_STACK_PTR_EMPTY() (fail_stack_ptr->avail == 0)
#define FAIL_STACK_FULL()      (fail_stack.avail == fail_stack.size)
#define FAIL_STACK_TOP()       (fail_stack.stack[fail_stack.avail])
#define INIT_FAIL_STACK()						\
      REGEX_ALLOCATE (INIT_FAILURE_ALLOC * sizeof (fail_stack_elt_t));	\
    fail_stack.size = INIT_FAILURE_ALLOC;				\
/* Double the size of FAIL_STACK, up to approximately `re_max_failures' items.
   REGEX_REALLOCATE requires `destination' be declared.   */
#define DOUBLE_FAIL_STACK(fail_stack)					\
  ((fail_stack).size > re_max_failures * MAX_FAILURE_ITEMS		\
        REGEX_REALLOCATE ((fail_stack).stack, 				\
/* Push PATTERN_OP on FAIL_STACK. 
#define PUSH_PATTERN_OP(pattern_op, fail_stack)				\
  ((FAIL_STACK_FULL ()							\
    && !DOUBLE_FAIL_STACK (fail_stack))					\
   value.  Assumes the variable `fail_stack'.  Probably should only
   be called from within `PUSH_FAILURE_POINT'.  */
#define PUSH_FAILURE_ITEM(item)						\
/* The complement operation.  Assumes `fail_stack' is nonempty.  */
#define POP_FAILURE_ITEM() fail_stack.stack[--fail_stack.avail]
#define DEBUG_PUSH PUSH_FAILURE_ITEM
#define DEBUG_POP(item_addr) *(item_addr) = POP_FAILURE_ITEM ()
   num_regs be declared.  DOUBLE_FAIL_STACK requires `destination' be
   Does `return FAILURE_CODE' if runs out of memory.  */
#define PUSH_FAILURE_POINT(pattern_place, string_place, failure_code)	\
    DEBUG_STATEMENT (failure_id++);					\
    DEBUG_STATEMENT (nfailure_points_pushed++);				\
    DEBUG_PRINT2 ("\nPUSH_FAILURE_POINT #%u:\n", failure_id);		\
    DEBUG_PRINT2 ("  slots needed: %d\n", NUM_FAILURE_ITEMS);		\
    DEBUG_PRINT2 ("     available: %d\n", REMAINING_AVAIL_SLOTS);	\
    while (REMAINING_AVAIL_SLOTS < NUM_FAILURE_ITEMS)			\
        if (!DOUBLE_FAIL_STACK (fail_stack))			\
        DEBUG_PRINT2 ("  slots available: %d\n", REMAINING_AVAIL_SLOTS);\
        DEBUG_STATEMENT (num_regs_pushed++);				\
        PUSH_FAILURE_ITEM (regstart[this_reg]);				\
        PUSH_FAILURE_ITEM (regend[this_reg]);				\
                      REG_MATCH_NULL_STRING_P (reg_info[this_reg]));	\
        DEBUG_PRINT2 (" active=%d", IS_ACTIVE (reg_info[this_reg]));	\
                      MATCHED_SOMETHING (reg_info[this_reg]));		\
                      EVER_MATCHED_SOMETHING (reg_info[this_reg]));	\
        PUSH_FAILURE_ITEM (reg_info[this_reg].word);			\
    PUSH_FAILURE_ITEM (lowest_active_reg);				\
    PUSH_FAILURE_ITEM (highest_active_reg);				\
    DEBUG_PRINT_COMPILED_PATTERN (bufp, pattern_place, pend);		\
    PUSH_FAILURE_ITEM (pattern_place);					\
    PUSH_FAILURE_ITEM (string_place);					\
#define MAX_FAILURE_ITEMS ((num_regs - 1) * NUM_REG_ITEMS + NUM_NONREG_ITEMS)
#define NUM_FAILURE_ITEMS						\
#define REMAINING_AVAIL_SLOTS ((fail_stack).size - (fail_stack).avail)
/* Pops what PUSH_FAIL_STACK pushes.
     PAT -- the saved pattern position.
     REGSTART, REGEND -- arrays of string positions.
   Also assumes the variables `fail_stack' and (if debugging), `bufp',
#define POP_FAILURE_POINT(str, pat, low_reg, high_reg, regstart, regend, reg_info)\
  DEBUG_STATEMENT (fail_stack_elt_t failure_id;)			\
  assert (!FAIL_STACK_EMPTY ());					\
  DEBUG_PRINT1 ("POP_FAILURE_POINT:\n");				\
  string_temp = POP_FAILURE_ITEM ();					\
  pat = (unsigned char *) POP_FAILURE_ITEM ();				\
  DEBUG_PRINT_COMPILED_PATTERN (bufp, pat, pend);			\
  high_reg = (unsigned) POP_FAILURE_ITEM ();				\
  low_reg = (unsigned) POP_FAILURE_ITEM ();				\
      reg_info[this_reg].word = POP_FAILURE_ITEM ();			\
      regend[this_reg] = (const char *) POP_FAILURE_ITEM ();		\
      regstart[this_reg] = (const char *) POP_FAILURE_ITEM ();		\
  DEBUG_STATEMENT (nfailure_points_popped++);				\
} /* POP_FAILURE_POINT */
   BUFP.  A fastmap records which of the (1 << BYTEWIDTH) possible
#ifndef REGEX_MALLOC
  /* Assume that each path through the pattern can be null until
  INIT_FAIL_STACK ();
  bzero (fastmap, 1 << BYTEWIDTH);  /* Assume nothing's valid.  */
  while (p != pend || !FAIL_STACK_EMPTY ())
	    if (SYNTAX (j) == Sword)
	    if (SYNTAX (j) != Sword)
	    if (SYNTAX (j) == (enum syntaxcode) k)
	    if (SYNTAX (j) != (enum syntaxcode) k)
      /* All cases after this match the empty string.  These end with
          EXTRACT_NUMBER_AND_INCR (j, p);
          EXTRACT_NUMBER_AND_INCR (j, p);
          if (!FAIL_STACK_EMPTY () 
          EXTRACT_NUMBER_AND_INCR (j, p);
              if (!PUSH_PATTERN_OP (p + j, fail_stack))
              EXTRACT_NUMBER_AND_INCR (k, p);	/* Skip the n.  */
          EXTRACT_NUMBER_AND_INCR (k, p);
/* Set REGS to hold NUM_REGS registers, storing them in STARTS and
   ENDS.  Subsequent matches using PATTERN_BUFFER and REGS will use
   this memory for recording register information.  STARTS and ENDS
   PATTERN_BUFFER will allocate its own register data, without
      bufp->regs_allocated = REGS_REALLOCATE;
      bufp->regs_allocated = REGS_UNALLOCATED;
   STARTPOS, then at STARTPOS + 1, and so on.
   RANGE is how far to scan while trying to match.  RANGE = 0 means try
   only at STARTPOS; in general, the last start tried is STARTPOS +
   RANGE.
  /* Check for out-of-range STARTPOS.  */
  /* Fix up RANGE if it might eventually take us outside
	      if (!fastmap[(unsigned char) TRANSLATE (c)])
         zero if not.  If not yet determined,  `MATCH_NULL_UNSET_VALUE'.  */
#define MATCH_NULL_UNSET_VALUE 3
#define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)
#define IS_ACTIVE(R)  ((R).bits.is_active)
#define MATCHED_SOMETHING(R)  ((R).bits.matched_something)
#define EVER_MATCHED_SOMETHING(R)  ((R).bits.ever_matched_something)
   for the subexpressions which we are currently inside.  Also records
#define SET_REGS_MATCHED()						\
          MATCHED_SOMETHING (reg_info[r])				\
            = EVER_MATCHED_SOMETHING (reg_info[r])			\
#define REG_UNSET_VALUE ((char *) -1)
#define REG_UNSET(e) ((e) == REG_UNSET_VALUE)
#define MATCHING_IN_FIRST_STRING  (dend == end_match_1)
#define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)
#define AT_STRINGS_END(d) ((d) == end2)	
#define WORDCHAR_P(d)							\
  (SYNTAX ((d) == end1 ? *string2					\
#define AT_WORD_BOUNDARY(d)						\
  (AT_STRINGS_BEG (d) || AT_STRINGS_END (d)				\
   || WORDCHAR_P (d - 1) != WORDCHAR_P (d))
#ifdef REGEX_MALLOC
#define FREE_VAR(var) if (var) free (var); var = NULL
#define FREE_VARIABLES()						\
    FREE_VAR (fail_stack.stack);					\
    FREE_VAR (regstart);						\
    FREE_VAR (regend);							\
    FREE_VAR (old_regstart);						\
    FREE_VAR (old_regend);						\
    FREE_VAR (best_regstart);						\
    FREE_VAR (best_regend);						\
    FREE_VAR (reg_info);						\
    FREE_VAR (reg_dummy);						\
    FREE_VAR (reg_info_dummy);						\
#else /* not REGEX_MALLOC */
#define FREE_VARIABLES() alloca (0)
#endif /* not REGEX_MALLOC */
   NUM_FAILURE_ITEMS above.  And the value for the lowest register must
#define NO_HIGHEST_ACTIVE_REG (1 << BYTEWIDTH)
#define NO_LOWEST_ACTIVE_REG (NO_HIGHEST_ACTIVE_REG + 1)
  unsigned lowest_active_reg = NO_LOWEST_ACTIVE_REG;
  unsigned highest_active_reg = NO_HIGHEST_ACTIVE_REG;
     else (see below).  Also, we never need info about register 0 for
  INIT_FAIL_STACK ();
      regstart = REGEX_TALLOC (num_regs, const char *);
      regend = REGEX_TALLOC (num_regs, const char *);
      old_regstart = REGEX_TALLOC (num_regs, const char *);
      old_regend = REGEX_TALLOC (num_regs, const char *);
      best_regstart = REGEX_TALLOC (num_regs, const char *);
      best_regend = REGEX_TALLOC (num_regs, const char *);
      reg_info = REGEX_TALLOC (num_regs, register_info_type);
      reg_dummy = REGEX_TALLOC (num_regs, const char *);
      reg_info_dummy = REGEX_TALLOC (num_regs, register_info_type);
          FREE_VARIABLES ();
#ifdef REGEX_MALLOC
         `FREE_VARIABLES' doesn't try to free them.  */
#endif /* REGEX_MALLOC */
      FREE_VARIABLES ();
     start_memory/stop_memory has been seen for. Also initialize the
        = old_regstart[mcnt] = old_regend[mcnt] = REG_UNSET_VALUE;
      REG_MATCH_NULL_STRING_P (reg_info[mcnt]) = MATCH_NULL_UNSET_VALUE;
      IS_ACTIVE (reg_info[mcnt]) = 0;
      MATCHED_SOMETHING (reg_info[mcnt]) = 0;
      EVER_MATCHED_SOMETHING (reg_info[mcnt]) = 0;
  DEBUG_PRINT_COMPILED_PATTERN (bufp, p, pend);
              if (!FAIL_STACK_EMPTY ())
	        	                == MATCHING_IN_FIRST_STRING);
                      || (!same_str_p && !MATCHING_IN_FIRST_STRING))
                      DEBUG_PRINT1 ("\nSAVING match as best so far.\n");
          DEBUG_PRINT1 ("Accepting match.\n");
              if (bufp->regs_allocated == REGS_UNALLOCATED)
                  regs->num_regs = MAX (RE_NREGS, num_regs + 1);
                  regs->start = TALLOC (regs->num_regs, regoff_t);
                  regs->end = TALLOC (regs->num_regs, regoff_t);
                  bufp->regs_allocated = REGS_REALLOCATE;
              else if (bufp->regs_allocated == REGS_REALLOCATE)
                      RETALLOC (regs->start, regs->num_regs, regoff_t);
                      RETALLOC (regs->end, regs->num_regs, regoff_t);
                  regs->end[0] = (MATCHING_IN_FIRST_STRING ? d - string1
          FREE_VARIABLES ();
          mcnt = d - pos - (MATCHING_IN_FIRST_STRING 
	  SET_REGS_MATCHED ();
          if ((!(bufp->syntax & RE_DOT_NEWLINE) && TRANSLATE (*d) == '\n')
              || (bufp->syntax & RE_DOT_NOT_NULL && TRANSLATE (*d) == '\000'))
          SET_REGS_MATCHED ();
	    c = TRANSLATE (*d); /* The character to match.  */
	    SET_REGS_MATCHED ();
          if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)
            REG_MATCH_NULL_STRING_P (reg_info[*p]) 
          old_regstart[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
          IS_ACTIVE (reg_info[*p]) = 1;
          MATCHED_SOMETHING (reg_info[*p]) = 0;
          if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
          old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
          IS_ACTIVE (reg_info[*p]) = 0;
              lowest_active_reg = NO_LOWEST_ACTIVE_REG;
              highest_active_reg = NO_HIGHEST_ACTIVE_REG;
              while (r > 0 && !IS_ACTIVE (reg_info[r]))
                  lowest_active_reg = NO_LOWEST_ACTIVE_REG;
                  highest_active_reg = NO_HIGHEST_ACTIVE_REG;
          if ((!MATCHED_SOMETHING (reg_info[*p])
                    EXTRACT_NUMBER_AND_INCR (mcnt, p1);
                     Also restore the registers for inner groups for,
                  if (EVER_MATCHED_SOMETHING (reg_info[*p]))
                      EVER_MATCHED_SOMETHING (reg_info[*p]) = 0;
                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
                  PUSH_FAILURE_POINT (p1 + mcnt, d, -2);
		/* At end of register contents => success */
          if (AT_STRINGS_BEG (d))
          if (AT_STRINGS_END (d))
          if (AT_STRINGS_BEG (d))
	  if (AT_STRINGS_END (d))
          EXTRACT_NUMBER_AND_INCR (mcnt, p);
          PUSH_FAILURE_POINT (p + mcnt, NULL, -2);
          EXTRACT_NUMBER_AND_INCR (mcnt, p);
              if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
          PUSH_FAILURE_POINT (p + mcnt, d, -2);
        /* A smart repeat ends with `maybe_pop_jump'.
          EXTRACT_NUMBER_AND_INCR (mcnt, p);
            POP_FAILURE_POINT (sdummy, pdummy,
	  EXTRACT_NUMBER_AND_INCR (mcnt, p);	/* Get the amount to jump.  */
          PUSH_FAILURE_POINT (0, 0, -2);
        /* At the end of an alternative, we need to push a dummy failure
          PUSH_FAILURE_POINT (0, 0, -2);
           After that, handle like `on_failure_jump'.  */
          EXTRACT_NUMBER (mcnt, p + 2);
          /* Originally, this is how many times we HAVE to succeed.  */
               STORE_NUMBER_AND_INCR (p, mcnt);
          EXTRACT_NUMBER (mcnt, p + 2);
          /* Originally, this is how many times we CAN jump.  */
            EXTRACT_NUMBER_AND_INCR (mcnt, p);
            EXTRACT_NUMBER_AND_INCR (mcnt, p);
          if (AT_WORD_BOUNDARY (d))
	  if (AT_WORD_BOUNDARY (d))
	  if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))
	  if (!AT_STRINGS_BEG (d) && WORDCHAR_P (d - 1)
              && (!WORDCHAR_P (d) || AT_STRINGS_END (d)))
 	  if (PTR_CHAR_POS ((unsigned char *) d) >= point)
 	  if (PTR_CHAR_POS ((unsigned char *) d) != point)
          if (PTR_CHAR_POS ((unsigned char *) d) <= point)
	  if (PTR_CHAR_POS ((unsigned char *) d) + 1 != point)
	  if (SYNTAX (*d++) != (enum syntaxcode) mcnt)
          SET_REGS_MATCHED ();
	  if (SYNTAX (*d++) == (enum syntaxcode) mcnt)
	  SET_REGS_MATCHED ();
          if (!WORDCHAR_P (d))
	  SET_REGS_MATCHED ();
	  if (WORDCHAR_P (d))
          SET_REGS_MATCHED ();
      if (!FAIL_STACK_EMPTY ())
	{ /* A restart point is known.  Restore to that state.  */
          DEBUG_PRINT1 ("\nFAIL:\n");
          POP_FAILURE_POINT (d, p,
                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
  FREE_VARIABLES ();
          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
              EXTRACT_NUMBER (mcnt, p1 - 2);
          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
      assert (reg_no > 0 && reg_no <= MAX_REGNUM);
      if (REG_MATCH_NULL_STRING_P (reg_info[reg_no]) == MATCH_NULL_UNSET_VALUE)
        REG_MATCH_NULL_STRING_P (reg_info[reg_no]) = ret;
      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
      if (!REG_MATCH_NULL_STRING_P (reg_info[*p1]))
      /* All other opcodes mean we cannot match the empty string.  */
/* Return zero if TRANSLATE[S1] and TRANSLATE[S2] are identical for LEN
   compiles PATTERN (of length SIZE) and puts the result in BUFP.
   Assumes the `allocated' (and perhaps `buffer') and `translate' fields
  bufp->regs_allocated = REGS_UNALLOCATED;
  /* And GNU code determines whether or not to get register information
     `syntax' to RE_SYNTAX_POSIX_EXTENDED if the
       REG_EXTENDED bit in CFLAGS is set; otherwise, to
       RE_SYNTAX_POSIX_BASIC;
     `newline_anchor' to REG_NEWLINE being set in CFLAGS;
     `re_nsub' to the number of subexpressions in PATTERN.
   PATTERN is the address of the pattern string.
   CFLAGS is a series of bits which affect compilation.
     Also, regexec will try a match beginning after every newline.
     If REG_ICASE is set, then we considers upper- and lowercase
      RE_SYNTAX_POSIX_EXTENDED : RE_SYNTAX_POSIX_BASIC;
  if (cflags & REG_ICASE)
      preg->translate = (char *) malloc (CHAR_SET_SIZE);
        return (int) REG_ESPACE;
      for (i = 0; i < CHAR_SET_SIZE; i++)
      syntax |= RE_HAT_LISTS_NOT_NEWLINE;
     unmatched close-group: both are REG_EPAREN.  */
  if (ret == REG_ERPAREN) ret = REG_EPAREN;
   If NMATCH is zero or REG_NOSUB was set in the cflags argument to
   `regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at
   least NMATCH elements, and we set them to the offsets of the
   EFLAGS specifies `execution flags' which affect matching: if
   We return 0 if we find a match and REG_NOMATCH if not.  */
      regs.start = TALLOC (nmatch, regoff_t);
      regs.end = TALLOC (nmatch, regoff_t);
        return (int) REG_NOMATCH;
  return ret >= 0 ? (int) REG_NOERROR : (int) REG_NOMATCH;
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
   Modified July, 1988 by Arthur David Olson to assist BMG speedups  */
#ifdef STDC_HEADERS
#if defined(HAVE_STRING_H) || defined(STDC_HEADERS)
#undef ISALPHA
#undef ISSPACE
#undef ISALNUM
#undef ISGRAPH
#define ISALPHA(C) (isascii(C) && isalpha(C))
#define ISSPACE(C) (isascii(C) && isspace(C))
#define ISALNUM(C) (isascii(C) && isalnum(C))
#define ISGRAPH(C) (isascii(C) && isgraph(C))
#define ISALPHA(C) isalpha(C)
#define ISSPACE(C) isspace(C)
#define ISALNUM(C) isalnum(C)
#define ISGRAPH(C) isgraph(C)
#define CALLOC(p, t, n) ((p) = (t *) xcalloc((n), sizeof (t)))
#define MALLOC(p, t, n) ((p) = (t *) xmalloc_1((n) * sizeof (t)))
#define REALLOC(p, t, n) ((p) = (t *) xrealloc_1((ptr_t) (p), (n) * sizeof (t)))
#define REALLOC_IF_NECESSARY(p, t, nalloc, index) \
      REALLOC(p, t, nalloc);			  \
  else if (t < NOTCHAR)
	case BACKREF: s = "BACKREF"; break;
	case QMARK: s = "QMARK"; break;
	case STAR: s = "STAR"; break;
	case CAT: s = "CAT"; break;
	case LPAREN: s = "LPAREN"; break;
	case RPAREN: s = "RPAREN"; break;
  for (i = 0; i < CHARCLASS_INTS; ++i)
  for (i = 0; i < CHARCLASS_INTS; ++i)
  for (i = 0; i < CHARCLASS_INTS; ++i)
  for (i = 0; i < CHARCLASS_INTS; ++i)
/* A pointer to the current dfa is kept here during parsing. */
  REALLOC_IF_NECESSARY(dfa->charclasses, charclass, dfa->calloc, dfa->cindex);
/* Lexical analyzer.  All the dross that deals with the obnoxious
FUNC(is_alpha, ISALPHA)
FUNC(is_space, ISSPACE)
FUNC(is_alnum, ISALNUM)
FUNC(is_graph, ISGRAPH)
	  if (syntax_bits & RE_CONTEXT_INDEP_ANCHORS
	      || lasttok == LPAREN
	  if (syntax_bits & RE_CONTEXT_INDEP_ANCHORS
	      || (syntax_bits & RE_NO_BK_PARENS
	      || (syntax_bits & RE_NO_BK_VBAR
	      || ((syntax_bits & RE_NEWLINE_ALT)
	      return lasttok = BACKREF;
	  return lasttok = QMARK;
	  return lasttok = STAR;
	  if (!(syntax_bits & RE_INTERVALS))
	  if (backslash != ((syntax_bits & RE_NO_BK_BRACES) == 0))
	  if (!(syntax_bits & RE_NO_BK_BRACES))
	  if (backslash != ((syntax_bits & RE_NO_BK_VBAR) == 0))
	      || !(syntax_bits & RE_NEWLINE_ALT))
	  if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))
	  return lasttok = LPAREN;
	  if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))
	  if (parens == 0 && syntax_bits & RE_UNMATCHED_RIGHT_PAREN_ORD)
	  return lasttok = RPAREN;
	  for (c2 = 0; c2 < NOTCHAR; ++c2)
	    if (ISALNUM(c2))
	      if (c == '[' && (syntax_bits & RE_CHAR_CLASSES))
		      for (c2 = 0; c2 < NOTCHAR; ++c2)
	      if (c == '\\' && (syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))
			  && (syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))
	      if (syntax_bits & RE_HAT_LISTS_NOT_NEWLINE)
	  if (case_fold && ISALPHA(c))
/* Add the given token to the parse tree, maintaining the depth count and
  REALLOC_IF_NECESSARY(dfa->tokens, token, dfa->talloc, dfa->tindex);
    case QMARK:
    case STAR:
    case CAT:
     closure QMARK
     closure STAR
     BACKREF
  if ((tok >= 0 && tok < NOTCHAR) || tok >= CSET || tok == BACKREF
  else if (tok == LPAREN)
      if (tok != RPAREN)
    case QMARK:
    case STAR:
    case CAT:
  while (tok == QMARK || tok == STAR || tok == PLUS || tok == REPMN)
	  addtok(QMARK);
	    addtok(CAT);
	    addtok(QMARK);
	    addtok(CAT);
  while (tok != RPAREN && tok != OR && tok >= 0)
      addtok(CAT);
  addtok(CAT);
  REALLOC_IF_NECESSARY(d->states, dfa_state, d->salloc, d->sindex);
  MALLOC(d->states[i].elems.elems, position, s->nelem);
    else if (d->tokens[s->elems[j].index] == BACKREF)
	d->states[i].constraint = NO_CONSTRAINT;
  MALLOC(visited, int, d->tindex);
    if (d->tokens[s->elems[i].index] >= NOTCHAR
	&& d->tokens[s->elems[i].index] != BACKREF
	    p.constraint &= BEGLINE_CONSTRAINT;
	    p.constraint &= ENDLINE_CONSTRAINT;
	    p.constraint &= BEGWORD_CONSTRAINT;
	    p.constraint &= ENDWORD_CONSTRAINT;
	    p.constraint &= LIMWORD_CONSTRAINT;
	    p.constraint &= NOTLIMWORD_CONSTRAINT;
   Nullable:  A node is nullable if it is at the root of a regexp that can
   * A QMARK or STAR node is nullable.
   * A PLUS node is nullable if its argument is nullable.
   * A CAT node is nullable if both its arguments are nullable.
   * An OR node is nullable if either argument is nullable.
   * The firstpos of a QMARK, STAR, or PLUS node is the firstpos of its
   * The firstpos of a CAT node is the firstpos of the left argument, union
   * The lastpos of a QMARK, STAR, or PLUS node is the lastpos of its
   * The lastpos of a CAT node is the lastpos of its right argument, union
   a string matching the regexp.  At this point we consider special symbols
   * Every node in the firstpos of the argument of a STAR or PLUS node is in
   * Every node in the firstpos of the second argument of a CAT node is in
  position *firstpos;		/* Array where firstpos elements are stored. */
  position *lastpos;		/* Array where lastpos elements are stored. */
  MALLOC(nullable, int, d->depth);
  MALLOC(nfirstpos, int, d->depth);
  MALLOC(firstpos, position, d->nleaves);
  MALLOC(nlastpos, int, d->depth);
  MALLOC(lastpos, position, d->nleaves);
  MALLOC(nalloc, int, d->tindex);
  MALLOC(merged.elems, position, d->nleaves);
  CALLOC(d->follows, position_set, d->tindex);
      case STAR:
	    REALLOC_IF_NECESSARY(d->follows[pos[j].index].elems, position,
      case QMARK:
	/* A QMARK or STAR node is automatically nullable. */
      case CAT:
	    REALLOC_IF_NECESSARY(d->follows[pos[j].index].elems, position,
	/* The firstpos of a CAT node is the firstpos of the first argument,
	/* The lastpos of a CAT node is the lastpos of the second argument,
	/* A CAT node is nullable if both arguments are nullable. */
	/* An OR node is nullable if either argument is nullable. */
	/* Anything else is a nonempty position.  (Note that special
	*nullable++ = d->tokens[i] == BACKREF;
	firstpos->constraint = lastpos->constraint = NO_CONSTRAINT;
	/* Allocate the follow set for this position. */
	MALLOC(d->follows[i].elems, position, nalloc[i]);
    if (d->tokens[i] < NOTCHAR || d->tokens[i] == BACKREF
	  REALLOC(d->follows[i].elems, position, merged.nelem);
  MALLOC(d->states, dfa_state, d->salloc);
  position_set grps[NOTCHAR];	/* As many as will ever be needed. */
  charclass labels[NOTCHAR];	/* Labels corresponding to the groups. */
      for (i = 0; i < NOTCHAR; ++i)
	if (ISALNUM(i))
      if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR)
	  if (! MATCHES_NEWLINE_CONTEXT(pos.constraint,
	  if (! MATCHES_NEWLINE_CONTEXT(pos.constraint,
	    for (j = 0; j < CHARCLASS_INTS; ++j)
	  if (! MATCHES_LETTER_CONTEXT(pos.constraint,
	    for (j = 0; j < CHARCLASS_INTS; ++j)
	  if (! MATCHES_LETTER_CONTEXT(pos.constraint,
	    for (j = 0; j < CHARCLASS_INTS; ++j)
	  for (j = 0; j < CHARCLASS_INTS && !matches[j]; ++j)
	  if (j == CHARCLASS_INTS)
	  if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR
	  for (k = 0; k < CHARCLASS_INTS; ++k)
	  for (k = 0; k < CHARCLASS_INTS; ++k)
	      MALLOC(grps[ngrps].elems, position, d->nleaves);
	  MALLOC(grps[ngrps].elems, position, d->nleaves);
  MALLOC(follows.elems, position, d->nleaves);
  MALLOC(tmp.elems, position, d->nleaves);
      for (i = 0; i < NOTCHAR; ++i)
	else if (ISALNUM(i))
    for (i = 0; i < NOTCHAR; ++i)
      for (j = 0; j < CHARCLASS_INTS; ++j)
      if (j < CHARCLASS_INTS)
      for (j = 0; j < CHARCLASS_INTS; ++j)
	      else if (ISALNUM(c))
	      else if (c < NOTCHAR)
  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 1, d->states[s].letter, 0,
  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 0, d->states[s].letter, 1,
  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 0, d->states[s].letter, 0,
  MALLOC(trans, int, NOTCHAR);
  for (i = 0; i < NOTCHAR; ++i)
	REALLOC(d->realtrans, int *, d->tralloc + 1);
	REALLOC(d->fails, int *, d->tralloc);
	REALLOC(d->success, int, d->tralloc);
	REALLOC(d->newlines, int, d->tralloc);
  if (ACCEPTING(s, *d))
  CALLOC(d->realtrans, int *, d->tralloc + 1);
  CALLOC(d->fails, int *, d->tralloc);
  MALLOC(d->success, int, d->tralloc);
  MALLOC(d->newlines, int, d->tralloc);
  static sbit[NOTCHAR];	/* Table for anding with d->success. */
      for (i = 0; i < NOTCHAR; ++i)
	else if (ISALNUM(i))
  MALLOC(d->charclasses, charclass, d->calloc);
  MALLOC(d->tokens, token, d->talloc);
   The sequences calculated for the various types of node (in pseudo ANSI c)
	STAR	ZERO		ZERO		ZERO		ZERO
	QMARK	ZERO		ZERO		ZERO		ZERO
	CAT	(p->is==ZERO)?	(q->is==ZERO)?	(p->is!=ZERO &&	p->in plus
   And. . .is it here or someplace that we might ponder "optimizations" such as
   Are optimizable r.e.'s likely to be used in real-life situations
  /* Add the new string. */
	case LPAREN:
	case RPAREN:
	case BACKREF:
	case STAR:
	case QMARK:
	case CAT:
		  Written August 1989 by Mike Haertel.
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   See "A String Matching Algorithm Fast on the Average," Technical Report,
   Heidelberg, Germany.  See also Aho, A.V., and M. Corasick, "Efficient
   String Matching:  An Aid to Bibliographic Search," CACM June 1975,
#ifdef STDC_HEADERS
#undef RE_DUP_MAX
#define INT_MAX 2147483647
#define UCHAR_MAX 255
#ifdef HAVE_MEMCHR
#define NCHAR (UCHAR_MAX + 1)
  struct trie *fail;		/* Aho-Corasick failure function. */
  unsigned char delta[NCHAR];	/* Delta table for rapid search. */
  struct trie *next[NCHAR];	/* Table of children of the root. */
/* Allocate and initialize a keyword set object, returning an opaque
  kwset->mind = INT_MAX;
/* Add the given string to the contents of the keyword set.  Return NULL
/* Compute the Aho-Corasick failure function for the trie nodes referenced
/* Return true if A has every label in B. */
  unsigned char delta[NCHAR];
  struct trie *last, *next[NCHAR];
    for (i = 0; i < NCHAR; ++i)
    for (i = 0; i < NCHAR; ++i)
      for (i = 0; i < NCHAR; ++i)
	for (i = 0; i < NCHAR; ++i)
	for (i = 0; i < NCHAR; ++i)
    for (i = 0; i < NCHAR; ++i)
    for (i = 0; i < NCHAR; ++i)
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
/* This is just to get __GNU_LIBRARY__ defined.  */
#if defined (_LIBC) || !defined (__GNU_LIBRARY__)
#define DEFAULT_ALIGNMENT  \
/* If malloc were really smart, it would round addresses to DEFAULT_ALIGNMENT.
   DEFAULT_ROUNDING.  So we prepare for it to do that.  */
#define DEFAULT_ROUNDING (sizeof (union fooround))
#define CALL_CHUNKFUN(h, size) \
#define CALL_FREEFUN(h, old_chunk) \
   Objects start on multiples of ALIGNMENT (0 means use default).
    alignment = DEFAULT_ALIGNMENT;
      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
		    + 4 + DEFAULT_ROUNDING - 1)
		   & ~(DEFAULT_ROUNDING - 1));
  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
    alignment = DEFAULT_ALIGNMENT;
      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
		    + 4 + DEFAULT_ROUNDING - 1)
		   & ~(DEFAULT_ROUNDING - 1));
  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
/* Allocate a new current chunk for the obstack *H
  /* Allocate and initialize the new chunk.  */
  new_chunk = h->chunk = CALL_CHUNKFUN (h, new_size);
  if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)
      CALL_FREEFUN (h, old_chunk);
   This is the first one, called from non-ANSI code.  */
      CALL_FREEFUN (h, lp);
/* This function is used from ANSI code.  */
      CALL_FREEFUN (h, lp);
/* These function definitions do not work with non-ANSI preprocessors;
#endif	/* _LIBC or not __GNU_LIBRARY__.  */
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
   Written August 1992 by Mike Haertel. */
#ifdef STDC_HEADERS
#undef RE_DUP_MAX
#define UCHAR_MAX 255
#ifdef HAVE_MEMCHR
#if defined(HAVE_STRING_H) || defined(STDC_HEADERS)
#define ISALNUM(C) (isascii(C) && isalnum(C))
#define ISALNUM(C) isalnum(C)
#define NCHAR (UCHAR_MAX + 1)
#define WCHAR(C) (ISALNUM(C) || (C) == '_')
/* DFA compiled regexp. */
  static char trans[NCHAR];
    for (i = 0; i < NCHAR; ++i)
/* If the DFA turns out to have some set of fixed strings one of
  re_set_syntax(RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
  dfasyntax(RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE, match_icase);
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
	 (^|[^A-Za-z_])(userpattern)([^A-Za-z_]|$).
	 BUG: Using [A-Za-z_] is locale-dependent!  */
	strcpy(n, "\\(^\\|[^0-9A-Za-z_]\\)\\(");
	strcpy(n + i, "\\)\\([^0-9A-Za-z_]\\|$\\)");
      re_set_syntax(RE_SYNTAX_POSIX_EGREP);
      dfasyntax(RE_SYNTAX_POSIX_EGREP, match_icase);
      re_set_syntax(RE_SYNTAX_EGREP);
      dfasyntax(RE_SYNTAX_EGREP, match_icase);
     for the DFA matcher that will quickly throw out cases that won't work.
     Then if DFA succeeds we do some hairy stuff using the regex matcher
	 (^|[^A-Za-z_])(userpattern)([^A-Za-z_]|$).
	 BUG: Using [A-Za-z_] is locale-dependent!  */
	strcpy(n, "(^|[^0-9A-Za-z_])(");
	strcpy(n + i, ")([^0-9A-Za-z_]|$)");
  static struct re_registers regs; /* This is static on account of a BRAIN-DEAD
	     run it through DFA. */
	  /* No good fixed strings; start with DFA. */
      /* If we've made it to this point, this means DFA has seen
		if ((start == 0 || !WCHAR(beg[start - 1]))
		    && (len == end - beg || !WCHAR(beg[start + len])))
	    if (try > buf && WCHAR((unsigned char) try[-1]))
	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
